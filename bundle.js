/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(2);
	
	var _package = __webpack_require__(3);
	
	var _framesCounter = __webpack_require__(4);
	
	var _framesCounter2 = _interopRequireDefault(_framesCounter);
	
	var _Renderer = __webpack_require__(6);
	
	var _Renderer2 = _interopRequireDefault(_Renderer);
	
	var _App = __webpack_require__(143);
	
	var _App2 = _interopRequireDefault(_App);
	
	var _GameStore = __webpack_require__(151);
	
	var _GameStore2 = _interopRequireDefault(_GameStore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var renderer = new _Renderer2.default(_package.config.stageWidth, _package.config.stageHeight);
	var app = new _App2.default(_package.config.stageWidth, _package.config.stageHeight);
	
	document.body.appendChild(renderer.view);
	
	_GameStore2.default.set('gameOutcome', _GameStore2.default.setGameOutcome());
	
	renderer.addRenderable(app);
	renderer.start();
	(0, _framesCounter2.default)();

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "index.html";

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = {
		"name": "feed-me",
		"version": "1.0.0",
		"repository": "https://github.com/tanyapowell/feed-me",
		"description": "Game built with Pixi.js, webpack and ES6",
		"config": {
			"buildDir": "./build",
			"stageWidth": 1920,
			"stageHeight": 1080
		},
		"scripts": {
			"deploy": "gh-pages -d build",
			"prestart": "npm install",
			"start": "NODE_ENV=development webpack-dev-server --content-base ./build/ --hot --inline --host 0.0.0.0",
			"webpack": "webpack -p --config ./webpack.config.js",
			"build": "NODE_ENV=production npm run webpack",
			"prewebpack": "npm run clean",
			"clean": "rimraf $npm_package_config_buildDir && mkdir $npm_package_config_buildDir",
			"lint": "eslint ./app/**/*.js",
			"reactman": "reactman --config ./templates/reactman.config.js"
		},
		"dependencies": {
			"pixi.js": "^3.0.7",
			"stats-js": "^1.0.0-alpha1"
		},
		"devDependencies": {
			"babel-core": "^6.7.2",
			"babel-eslint": "^5.0.0",
			"babel-loader": "^6.2.4",
			"babel-preset-es2015": "^6.6.0",
			"babel-runtime": "^6.6.1",
			"brfs": "^1.4.3",
			"eslint": "^2.4.0",
			"file-loader": "^0.8.4",
			"gh-pages": "^0.12.0",
			"html-loader": "^0.4.3",
			"json-loader": "^0.5.3",
			"reactman": "^3.2.0",
			"rimraf": "^2.4.3",
			"transform-loader": "^0.2.3",
			"webpack": "^1.12.2",
			"webpack-dev-server": "^1.11.0"
		},
		"engines": {
			"node": ">=5.0.0"
		}
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = framesCounter;
	
	var _statsJs = __webpack_require__(5);
	
	var _statsJs2 = _interopRequireDefault(_statsJs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function framesCounter() {
	  var stats = new _statsJs2.default();
	  stats.setMode(0);
	
	  stats.domElement.style.position = 'absolute';
	  stats.domElement.style.left = '0px';
	  stats.domElement.style.top = '0px';
	
	  document.body.appendChild(stats.domElement);
	
	  setInterval(function () {
	    stats.begin();
	    stats.end();
	  }, 1000 / 60);
	}

/***/ },
/* 5 */
/***/ function(module, exports) {

	// stats.js - http://github.com/mrdoob/stats.js
	var Stats=function(){var l=Date.now(),m=l,g=0,n=Infinity,o=0,h=0,p=Infinity,q=0,r=0,s=0,f=document.createElement("div");f.id="stats";f.addEventListener("mousedown",function(b){b.preventDefault();t(++s%2)},!1);f.style.cssText="width:80px;opacity:0.9;cursor:pointer";var a=document.createElement("div");a.id="fps";a.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#002";f.appendChild(a);var i=document.createElement("div");i.id="fpsText";i.style.cssText="color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
	i.innerHTML="FPS";a.appendChild(i);var c=document.createElement("div");c.id="fpsGraph";c.style.cssText="position:relative;width:74px;height:30px;background-color:#0ff";for(a.appendChild(c);74>c.children.length;){var j=document.createElement("span");j.style.cssText="width:1px;height:30px;float:left;background-color:#113";c.appendChild(j)}var d=document.createElement("div");d.id="ms";d.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";f.appendChild(d);var k=document.createElement("div");
	k.id="msText";k.style.cssText="color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";k.innerHTML="MS";d.appendChild(k);var e=document.createElement("div");e.id="msGraph";e.style.cssText="position:relative;width:74px;height:30px;background-color:#0f0";for(d.appendChild(e);74>e.children.length;)j=document.createElement("span"),j.style.cssText="width:1px;height:30px;float:left;background-color:#131",e.appendChild(j);var t=function(b){s=b;switch(s){case 0:a.style.display=
	"block";d.style.display="none";break;case 1:a.style.display="none",d.style.display="block"}};return{REVISION:12,domElement:f,setMode:t,begin:function(){l=Date.now()},end:function(){var b=Date.now();g=b-l;n=Math.min(n,g);o=Math.max(o,g);k.textContent=g+" MS ("+n+"-"+o+")";var a=Math.min(30,30-30*(g/200));e.appendChild(e.firstChild).style.height=a+"px";r++;b>m+1E3&&(h=Math.round(1E3*r/(b-m)),p=Math.min(p,h),q=Math.max(q,h),i.textContent=h+" FPS ("+p+"-"+q+")",a=Math.min(30,30-30*(h/100)),c.appendChild(c.firstChild).style.height=
	a+"px",m=b,r=0);return b},update:function(){l=this.end()}}};"object"===typeof module&&(module.exports=Stats);


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _pixi = __webpack_require__(7);
	
	var _pixi2 = _interopRequireDefault(_pixi);
	
	var _RendererStore = __webpack_require__(140);
	
	var _RendererStore2 = _interopRequireDefault(_RendererStore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var renderables = new Set();
	
	var Renderer = function (_PIXI$WebGLRenderer) {
	  _inherits(Renderer, _PIXI$WebGLRenderer);
	
	  function Renderer() {
	    var _ref;
	
	    _classCallCheck(this, Renderer);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = _possibleConstructorReturn(this, (_ref = Renderer.__proto__ || Object.getPrototypeOf(Renderer)).call.apply(_ref, [this].concat(args)));
	
	    window.addEventListener('resize', _this.resizeHandler.bind(_this));
	
	    _RendererStore2.default.set('resolution', _this.resolution);
	    _RendererStore2.default.set('stageWidth', args[0]);
	    _RendererStore2.default.set('stageHeight', args[1]);
	    _RendererStore2.default.set('stageCenter', new _pixi2.default.Point(args[0] / 2, args[1] / 2));
	
	    _this.setStore();
	
	    _this.resizeHandler();
	    return _this;
	  }
	
	  _createClass(Renderer, [{
	    key: 'setStore',
	    value: function setStore() {
	      _RendererStore2.default.set('width', this.getWindowSize()[0]);
	      _RendererStore2.default.set('height', this.getWindowSize()[1]);
	    }
	  }, {
	    key: 'resizeHandler',
	    value: function resizeHandler() {
	      this.resize.apply(this, _toConsumableArray(this.getWindowSize()));
	      this.setStore();
	      _RendererStore2.default.emitChange();
	    }
	  }, {
	    key: 'getWindowSize',
	    value: function getWindowSize() {
	      var width = window.innerWidth;
	      var height = window.innerHeight;
	
	      return [width, height];
	    }
	  }, {
	    key: 'start',
	    value: function start() {
	      this.active = true;
	      window.requestAnimationFrame(this.animate.bind(this));
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      this.active = false;
	    }
	  }, {
	    key: 'animate',
	    value: function animate() {
	      this.renderRenderables();
	
	      if (this.active) {
	        window.requestAnimationFrame(this.animate.bind(this));
	      }
	    }
	  }, {
	    key: 'addRenderable',
	    value: function addRenderable(renderable) {
	      return renderables.add(renderable);
	    }
	  }, {
	    key: 'removeRenderable',
	    value: function removeRenderable(renderable) {
	      var hasRenderable = renderables.has(renderable);
	
	      if (hasRenderable) {
	        renderables.delete(renderable);
	      }
	
	      return hasRenderable;
	    }
	  }, {
	    key: 'renderRenderables',
	    value: function renderRenderables() {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = renderables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var entry = _step.value;
	
	          this.render(entry);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  }]);
	
	  return Renderer;
	}(_pixi2.default.WebGLRenderer);
	
	exports.default = Renderer;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// run the polyfills
	__webpack_require__(8);
	
	var core = module.exports = __webpack_require__(13);
	
	// add core plugins.
	core.extras         = __webpack_require__(76);
	core.filters        = __webpack_require__(83);
	core.interaction    = __webpack_require__(111);
	core.loaders        = __webpack_require__(115);
	core.mesh           = __webpack_require__(130);
	core.accessibility  = __webpack_require__(136);
	
	// export a premade loader instance
	/**
	 * A premade instance of the loader that can be used to loader resources.
	 *
	 * @name loader
	 * @memberof PIXI
	 * @property {PIXI.loaders.Loader}
	 */
	core.loader = new core.loaders.Loader();
	
	// mixin the deprecation features.
	Object.assign(core, __webpack_require__(139));
	
	// Always export pixi globally.
	global.PIXI = core;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(9);
	__webpack_require__(11);
	__webpack_require__(12);


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// References:
	// https://github.com/sindresorhus/object-assign
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
	if (!Object.assign)
	{
	    Object.assign = __webpack_require__(10);
	}


/***/ },
/* 10 */
/***/ function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {// References:
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// https://gist.github.com/1579671
	// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
	// https://gist.github.com/timhall/4078614
	// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame
	
	// Expected to be used with Browserfiy
	// Browserify automatically detects the use of `global` and passes the
	// correct reference of `global`, `self`, and finally `window`
	
	// Date.now
	if (!(Date.now && Date.prototype.getTime)) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	
	// performance.now
	if (!(global.performance && global.performance.now)) {
	    var startTime = Date.now();
	    if (!global.performance) {
	        global.performance = {};
	    }
	    global.performance.now = function () {
	        return Date.now() - startTime;
	    };
	}
	
	// requestAnimationFrame
	var lastTime = Date.now();
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	
	for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
	    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
	    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
	        global[vendors[x] + 'CancelRequestAnimationFrame'];
	}
	
	if (!global.requestAnimationFrame) {
	    global.requestAnimationFrame = function (callback) {
	        if (typeof callback !== 'function') {
	            throw new TypeError(callback + 'is not a function');
	        }
	
	        var currentTime = Date.now(),
	            delay = 16 + lastTime - currentTime;
	
	        if (delay < 0) {
	            delay = 0;
	        }
	
	        lastTime = currentTime;
	
	        return setTimeout(function () {
	            lastTime = Date.now();
	            callback(performance.now());
	        }, delay);
	    };
	}
	
	if (!global.cancelAnimationFrame) {
	    global.cancelAnimationFrame = function(id) {
	        clearTimeout(id);
	    };
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 12 */
/***/ function(module, exports) {

	// References:
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
	if (!Math.sign)
	{
	    Math.sign = function (x) {
	        x = +x;
	        if (x === 0 || isNaN(x))
	        {
	            return x;
	        }
	        return x > 0 ? 1 : -1;
	    };
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file        Main export of the PIXI core library
	 * @author      Mat Groves <mat@goodboydigital.com>
	 * @copyright   2013-2015 GoodBoyDigital
	 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
	 */
	
	/**
	 * @namespace PIXI
	 */
	// export core and const. We assign core to const so that the non-reference types in const remain in-tact
	var core = module.exports = Object.assign(__webpack_require__(14), __webpack_require__(15), {
	    // utils
	    utils: __webpack_require__(24),
	    ticker: __webpack_require__(31),
	
	    // display
	    DisplayObject:          __webpack_require__(33),
	    Container:              __webpack_require__(45),
	
	    // sprites
	    Sprite:                 __webpack_require__(46),
	    ParticleContainer:      __webpack_require__(48),
	    SpriteRenderer:         __webpack_require__(49),
	    ParticleRenderer:       __webpack_require__(64),
	
	    // text
	    Text:                   __webpack_require__(67),
	
	    // primitives
	    Graphics:               __webpack_require__(68),
	    GraphicsData:           __webpack_require__(70),
	    GraphicsRenderer:       __webpack_require__(71),
	
	    // textures
	    Texture:                __webpack_require__(36),
	    BaseTexture:            __webpack_require__(35),
	    RenderTexture:          __webpack_require__(34),
	    VideoBaseTexture:       __webpack_require__(37),
	    TextureUvs:             __webpack_require__(38),
	
	    // renderers - canvas
	    CanvasRenderer:         __webpack_require__(74),
	    CanvasGraphics:         __webpack_require__(69),
	    CanvasBuffer:           __webpack_require__(44),
	
	    // renderers - webgl
	    WebGLRenderer:          __webpack_require__(51),
	    WebGLManager:           __webpack_require__(42),
	    ShaderManager:          __webpack_require__(53),
	    Shader:                 __webpack_require__(55),
	    TextureShader:          __webpack_require__(54),
	    PrimitiveShader:        __webpack_require__(57),
	    ComplexPrimitiveShader: __webpack_require__(56),
	    ObjectRenderer:         __webpack_require__(50),
	    RenderTarget:           __webpack_require__(39),
	
	    // filters - webgl
	    AbstractFilter:         __webpack_require__(60),
	    FXAAFilter:             __webpack_require__(63),
	    SpriteMaskFilter:       __webpack_require__(59),
	
	    /**
	     * This helper function will automatically detect which renderer you should be using.
	     * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
	     * the browser then this function will return a canvas renderer
	     *
	     * @memberof PIXI
	     * @param width=800 {number} the width of the renderers view
	     * @param height=600 {number} the height of the renderers view
	     * @param [options] {object} The optional renderer parameters
	     * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	     * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	     * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	     * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if you
	     *      need to call toDataUrl on the webgl context
	     * @param [options.resolution=1] {number} the resolution of the renderer, retina would be 2
	     * @param [noWebGL=false] {boolean} prevents selection of WebGL renderer, even if such is present
	     *
	     * @return {WebGLRenderer|CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
	     */
	    autoDetectRenderer: function (width, height, options, noWebGL)
	    {
	        width = width || 800;
	        height = height || 600;
	
	        if (!noWebGL && core.utils.isWebGLSupported())
	        {
	            return new core.WebGLRenderer(width, height, options);
	        }
	
	        return new core.CanvasRenderer(width, height, options);
	    }
	});


/***/ },
/* 14 */
/***/ function(module, exports) {

	/**
	 * Constant values used in pixi
	 *
	 * @lends PIXI
	 */
	var CONST = {
	    /**
	     * String of the current PIXI version
	     *
	     * @static
	     * @constant
	     * @property {string} VERSION
	     */
	    VERSION: '__VERSION__',
	
	    /**
	     * @property {number} PI_2 - Two Pi
	     * @constant
	     * @static
	     */
	    PI_2: Math.PI * 2,
	
	    /**
	     * @property {number} RAD_TO_DEG - Constant conversion factor for converting radians to degrees
	     * @constant
	     * @static
	     */
	    RAD_TO_DEG: 180 / Math.PI,
	
	    /**
	     * @property {Number} DEG_TO_RAD - Constant conversion factor for converting degrees to radians
	     * @constant
	     * @static
	     */
	    DEG_TO_RAD: Math.PI / 180,
	
	    /**
	     * Target frames per millisecond.
	     *
	     * @static
	     * @constant
	     * @property {number} TARGET_FPMS=0.06
	     */
	    TARGET_FPMS: 0.06,
	
	    /**
	     * Constant to identify the Renderer Type.
	     *
	     * @static
	     * @constant
	     * @property {object} RENDERER_TYPE
	     * @property {number} RENDERER_TYPE.UNKNOWN
	     * @property {number} RENDERER_TYPE.WEBGL
	     * @property {number} RENDERER_TYPE.CANVAS
	     */
	    RENDERER_TYPE: {
	        UNKNOWN:    0,
	        WEBGL:      1,
	        CANVAS:     2
	    },
	
	    /**
	     * Various blend modes supported by PIXI. IMPORTANT - The WebGL renderer only supports
	     * the NORMAL, ADD, MULTIPLY and SCREEN blend modes. Anything else will silently act like
	     * NORMAL.
	     *
	     * @static
	     * @constant
	     * @property {object} BLEND_MODES
	     * @property {number} BLEND_MODES.NORMAL
	     * @property {number} BLEND_MODES.ADD
	     * @property {number} BLEND_MODES.MULTIPLY
	     * @property {number} BLEND_MODES.SCREEN
	     * @property {number} BLEND_MODES.OVERLAY
	     * @property {number} BLEND_MODES.DARKEN
	     * @property {number} BLEND_MODES.LIGHTEN
	     * @property {number} BLEND_MODES.COLOR_DODGE
	     * @property {number} BLEND_MODES.COLOR_BURN
	     * @property {number} BLEND_MODES.HARD_LIGHT
	     * @property {number} BLEND_MODES.SOFT_LIGHT
	     * @property {number} BLEND_MODES.DIFFERENCE
	     * @property {number} BLEND_MODES.EXCLUSION
	     * @property {number} BLEND_MODES.HUE
	     * @property {number} BLEND_MODES.SATURATION
	     * @property {number} BLEND_MODES.COLOR
	     * @property {number} BLEND_MODES.LUMINOSITY
	     */
	    BLEND_MODES: {
	        NORMAL:         0,
	        ADD:            1,
	        MULTIPLY:       2,
	        SCREEN:         3,
	        OVERLAY:        4,
	        DARKEN:         5,
	        LIGHTEN:        6,
	        COLOR_DODGE:    7,
	        COLOR_BURN:     8,
	        HARD_LIGHT:     9,
	        SOFT_LIGHT:     10,
	        DIFFERENCE:     11,
	        EXCLUSION:      12,
	        HUE:            13,
	        SATURATION:     14,
	        COLOR:          15,
	        LUMINOSITY:     16
	    },
	
	    /**
	     * Various webgl draw modes. These can be used to specify which GL drawMode to use
	     * under certain situations and renderers.
	     *
	     * @static
	     * @constant
	     * @property {object} DRAW_MODES
	     * @property {number} DRAW_MODES.POINTS
	     * @property {number} DRAW_MODES.LINES
	     * @property {number} DRAW_MODES.LINE_LOOP
	     * @property {number} DRAW_MODES.LINE_STRIP
	     * @property {number} DRAW_MODES.TRIANGLES
	     * @property {number} DRAW_MODES.TRIANGLE_STRIP
	     * @property {number} DRAW_MODES.TRIANGLE_FAN
	     */
	    DRAW_MODES: {
	        POINTS:         0,
	        LINES:          1,
	        LINE_LOOP:      2,
	        LINE_STRIP:     3,
	        TRIANGLES:      4,
	        TRIANGLE_STRIP: 5,
	        TRIANGLE_FAN:   6
	    },
	
	    /**
	     * The scale modes that are supported by pixi.
	     *
	     * The DEFAULT scale mode affects the default scaling mode of future operations.
	     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
	     *
	     * @static
	     * @constant
	     * @property {object} SCALE_MODES
	     * @property {number} SCALE_MODES.DEFAULT=LINEAR
	     * @property {number} SCALE_MODES.LINEAR Smooth scaling
	     * @property {number} SCALE_MODES.NEAREST Pixelating scaling
	     */
	    SCALE_MODES: {
	        DEFAULT:    0,
	        LINEAR:     0,
	        NEAREST:    1
	    },
	
	    /**
	     * The prefix that denotes a URL is for a retina asset
	     *
	     * @static
	     * @constant
	     * @property {string} RETINA_PREFIX
	     */
	    //example: '@2x',
	    RETINA_PREFIX: /@(.+)x/,
	
	    RESOLUTION:1,
	
	    FILTER_RESOLUTION:1,
	
	    /**
	     * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
	     * or {@link PIXI.CanvasRenderer}.
	     *
	     * @static
	     * @constant
	     * @property {object} DEFAULT_RENDER_OPTIONS
	     * @property {HTMLCanvasElement} DEFAULT_RENDER_OPTIONS.view=null
	     * @property {boolean} DEFAULT_RENDER_OPTIONS.transparent=false
	     * @property {boolean} DEFAULT_RENDER_OPTIONS.antialias=false
	     * @property {boolean} DEFAULT_RENDER_OPTIONS.forceFXAA=false
	     * @property {boolean} DEFAULT_RENDER_OPTIONS.preserveDrawingBuffer=false
	     * @property {number} DEFAULT_RENDER_OPTIONS.resolution=1
	     * @property {number} DEFAULT_RENDER_OPTIONS.backgroundColor=0x000000
	     * @property {boolean} DEFAULT_RENDER_OPTIONS.clearBeforeRender=true
	     * @property {boolean} DEFAULT_RENDER_OPTIONS.autoResize=false
	     */
	    DEFAULT_RENDER_OPTIONS: {
	        view: null,
	        resolution: 1,
	        antialias: false,
	        forceFXAA: false,
	        autoResize: false,
	        transparent: false,
	        backgroundColor: 0x000000,
	        clearBeforeRender: true,
	        preserveDrawingBuffer: false,
	        roundPixels: false
	    },
	
	    /**
	     * Constants that identify shapes, mainly to prevent `instanceof` calls.
	     *
	     * @static
	     * @constant
	     * @property {object} SHAPES
	     * @property {object} SHAPES.POLY=0
	     * @property {object} SHAPES.RECT=1
	     * @property {object} SHAPES.CIRC=2
	     * @property {object} SHAPES.ELIP=3
	     * @property {object} SHAPES.RREC=4
	     */
	    SHAPES: {
	        POLY: 0,
	        RECT: 1,
	        CIRC: 2,
	        ELIP: 3,
	        RREC: 4
	    },
	
	    // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
	    // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
	    SPRITE_BATCH_SIZE: 2000 //nice balance between mobile and desktop machines
	};
	
	module.exports = CONST;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Math classes and utilities mixed into PIXI namespace.
	 *
	 * @lends PIXI
	 */
	module.exports = {
	    // These will be mixed to be made publicly available,
	    // while this module is used internally in core
	    // to avoid circular dependencies and cut down on
	    // internal module requires.
	
	    Point:      __webpack_require__(16),
	    Matrix:     __webpack_require__(17),
	    GroupD8:    __webpack_require__(18),
	
	    Circle:     __webpack_require__(19),
	    Ellipse:    __webpack_require__(21),
	    Polygon:    __webpack_require__(22),
	    Rectangle:  __webpack_require__(20),
	    RoundedRectangle: __webpack_require__(23)
	};


/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * The Point object represents a location in a two-dimensional coordinate system, where x represents
	 * the horizontal axis and y represents the vertical axis.
	 *
	 * @class
	 * @memberof PIXI
	 * @param [x=0] {number} position of the point on the x axis
	 * @param [y=0] {number} position of the point on the y axis
	 */
	function Point(x, y)
	{
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y || 0;
	}
	
	Point.prototype.constructor = Point;
	module.exports = Point;
	
	/**
	 * Creates a clone of this point
	 *
	 * @return {PIXI.Point} a copy of the point
	 */
	Point.prototype.clone = function ()
	{
	    return new Point(this.x, this.y);
	};
	
	/**
	 * Copies x and y from the given point
	 *
	 * @param p {PIXI.Point}
	 */
	Point.prototype.copy = function (p) {
	    this.set(p.x, p.y);
	};
	
	/**
	 * Returns true if the given point is equal to this point
	 *
	 * @param p {PIXI.Point}
	 * @returns {boolean}
	 */
	Point.prototype.equals = function (p) {
	    return (p.x === this.x) && (p.y === this.y);
	};
	
	/**
	 * Sets the point to a new x and y position.
	 * If y is omitted, both x and y will be set to x.
	 *
	 * @param [x=0] {number} position of the point on the x axis
	 * @param [y=0] {number} position of the point on the y axis
	 */
	Point.prototype.set = function (x, y)
	{
	    this.x = x || 0;
	    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	// @todo - ignore the too many parameters warning for now
	// should either fix it or change the jshint config
	// jshint -W072
	
	var Point = __webpack_require__(16);
	
	/**
	 * The pixi Matrix class as an object, which makes it a lot faster,
	 * here is a representation of it :
	 * | a | b | tx|
	 * | c | d | ty|
	 * | 0 | 0 | 1 |
	 *
	 * @class
	 * @memberof PIXI
	 */
	function Matrix()
	{
	    /**
	     * @member {number}
	     * @default 1
	     */
	    this.a = 1;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.b = 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.c = 0;
	
	    /**
	     * @member {number}
	     * @default 1
	     */
	    this.d = 1;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.tx = 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.ty = 0;
	}
	
	Matrix.prototype.constructor = Matrix;
	module.exports = Matrix;
	
	/**
	 * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
	 *
	 * a = array[0]
	 * b = array[1]
	 * c = array[3]
	 * d = array[4]
	 * tx = array[2]
	 * ty = array[5]
	 *
	 * @param array {number[]} The array that the matrix will be populated from.
	 */
	Matrix.prototype.fromArray = function (array)
	{
	    this.a = array[0];
	    this.b = array[1];
	    this.c = array[3];
	    this.d = array[4];
	    this.tx = array[2];
	    this.ty = array[5];
	};
	
	
	/**
	 * sets the matrix properties
	 *
	 * @param {number} a
	 * @param {number} b
	 * @param {number} c
	 * @param {number} d
	 * @param {number} tx
	 * @param {number} ty
	 *
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.set = function (a, b, c, d, tx, ty)
	{
	    this.a = a;
	    this.b = b;
	    this.c = c;
	    this.d = d;
	    this.tx = tx;
	    this.ty = ty;
	
	    return this;
	};
	
	
	/**
	 * Creates an array from the current Matrix object.
	 *
	 * @param transpose {boolean} Whether we need to transpose the matrix or not
	 * @param [out] {Array} If provided the array will be assigned to out
	 * @return {number[]} the newly created array which contains the matrix
	 */
	Matrix.prototype.toArray = function (transpose, out)
	{
	    if (!this.array)
	    {
	        this.array = new Float32Array(9);
	    }
	
	    var array = out || this.array;
	
	    if (transpose)
	    {
	        array[0] = this.a;
	        array[1] = this.b;
	        array[2] = 0;
	        array[3] = this.c;
	        array[4] = this.d;
	        array[5] = 0;
	        array[6] = this.tx;
	        array[7] = this.ty;
	        array[8] = 1;
	    }
	    else
	    {
	        array[0] = this.a;
	        array[1] = this.c;
	        array[2] = this.tx;
	        array[3] = this.b;
	        array[4] = this.d;
	        array[5] = this.ty;
	        array[6] = 0;
	        array[7] = 0;
	        array[8] = 1;
	    }
	
	    return array;
	};
	
	/**
	 * Get a new position with the current transformation applied.
	 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
	 *
	 * @param pos {PIXI.Point} The origin
	 * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)
	 * @return {PIXI.Point} The new point, transformed through this matrix
	 */
	Matrix.prototype.apply = function (pos, newPos)
	{
	    newPos = newPos || new Point();
	
	    var x = pos.x;
	    var y = pos.y;
	
	    newPos.x = this.a * x + this.c * y + this.tx;
	    newPos.y = this.b * x + this.d * y + this.ty;
	
	    return newPos;
	};
	
	/**
	 * Get a new position with the inverse of the current transformation applied.
	 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
	 *
	 * @param pos {PIXI.Point} The origin
	 * @param [newPos] {PIXI.Point} The point that the new position is assigned to (allowed to be same as input)
	 * @return {PIXI.Point} The new point, inverse-transformed through this matrix
	 */
	Matrix.prototype.applyInverse = function (pos, newPos)
	{
	    newPos = newPos || new Point();
	
	    var id = 1 / (this.a * this.d + this.c * -this.b);
	
	    var x = pos.x;
	    var y = pos.y;
	
	    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
	    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
	
	    return newPos;
	};
	
	/**
	 * Translates the matrix on the x and y.
	 *
	 * @param {number} x
	 * @param {number} y
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.translate = function (x, y)
	{
	    this.tx += x;
	    this.ty += y;
	
	    return this;
	};
	
	/**
	 * Applies a scale transformation to the matrix.
	 *
	 * @param {number} x The amount to scale horizontally
	 * @param {number} y The amount to scale vertically
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.scale = function (x, y)
	{
	    this.a *= x;
	    this.d *= y;
	    this.c *= x;
	    this.b *= y;
	    this.tx *= x;
	    this.ty *= y;
	
	    return this;
	};
	
	
	/**
	 * Applies a rotation transformation to the matrix.
	 *
	 * @param {number} angle - The angle in radians.
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.rotate = function (angle)
	{
	    var cos = Math.cos( angle );
	    var sin = Math.sin( angle );
	
	    var a1 = this.a;
	    var c1 = this.c;
	    var tx1 = this.tx;
	
	    this.a = a1 * cos-this.b * sin;
	    this.b = a1 * sin+this.b * cos;
	    this.c = c1 * cos-this.d * sin;
	    this.d = c1 * sin+this.d * cos;
	    this.tx = tx1 * cos - this.ty * sin;
	    this.ty = tx1 * sin + this.ty * cos;
	
	    return this;
	};
	
	/**
	 * Appends the given Matrix to this Matrix.
	 *
	 * @param {PIXI.Matrix} matrix
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.append = function (matrix)
	{
	    var a1 = this.a;
	    var b1 = this.b;
	    var c1 = this.c;
	    var d1 = this.d;
	
	    this.a  = matrix.a * a1 + matrix.b * c1;
	    this.b  = matrix.a * b1 + matrix.b * d1;
	    this.c  = matrix.c * a1 + matrix.d * c1;
	    this.d  = matrix.c * b1 + matrix.d * d1;
	
	    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
	    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
	
	    return this;
	};
	
	/**
	 * Sets the matrix based on all the available properties
	 *
	 * @param {number} x
	 * @param {number} y
	 * @param {number} pivotX
	 * @param {number} pivotY
	 * @param {number} scaleX
	 * @param {number} scaleY
	 * @param {number} rotation
	 * @param {number} skewX
	 * @param {number} skewY
	 *
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.setTransform = function (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY)
	{
	    var a, b, c, d, sr, cr, cy, sy, nsx, cx;
	
	    sr  = Math.sin(rotation);
	    cr  = Math.cos(rotation);
	    cy  = Math.cos(skewY);
	    sy  = Math.sin(skewY);
	    nsx = -Math.sin(skewX);
	    cx  =  Math.cos(skewX);
	
	    a  =  cr * scaleX;
	    b  =  sr * scaleX;
	    c  = -sr * scaleY;
	    d  =  cr * scaleY;
	
	    this.a  = cy * a + sy * c;
	    this.b  = cy * b + sy * d;
	    this.c  = nsx * a + cx * c;
	    this.d  = nsx * b + cx * d;
	
	    this.tx = x + ( pivotX * a + pivotY * c );
	    this.ty = y + ( pivotX * b + pivotY * d );
	
	    return this;
	};
	
	/**
	 * Prepends the given Matrix to this Matrix.
	 *
	 * @param {PIXI.Matrix} matrix
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.prepend = function(matrix)
	{
	    var tx1 = this.tx;
	
	    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)
	    {
	        var a1 = this.a;
	        var c1 = this.c;
	        this.a  = a1*matrix.a+this.b*matrix.c;
	        this.b  = a1*matrix.b+this.b*matrix.d;
	        this.c  = c1*matrix.a+this.d*matrix.c;
	        this.d  = c1*matrix.b+this.d*matrix.d;
	    }
	
	    this.tx = tx1*matrix.a+this.ty*matrix.c+matrix.tx;
	    this.ty = tx1*matrix.b+this.ty*matrix.d+matrix.ty;
	
	    return this;
	};
	
	/**
	 * Inverts this matrix
	 *
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.invert = function()
	{
	    var a1 = this.a;
	    var b1 = this.b;
	    var c1 = this.c;
	    var d1 = this.d;
	    var tx1 = this.tx;
	    var n = a1*d1-b1*c1;
	
	    this.a = d1/n;
	    this.b = -b1/n;
	    this.c = -c1/n;
	    this.d = a1/n;
	    this.tx = (c1*this.ty-d1*tx1)/n;
	    this.ty = -(a1*this.ty-b1*tx1)/n;
	
	    return this;
	};
	
	
	/**
	 * Resets this Matix to an identity (default) matrix.
	 *
	 * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
	 */
	Matrix.prototype.identity = function ()
	{
	    this.a = 1;
	    this.b = 0;
	    this.c = 0;
	    this.d = 1;
	    this.tx = 0;
	    this.ty = 0;
	
	    return this;
	};
	
	/**
	 * Creates a new Matrix object with the same values as this one.
	 *
	 * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
	 */
	Matrix.prototype.clone = function ()
	{
	    var matrix = new Matrix();
	    matrix.a = this.a;
	    matrix.b = this.b;
	    matrix.c = this.c;
	    matrix.d = this.d;
	    matrix.tx = this.tx;
	    matrix.ty = this.ty;
	
	    return matrix;
	};
	
	/**
	 * Changes the values of the given matrix to be the same as the ones in this matrix
	 *
	 * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
	 */
	Matrix.prototype.copy = function (matrix)
	{
	    matrix.a = this.a;
	    matrix.b = this.b;
	    matrix.c = this.c;
	    matrix.d = this.d;
	    matrix.tx = this.tx;
	    matrix.ty = this.ty;
	
	    return matrix;
	};
	
	/**
	 * A default (identity) matrix
	 *
	 * @static
	 * @const
	 */
	Matrix.IDENTITY = new Matrix();
	
	/**
	 * A temp matrix
	 *
	 * @static
	 * @const
	 */
	Matrix.TEMP_MATRIX = new Matrix();


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16
	
	var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
	var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
	var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
	var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
	var tempMatrices = [];
	var Matrix = __webpack_require__(17);
	
	var mul = [];
	
	function signum(x) {
	    if (x < 0) {
	        return -1;
	    }
	    if (x > 0) {
	        return 1;
	    }
	    return 0;
	}
	
	function init() {
	    for (var i = 0; i < 16; i++) {
	        var row = [];
	        mul.push(row);
	        for (var j = 0; j < 16; j++) {
	            var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
	            var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
	            var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
	            var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
	            for (var k = 0; k < 16; k++) {
	                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
	                    row.push(k);
	                    break;
	                }
	            }
	        }
	    }
	
	    for (i=0;i<16;i++) {
	        var mat = new Matrix();
	        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
	        tempMatrices.push(mat);
	    }
	}
	
	init();
	
	/**
	 * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html}, D8 is the same but with diagonals
	 * Used for texture rotations
	 * Vector xX(i), xY(i) is U-axis of sprite with rotation i
	 * Vector yY(i), yY(i) is V-axis of sprite with rotation i
	 * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)
	 * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)
	 * This is the small part of gameofbombs.com portal system. It works.
	 * @author Ivan @ivanpopelyshev
	 *
	 * @namespace PIXI.GroupD8
	 */
	var GroupD8 = {
	    E: 0,
	    SE: 1,
	    S: 2,
	    SW: 3,
	    W: 4,
	    NW: 5,
	    N: 6,
	    NE: 7,
	    MIRROR_VERTICAL: 8,
	    MIRROR_HORIZONTAL: 12,
	    uX: function (ind) {
	        return ux[ind];
	    },
	    uY: function (ind) {
	        return uy[ind];
	    },
	    vX: function (ind) {
	        return vx[ind];
	    },
	    vY: function (ind) {
	        return vy[ind];
	    },
	    inv: function (rotation) {
	        if (rotation & 8) {
	            return rotation & 15;
	        }
	        return (-rotation) & 7;
	    },
	    add: function (rotationSecond, rotationFirst) {
	        return mul[rotationSecond][rotationFirst];
	    },
	    sub: function (rotationSecond, rotationFirst) {
	        return mul[rotationSecond][GroupD8.inv(rotationFirst)];
	    },
	    /**
	     * Adds 180 degrees to rotation. Commutative operation
	     * @param rotation
	     * @returns {number}
	     */
	    rotate180: function (rotation) {
	        return rotation ^ 4;
	    },
	    /**
	     * I dont know why sometimes width and heights needs to be swapped. We'll fix it later.
	     * @param rotation
	     * @returns {boolean}
	     */
	    isSwapWidthHeight: function(rotation) {
	        return (rotation & 3) === 2;
	    },
	    byDirection: function (dx, dy) {
	        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
	            if (dy >= 0) {
	                return GroupD8.S;
	            }
	            else {
	                return GroupD8.N;
	            }
	        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
	            if (dx > 0) {
	                return GroupD8.E;
	            }
	            else {
	                return GroupD8.W;
	            }
	        } else {
	            if (dy > 0) {
	                if (dx > 0) {
	                    return GroupD8.SE;
	                }
	                else {
	                    return GroupD8.SW;
	                }
	            }
	            else if (dx > 0) {
	                return GroupD8.NE;
	            }
	            else {
	                return GroupD8.NW;
	            }
	        }
	    },
	    /**
	     * Helps sprite to compensate texture packer rotation.
	     * @param matrix {PIXI.Matrix} sprite world matrix
	     * @param rotation {number}
	     * @param tx {number|*} sprite anchoring
	     * @param ty {number|*} sprite anchoring
	     */
	    matrixAppendRotationInv: function (matrix, rotation, tx, ty) {
	        //Packer used "rotation", we use "inv(rotation)"
	        var mat = tempMatrices[GroupD8.inv(rotation)];
	        tx = tx || 0;
	        ty = ty || 0;
	        mat.tx = tx;
	        mat.ty = ty;
	        matrix.append(mat);
	    }
	};
	
	module.exports = GroupD8;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var Rectangle = __webpack_require__(20),
	    CONST = __webpack_require__(14);
	
	/**
	 * The Circle object can be used to specify a hit area for displayObjects
	 *
	 * @class
	 * @memberof PIXI
	 * @param x {number} The X coordinate of the center of this circle
	 * @param y {number} The Y coordinate of the center of this circle
	 * @param radius {number} The radius of the circle
	 */
	function Circle(x, y, radius)
	{
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.radius = radius || 0;
	
	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     */
	    this.type = CONST.SHAPES.CIRC;
	}
	
	Circle.prototype.constructor = Circle;
	module.exports = Circle;
	
	/**
	 * Creates a clone of this Circle instance
	 *
	 * @return {PIXI.Circle} a copy of the Circle
	 */
	Circle.prototype.clone = function ()
	{
	    return new Circle(this.x, this.y, this.radius);
	};
	
	/**
	 * Checks whether the x and y coordinates given are contained within this circle
	 *
	 * @param x {number} The X coordinate of the point to test
	 * @param y {number} The Y coordinate of the point to test
	 * @return {boolean} Whether the x/y coordinates are within this Circle
	 */
	Circle.prototype.contains = function (x, y)
	{
	    if (this.radius <= 0)
	    {
	        return false;
	    }
	
	    var dx = (this.x - x),
	        dy = (this.y - y),
	        r2 = this.radius * this.radius;
	
	    dx *= dx;
	    dy *= dy;
	
	    return (dx + dy <= r2);
	};
	
	/**
	* Returns the framing rectangle of the circle as a Rectangle object
	*
	* @return {PIXI.Rectangle} the framing rectangle
	*/
	Circle.prototype.getBounds = function ()
	{
	    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var CONST = __webpack_require__(14);
	
	/**
	 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
	 *
	 * @class
	 * @memberof PIXI
	 * @param x {number} The X coordinate of the upper-left corner of the rectangle
	 * @param y {number} The Y coordinate of the upper-left corner of the rectangle
	 * @param width {number} The overall width of this rectangle
	 * @param height {number} The overall height of this rectangle
	 */
	function Rectangle(x, y, width, height)
	{
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.width = width || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.height = height || 0;
	
	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     */
	    this.type = CONST.SHAPES.RECT;
	}
	
	Rectangle.prototype.constructor = Rectangle;
	module.exports = Rectangle;
	
	/**
	 * A constant empty rectangle.
	 *
	 * @static
	 * @constant
	 */
	Rectangle.EMPTY = new Rectangle(0, 0, 0, 0);
	
	
	/**
	 * Creates a clone of this Rectangle
	 *
	 * @return {PIXI.Rectangle} a copy of the rectangle
	 */
	Rectangle.prototype.clone = function ()
	{
	    return new Rectangle(this.x, this.y, this.width, this.height);
	};
	
	/**
	 * Checks whether the x and y coordinates given are contained within this Rectangle
	 *
	 * @param x {number} The X coordinate of the point to test
	 * @param y {number} The Y coordinate of the point to test
	 * @return {boolean} Whether the x/y coordinates are within this Rectangle
	 */
	Rectangle.prototype.contains = function (x, y)
	{
	    if (this.width <= 0 || this.height <= 0)
	    {
	        return false;
	    }
	
	    if (x >= this.x && x < this.x + this.width)
	    {
	        if (y >= this.y && y < this.y + this.height)
	        {
	            return true;
	        }
	    }
	
	    return false;
	};


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var Rectangle = __webpack_require__(20),
	    CONST = __webpack_require__(14);
	
	/**
	 * The Ellipse object can be used to specify a hit area for displayObjects
	 *
	 * @class
	 * @memberof PIXI
	 * @param x {number} The X coordinate of the center of the ellipse
	 * @param y {number} The Y coordinate of the center of the ellipse
	 * @param width {number} The half width of this ellipse
	 * @param height {number} The half height of this ellipse
	 */
	function Ellipse(x, y, width, height)
	{
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.width = width || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.height = height || 0;
	
	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     */
	    this.type = CONST.SHAPES.ELIP;
	}
	
	Ellipse.prototype.constructor = Ellipse;
	module.exports = Ellipse;
	
	/**
	 * Creates a clone of this Ellipse instance
	 *
	 * @return {PIXI.Ellipse} a copy of the ellipse
	 */
	Ellipse.prototype.clone = function ()
	{
	    return new Ellipse(this.x, this.y, this.width, this.height);
	};
	
	/**
	 * Checks whether the x and y coordinates given are contained within this ellipse
	 *
	 * @param x {number} The X coordinate of the point to test
	 * @param y {number} The Y coordinate of the point to test
	 * @return {boolean} Whether the x/y coords are within this ellipse
	 */
	Ellipse.prototype.contains = function (x, y)
	{
	    if (this.width <= 0 || this.height <= 0)
	    {
	        return false;
	    }
	
	    //normalize the coords to an ellipse with center 0,0
	    var normx = ((x - this.x) / this.width),
	        normy = ((y - this.y) / this.height);
	
	    normx *= normx;
	    normy *= normy;
	
	    return (normx + normy <= 1);
	};
	
	/**
	 * Returns the framing rectangle of the ellipse as a Rectangle object
	 *
	 * @return {PIXI.Rectangle} the framing rectangle
	 */
	Ellipse.prototype.getBounds = function ()
	{
	    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var Point = __webpack_require__(16),
	    CONST = __webpack_require__(14);
	
	/**
	 * @class
	 * @memberof PIXI
	 * @param points {PIXI.Point[]|number[]|...PIXI.Point|...number} This can be an array of Points that form the polygon,
	 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
	 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
	 *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
	 *      Numbers.
	 */
	function Polygon(points_)
	{
	    // prevents an argument assignment deopt
	    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
	    var points = points_;
	
	    //if points isn't an array, use arguments as the array
	    if (!Array.isArray(points))
	    {
	        // prevents an argument leak deopt
	        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
	        points = new Array(arguments.length);
	
	        for (var a = 0; a < points.length; ++a) {
	            points[a] = arguments[a];
	        }
	    }
	
	    // if this is an array of points, convert it to a flat array of numbers
	    if (points[0] instanceof Point)
	    {
	        var p = [];
	        for (var i = 0, il = points.length; i < il; i++)
	        {
	            p.push(points[i].x, points[i].y);
	        }
	
	        points = p;
	    }
	
	    this.closed = true;
	
	    /**
	     * An array of the points of this polygon
	     *
	     * @member {number[]}
	     */
	    this.points = points;
	
	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     */
	    this.type = CONST.SHAPES.POLY;
	}
	
	Polygon.prototype.constructor = Polygon;
	module.exports = Polygon;
	
	/**
	 * Creates a clone of this polygon
	 *
	 * @return {PIXI.Polygon} a copy of the polygon
	 */
	Polygon.prototype.clone = function ()
	{
	    return new Polygon(this.points.slice());
	};
	
	/**
	 * Checks whether the x and y coordinates passed to this function are contained within this polygon
	 *
	 * @param x {number} The X coordinate of the point to test
	 * @param y {number} The Y coordinate of the point to test
	 * @return {boolean} Whether the x/y coordinates are within this polygon
	 */
	Polygon.prototype.contains = function (x, y)
	{
	    var inside = false;
	
	    // use some raycasting to test hits
	    // https://github.com/substack/point-in-polygon/blob/master/index.js
	    var length = this.points.length / 2;
	
	    for (var i = 0, j = length - 1; i < length; j = i++)
	    {
	        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],
	            xj = this.points[j * 2], yj = this.points[j * 2 + 1],
	            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
	
	        if (intersect)
	        {
	            inside = !inside;
	        }
	    }
	
	    return inside;
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var CONST = __webpack_require__(14);
	
	/**
	 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its top-left corner point (x, y) and by its width and its height and its radius.
	 *
	 * @class
	 * @memberof PIXI
	 * @param x {number} The X coordinate of the upper-left corner of the rounded rectangle
	 * @param y {number} The Y coordinate of the upper-left corner of the rounded rectangle
	 * @param width {number} The overall width of this rounded rectangle
	 * @param height {number} The overall height of this rounded rectangle
	 * @param radius {number} Controls the radius of the rounded corners
	 */
	function RoundedRectangle(x, y, width, height, radius)
	{
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.x = x || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.y = y || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.width = width || 0;
	
	    /**
	     * @member {number}
	     * @default 0
	     */
	    this.height = height || 0;
	
	    /**
	     * @member {number}
	     * @default 20
	     */
	    this.radius = radius || 20;
	
	    /**
	     * The type of the object, mainly used to avoid `instanceof` checks
	     *
	     * @member {number}
	     */
	    this.type = CONST.SHAPES.RREC;
	}
	
	RoundedRectangle.prototype.constructor = RoundedRectangle;
	module.exports = RoundedRectangle;
	
	/**
	 * Creates a clone of this Rounded Rectangle
	 *
	 * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
	 */
	RoundedRectangle.prototype.clone = function ()
	{
	    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
	};
	
	/**
	 * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
	 *
	 * @param x {number} The X coordinate of the point to test
	 * @param y {number} The Y coordinate of the point to test
	 * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
	 */
	RoundedRectangle.prototype.contains = function (x, y)
	{
	    if (this.width <= 0 || this.height <= 0)
	    {
	        return false;
	    }
	
	    if (x >= this.x && x <= this.x + this.width)
	    {
	        if (y >= this.y && y <= this.y + this.height)
	        {
	            return true;
	        }
	    }
	
	    return false;
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var CONST = __webpack_require__(14);
	
	/**
	 * @namespace PIXI.utils
	 */
	var utils = module.exports = {
	    _uid: 0,
	    _saidHello: false,
	
	    EventEmitter:   __webpack_require__(25),
	    pluginTarget:   __webpack_require__(26),
	    async:          __webpack_require__(27),
	
	    /**
	     * Gets the next unique identifier
	     *
	     * @return {number} The next unique identifier to use.
	     */
	    uid: function ()
	    {
	        return ++utils._uid;
	    },
	
	    /**
	     * Converts a hex color number to an [R, G, B] array
	     *
	     * @param hex {number}
	     * @param  {number[]} [out=[]]
	     * @return {number[]} An array representing the [R, G, B] of the color.
	     */
	    hex2rgb: function (hex, out)
	    {
	        out = out || [];
	
	        out[0] = (hex >> 16 & 0xFF) / 255;
	        out[1] = (hex >> 8 & 0xFF) / 255;
	        out[2] = (hex & 0xFF) / 255;
	
	        return out;
	    },
	
	    /**
	     * Converts a hex color number to a string.
	     *
	     * @param hex {number}
	     * @return {string} The string color.
	     */
	    hex2string: function (hex)
	    {
	        hex = hex.toString(16);
	        hex = '000000'.substr(0, 6 - hex.length) + hex;
	
	        return '#' + hex;
	    },
	
	    /**
	     * Converts a color as an [R, G, B] array to a hex number
	     *
	     * @param rgb {number[]}
	     * @return {number} The color number
	     */
	    rgb2hex: function (rgb)
	    {
	        return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
	    },
	
	    /**
	     * Checks whether the Canvas BlendModes are supported by the current browser
	     *
	     * @return {boolean} whether they are supported
	     */
	    canUseNewCanvasBlendModes: function ()
	    {
	        if (typeof document === 'undefined')
	        {
	            return false;
	        }
	
	        var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
	        var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';
	
	        var magenta = new Image();
	        magenta.src = pngHead + 'AP804Oa6' + pngEnd;
	
	        var yellow = new Image();
	        yellow.src = pngHead + '/wCKxvRF' + pngEnd;
	
	        var canvas = document.createElement('canvas');
	        canvas.width = 6;
	        canvas.height = 1;
	
	        var context = canvas.getContext('2d');
	        context.globalCompositeOperation = 'multiply';
	        context.drawImage(magenta, 0, 0);
	        context.drawImage(yellow, 2, 0);
	
	        var data = context.getImageData(2,0,1,1).data;
	
	        return (data[0] === 255 && data[1] === 0 && data[2] === 0);
	    },
	
	    /**
	     * Given a number, this function returns the closest number that is a power of two
	     * this function is taken from Starling Framework as its pretty neat ;)
	     *
	     * @param number {number}
	     * @return {number} the closest number that is a power of two
	     */
	    getNextPowerOfTwo: function (number)
	    {
	        // see: http://en.wikipedia.org/wiki/Power_of_two#Fast_algorithm_to_check_if_a_positive_number_is_a_power_of_two
	        if (number > 0 && (number & (number - 1)) === 0)
	        {
	            return number;
	        }
	        else
	        {
	            var result = 1;
	
	            while (result < number)
	            {
	                result <<= 1;
	            }
	
	            return result;
	        }
	    },
	
	    /**
	     * checks if the given width and height make a power of two rectangle
	     *
	     * @param width {number}
	     * @param height {number}
	     * @return {boolean}
	     */
	    isPowerOfTwo: function (width, height)
	    {
	        return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
	    },
	
	    /**
	     * get the resolution of an asset by looking for the prefix
	     * used by spritesheets and image urls
	     *
	     * @param url {string} the image path
	     * @return {number}
	     */
	    getResolutionOfUrl: function (url)
	    {
	        var resolution = CONST.RETINA_PREFIX.exec(url);
	
	        if (resolution)
	        {
	           return parseFloat(resolution[1]);
	        }
	
	        return 1;
	    },
	
	    /**
	     * Logs out the version and renderer information for this running instance of PIXI.
	     * If you don't want to see this message you can set `PIXI.utils._saidHello = true;`
	     * so the library thinks it already said it. Keep in mind that doing that will forever
	     * makes you a jerk face.
	     *
	     * @param {string} type - The string renderer type to log.
	     * @constant
	     * @static
	     */
	    sayHello: function (type)
	    {
	        if (utils._saidHello)
	        {
	            return;
	        }
	
	        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1)
	        {
	            var args = [
	                '\n %c %c %c Pixi.js ' + CONST.VERSION + ' -  ' + type + '   %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c %c%c \n\n',
	                'background: #ff66a5; padding:5px 0;',
	                'background: #ff66a5; padding:5px 0;',
	                'color: #ff66a5; background: #030307; padding:5px 0;',
	                'background: #ff66a5; padding:5px 0;',
	                'background: #ffc3dc; padding:5px 0;',
	                'background: #ff66a5; padding:5px 0;',
	                'color: #ff2424; background: #fff; padding:5px 0;',
	                'color: #ff2424; background: #fff; padding:5px 0;',
	                'color: #ff2424; background: #fff; padding:5px 0;'
	            ];
	
	            window.console.log.apply(console, args); //jshint ignore:line
	        }
	        else if (window.console)
	        {
	            window.console.log('Pixi.js ' + CONST.VERSION + ' - ' + type + ' - http://www.pixijs.com/'); //jshint ignore:line
	        }
	
	        utils._saidHello = true;
	    },
	
	    /**
	     * Helper for checking for webgl support
	     *
	     * @return {boolean}
	     */
	    isWebGLSupported: function ()
	    {
	        var contextOptions = { stencil: true };
	        try
	        {
	            if (!window.WebGLRenderingContext)
	            {
	                return false;
	            }
	
	            var canvas = document.createElement('canvas'),
	                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
	
	            return !!(gl && gl.getContextAttributes().stencil);
	        }
	        catch (e)
	        {
	            return false;
	        }
	    },
	
	    /**
	     * Returns sign of number
	     *
	     * @param n {number}
	     * @returns {number} 0 if n is 0, -1 if n is negative, 1 if n i positive
	     */
	    sign: function (n)
	    {
	        return n ? (n < 0 ? -1 : 1) : 0;
	    },
	
	    /**
	     * removeItems
	     *
	     * @param {array} arr The target array
	     * @param {number} startIdx The index to begin removing from (inclusive)
	     * @param {number} removeCount How many items to remove
	     */
	    removeItems: function (arr, startIdx, removeCount)
	    {
	        var length = arr.length;
	
	        if (startIdx >= length || removeCount === 0)
	        {
	            return;
	        }
	
	        removeCount = (startIdx+removeCount > length ? length-startIdx : removeCount);
	        for (var i = startIdx, len = length-removeCount; i < len; ++i)
	        {
	            arr[i] = arr[i + removeCount];
	        }
	
	        arr.length = len;
	    },
	
	    /**
	     * @todo Describe property usage
	     * @private
	     */
	    TextureCache: {},
	
	    /**
	     * @todo Describe property usage
	     * @private
	     */
	    BaseTextureCache: {}
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var has = Object.prototype.hasOwnProperty;
	
	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;
	
	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} [once=false] Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}
	
	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }
	
	/**
	 * Hold the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;
	
	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var events = this._events
	    , names = []
	    , name;
	
	  if (!events) return names;
	
	  for (name in events) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }
	
	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }
	
	  return names;
	};
	
	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];
	
	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];
	
	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }
	
	  return ee;
	};
	
	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return false;
	
	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;
	
	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	
	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }
	
	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }
	
	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;
	
	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	
	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }
	
	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return this;
	
	  var listeners = this._events[evt]
	    , events = [];
	
	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }
	
	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }
	
	  return this;
	};
	
	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;
	
	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);
	
	  return this;
	};
	
	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	
	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};
	
	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;
	
	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * Mixins functionality to make an object have "plugins".
	 *
	 * @mixin
	 * @memberof PIXI.utils
	 * @param obj {object} The object to mix into.
	 * @example
	 *      function MyObject() {}
	 *
	 *      pluginTarget.mixin(MyObject);
	 */
	function pluginTarget(obj)
	{
	    obj.__plugins = {};
	
	    /**
	     * Adds a plugin to an object
	     *
	     * @param pluginName {string} The events that should be listed.
	     * @param ctor {Function} The constructor function for the plugin.
	     */
	    obj.registerPlugin = function (pluginName, ctor)
	    {
	        obj.__plugins[pluginName] = ctor;
	    };
	
	    /**
	     * Instantiates all the plugins of this object
	     *
	     */
	    obj.prototype.initPlugins = function ()
	    {
	        this.plugins = this.plugins || {};
	
	        for (var o in obj.__plugins)
	        {
	            this.plugins[o] = new (obj.__plugins[o])(this);
	        }
	    };
	
	    /**
	     * Removes all the plugins of this object
	     *
	     */
	    obj.prototype.destroyPlugins = function ()
	    {
	        for (var o in this.plugins)
	        {
	            this.plugins[o].destroy();
	            this.plugins[o] = null;
	        }
	
	        this.plugins = null;
	    };
	}
	
	
	module.exports = {
	    /**
	     * Mixes in the properties of the pluginTarget into another object
	     *
	     * @param object {object} The obj to mix into
	     */
	    mixin: function mixin(obj)
	    {
	        pluginTarget(obj);
	    }
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	(function () {
	
	    var async = {};
	    function noop() {}
	    function identity(v) {
	        return v;
	    }
	    function toBool(v) {
	        return !!v;
	    }
	    function notId(v) {
	        return !v;
	    }
	
	    // global on the server, window in the browser
	    var previous_async;
	
	    // Establish the root object, `window` (`self`) in the browser, `global`
	    // on the server, or `this` in some virtual machines. We use `self`
	    // instead of `window` for `WebWorker` support.
	    var root = typeof self === 'object' && self.self === self && self ||
	            typeof global === 'object' && global.global === global && global ||
	            this;
	
	    if (root != null) {
	        previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        return function() {
	            if (fn === null) throw new Error("Callback was already called.");
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    function _once(fn) {
	        return function() {
	            if (fn === null) return;
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    // Ported from underscore.js isObject
	    var _isObject = function(obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };
	
	    function _isArrayLike(arr) {
	        return _isArray(arr) || (
	            // has a positive integer length property
	            typeof arr.length === "number" &&
	            arr.length >= 0 &&
	            arr.length % 1 === 0
	        );
	    }
	
	    function _arrayEach(arr, iterator) {
	        var index = -1,
	            length = arr.length;
	
	        while (++index < length) {
	            iterator(arr[index], index, arr);
	        }
	    }
	
	    function _map(arr, iterator) {
	        var index = -1,
	            length = arr.length,
	            result = Array(length);
	
	        while (++index < length) {
	            result[index] = iterator(arr[index], index, arr);
	        }
	        return result;
	    }
	
	    function _range(count) {
	        return _map(Array(count), function (v, i) { return i; });
	    }
	
	    function _reduce(arr, iterator, memo) {
	        _arrayEach(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    }
	
	    function _forEachOf(object, iterator) {
	        _arrayEach(_keys(object), function (key) {
	            iterator(object[key], key);
	        });
	    }
	
	    function _indexOf(arr, item) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === item) return i;
	        }
	        return -1;
	    }
	
	    var _keys = Object.keys || function (obj) {
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    function _keyIterator(coll) {
	        var i = -1;
	        var len;
	        var keys;
	        if (_isArrayLike(coll)) {
	            len = coll.length;
	            return function next() {
	                i++;
	                return i < len ? i : null;
	            };
	        } else {
	            keys = _keys(coll);
	            len = keys.length;
	            return function next() {
	                i++;
	                return i < len ? keys[i] : null;
	            };
	        }
	    }
	
	    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
	    // This accumulates the arguments passed into an array, after a given index.
	    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
	    function _restParam(func, startIndex) {
	        startIndex = startIndex == null ? func.length - 1 : +startIndex;
	        return function() {
	            var length = Math.max(arguments.length - startIndex, 0);
	            var rest = Array(length);
	            for (var index = 0; index < length; index++) {
	                rest[index] = arguments[index + startIndex];
	            }
	            switch (startIndex) {
	                case 0: return func.call(this, rest);
	                case 1: return func.call(this, arguments[0], rest);
	            }
	            // Currently unused but handle cases outside of the switch statement:
	            // var args = Array(startIndex + 1);
	            // for (index = 0; index < startIndex; index++) {
	            //     args[index] = arguments[index];
	            // }
	            // args[startIndex] = rest;
	            // return func.apply(this, args);
	        };
	    }
	
	    function _withoutIndex(iterator) {
	        return function (value, index, callback) {
	            return iterator(value, callback);
	        };
	    }
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	
	    // capture the global reference to guard against fakeTimer mocks
	    var _setImmediate = typeof setImmediate === 'function' && setImmediate;
	
	    var _delay = _setImmediate ? function(fn) {
	        // not a direct alias for IE10 compatibility
	        _setImmediate(fn);
	    } : function(fn) {
	        setTimeout(fn, 0);
	    };
	
	    if (typeof process === 'object' && typeof process.nextTick === 'function') {
	        async.nextTick = process.nextTick;
	    } else {
	        async.nextTick = _delay;
	    }
	    async.setImmediate = _setImmediate ? _delay : async.nextTick;
	
	
	    async.forEach =
	    async.each = function (arr, iterator, callback) {
	        return async.eachOf(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachSeries =
	    async.eachSeries = function (arr, iterator, callback) {
	        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
	    };
	
	
	    async.forEachLimit =
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachOf =
	    async.eachOf = function (object, iterator, callback) {
	        callback = _once(callback || noop);
	        object = object || [];
	
	        var iter = _keyIterator(object);
	        var key, completed = 0;
	
	        while ((key = iter()) != null) {
	            completed += 1;
	            iterator(object[key], key, only_once(done));
	        }
	
	        if (completed === 0) callback(null);
	
	        function done(err) {
	            completed--;
	            if (err) {
	                callback(err);
	            }
	            // Check key is null in case iterator isn't exhausted
	            // and done resolved synchronously.
	            else if (key === null && completed <= 0) {
	                callback(null);
	            }
	        }
	    };
	
	    async.forEachOfSeries =
	    async.eachOfSeries = function (obj, iterator, callback) {
	        callback = _once(callback || noop);
	        obj = obj || [];
	        var nextKey = _keyIterator(obj);
	        var key = nextKey();
	        function iterate() {
	            var sync = true;
	            if (key === null) {
	                return callback(null);
	            }
	            iterator(obj[key], key, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    key = nextKey();
	                    if (key === null) {
	                        return callback(null);
	                    } else {
	                        if (sync) {
	                            async.setImmediate(iterate);
	                        } else {
	                            iterate();
	                        }
	                    }
	                }
	            }));
	            sync = false;
	        }
	        iterate();
	    };
	
	
	
	    async.forEachOfLimit =
	    async.eachOfLimit = function (obj, limit, iterator, callback) {
	        _eachOfLimit(limit)(obj, iterator, callback);
	    };
	
	    function _eachOfLimit(limit) {
	
	        return function (obj, iterator, callback) {
	            callback = _once(callback || noop);
	            obj = obj || [];
	            var nextKey = _keyIterator(obj);
	            if (limit <= 0) {
	                return callback(null);
	            }
	            var done = false;
	            var running = 0;
	            var errored = false;
	
	            (function replenish () {
	                if (done && running <= 0) {
	                    return callback(null);
	                }
	
	                while (running < limit && !errored) {
	                    var key = nextKey();
	                    if (key === null) {
	                        done = true;
	                        if (running <= 0) {
	                            callback(null);
	                        }
	                        return;
	                    }
	                    running += 1;
	                    iterator(obj[key], key, only_once(function (err) {
	                        running -= 1;
	                        if (err) {
	                            callback(err);
	                            errored = true;
	                        }
	                        else {
	                            replenish();
	                        }
	                    }));
	                }
	            })();
	        };
	    }
	
	
	    function doParallel(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOf, obj, iterator, callback);
	        };
	    }
	    function doParallelLimit(fn) {
	        return function (obj, limit, iterator, callback) {
	            return fn(_eachOfLimit(limit), obj, iterator, callback);
	        };
	    }
	    function doSeries(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOfSeries, obj, iterator, callback);
	        };
	    }
	
	    function _asyncMap(eachfn, arr, iterator, callback) {
	        callback = _once(callback || noop);
	        arr = arr || [];
	        var results = _isArrayLike(arr) ? [] : {};
	        eachfn(arr, function (value, index, callback) {
	            iterator(value, function (err, v) {
	                results[index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = doParallelLimit(_asyncMap);
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.inject =
	    async.foldl =
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachOfSeries(arr, function (x, i, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	
	    async.foldr =
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, identity).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	
	    async.transform = function (arr, memo, iterator, callback) {
	        if (arguments.length === 3) {
	            callback = iterator;
	            iterator = memo;
	            memo = _isArray(arr) ? [] : {};
	        }
	
	        async.eachOf(arr, function(v, k, cb) {
	            iterator(memo, v, k, cb);
	        }, function(err) {
	            callback(err, memo);
	        });
	    };
	
	    function _filter(eachfn, arr, iterator, callback) {
	        var results = [];
	        eachfn(arr, function (x, index, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    results.push({index: index, value: x});
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }
	
	    async.select =
	    async.filter = doParallel(_filter);
	
	    async.selectLimit =
	    async.filterLimit = doParallelLimit(_filter);
	
	    async.selectSeries =
	    async.filterSeries = doSeries(_filter);
	
	    function _reject(eachfn, arr, iterator, callback) {
	        _filter(eachfn, arr, function(value, cb) {
	            iterator(value, function(v) {
	                cb(!v);
	            });
	        }, callback);
	    }
	    async.reject = doParallel(_reject);
	    async.rejectLimit = doParallelLimit(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    function _createTester(eachfn, check, getResult) {
	        return function(arr, limit, iterator, cb) {
	            function done() {
	                if (cb) cb(getResult(false, void 0));
	            }
	            function iteratee(x, _, callback) {
	                if (!cb) return callback();
	                iterator(x, function (v) {
	                    if (cb && check(v)) {
	                        cb(getResult(true, x));
	                        cb = iterator = false;
	                    }
	                    callback();
	                });
	            }
	            if (arguments.length > 3) {
	                eachfn(arr, limit, iteratee, done);
	            } else {
	                cb = iterator;
	                iterator = limit;
	                eachfn(arr, iteratee, done);
	            }
	        };
	    }
	
	    async.any =
	    async.some = _createTester(async.eachOf, toBool, identity);
	
	    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
	
	    async.all =
	    async.every = _createTester(async.eachOf, notId, notId);
	
	    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
	
	    function _findGetResult(v, x) {
	        return x;
	    }
	    async.detect = _createTester(async.eachOf, identity, _findGetResult);
	    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
	    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                callback(null, _map(results.sort(comparator), function (x) {
	                    return x.value;
	                }));
	            }
	
	        });
	
	        function comparator(left, right) {
	            var a = left.criteria, b = right.criteria;
	            return a < b ? -1 : a > b ? 1 : 0;
	        }
	    };
	
	    async.auto = function (tasks, concurrency, callback) {
	        if (typeof arguments[1] === 'function') {
	            // concurrency is optional, shift the args.
	            callback = concurrency;
	            concurrency = null;
	        }
	        callback = _once(callback || noop);
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length;
	        if (!remainingTasks) {
	            return callback(null);
	        }
	        if (!concurrency) {
	            concurrency = remainingTasks;
	        }
	
	        var results = {};
	        var runningTasks = 0;
	
	        var hasError = false;
	
	        var listeners = [];
	        function addListener(fn) {
	            listeners.unshift(fn);
	        }
	        function removeListener(fn) {
	            var idx = _indexOf(listeners, fn);
	            if (idx >= 0) listeners.splice(idx, 1);
	        }
	        function taskComplete() {
	            remainingTasks--;
	            _arrayEach(listeners.slice(0), function (fn) {
	                fn();
	            });
	        }
	
	        addListener(function () {
	            if (!remainingTasks) {
	                callback(null, results);
	            }
	        });
	
	        _arrayEach(keys, function (k) {
	            if (hasError) return;
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = _restParam(function(err, args) {
	                runningTasks--;
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _forEachOf(results, function(val, rkey) {
	                        safeResults[rkey] = val;
	                    });
	                    safeResults[k] = args;
	                    hasError = true;
	
	                    callback(err, safeResults);
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            });
	            var requires = task.slice(0, task.length - 1);
	            // prevent dead-locks
	            var len = requires.length;
	            var dep;
	            while (len--) {
	                if (!(dep = tasks[requires[len]])) {
	                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
	                }
	                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
	                    throw new Error('Has cyclic dependencies');
	                }
	            }
	            function ready() {
	                return runningTasks < concurrency && _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            }
	            if (ready()) {
	                runningTasks++;
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                addListener(listener);
	            }
	            function listener() {
	                if (ready()) {
	                    runningTasks++;
	                    removeListener(listener);
	                    task[task.length - 1](taskCallback, results);
	                }
	            }
	        });
	    };
	
	
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var DEFAULT_INTERVAL = 0;
	
	        var attempts = [];
	
	        var opts = {
	            times: DEFAULT_TIMES,
	            interval: DEFAULT_INTERVAL
	        };
	
	        function parseTimes(acc, t){
	            if(typeof t === 'number'){
	                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
	            } else if(typeof t === 'object'){
	                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
	                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
	            } else {
	                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
	            }
	        }
	
	        var length = arguments.length;
	        if (length < 1 || length > 3) {
	            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
	        } else if (length <= 2 && typeof times === 'function') {
	            callback = task;
	            task = times;
	        }
	        if (typeof times !== 'function') {
	            parseTimes(opts, times);
	        }
	        opts.callback = callback;
	        opts.task = task;
	
	        function wrappedTask(wrappedCallback, wrappedResults) {
	            function retryAttempt(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            }
	
	            function retryInterval(interval){
	                return function(seriesCallback){
	                    setTimeout(function(){
	                        seriesCallback(null);
	                    }, interval);
	                };
	            }
	
	            while (opts.times) {
	
	                var finalAttempt = !(opts.times-=1);
	                attempts.push(retryAttempt(opts.task, finalAttempt));
	                if(!finalAttempt && opts.interval > 0){
	                    attempts.push(retryInterval(opts.interval));
	                }
	            }
	
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || opts.callback)(data.err, data.result);
	            });
	        }
	
	        // If a callback is passed, run this as a controll flow
	        return opts.callback ? wrappedTask() : wrappedTask;
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = _once(callback || noop);
	        if (!_isArray(tasks)) {
	            var err = new Error('First argument to waterfall must be an array of functions');
	            return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        function wrapIterator(iterator) {
	            return _restParam(function (err, args) {
	                if (err) {
	                    callback.apply(null, [err].concat(args));
	                }
	                else {
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    ensureAsync(iterator).apply(null, args);
	                }
	            });
	        }
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    function _parallel(eachfn, tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};
	
	        eachfn(tasks, function (task, key, callback) {
	            task(_restParam(function (err, args) {
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            }));
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.parallel = function (tasks, callback) {
	        _parallel(async.eachOf, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel(_eachOfLimit(limit), tasks, callback);
	    };
	
	    async.series = function(tasks, callback) {
	        _parallel(async.eachOfSeries, tasks, callback);
	    };
	
	    async.iterator = function (tasks) {
	        function makeCallback(index) {
	            function fn() {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            }
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        }
	        return makeCallback(0);
	    };
	
	    async.apply = _restParam(function (fn, args) {
	        return _restParam(function (callArgs) {
	            return fn.apply(
	                null, args.concat(callArgs)
	            );
	        });
	    });
	
	    function _concat(eachfn, arr, fn, callback) {
	        var result = [];
	        eachfn(arr, function (x, index, cb) {
	            fn(x, function (err, y) {
	                result = result.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, result);
	        });
	    }
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        callback = callback || noop;
	        if (test()) {
	            var next = _restParam(function(err, args) {
	                if (err) {
	                    callback(err);
	                } else if (test.apply(this, args)) {
	                    iterator(next);
	                } else {
	                    callback.apply(null, [null].concat(args));
	                }
	            });
	            iterator(next);
	        } else {
	            callback(null);
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        var calls = 0;
	        return async.whilst(function() {
	            return ++calls <= 1 || test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.until = function (test, iterator, callback) {
	        return async.whilst(function() {
	            return !test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        return async.doWhilst(iterator, function() {
	            return !test.apply(this, arguments);
	        }, callback);
	    };
	
	    async.during = function (test, iterator, callback) {
	        callback = callback || noop;
	
	        var next = _restParam(function(err, args) {
	            if (err) {
	                callback(err);
	            } else {
	                args.push(check);
	                test.apply(this, args);
	            }
	        });
	
	        var check = function(err, truth) {
	            if (err) {
	                callback(err);
	            } else if (truth) {
	                iterator(next);
	            } else {
	                callback(null);
	            }
	        };
	
	        test(check);
	    };
	
	    async.doDuring = function (iterator, test, callback) {
	        var calls = 0;
	        async.during(function(next) {
	            if (calls++ < 1) {
	                next(null, true);
	            } else {
	                test.apply(this, arguments);
	            }
	        }, iterator, callback);
	    };
	
	    function _queue(worker, concurrency, payload) {
	        if (concurrency == null) {
	            concurrency = 1;
	        }
	        else if(concurrency === 0) {
	            throw new Error('Concurrency must not be zero');
	        }
	        function _insert(q, data, pos, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0 && q.idle()) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    callback: callback || noop
	                };
	
	                if (pos) {
	                    q.tasks.unshift(item);
	                } else {
	                    q.tasks.push(item);
	                }
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	            });
	            async.setImmediate(q.process);
	        }
	        function _next(q, tasks) {
	            return function(){
	                workers -= 1;
	
	                var removed = false;
	                var args = arguments;
	                _arrayEach(tasks, function (task) {
	                    _arrayEach(workersList, function (worker, index) {
	                        if (worker === task && !removed) {
	                            workersList.splice(index, 1);
	                            removed = true;
	                        }
	                    });
	
	                    task.callback.apply(task, args);
	                });
	                if (q.tasks.length + workers === 0) {
	                    q.drain();
	                }
	                q.process();
	            };
	        }
	
	        var workers = 0;
	        var workersList = [];
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            payload: payload,
	            saturated: noop,
	            empty: noop,
	            drain: noop,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	                _insert(q, data, false, callback);
	            },
	            kill: function () {
	                q.drain = noop;
	                q.tasks = [];
	            },
	            unshift: function (data, callback) {
	                _insert(q, data, true, callback);
	            },
	            process: function () {
	                while(!q.paused && workers < q.concurrency && q.tasks.length){
	
	                    var tasks = q.payload ?
	                        q.tasks.splice(0, q.payload) :
	                        q.tasks.splice(0, q.tasks.length);
	
	                    var data = _map(tasks, function (task) {
	                        return task.data;
	                    });
	
	                    if (q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    workersList.push(tasks[0]);
	                    var cb = only_once(_next(q, tasks));
	                    worker(data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            workersList: function () {
	                return workersList;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                var resumeCount = Math.min(q.concurrency, q.tasks.length);
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= resumeCount; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    }
	
	    async.queue = function (worker, concurrency) {
	        var q = _queue(function (items, cb) {
	            worker(items[0], cb);
	        }, concurrency, 1);
	
	        return q;
	    };
	
	    async.priorityQueue = function (worker, concurrency) {
	
	        function _compareTasks(a, b){
	            return a.priority - b.priority;
	        }
	
	        function _binarySearch(sequence, item, compare) {
	            var beg = -1,
	                end = sequence.length - 1;
	            while (beg < end) {
	                var mid = beg + ((end - beg + 1) >>> 1);
	                if (compare(item, sequence[mid]) >= 0) {
	                    beg = mid;
	                } else {
	                    end = mid - 1;
	                }
	            }
	            return beg;
	        }
	
	        function _insert(q, data, priority, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    priority: priority,
	                    callback: typeof callback === 'function' ? callback : noop
	                };
	
	                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	                async.setImmediate(q.process);
	            });
	        }
	
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	            _insert(q, data, priority, callback);
	        };
	
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        return _queue(worker, 1, payload);
	    };
	
	    function _console_fn(name) {
	        return _restParam(function (fn, args) {
	            fn.apply(null, args.concat([_restParam(function (err, args) {
	                if (typeof console === 'object') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _arrayEach(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            })]));
	        });
	    }
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        var has = Object.prototype.hasOwnProperty;
	        hasher = hasher || identity;
	        var memoized = _restParam(function memoized(args) {
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (has.call(memo, key)) {   
	                async.setImmediate(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (has.call(queues, key)) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([_restParam(function (args) {
	                    memo[key] = args;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                        q[i].apply(null, args);
	                    }
	                })]));
	            }
	        });
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	        return function () {
	            return (fn.unmemoized || fn).apply(null, arguments);
	        };
	    };
	
	    function _times(mapper) {
	        return function (count, iterator, callback) {
	            mapper(_range(count), iterator, callback);
	        };
	    }
	
	    async.times = _times(async.map);
	    async.timesSeries = _times(async.mapSeries);
	    async.timesLimit = function (count, limit, iterator, callback) {
	        return async.mapLimit(_range(count), limit, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return _restParam(function (args) {
	            var that = this;
	
	            var callback = args[args.length - 1];
	            if (typeof callback == 'function') {
	                args.pop();
	            } else {
	                callback = noop;
	            }
	
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
	                    cb(err, nextargs);
	                })]));
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        });
	    };
	
	    async.compose = function (/* functions... */) {
	        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	
	    function _applyEach(eachfn) {
	        return _restParam(function(fns, args) {
	            var go = _restParam(function(args) {
	                var that = this;
	                var callback = args.pop();
	                return eachfn(fns, function (fn, _, cb) {
	                    fn.apply(that, args.concat([cb]));
	                },
	                callback);
	            });
	            if (args.length) {
	                return go.apply(this, args);
	            }
	            else {
	                return go;
	            }
	        });
	    }
	
	    async.applyEach = _applyEach(async.eachOf);
	    async.applyEachSeries = _applyEach(async.eachOfSeries);
	
	
	    async.forever = function (fn, callback) {
	        var done = only_once(callback || noop);
	        var task = ensureAsync(fn);
	        function next(err) {
	            if (err) {
	                return done(err);
	            }
	            task(next);
	        }
	        next();
	    };
	
	    function ensureAsync(fn) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            args.push(function () {
	                var innerArgs = arguments;
	                if (sync) {
	                    async.setImmediate(function () {
	                        callback.apply(null, innerArgs);
	                    });
	                } else {
	                    callback.apply(null, innerArgs);
	                }
	            });
	            var sync = true;
	            fn.apply(this, args);
	            sync = false;
	        });
	    }
	
	    async.ensureAsync = ensureAsync;
	
	    async.constant = _restParam(function(values) {
	        var args = [null].concat(values);
	        return function (callback) {
	            return callback.apply(this, args);
	        };
	    });
	
	    async.wrapSync =
	    async.asyncify = function asyncify(func) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            var result;
	            try {
	                result = func.apply(this, args);
	            } catch (e) {
	                return callback(e);
	            }
	            // if result is Promise object
	            if (_isObject(result) && typeof result.then === "function") {
	                result.then(function(value) {
	                    callback(null, value);
	                })["catch"](function(err) {
	                    callback(err.message ? err : new Error(err));
	                });
	            } else {
	                callback(null, result);
	            }
	        });
	    };
	
	    // Node.js
	    if (typeof module === 'object' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(28).setImmediate, __webpack_require__(30)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(29);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 68
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(30)))

/***/ },
/* 30 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var Ticker = __webpack_require__(32);
	
	/**
	 * The shared ticker instance used by {@link PIXI.extras.MovieClip}.
	 * and by {@link PIXI.interaction.InteractionManager}.
	 * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`
	 * for this instance. Please follow the examples for usage, including
	 * how to opt-out of auto-starting the shared ticker.
	 *
	 * @example
	 * var ticker = PIXI.ticker.shared;
	 * // Set this to prevent starting this ticker when listeners are added.
	 * // By default this is true only for the PIXI.ticker.shared instance.
	 * ticker.autoStart = false;
	 * // FYI, call this to ensure the ticker is stopped. It should be stopped
	 * // if you have not attempted to render anything yet.
	 * ticker.stop();
	 * // Call this when you are ready for a running shared ticker.
	 * ticker.start();
	 *
	 * @example
	 * // You may use the shared ticker to render...
	 * var renderer = PIXI.autoDetectRenderer(800, 600);
	 * var stage = new PIXI.Container();
	 * var interactionManager = PIXI.interaction.InteractionManager(renderer);
	 * document.body.appendChild(renderer.view);
	 * ticker.add(function (time) {
	 *     renderer.render(stage);
	 * });
	 *
	 * @example
	 * // Or you can just update it manually.
	 * ticker.autoStart = false;
	 * ticker.stop();
	 * function animate(time) {
	 *     ticker.update(time);
	 *     renderer.render(stage);
	 *     requestAnimationFrame(animate);
	 * }
	 * animate(performance.now());
	 *
	 * @type {PIXI.ticker.Ticker}
	 * @memberof PIXI.ticker
	 */
	var shared = new Ticker();
	shared.autoStart = true;
	
	/**
	 * @namespace PIXI.ticker
	 */
	module.exports = {
	    shared: shared,
	    Ticker: Ticker
	};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var CONST = __webpack_require__(14),
	    EventEmitter = __webpack_require__(25),
	    // Internal event used by composed emitter
	    TICK = 'tick';
	
	/**
	 * A Ticker class that runs an update loop that other objects listen to.
	 * This class is composed around an EventEmitter object to add listeners
	 * meant for execution on the next requested animation frame.
	 * Animation frames are requested only when necessary,
	 * e.g. When the ticker is started and the emitter has listeners.
	 *
	 * @class
	 * @memberof PIXI.ticker
	 */
	function Ticker()
	{
	    var _this = this;
	
	    /**
	     * Internal tick method bound to ticker instance.
	     * This is because in early 2015, Function.bind
	     * is still 60% slower in high performance scenarios.
	     * Also separating frame requests from update method
	     * so listeners may be called at any time and with
	     * any animation API, just invoke ticker.update(time).
	     *
	     * @private
	     */
	    this._tick = function _tick(time) {
	
	        _this._requestId = null;
	
	        if (_this.started)
	        {
	            // Invoke listeners now
	            _this.update(time);
	            // Listener side effects may have modified ticker state.
	            if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true))
	            {
	                _this._requestId = requestAnimationFrame(_this._tick);
	            }
	        }
	    };
	
	    /**
	     * Internal emitter used to fire 'tick' event
	     * @private
	     */
	    this._emitter = new EventEmitter();
	
	    /**
	     * Internal current frame request ID
	     * @private
	     */
	    this._requestId = null;
	
	    /**
	     * Internal value managed by minFPS property setter and getter.
	     * This is the maximum allowed milliseconds between updates.
	     * @private
	     */
	    this._maxElapsedMS = 100;
	
	    /**
	     * Whether or not this ticker should invoke the method
	     * {@link PIXI.ticker.Ticker#start} automatically
	     * when a listener is added.
	     *
	     * @member {boolean}
	     * @default false
	     */
	    this.autoStart = false;
	
	    /**
	     * Scalar time value from last frame to this frame.
	     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
	     * and is scaled with {@link PIXI.ticker.Ticker#speed}.
	     * **Note:** The cap may be exceeded by scaling.
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.deltaTime = 1;
	
	    /**
	     * Time elapsed in milliseconds from last frame to this frame.
	     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
	     * is based, this value is neither capped nor scaled.
	     * If the platform supports DOMHighResTimeStamp,
	     * this value will have a precision of 1 s.
	     *
	     * @member {DOMHighResTimeStamp|number}
	     * @default 1 / TARGET_FPMS
	     */
	    this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time
	
	    /**
	     * The last time {@link PIXI.ticker.Ticker#update} was invoked.
	     * This value is also reset internally outside of invoking
	     * update, but only when a new animation frame is requested.
	     * If the platform supports DOMHighResTimeStamp,
	     * this value will have a precision of 1 s.
	     *
	     * @member {DOMHighResTimeStamp|number}
	     * @default 0
	     */
	    this.lastTime = 0;
	
	    /**
	     * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
	     * @example
	     * // Scales ticker.deltaTime to what would be
	     * // the equivalent of approximately 120 FPS
	     * ticker.speed = 2;
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.speed = 1;
	
	    /**
	     * Whether or not this ticker has been started.
	     * `true` if {@link PIXI.ticker.Ticker#start} has been called.
	     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
	     * While `false`, this value may change to `true` in the
	     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
	     * and a listener is added.
	     *
	     * @member {boolean}
	     * @default false
	     */
	    this.started = false;
	}
	
	Object.defineProperties(Ticker.prototype, {
	    /**
	     * The frames per second at which this ticker is running.
	     * The default is approximately 60 in most modern browsers.
	     * **Note:** This does not factor in the value of
	     * {@link PIXI.ticker.Ticker#speed}, which is specific
	     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
	     *
	     * @member
	     * @memberof PIXI.ticker.Ticker#
	     * @readonly
	     */
	    FPS: {
	        get: function()
	        {
	            return 1000 / this.elapsedMS;
	        }
	    },
	
	    /**
	     * Manages the maximum amount of milliseconds allowed to
	     * elapse between invoking {@link PIXI.ticker.Ticker#update}.
	     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
	     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
	     * When setting this property it is clamped to a value between
	     * `0` and `PIXI.TARGET_FPMS * 1000`.
	     *
	     * @member
	     * @memberof PIXI.ticker.Ticker#
	     * @default 10
	     */
	    minFPS: {
	        get: function()
	        {
	            return 1000 / this._maxElapsedMS;
	        },
	        set: function(fps)
	        {
	            // Clamp: 0 to TARGET_FPMS
	            var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);
	            this._maxElapsedMS = 1 / minFPMS;
	        }
	    }
	});
	
	/**
	 * Conditionally requests a new animation frame.
	 * If a frame has not already been requested, and if the internal
	 * emitter has listeners, a new frame is requested.
	 *
	 * @private
	 */
	Ticker.prototype._requestIfNeeded = function _requestIfNeeded()
	{
	    if (this._requestId === null && this._emitter.listeners(TICK, true))
	    {
	        // ensure callbacks get correct delta
	        this.lastTime = performance.now();
	        this._requestId = requestAnimationFrame(this._tick);
	    }
	};
	
	/**
	 * Conditionally cancels a pending animation frame.
	 *
	 * @private
	 */
	Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded()
	{
	    if (this._requestId !== null)
	    {
	        cancelAnimationFrame(this._requestId);
	        this._requestId = null;
	    }
	};
	
	/**
	 * Conditionally requests a new animation frame.
	 * If the ticker has been started it checks if a frame has not already
	 * been requested, and if the internal emitter has listeners. If these
	 * conditions are met, a new frame is requested. If the ticker has not
	 * been started, but autoStart is `true`, then the ticker starts now,
	 * and continues with the previous conditions to request a new frame.
	 *
	 * @private
	 */
	Ticker.prototype._startIfPossible = function _startIfPossible()
	{
	    if (this.started)
	    {
	        this._requestIfNeeded();
	    }
	    else if (this.autoStart)
	    {
	        this.start();
	    }
	};
	
	/**
	 * Calls {@link module:eventemitter3.EventEmitter#on} internally for the
	 * internal 'tick' event. It checks if the emitter has listeners,
	 * and if so it requests a new animation frame at this point.
	 *
	 * @param fn {Function} The listener function to be added for updates
	 * @param [context] {Function} The listener context
	 * @returns {PIXI.ticker.Ticker} this
	 */
	Ticker.prototype.add = function add(fn, context)
	{
	    this._emitter.on(TICK, fn, context);
	
	    this._startIfPossible();
	
	    return this;
	};
	
	/**
	 * Calls {@link module:eventemitter3.EventEmitter#once} internally for the
	 * internal 'tick' event. It checks if the emitter has listeners,
	 * and if so it requests a new animation frame at this point.
	 *
	 * @param fn {Function} The listener function to be added for one update
	 * @param [context] {Function} The listener context
	 * @returns {PIXI.ticker.Ticker} this
	 */
	Ticker.prototype.addOnce = function addOnce(fn, context)
	{
	    this._emitter.once(TICK, fn, context);
	
	    this._startIfPossible();
	
	    return this;
	};
	
	/**
	 * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.
	 * It checks if the emitter has listeners for 'tick' event.
	 * If it does, then it cancels the animation frame.
	 *
	 * @param [fn] {Function} The listener function to be removed
	 * @param [context] {Function} The listener context to be removed
	 * @returns {PIXI.ticker.Ticker} this
	 */
	Ticker.prototype.remove = function remove(fn, context)
	{
	    this._emitter.off(TICK, fn, context);
	
	    if (!this._emitter.listeners(TICK, true))
	    {
	        this._cancelIfNeeded();
	    }
	
	    return this;
	};
	
	/**
	 * Starts the ticker. If the ticker has listeners
	 * a new animation frame is requested at this point.
	 */
	Ticker.prototype.start = function start()
	{
	    if (!this.started)
	    {
	        this.started = true;
	        this._requestIfNeeded();
	    }
	};
	
	/**
	 * Stops the ticker. If the ticker has requested
	 * an animation frame it is canceled at this point.
	 */
	Ticker.prototype.stop = function stop()
	{
	    if (this.started)
	    {
	        this.started = false;
	        this._cancelIfNeeded();
	    }
	};
	
	/**
	 * Triggers an update. An update entails setting the
	 * current {@link PIXI.ticker.Ticker#elapsedMS},
	 * the current {@link PIXI.ticker.Ticker#deltaTime},
	 * invoking all listeners with current deltaTime,
	 * and then finally setting {@link PIXI.ticker.Ticker#lastTime}
	 * with the value of currentTime that was provided.
	 * This method will be called automatically by animation
	 * frame callbacks if the ticker instance has been started
	 * and listeners are added.
	 *
	 * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution
	 */
	Ticker.prototype.update = function update(currentTime)
	{
	    var elapsedMS;
	
	    // Allow calling update directly with default currentTime.
	    currentTime = currentTime || performance.now();
	    // Save uncapped elapsedMS for measurement
	    elapsedMS = this.elapsedMS = currentTime - this.lastTime;
	
	    // cap the milliseconds elapsed used for deltaTime
	    if (elapsedMS > this._maxElapsedMS)
	    {
	        elapsedMS = this._maxElapsedMS;
	    }
	
	    this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed;
	
	    // Invoke listeners added to internal emitter
	    this._emitter.emit(TICK, this.deltaTime);
	
	    this.lastTime = currentTime;
	};
	
	module.exports = Ticker;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var math = __webpack_require__(15),
	    RenderTexture = __webpack_require__(34),
	    EventEmitter = __webpack_require__(25),
	    CONST = __webpack_require__(14),
	    _tempMatrix = new math.Matrix(),
	    _tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};
	
	
	/**
	 * The base class for all objects that are rendered on the screen.
	 * This is an abstract class and should not be used on its own rather it should be extended.
	 *
	 * @class
	 * @extends EventEmitter
	 * @memberof PIXI
	 */
	function DisplayObject()
	{
	    EventEmitter.call(this);
	
	    /**
	     * The coordinate of the object relative to the local coordinates of the parent.
	     *
	     * @member {PIXI.Point}
	     */
	    this.position = new math.Point();
	
	    /**
	     * The scale factor of the object.
	     *
	     * @member {PIXI.Point}
	     */
	    this.scale = new math.Point(1, 1);
	
	    /**
	     * The pivot point of the displayObject that it rotates around
	     *
	     * @member {PIXI.Point}
	     */
	    this.pivot = new math.Point(0, 0);
	
	
	    /**
	     * The skew factor for the object in radians.
	     *
	     * @member {PIXI.Point}
	     */
	    this.skew = new math.Point(0, 0);
	
	    /**
	     * The rotation of the object in radians.
	     *
	     * @member {number}
	     */
	    this.rotation = 0;
	
	    /**
	     * The opacity of the object.
	     *
	     * @member {number}
	     */
	    this.alpha = 1;
	
	    /**
	     * The visibility of the object. If false the object will not be drawn, and
	     * the updateTransform function will not be called.
	     *
	     * @member {boolean}
	     */
	    this.visible = true;
	
	    /**
	     * Can this object be rendered, if false the object will not be drawn but the updateTransform
	     * methods will still be called.
	     *
	     * @member {boolean}
	     */
	    this.renderable = true;
	
	    /**
	     * The display object container that contains this display object.
	     *
	     * @member {PIXI.Container}
	     * @readOnly
	     */
	    this.parent = null;
	
	    /**
	     * The multiplied alpha of the displayObject
	     *
	     * @member {number}
	     * @readOnly
	     */
	    this.worldAlpha = 1;
	
	    /**
	     * Current transform of the object based on world (parent) factors
	     *
	     * @member {PIXI.Matrix}
	     * @readOnly
	     */
	    this.worldTransform = new math.Matrix();
	
	    /**
	     * The area the filter is applied to. This is used as more of an optimisation
	     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
	     *
	     * @member {PIXI.Rectangle}
	     */
	    this.filterArea = null;
	
	    /**
	     * cached sin rotation
	     *
	     * @member {number}
	     * @private
	     */
	    this._sr = 0;
	
	    /**
	     * cached cos rotation
	     *
	     * @member {number}
	     * @private
	     */
	    this._cr = 1;
	
	    /**
	     * The original, cached bounds of the object
	     *
	     * @member {PIXI.Rectangle}
	     * @private
	     */
	    this._bounds = new math.Rectangle(0, 0, 1, 1);
	
	    /**
	     * The most up-to-date bounds of the object
	     *
	     * @member {PIXI.Rectangle}
	     * @private
	     */
	    this._currentBounds = null;
	
	    /**
	     * The original, cached mask of the object
	     *
	     * @member {PIXI.Rectangle}
	     * @private
	     */
	    this._mask = null;
	}
	
	// constructor
	DisplayObject.prototype = Object.create(EventEmitter.prototype);
	DisplayObject.prototype.constructor = DisplayObject;
	module.exports = DisplayObject;
	
	Object.defineProperties(DisplayObject.prototype, {
	    /**
	     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
	     *
	     * @member {number}
	     * @memberof PIXI.DisplayObject#
	     */
	    x: {
	        get: function ()
	        {
	            return this.position.x;
	        },
	        set: function (value)
	        {
	            this.position.x = value;
	        }
	    },
	
	    /**
	     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
	     *
	     * @member {number}
	     * @memberof PIXI.DisplayObject#
	     */
	    y: {
	        get: function ()
	        {
	            return this.position.y;
	        },
	        set: function (value)
	        {
	            this.position.y = value;
	        }
	    },
	
	    /**
	     * Indicates if the sprite is globally visible.
	     *
	     * @member {boolean}
	     * @memberof PIXI.DisplayObject#
	     * @readonly
	     */
	    worldVisible: {
	        get: function ()
	        {
	            var item = this;
	
	            do {
	                if (!item.visible)
	                {
	                    return false;
	                }
	
	                item = item.parent;
	            } while (item);
	
	            return true;
	        }
	    },
	
	    /**
	     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
	     * In PIXI a regular mask must be a PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it utilises shape clipping.
	     * To remove a mask, set this property to null.
	     *
	     * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
	     *
	     * @member {PIXI.Graphics|PIXI.Sprite}
	     * @memberof PIXI.DisplayObject#
	     */
	    mask: {
	        get: function ()
	        {
	            return this._mask;
	        },
	        set: function (value)
	        {
	            if (this._mask)
	            {
	                this._mask.renderable = true;
	            }
	
	            this._mask = value;
	
	            if (this._mask)
	            {
	                this._mask.renderable = false;
	            }
	        }
	    },
	
	    /**
	     * Sets the filters for the displayObject.
	     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
	     * To remove filters simply set this property to 'null'
	     *
	     * @member {PIXI.AbstractFilter[]}
	     * @memberof PIXI.DisplayObject#
	     */
	    filters: {
	        get: function ()
	        {
	            return this._filters && this._filters.slice();
	        },
	        set: function (value)
	        {
	            this._filters = value && value.slice();
	        }
	    }
	
	});
	
	/*
	 * Updates the object transform for rendering
	 *
	 * TODO - Optimization pass!
	 */
	DisplayObject.prototype.updateTransform = function ()
	{
	    // create some matrix refs for easy access
	    var pt = this.parent.worldTransform;
	    var wt = this.worldTransform;
	
	    // temporary matrix variables
	    var a, b, c, d, tx, ty;
	
	    // looks like we are skewing
	    if(this.skew.x || this.skew.y)
	    {
	        // I'm assuming that skewing is not going to be very common
	        // With that in mind, we can do a full setTransform using the temp matrix
	        _tempMatrix.setTransform(
	            this.position.x,
	            this.position.y,
	            this.pivot.x,
	            this.pivot.y,
	            this.scale.x,
	            this.scale.y,
	            this.rotation,
	            this.skew.x,
	            this.skew.y
	        );
	
	        // now concat the matrix (inlined so that we can avoid using copy)
	        wt.a  = _tempMatrix.a  * pt.a + _tempMatrix.b  * pt.c;
	        wt.b  = _tempMatrix.a  * pt.b + _tempMatrix.b  * pt.d;
	        wt.c  = _tempMatrix.c  * pt.a + _tempMatrix.d  * pt.c;
	        wt.d  = _tempMatrix.c  * pt.b + _tempMatrix.d  * pt.d;
	        wt.tx = _tempMatrix.tx * pt.a + _tempMatrix.ty * pt.c + pt.tx;
	        wt.ty = _tempMatrix.tx * pt.b + _tempMatrix.ty * pt.d + pt.ty;
	    }
	    else
	    {
	        // so if rotation is between 0 then we can simplify the multiplication process...
	        if (this.rotation % CONST.PI_2)
	        {
	            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
	            if (this.rotation !== this.rotationCache)
	            {
	                this.rotationCache = this.rotation;
	                this._sr = Math.sin(this.rotation);
	                this._cr = Math.cos(this.rotation);
	            }
	
	            // get the matrix values of the displayobject based on its transform properties..
	            a  =  this._cr * this.scale.x;
	            b  =  this._sr * this.scale.x;
	            c  = -this._sr * this.scale.y;
	            d  =  this._cr * this.scale.y;
	            tx =  this.position.x;
	            ty =  this.position.y;
	
	            // check for pivot.. not often used so geared towards that fact!
	            if (this.pivot.x || this.pivot.y)
	            {
	                tx -= this.pivot.x * a + this.pivot.y * c;
	                ty -= this.pivot.x * b + this.pivot.y * d;
	            }
	
	            // concat the parent matrix with the objects transform.
	            wt.a  = a  * pt.a + b  * pt.c;
	            wt.b  = a  * pt.b + b  * pt.d;
	            wt.c  = c  * pt.a + d  * pt.c;
	            wt.d  = c  * pt.b + d  * pt.d;
	            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
	            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
	        }
	        else
	        {
	            // lets do the fast version as we know there is no rotation..
	            a  = this.scale.x;
	            d  = this.scale.y;
	
	            tx = this.position.x - this.pivot.x * a;
	            ty = this.position.y - this.pivot.y * d;
	
	            wt.a  = a  * pt.a;
	            wt.b  = a  * pt.b;
	            wt.c  = d  * pt.c;
	            wt.d  = d  * pt.d;
	            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
	            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
	        }
	    }
	
	    // multiply the alphas..
	    this.worldAlpha = this.alpha * this.parent.worldAlpha;
	
	    // reset the bounds each time this is called!
	    this._currentBounds = null;
	};
	
	// performance increase to avoid using call.. (10x faster)
	DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
	
	/**
	 *
	 *
	 * Retrieves the bounds of the displayObject as a rectangle object
	 *
	 * @param matrix {PIXI.Matrix}
	 * @return {PIXI.Rectangle} the rectangular bounding area
	 */
	DisplayObject.prototype.getBounds = function (matrix) // jshint unused:false
	{
	    return math.Rectangle.EMPTY;
	};
	
	/**
	 * Retrieves the local bounds of the displayObject as a rectangle object
	 *
	 * @return {PIXI.Rectangle} the rectangular bounding area
	 */
	DisplayObject.prototype.getLocalBounds = function ()
	{
	    return this.getBounds(math.Matrix.IDENTITY);
	};
	
	/**
	 * Calculates the global position of the display object
	 *
	 * @param position {PIXI.Point} The world origin to calculate from
	 * @return {PIXI.Point} A point object representing the position of this object
	 */
	DisplayObject.prototype.toGlobal = function (position)
	{
	    // this parent check is for just in case the item is a root object.
	    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
	    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
	    if(!this.parent)
	    {
	        this.parent = _tempDisplayObjectParent;
	        this.displayObjectUpdateTransform();
	        this.parent = null;
	    }
	    else
	    {
	        this.displayObjectUpdateTransform();
	    }
	
	    // don't need to update the lot
	    return this.worldTransform.apply(position);
	};
	
	/**
	 * Calculates the local position of the display object relative to another point
	 *
	 * @param position {PIXI.Point} The world origin to calculate from
	 * @param [from] {PIXI.DisplayObject} The DisplayObject to calculate the global position from
	 * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new Point)
	 * @return {PIXI.Point} A point object representing the position of this object
	 */
	DisplayObject.prototype.toLocal = function (position, from, point)
	{
	    if (from)
	    {
	        position = from.toGlobal(position);
	    }
	
	    // this parent check is for just in case the item is a root object.
	    // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
	    // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
	    if(!this.parent)
	    {
	        this.parent = _tempDisplayObjectParent;
	        this.displayObjectUpdateTransform();
	        this.parent = null;
	    }
	    else
	    {
	        this.displayObjectUpdateTransform();
	    }
	
	    // simply apply the matrix..
	    return this.worldTransform.applyInverse(position, point);
	};
	
	/**
	 * Renders the object using the WebGL renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer} The renderer
	 * @private
	 */
	DisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false
	{
	    // OVERWRITE;
	};
	
	/**
	 * Renders the object using the Canvas renderer
	 *
	 * @param renderer {PIXI.CanvasRenderer} The renderer
	 * @private
	 */
	DisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false
	{
	    // OVERWRITE;
	};
	/**
	 * Useful function that returns a texture of the display object that can then be used to create sprites
	 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
	 *
	 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @param resolution {number} The resolution of the texture being generated
	 * @return {PIXI.Texture} a texture of the display object
	 */
	DisplayObject.prototype.generateTexture = function (renderer, scaleMode, resolution)
	{
	    var bounds = this.getLocalBounds();
	
	    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);
	
	    _tempMatrix.tx = -bounds.x;
	    _tempMatrix.ty = -bounds.y;
	
	    renderTexture.render(this, _tempMatrix);
	
	    return renderTexture;
	};
	
	/**
	 * Set the parent Container of this DisplayObject
	 *
	 * @param container {Container} The Container to add this DisplayObject to
	 * @return {Container} The Container that this DisplayObject was added to
	 */
	DisplayObject.prototype.setParent = function (container)
	{
	    if (!container || !container.addChild)
	    {
	        throw new Error('setParent: Argument must be a Container');
	    }
	
	    container.addChild(this);
	    return container;
	};
	
	/**
	 * Convenience function to set the postion, scale, skew and pivot at once.
	 *
	 * @param [x=0] {number} The X position
	 * @param [y=0] {number} The Y position
	 * @param [scaleX=1] {number} The X scale value
	 * @param [scaleY=1] {number} The Y scale value
	 * @param [rotation=0] {number} The rotation
	 * @param [skewX=0] {number} The X skew value
	 * @param [skewY=0] {number} The Y skew value
	 * @param [pivotX=0] {number} The X pivot value
	 * @param [pivotY=0] {number} The Y pivot value
	 * @return {PIXI.DisplayObject}
	 */
	DisplayObject.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) //jshint ignore:line
	{
	    this.position.x = x || 0;
	    this.position.y = y || 0;
	    this.scale.x = !scaleX ? 1 : scaleX;
	    this.scale.y = !scaleY ? 1 : scaleY;
	    this.rotation = rotation || 0;
	    this.skew.x = skewX || 0;
	    this.skew.y = skewY || 0;
	    this.pivot.x = pivotX || 0;
	    this.pivot.y = pivotY || 0;
	    return this;
	};
	
	/**
	 * Base destroy method for generic display objects
	 *
	 */
	DisplayObject.prototype.destroy = function ()
	{
	
	    this.position = null;
	    this.scale = null;
	    this.pivot = null;
	    this.skew = null;
	
	    this.parent = null;
	
	    this._bounds = null;
	    this._currentBounds = null;
	    this._mask = null;
	
	    this.worldTransform = null;
	    this.filterArea = null;
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var BaseTexture = __webpack_require__(35),
	    Texture = __webpack_require__(36),
	    RenderTarget = __webpack_require__(39),
	    FilterManager = __webpack_require__(41),
	    CanvasBuffer = __webpack_require__(44),
	    math = __webpack_require__(15),
	    CONST = __webpack_require__(14),
	    tempMatrix = new math.Matrix();
	
	/**
	 * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
	 *
	 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
	 * otherwise black rectangles will be drawn instead.
	 *
	 * A RenderTexture takes a snapshot of any Display Object given to its render method. The position
	 * and rotation of the given Display Objects is ignored. For example:
	 *
	 * ```js
	 * var renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
	 * var renderTexture = new PIXI.RenderTexture(renderer, 800, 600);
	 * var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
	 *
	 * sprite.position.x = 800/2;
	 * sprite.position.y = 600/2;
	 * sprite.anchor.x = 0.5;
	 * sprite.anchor.y = 0.5;
	 *
	 * renderTexture.render(sprite);
	 * ```
	 *
	 * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual
	 * position a Container should be used:
	 *
	 * ```js
	 * var doc = new PIXI.Container();
	 *
	 * doc.addChild(sprite);
	 *
	 * renderTexture.render(doc);  // Renders to center of renderTexture
	 * ```
	 *
	 * @class
	 * @extends PIXI.Texture
	 * @memberof PIXI
	 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used for this RenderTexture
	 * @param [width=100] {number} The width of the render texture
	 * @param [height=100] {number} The height of the render texture
	 * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @param [resolution=1] {number} The resolution of the texture being generated
	 */
	function RenderTexture(renderer, width, height, scaleMode, resolution)
	{
	    if (!renderer)
	    {
	        throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');
	    }
	
	    width = width || 100;
	    height = height || 100;
	    resolution = resolution || CONST.RESOLUTION;
	
	    /**
	     * The base texture object that this texture uses
	     *
	     * @member {BaseTexture}
	     */
	    var baseTexture = new BaseTexture();
	    baseTexture.width = width;
	    baseTexture.height = height;
	    baseTexture.resolution = resolution;
	    baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
	    baseTexture.hasLoaded = true;
	
	
	    Texture.call(this,
	        baseTexture,
	        new math.Rectangle(0, 0, width, height)
	    );
	
	
	    /**
	     * The with of the render texture
	     *
	     * @member {number}
	     */
	    this.width = width;
	
	    /**
	     * The height of the render texture
	     *
	     * @member {number}
	     */
	    this.height = height;
	
	    /**
	     * The Resolution of the texture.
	     *
	     * @member {number}
	     */
	    this.resolution = resolution;
	
	    /**
	     * Draw/render the given DisplayObject onto the texture.
	     *
	     * The displayObject and descendents are transformed during this operation.
	     * If `updateTransform` is true then the transformations will be restored before the
	     * method returns. Otherwise it is up to the calling code to correctly use or reset
	     * the transformed display objects.
	     *
	     * The display object is always rendered with a worldAlpha value of 1.
	     *
	     * @method
	     * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
	     * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
	     * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
	     * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
	     *  transformations will be restored. Not restoring this information will be a little faster.
	     */
	    this.render = null;
	
	    /**
	     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.
	     *
	     * @member {PIXI.CanvasRenderer|PIXI.WebGLRenderer}
	     */
	    this.renderer = renderer;
	
	    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
	    {
	        var gl = this.renderer.gl;
	
	        this.textureBuffer = new RenderTarget(gl, this.width, this.height, baseTexture.scaleMode, this.resolution);//, this.baseTexture.scaleMode);
	        this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;
	
	        //TODO refactor filter manager.. as really its no longer a manager if we use it here..
	        this.filterManager = new FilterManager(this.renderer);
	        this.filterManager.onContextChange();
	        this.filterManager.resize(width, height);
	        this.render = this.renderWebGL;
	
	        // the creation of a filter manager unbinds the buffers..
	        this.renderer.currentRenderer.start();
	        this.renderer.currentRenderTarget.activate();
	    }
	    else
	    {
	
	        this.render = this.renderCanvas;
	        this.textureBuffer = new CanvasBuffer(this.width* this.resolution, this.height* this.resolution);
	        this.baseTexture.source = this.textureBuffer.canvas;
	    }
	
	    /**
	     * @member {boolean}
	     */
	    this.valid = true;
	
	    this._updateUvs();
	}
	
	RenderTexture.prototype = Object.create(Texture.prototype);
	RenderTexture.prototype.constructor = RenderTexture;
	module.exports = RenderTexture;
	
	/**
	 * Resizes the RenderTexture.
	 *
	 * @param width {number} The width to resize to.
	 * @param height {number} The height to resize to.
	 * @param updateBase {boolean} Should the baseTexture.width and height values be resized as well?
	 */
	RenderTexture.prototype.resize = function (width, height, updateBase)
	{
	    if (width === this.width && height === this.height)
	    {
	        return;
	    }
	
	    this.valid = (width > 0 && height > 0);
	
	    this.width = this._frame.width = this.crop.width = width;
	    this.height =  this._frame.height = this.crop.height = height;
	
	    if (updateBase)
	    {
	        this.baseTexture.width = this.width;
	        this.baseTexture.height = this.height;
	    }
	
	    if (!this.valid)
	    {
	        return;
	    }
	
	    this.textureBuffer.resize(this.width, this.height);
	
	    if(this.filterManager)
	    {
	        this.filterManager.resize(this.width, this.height);
	    }
	};
	
	/**
	 * Clears the RenderTexture.
	 *
	 */
	RenderTexture.prototype.clear = function ()
	{
	    if (!this.valid)
	    {
	        return;
	    }
	
	    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
	    {
	        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
	    }
	
	    this.textureBuffer.clear();
	};
	
	/**
	 * Internal method assigned to the `render` property if using a CanvasRenderer.
	 *
	 * @private
	 * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
	 * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
	 * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
	 * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
	 *  transformations will be restored. Not restoring this information will be a little faster.
	 */
	RenderTexture.prototype.renderWebGL = function (displayObject, matrix, clear, updateTransform)
	{
	    if (!this.valid)
	    {
	        return;
	    }
	
	
	    updateTransform = (updateTransform !== undefined) ? updateTransform : true;//!updateTransform;
	
	    this.textureBuffer.transform = matrix;
	
	    //TODO not a fan that this is here... it will move!
	    this.textureBuffer.activate();
	
	    // setWorld Alpha to ensure that the object is renderer at full opacity
	    displayObject.worldAlpha = 1;
	
	    if (updateTransform)
	    {
	
	        // reset the matrix of the displatyObject..
	        displayObject.worldTransform.identity();
	
	        displayObject.currentBounds = null;
	
	        // Time to update all the children of the displayObject with the new matrix..
	        var children = displayObject.children;
	        var i, j;
	
	        for (i = 0, j = children.length; i < j; ++i)
	        {
	            children[i].updateTransform();
	        }
	    }
	
	    //TODO rename textureBuffer to renderTarget..
	    var temp =  this.renderer.filterManager;
	
	    this.renderer.filterManager = this.filterManager;
	    this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);
	
	    this.renderer.filterManager = temp;
	};
	
	
	/**
	 * Internal method assigned to the `render` property if using a CanvasRenderer.
	 *
	 * @private
	 * @param displayObject {PIXI.DisplayObject} The display object to render this texture on
	 * @param [matrix] {PIXI.Matrix} Optional matrix to apply to the display object before rendering.
	 * @param [clear] {boolean} If true the texture will be cleared before the displayObject is drawn
	 */
	RenderTexture.prototype.renderCanvas = function (displayObject, matrix, clear, updateTransform)
	{
	    if (!this.valid)
	    {
	        return;
	    }
	
	    updateTransform = !!updateTransform;
	
	    var wt = tempMatrix;
	
	    wt.identity();
	
	    if (matrix)
	    {
	        wt.append(matrix);
	    }
	
	    var cachedWt = displayObject.worldTransform;
	    displayObject.worldTransform = wt;
	
	    // setWorld Alpha to ensure that the object is renderer at full opacity
	    displayObject.worldAlpha = 1;
	
	    // Time to update all the children of the displayObject with the new matrix..
	    var children = displayObject.children;
	    var i, j;
	
	    for (i = 0, j = children.length; i < j; ++i)
	    {
	        children[i].updateTransform();
	    }
	
	    if (clear)
	    {
	        this.textureBuffer.clear();
	    }
	
	
	//    this.textureBuffer.
	    var context = this.textureBuffer.context;
	
	    var realResolution = this.renderer.resolution;
	
	    this.renderer.resolution = this.resolution;
	
	    this.renderer.renderDisplayObject(displayObject, context);
	
	    this.renderer.resolution = realResolution;
	
	    if(displayObject.worldTransform === wt)
	    {
	        // fixes cacheAsBitmap Happening during the above..
	        displayObject.worldTransform = cachedWt;
	    }
	
	};
	
	/**
	 * Destroys this texture
	 *
	 * @param destroyBase {boolean} Whether to destroy the base texture as well
	 */
	RenderTexture.prototype.destroy = function ()
	{
	    Texture.prototype.destroy.call(this, true);
	
	    this.textureBuffer.destroy();
	
	    // destroy the filtermanager..
	    if(this.filterManager)
	    {
	        this.filterManager.destroy();
	    }
	
	    this.renderer = null;
	};
	
	/**
	 * Will return a HTML Image of the texture
	 *
	 * @return {Image}
	 */
	RenderTexture.prototype.getImage = function ()
	{
	    var image = new Image();
	    image.src = this.getBase64();
	    return image;
	};
	
	/**
	 * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.
	 *
	 * @return {string} A base64 encoded string of the texture.
	 */
	RenderTexture.prototype.getBase64 = function ()
	{
	    return this.getCanvas().toDataURL();
	};
	
	/**
	 * Creates a Canvas element, renders this RenderTexture to it and then returns it.
	 *
	 * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
	 */
	RenderTexture.prototype.getCanvas = function ()
	{
	    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
	    {
	        var gl = this.renderer.gl;
	        var width = this.textureBuffer.size.width;
	        var height = this.textureBuffer.size.height;
	
	        var webGLPixels = new Uint8Array(4 * width * height);
	
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
	        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	
	        var tempCanvas = new CanvasBuffer(width, height);
	        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
	        canvasData.data.set(webGLPixels);
	
	        tempCanvas.context.putImageData(canvasData, 0, 0);
	
	        return tempCanvas.canvas;
	    }
	    else
	    {
	        return this.textureBuffer.canvas;
	    }
	};
	
	/**
	 * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA order, with integer values between 0 and 255 (included).
	 *
	 * @return {Uint8ClampedArray}
	 */
	RenderTexture.prototype.getPixels = function ()
	{
	    var width, height;
	
	    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
	    {
	        var gl = this.renderer.gl;
	        width = this.textureBuffer.size.width;
	        height = this.textureBuffer.size.height;
	
	        var webGLPixels = new Uint8Array(4 * width * height);
	
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
	        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	
	        return webGLPixels;
	    }
	    else
	    {
	        width = this.textureBuffer.canvas.width;
	        height = this.textureBuffer.canvas.height;
	
	        return this.textureBuffer.canvas.getContext('2d').getImageData(0, 0, width, height).data;
	    }
	};
	
	/**
	 * Will return a one-dimensional array containing the pixel data of a pixel within the texture in RGBA order, with integer values between 0 and 255 (included).
	 *
	 * @param x {number} The x coordinate of the pixel to retrieve.
	 * @param y {number} The y coordinate of the pixel to retrieve.
	 * @return {Uint8ClampedArray}
	 */
	RenderTexture.prototype.getPixel = function (x, y)
	{
	    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
	    {
	        var gl = this.renderer.gl;
	
	        var webGLPixels = new Uint8Array(4);
	
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
	        gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
	        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	
	        return webGLPixels;
	    }
	    else
	    {
	        return this.textureBuffer.canvas.getContext('2d').getImageData(x, y, 1, 1).data;
	    }
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(24),
	    CONST = __webpack_require__(14),
	    EventEmitter = __webpack_require__(25);
	
	/**
	 * A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @memberof PIXI
	 * @param source {Image|Canvas} the source object of the texture.
	 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @param resolution {number} the resolution of the texture for devices with different pixel ratios
	 */
	function BaseTexture(source, scaleMode, resolution)
	{
	    EventEmitter.call(this);
	
	    this.uid = utils.uid();
	
	    /**
	     * The Resolution of the texture.
	     *
	     * @member {number}
	     */
	    this.resolution = resolution || 1;
	
	    /**
	     * The width of the base texture set when the image has loaded
	     *
	     * @member {number}
	     * @readOnly
	     */
	    this.width = 100;
	
	    /**
	     * The height of the base texture set when the image has loaded
	     *
	     * @member {number}
	     * @readOnly
	     */
	    this.height = 100;
	
	    // TODO docs
	    // used to store the actual dimensions of the source
	    /**
	     * Used to store the actual width of the source of this texture
	     *
	     * @member {number}
	     * @readOnly
	     */
	    this.realWidth = 100;
	    /**
	     * Used to store the actual height of the source of this texture
	     *
	     * @member {number}
	     * @readOnly
	     */
	    this.realHeight = 100;
	
	    /**
	     * The scale mode to apply when scaling this texture
	     *
	     * @member {number}
	     * @default PIXI.SCALE_MODES.LINEAR
	     * @see PIXI.SCALE_MODES
	     */
	    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
	
	    /**
	     * Set to true once the base texture has successfully loaded.
	     *
	     * This is never true if the underlying source fails to load or has no texture data.
	     *
	     * @member {boolean}
	     * @readOnly
	     */
	    this.hasLoaded = false;
	
	    /**
	     * Set to true if the source is currently loading.
	     *
	     * If an Image source is loading the 'loaded' or 'error' event will be
	     * dispatched when the operation ends. An underyling source that is
	     * immediately-available bypasses loading entirely.
	     *
	     * @member {boolean}
	     * @readonly
	     */
	    this.isLoading = false;
	
	    /**
	     * The image source that is used to create the texture.
	     *
	     * TODO: Make this a setter that calls loadSource();
	     *
	     * @member {Image|Canvas}
	     * @readonly
	     */
	    this.source = null; // set in loadSource, if at all
	
	    /**
	     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
	     * All blend modes, and shaders written for default value. Change it on your own risk.
	     *
	     * @member {boolean}
	     * @default true
	     */
	    this.premultipliedAlpha = true;
	
	    /**
	     * @member {string}
	     */
	    this.imageUrl = null;
	
	    /**
	     * Wether or not the texture is a power of two, try to use power of two textures as much as you can
	     * @member {boolean}
	     * @private
	     */
	    this.isPowerOfTwo = false;
	
	    // used for webGL
	
	    /**
	     *
	     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
	     * Also the texture must be a power of two size to work
	     *
	     * @member {boolean}
	     */
	    this.mipmap = false;
	
	    /**
	     * A map of renderer IDs to webgl textures
	     *
	     * @member {object<number, WebGLTexture>}
	     * @private
	     */
	    this._glTextures = {};
	
	    // if no source passed don't try to load
	    if (source)
	    {
	        this.loadSource(source);
	    }
	
	    /**
	     * Fired when a not-immediately-available source finishes loading.
	     *
	     * @event loaded
	     * @memberof PIXI.BaseTexture#
	     * @protected
	     */
	
	    /**
	     * Fired when a not-immediately-available source fails to load.
	     *
	     * @event error
	     * @memberof PIXI.BaseTexture#
	     * @protected
	     */
	}
	
	BaseTexture.prototype = Object.create(EventEmitter.prototype);
	BaseTexture.prototype.constructor = BaseTexture;
	module.exports = BaseTexture;
	
	/**
	 * Updates the texture on all the webgl renderers, this also assumes the src has changed.
	 *
	 * @fires update
	 */
	BaseTexture.prototype.update = function ()
	{
	    this.realWidth = this.source.naturalWidth || this.source.width;
	    this.realHeight = this.source.naturalHeight || this.source.height;
	
	    this.width = this.realWidth / this.resolution;
	    this.height = this.realHeight / this.resolution;
	
	    this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);
	
	    this.emit('update', this);
	};
	
	/**
	 * Load a source.
	 *
	 * If the source is not-immediately-available, such as an image that needs to be
	 * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
	 * and `hasLoaded` will remain false after this call.
	 *
	 * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
	 *
	 *     if (texture.hasLoaded)
	 {
	 *        // texture ready for use
	 *     } else if (texture.isLoading)
	 {
	 *        // listen to 'loaded' and/or 'error' events on texture
	 *     } else {
	 *        // not loading, not going to load UNLESS the source is reloaded
	 *        // (it may still make sense to listen to the events)
	 *     }
	 *
	 * @protected
	 * @param source {Image|Canvas} the source object of the texture.
	 */
	BaseTexture.prototype.loadSource = function (source)
	{
	    var wasLoading = this.isLoading;
	    this.hasLoaded = false;
	    this.isLoading = false;
	
	    if (wasLoading && this.source)
	    {
	        this.source.onload = null;
	        this.source.onerror = null;
	    }
	
	    this.source = source;
	
	    // Apply source if loaded. Otherwise setup appropriate loading monitors.
	    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
	    {
	        this._sourceLoaded();
	    }
	    else if (!source.getContext)
	    {
	
	        // Image fail / not ready
	        this.isLoading = true;
	
	        var scope = this;
	
	        source.onload = function ()
	        {
	            source.onload = null;
	            source.onerror = null;
	
	            if (!scope.isLoading)
	            {
	                return;
	            }
	
	            scope.isLoading = false;
	            scope._sourceLoaded();
	
	            scope.emit('loaded', scope);
	        };
	
	        source.onerror = function ()
	        {
	            source.onload = null;
	            source.onerror = null;
	
	            if (!scope.isLoading)
	            {
	                return;
	            }
	
	            scope.isLoading = false;
	            scope.emit('error', scope);
	        };
	
	        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
	        //   "The value of `complete` can thus change while a script is executing."
	        // So complete needs to be re-checked after the callbacks have been added..
	        // NOTE: complete will be true if the image has no src so best to check if the src is set.
	        if (source.complete && source.src)
	        {
	            this.isLoading = false;
	
	            // ..and if we're complete now, no need for callbacks
	            source.onload = null;
	            source.onerror = null;
	
	            if (source.width && source.height)
	            {
	                this._sourceLoaded();
	
	                // If any previous subscribers possible
	                if (wasLoading)
	                {
	                    this.emit('loaded', this);
	                }
	            }
	            else
	            {
	                // If any previous subscribers possible
	                if (wasLoading)
	                {
	                    this.emit('error', this);
	                }
	            }
	        }
	    }
	};
	
	/**
	 * Used internally to update the width, height, and some other tracking vars once
	 * a source has successfully loaded.
	 *
	 * @private
	 */
	BaseTexture.prototype._sourceLoaded = function ()
	{
	    this.hasLoaded = true;
	    this.update();
	};
	
	/**
	 * Destroys this base texture
	 *
	 */
	BaseTexture.prototype.destroy = function ()
	{
	    if (this.imageUrl)
	    {
	        delete utils.BaseTextureCache[this.imageUrl];
	        delete utils.TextureCache[this.imageUrl];
	
	        this.imageUrl = null;
	
	        if (!navigator.isCocoonJS)
	        {
	            this.source.src = '';
	        }
	    }
	    else if (this.source && this.source._pixiId)
	    {
	        delete utils.BaseTextureCache[this.source._pixiId];
	    }
	
	    this.source = null;
	
	    this.dispose();
	};
	
	/**
	 * Frees the texture from WebGL memory without destroying this texture object.
	 * This means you can still use the texture later which will upload it to GPU
	 * memory again.
	 *
	 */
	BaseTexture.prototype.dispose = function ()
	{
	    this.emit('dispose', this);
	
	    // this should no longer be needed, the renderers should cleanup all the gl textures.
	    // this._glTextures = {};
	};
	
	/**
	 * Changes the source image of the texture.
	 * The original source must be an Image element.
	 *
	 * @param newSrc {string} the path of the image
	 */
	BaseTexture.prototype.updateSourceImage = function (newSrc)
	{
	    this.source.src = newSrc;
	
	    this.loadSource(this.source);
	};
	
	/**
	 * Helper function that creates a base texture from the given image url.
	 * If the image is not in the base texture cache it will be created and loaded.
	 *
	 * @static
	 * @param imageUrl {string} The image url of the texture
	 * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
	 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return PIXI.BaseTexture
	 */
	BaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)
	{
	    var baseTexture = utils.BaseTextureCache[imageUrl];
	
	    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)
	    {
	        crossorigin = true;
	    }
	
	    if (!baseTexture)
	    {
	        // new Image() breaks tex loading in some versions of Chrome.
	        // See https://code.google.com/p/chromium/issues/detail?id=238071
	        var image = new Image();//document.createElement('img');
	        if (crossorigin)
	        {
	            image.crossOrigin = '';
	        }
	
	        baseTexture = new BaseTexture(image, scaleMode);
	        baseTexture.imageUrl = imageUrl;
	
	        image.src = imageUrl;
	
	        utils.BaseTextureCache[imageUrl] = baseTexture;
	
	        // if there is an @2x at the end of the url we are going to assume its a highres image
	        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);
	    }
	
	    return baseTexture;
	};
	
	/**
	 * Helper function that creates a base texture from the given canvas element.
	 *
	 * @static
	 * @param canvas {Canvas} The canvas element source of the texture
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return PIXI.BaseTexture
	 */
	BaseTexture.fromCanvas = function (canvas, scaleMode)
	{
	    if (!canvas._pixiId)
	    {
	        canvas._pixiId = 'canvas_' + utils.uid();
	    }
	
	    var baseTexture = utils.BaseTextureCache[canvas._pixiId];
	
	    if (!baseTexture)
	    {
	        baseTexture = new BaseTexture(canvas, scaleMode);
	        utils.BaseTextureCache[canvas._pixiId] = baseTexture;
	    }
	
	    return baseTexture;
	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var BaseTexture = __webpack_require__(35),
	    VideoBaseTexture = __webpack_require__(37),
	    TextureUvs = __webpack_require__(38),
	    EventEmitter = __webpack_require__(25),
	    math = __webpack_require__(15),
	    utils = __webpack_require__(24);
	
	/**
	 * A texture stores the information that represents an image or part of an image. It cannot be added
	 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
	 *
	 * You can directly create a texture from an image and then reuse it multiple times like this :
	 *
	 * ```js
	 * var texture = PIXI.Texture.fromImage('assets/image.png');
	 * var sprite1 = new PIXI.Sprite(texture);
	 * var sprite2 = new PIXI.Sprite(texture);
	 * ```
	 *
	 * @class
	 * @memberof PIXI
	 * @param baseTexture {PIXI.BaseTexture} The base texture source to create the texture from
	 * @param [frame] {PIXI.Rectangle} The rectangle frame of the texture to show
	 * @param [crop] {PIXI.Rectangle} The area of original texture
	 * @param [trim] {PIXI.Rectangle} Trimmed texture rectangle
	 * @param [rotate] {number} indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}
	 */
	function Texture(baseTexture, frame, crop, trim, rotate)
	{
	    EventEmitter.call(this);
	
	    /**
	     * Does this Texture have any frame data assigned to it?
	     *
	     * @member {boolean}
	     */
	    this.noFrame = false;
	
	    if (!frame)
	    {
	        this.noFrame = true;
	        frame = new math.Rectangle(0, 0, 1, 1);
	    }
	
	    if (baseTexture instanceof Texture)
	    {
	        baseTexture = baseTexture.baseTexture;
	    }
	
	    /**
	     * The base texture that this texture uses.
	     *
	     * @member {PIXI.BaseTexture}
	     */
	    this.baseTexture = baseTexture;
	
	    /**
	     * The frame specifies the region of the base texture that this texture uses
	     *
	     * @member {PIXI.Rectangle}
	     * @private
	     */
	    this._frame = frame;
	
	    /**
	     * The texture trim data.
	     *
	     * @member {PIXI.Rectangle}
	     */
	    this.trim = trim;
	
	    /**
	     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
	     *
	     * @member {boolean}
	     */
	    this.valid = false;
	
	    /**
	     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
	     *
	     * @member {boolean}
	     */
	    this.requiresUpdate = false;
	
	    /**
	     * The WebGL UV data cache.
	     *
	     * @member {PIXI.TextureUvs}
	     * @private
	     */
	    this._uvs = null;
	
	    /**
	     * The width of the Texture in pixels.
	     *
	     * @member {number}
	     */
	    this.width = 0;
	
	    /**
	     * The height of the Texture in pixels.
	     *
	     * @member {number}
	     */
	    this.height = 0;
	
	    /**
	     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
	     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
	     *
	     * @member {PIXI.Rectangle}
	     */
	    this.crop = crop || frame;//new math.Rectangle(0, 0, 1, 1);
	
	    this._rotate = +(rotate || 0);
	
	    if (rotate === true) {
	        // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
	        this._rotate = 2;
	    } else {
	        if (this._rotate % 2 !== 0) {
	            throw 'attempt to use diamond-shaped UVs. If you are sure, set rotation manually';
	        }
	    }
	
	    if (baseTexture.hasLoaded)
	    {
	        if (this.noFrame)
	        {
	            frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
	
	            // if there is no frame we should monitor for any base texture changes..
	            baseTexture.on('update', this.onBaseTextureUpdated, this);
	        }
	        this.frame = frame;
	    }
	    else
	    {
	        baseTexture.once('loaded', this.onBaseTextureLoaded, this);
	    }
	
	    /**
	     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
	     *
	     * @event update
	     * @memberof PIXI.Texture#
	     * @protected
	     */
	}
	
	Texture.prototype = Object.create(EventEmitter.prototype);
	Texture.prototype.constructor = Texture;
	module.exports = Texture;
	
	Object.defineProperties(Texture.prototype, {
	    /**
	     * The frame specifies the region of the base texture that this texture uses.
	     *
	     * @member {PIXI.Rectangle}
	     * @memberof PIXI.Texture#
	     */
	    frame: {
	        get: function ()
	        {
	            return this._frame;
	        },
	        set: function (frame)
	        {
	            this._frame = frame;
	
	            this.noFrame = false;
	
	            this.width = frame.width;
	            this.height = frame.height;
	
	            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
	            {
	                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
	            }
	
	            //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
	            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;
	
	            if (this.trim)
	            {
	                this.width = this.trim.width;
	                this.height = this.trim.height;
	                this._frame.width = this.trim.width;
	                this._frame.height = this.trim.height;
	            }
	            else
	            {
	                this.crop = frame;
	            }
	
	            if (this.valid)
	            {
	                this._updateUvs();
	            }
	        }
	    },
	    /**
	     * Indicates whether the texture is rotated inside the atlas
	     * set to 2 to compensate for texture packer rotation
	     * set to 6 to compensate for spine packer rotation
	     * can be used to rotate or mirror sprites
	     * See {@link PIXI.GroupD8} for explanation
	     *
	     * @member {number}
	     */
	    rotate: {
	        get: function ()
	        {
	            return this._rotate;
	        },
	        set: function (rotate)
	        {
	            this._rotate = rotate;
	            if (this.valid)
	            {
	                this._updateUvs();
	            }
	        }
	    }
	});
	
	/**
	 * Updates this texture on the gpu.
	 *
	 */
	Texture.prototype.update = function ()
	{
	    this.baseTexture.update();
	};
	
	/**
	 * Called when the base texture is loaded
	 *
	 * @private
	 */
	Texture.prototype.onBaseTextureLoaded = function (baseTexture)
	{
	    // TODO this code looks confusing.. boo to abusing getters and setterss!
	    if (this.noFrame)
	    {
	        this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
	    }
	    else
	    {
	        this.frame = this._frame;
	    }
	
	    this.emit('update', this);
	};
	
	/**
	 * Called when the base texture is updated
	 *
	 * @private
	 */
	Texture.prototype.onBaseTextureUpdated = function (baseTexture)
	{
	    this._frame.width = baseTexture.width;
	    this._frame.height = baseTexture.height;
	
	    this.emit('update', this);
	};
	
	/**
	 * Destroys this texture
	 *
	 * @param [destroyBase=false] {boolean} Whether to destroy the base texture as well
	 */
	Texture.prototype.destroy = function (destroyBase)
	{
	    if (this.baseTexture)
	    {
	        if (destroyBase)
	        {
	            this.baseTexture.destroy();
	        }
	
	        this.baseTexture.off('update', this.onBaseTextureUpdated, this);
	        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);
	
	        this.baseTexture = null;
	    }
	
	    this._frame = null;
	    this._uvs = null;
	    this.trim = null;
	    this.crop = null;
	
	    this.valid = false;
	
	    this.off('dispose', this.dispose, this);
	    this.off('update', this.update, this);
	};
	
	/**
	 * Creates a new texture object that acts the same as this one.
	 *
	 * @return {PIXI.Texture}
	 */
	Texture.prototype.clone = function ()
	{
	    return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);
	};
	
	/**
	 * Updates the internal WebGL UV cache.
	 *
	 * @private
	 */
	Texture.prototype._updateUvs = function ()
	{
	    if (!this._uvs)
	    {
	        this._uvs = new TextureUvs();
	    }
	
	    this._uvs.set(this.crop, this.baseTexture, this.rotate);
	};
	
	/**
	 * Helper function that creates a Texture object from the given image url.
	 * If the image is not in the texture cache it will be  created and loaded.
	 *
	 * @static
	 * @param imageUrl {string} The image url of the texture
	 * @param crossorigin {boolean} Whether requests should be treated as crossorigin
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.Texture} The newly created texture
	 */
	Texture.fromImage = function (imageUrl, crossorigin, scaleMode)
	{
	    var texture = utils.TextureCache[imageUrl];
	
	    if (!texture)
	    {
	        texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
	        utils.TextureCache[imageUrl] = texture;
	    }
	
	    return texture;
	};
	
	/**
	 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	 * The frame ids are created when a Texture packer file has been loaded
	 *
	 * @static
	 * @param frameId {string} The frame Id of the texture in the cache
	 * @return {PIXI.Texture} The newly created texture
	 */
	Texture.fromFrame = function (frameId)
	{
	    var texture = utils.TextureCache[frameId];
	
	    if (!texture)
	    {
	        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
	    }
	
	    return texture;
	};
	
	/**
	 * Helper function that creates a new Texture based on the given canvas element.
	 *
	 * @static
	 * @param canvas {Canvas} The canvas element source of the texture
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.Texture}
	 */
	Texture.fromCanvas = function (canvas, scaleMode)
	{
	    return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));
	};
	
	/**
	 * Helper function that creates a new Texture based on the given video element.
	 *
	 * @static
	 * @param video {HTMLVideoElement}
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.Texture} A Texture
	 */
	Texture.fromVideo = function (video, scaleMode)
	{
	    if (typeof video === 'string')
	    {
	        return Texture.fromVideoUrl(video, scaleMode);
	    }
	    else
	    {
	        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));
	    }
	};
	
	/**
	 * Helper function that creates a new Texture based on the video url.
	 *
	 * @static
	 * @param videoUrl {string}
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.Texture} A Texture
	 */
	Texture.fromVideoUrl = function (videoUrl, scaleMode)
	{
	    return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));
	};
	
	/**
	 * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.
	 *
	 * @static
	 * @param texture {PIXI.Texture} The Texture to add to the cache.
	 * @param id {string} The id that the texture will be stored against.
	 */
	Texture.addTextureToCache = function (texture, id)
	{
	    utils.TextureCache[id] = texture;
	};
	
	/**
	 * Remove a texture from the global utils.TextureCache.
	 *
	 * @static
	 * @param id {string} The id of the texture to be removed
	 * @return {PIXI.Texture} The texture that was removed
	 */
	Texture.removeTextureFromCache = function (id)
	{
	    var texture = utils.TextureCache[id];
	
	    delete utils.TextureCache[id];
	    delete utils.BaseTextureCache[id];
	
	    return texture;
	};
	
	/**
	 * An empty texture, used often to not have to create multiple empty textures.
	 *
	 * @static
	 * @constant
	 */
	Texture.EMPTY = new Texture(new BaseTexture());


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var BaseTexture = __webpack_require__(35),
	    utils = __webpack_require__(24);
	
	/**
	 * A texture of a [playing] Video.
	 *
	 * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
	 *
	 * This can be used in several ways, such as:
	 *
	 * ```js
	 * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrls([
	 *     { src: '/video.webm', mime: 'video/webm' },
	 *     { src: '/video.mp4', mime: 'video/mp4' }
	 * ]);
	 * ```
	 *
	 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
	 *
	 * @class
	 * @extends PIXI.BaseTexture
	 * @memberof PIXI
	 * @param source {HTMLVideoElement}
	 * @param [scaleMode] {number} See {@link PIXI.SCALE_MODES} for possible values
	 */
	function VideoBaseTexture(source, scaleMode)
	{
	    if (!source)
	    {
	        throw new Error('No video source element specified.');
	    }
	
	    // hook in here to check if video is already available.
	    // BaseTexture looks for a source.complete boolean, plus width & height.
	
	    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height)
	    {
	        source.complete = true;
	    }
	
	    BaseTexture.call(this, source, scaleMode);
	
	    /**
	     * Should the base texture automatically update itself, set to true by default
	     *
	     * @member {boolean}
	     * @default true
	     */
	    this.autoUpdate = false;
	
	    this._onUpdate = this._onUpdate.bind(this);
	    this._onCanPlay = this._onCanPlay.bind(this);
	
	    if (!source.complete)
	    {
	        source.addEventListener('canplay', this._onCanPlay);
	        source.addEventListener('canplaythrough', this._onCanPlay);
	
	        // started playing..
	        source.addEventListener('play', this._onPlayStart.bind(this));
	        source.addEventListener('pause', this._onPlayStop.bind(this));
	    }
	
	    this.__loaded = false;
	}
	
	VideoBaseTexture.prototype = Object.create(BaseTexture.prototype);
	VideoBaseTexture.prototype.constructor = VideoBaseTexture;
	module.exports = VideoBaseTexture;
	
	/**
	 * The internal update loop of the video base texture, only runs when autoUpdate is set to true
	 *
	 * @private
	 */
	VideoBaseTexture.prototype._onUpdate = function ()
	{
	    if (this.autoUpdate)
	    {
	        window.requestAnimationFrame(this._onUpdate);
	        this.update();
	    }
	};
	
	/**
	 * Runs the update loop when the video is ready to play
	 *
	 * @private
	 */
	VideoBaseTexture.prototype._onPlayStart = function ()
	{
	    if (!this.autoUpdate)
	    {
	        window.requestAnimationFrame(this._onUpdate);
	        this.autoUpdate = true;
	    }
	};
	
	/**
	 * Fired when a pause event is triggered, stops the update loop
	 *
	 * @private
	 */
	VideoBaseTexture.prototype._onPlayStop = function ()
	{
	    this.autoUpdate = false;
	};
	
	/**
	 * Fired when the video is loaded and ready to play
	 *
	 * @private
	 */
	VideoBaseTexture.prototype._onCanPlay = function ()
	{
	    this.hasLoaded = true;
	
	    if (this.source)
	    {
	        this.source.removeEventListener('canplay', this._onCanPlay);
	        this.source.removeEventListener('canplaythrough', this._onCanPlay);
	
	        this.width = this.source.videoWidth;
	        this.height = this.source.videoHeight;
	
	        this.source.play();
	
	        // prevent multiple loaded dispatches..
	        if (!this.__loaded)
	        {
	            this.__loaded = true;
	            this.emit('loaded', this);
	        }
	    }
	};
	
	/**
	 * Destroys this texture
	 *
	 */
	VideoBaseTexture.prototype.destroy = function ()
	{
	    if (this.source && this.source._pixiId)
	    {
	        delete utils.BaseTextureCache[ this.source._pixiId ];
	        delete this.source._pixiId;
	    }
	
	    BaseTexture.prototype.destroy.call(this);
	};
	
	/**
	 * Mimic Pixi BaseTexture.from.... method.
	 *
	 * @static
	 * @param video {HTMLVideoElement}
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.VideoBaseTexture}
	 */
	VideoBaseTexture.fromVideo = function (video, scaleMode)
	{
	    if (!video._pixiId)
	    {
	        video._pixiId = 'video_' + utils.uid();
	    }
	
	    var baseTexture = utils.BaseTextureCache[video._pixiId];
	
	    if (!baseTexture)
	    {
	        baseTexture = new VideoBaseTexture(video, scaleMode);
	        utils.BaseTextureCache[ video._pixiId ] = baseTexture;
	    }
	
	    return baseTexture;
	};
	
	/**
	 * Helper function that creates a new BaseTexture based on the given video element.
	 * This BaseTexture can then be used to create a texture
	 *
	 * @static
	 * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.
	 * @param [videoSrc.src] {string} One of the source urls for the video
	 * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified
	 *  the url's extension will be used as the second part of the mime type.
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.VideoBaseTexture}
	 */
	VideoBaseTexture.fromUrl = function (videoSrc, scaleMode)
	{
	    var video = document.createElement('video');
	
	    // array of objects or strings
	    if (Array.isArray(videoSrc))
	    {
	        for (var i = 0; i < videoSrc.length; ++i)
	        {
	            video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
	        }
	    }
	    // single object or string
	    else
	    {
	        video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
	    }
	
	    video.load();
	    video.play();
	
	    return VideoBaseTexture.fromVideo(video, scaleMode);
	};
	
	VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;
	
	function createSource(path, type)
	{
	    if (!type)
	    {
	        type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
	    }
	
	    var source = document.createElement('source');
	
	    source.src = path;
	    source.type = type;
	
	    return source;
	}


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A standard object to store the Uvs of a texture
	 *
	 * @class
	 * @private
	 * @memberof PIXI
	 */
	function TextureUvs()
	{
	    this.x0 = 0;
	    this.y0 = 0;
	
	    this.x1 = 1;
	    this.y1 = 0;
	
	    this.x2 = 1;
	    this.y2 = 1;
	
	    this.x3 = 0;
	    this.y3 = 1;
	}
	
	module.exports = TextureUvs;
	
	var GroupD8 = __webpack_require__(18);
	
	/**
	 * Sets the texture Uvs based on the given frame information
	 * @param frame {PIXI.Rectangle}
	 * @param baseFrame {PIXI.Rectangle}
	 * @param rotate {number} Rotation of frame, see {@link PIXI.GroupD8}
	 * @private
	 */
	TextureUvs.prototype.set = function (frame, baseFrame, rotate)
	{
	    var tw = baseFrame.width;
	    var th = baseFrame.height;
	
	    if(rotate)
	    {
	        //width and height div 2 div baseFrame size
	        var swapWidthHeight = GroupD8.isSwapWidthHeight(rotate);
	        var w2 = (swapWidthHeight ? frame.height : frame.width) / 2 / tw;
	        var h2 = (swapWidthHeight ? frame.width : frame.height) / 2 / th;
	        //coordinates of center
	        var cX = frame.x / tw + w2;
	        var cY = frame.y / th + h2;
	        rotate = GroupD8.add(rotate, GroupD8.NW); //NW is top-left corner
	        this.x0 = cX + w2 * GroupD8.uX(rotate);
	        this.y0 = cY + h2 * GroupD8.uY(rotate);
	        rotate = GroupD8.add(rotate, 2); //rotate 90 degrees clockwise
	        this.x1 = cX + w2 * GroupD8.uX(rotate);
	        this.y1 = cY + h2 * GroupD8.uY(rotate);
	        rotate = GroupD8.add(rotate, 2);
	        this.x2 = cX + w2 * GroupD8.uX(rotate);
	        this.y2 = cY + h2 * GroupD8.uY(rotate);
	        rotate = GroupD8.add(rotate, 2);
	        this.x3 = cX + w2 * GroupD8.uX(rotate);
	        this.y3 = cY + h2 * GroupD8.uY(rotate);
	    }
	    else
	    {
	
	        this.x0 = frame.x / tw;
	        this.y0 = frame.y / th;
	
	        this.x1 = (frame.x + frame.width) / tw;
	        this.y1 = frame.y / th;
	
	        this.x2 = (frame.x + frame.width) / tw;
	        this.y2 = (frame.y + frame.height) / th;
	
	        this.x3 = frame.x / tw;
	        this.y3 = (frame.y + frame.height) / th;
	    }
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var math = __webpack_require__(15),
	    utils = __webpack_require__(24),
	    CONST = __webpack_require__(14),
	    //StencilManager = require('../managers/StencilManager'),
	    StencilMaskStack = __webpack_require__(40);
	
	/**
	 * @author Mat Groves http://matgroves.com/ @Doormat23
	 */
	
	/**
	 * @class
	 * @memberof PIXI
	 * @param gl {WebGLRenderingContext} the current WebGL drawing context
	 * @param width {number} the horizontal range of the filter
	 * @param height {number} the vertical range of the filter
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @param resolution {number} the current resolution
	 * @param root {boolean} Whether this object is the root element or not
	 */
	var RenderTarget = function(gl, width, height, scaleMode, resolution, root)
	{
	    //TODO Resolution could go here ( eg low res blurs )
	
	    /**
	     * The current WebGL drawing context.
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;
	
	    // next time to create a frame buffer and texture
	
	    /**
	     * A frame buffer
	     *
	     * @member {WebGLFrameBuffer}
	     */
	    this.frameBuffer = null;
	
	    /**
	     * The texture
	     *
	     * @member {PIXI.Texture}
	     */
	    this.texture = null;
	
	    /**
	     * The size of the object as a rectangle
	     *
	     * @member {PIXI.Rectangle}
	     */
	    this.size = new math.Rectangle(0, 0, 1, 1);
	
	    /**
	     * The current resolution
	     *
	     * @member {number}
	     */
	    this.resolution = resolution || CONST.RESOLUTION;
	
	    /**
	     * The projection matrix
	     *
	     * @member {PIXI.Matrix}
	     */
	    this.projectionMatrix = new math.Matrix();
	
	    /**
	     * The object's transform
	     *
	     * @member {PIXI.Matrix}
	     */
	    this.transform = null;
	
	    /**
	     * The frame.
	     *
	     * @member {PIXI.Rectangle}
	     */
	    this.frame = null;
	
	    /**
	     * The stencil buffer stores masking data for the render target
	     *
	     * @member {WebGLRenderBuffer}
	     */
	    this.stencilBuffer = null;
	
	    /**
	     * The data structure for the stencil masks
	     *
	     * @member {PIXI.StencilMaskStack}
	     */
	    this.stencilMaskStack = new StencilMaskStack();
	
	    /**
	     * Stores filter data for the render target
	     *
	     * @member {object[]}
	     */
	    this.filterStack = [
	        {
	            renderTarget:this,
	            filter:[],
	            bounds:this.size
	        }
	    ];
	
	
	    /**
	     * The scale mode.
	     *
	     * @member {number}
	     * @default PIXI.SCALE_MODES.DEFAULT
	     * @see PIXI.SCALE_MODES
	     */
	    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
	
	    /**
	     * Whether this object is the root element or not
	     *
	     * @member {boolean}
	     */
	    this.root = root;
	
	    if (!this.root)
	    {
	       // this.flipY = true;
	        this.frameBuffer = gl.createFramebuffer();
	
	        /*
	            A frame buffer needs a target to render to..
	            create a texture and bind it attach it to the framebuffer..
	         */
	
	        this.texture = gl.createTexture();
	
	        gl.bindTexture(gl.TEXTURE_2D,  this.texture);
	
	        // set the scale properties of the texture..
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
	
	        // check to see if the texture is a power of two!
	        var isPowerOfTwo = utils.isPowerOfTwo(width, height);
	
	        //TODO for 99% of use cases if a texture is power of two we should tile the texture...
	         if (!isPowerOfTwo)
	        {
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        }
	        else
	        {
	
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        }
	
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
	    }
	
	    this.resize(width, height);
	};
	
	RenderTarget.prototype.constructor = RenderTarget;
	module.exports = RenderTarget;
	
	/**
	 * Clears the filter texture.
	 *
	 * @param [bind=false] {boolean} Should we bind our framebuffer before clearing?
	 */
	RenderTarget.prototype.clear = function(bind)
	{
	    var gl = this.gl;
	    if(bind)
	    {
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
	    }
	
	    gl.clearColor(0,0,0,0);
	    gl.clear(gl.COLOR_BUFFER_BIT);
	};
	
	/**
	 * Binds the stencil buffer.
	 *
	 */
	RenderTarget.prototype.attachStencilBuffer = function()
	{
	
	    if (this.stencilBuffer)
	    {
	        return;
	    }
	
	    /**
	     * The stencil buffer is used for masking in pixi
	     * lets create one and then add attach it to the framebuffer..
	     */
	    if (!this.root)
	    {
	        var gl = this.gl;
	
	        this.stencilBuffer = gl.createRenderbuffer();
	        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
	        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencilBuffer);
	        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.size.width * this.resolution  , this.size.height * this.resolution );
	    }
	};
	
	/**
	 * Binds the buffers and initialises the viewport.
	 *
	 */
	RenderTarget.prototype.activate = function()
	{
	    //TOOD refactor usage of frame..
	    var gl = this.gl;
	
	    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
	
	    var projectionFrame = this.frame || this.size;
	
	    // TODO add a dirty flag to this of a setter for the frame?
	    this.calculateProjection( projectionFrame );
	
	    if(this.transform)
	    {
	        this.projectionMatrix.append(this.transform);
	    }
	
	    gl.viewport(0,0, projectionFrame.width * this.resolution, projectionFrame.height * this.resolution);
	};
	
	/**
	 * Updates the projection matrix based on a projection frame (which is a rectangle)
	 *
	 */
	RenderTarget.prototype.calculateProjection = function (projectionFrame)
	{
	    var pm = this.projectionMatrix;
	
	    pm.identity();
	
	    if (!this.root)
	    {
	        pm.a = 1 / projectionFrame.width*2;
	        pm.d = 1 / projectionFrame.height*2;
	
	        pm.tx = -1 - projectionFrame.x * pm.a;
	        pm.ty = -1 - projectionFrame.y * pm.d;
	    }
	    else
	    {
	        pm.a = 1 / projectionFrame.width*2;
	        pm.d = -1 / projectionFrame.height*2;
	
	        pm.tx = -1 - projectionFrame.x * pm.a;
	        pm.ty = 1 - projectionFrame.y * pm.d;
	    }
	};
	
	
	/**
	 * Resizes the texture to the specified width and height
	 *
	 * @param width {Number} the new width of the texture
	 * @param height {Number} the new height of the texture
	 */
	RenderTarget.prototype.resize = function (width, height)
	{
	    width = width | 0;
	    height = height | 0;
	
	    if (this.size.width === width && this.size.height === height) {
	        return;
	    }
	
	    this.size.width = width;
	    this.size.height = height;
	
	    if (!this.root)
	    {
	        var gl = this.gl;
	
	        gl.bindTexture(gl.TEXTURE_2D,  this.texture);
	
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width * this.resolution, height * this.resolution , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	
	        if (this.stencilBuffer )
	        {
	            // update the stencil buffer width and height
	            gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
	            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  width * this.resolution, height * this.resolution );
	        }
	    }
	
	    var projectionFrame = this.frame || this.size;
	
	    this.calculateProjection( projectionFrame );
	};
	
	/**
	 * Destroys the render target.
	 *
	 */
	RenderTarget.prototype.destroy = function ()
	{
	    var gl = this.gl;
	    gl.deleteRenderbuffer( this.stencilBuffer );
	    gl.deleteFramebuffer( this.frameBuffer );
	    gl.deleteTexture( this.texture );
	
	    this.frameBuffer = null;
	    this.texture = null;
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * Generic Mask Stack data structure
	 * @class
	 * @memberof PIXI
	 */
	function StencilMaskStack()
	{
		/**
	     * The actual stack
	     *
	     * @member {any[]}
	     */
	    this.stencilStack = [];
	
	    /**
	     * TODO @alvin
	     *
	     * @member {boolean}
	     */
	    this.reverse = true;
	
	    /**
	     * Internal count
	     *
	     * @member {number}
	     */
	    this.count = 0;
	}
	
	StencilMaskStack.prototype.constructor = StencilMaskStack;
	module.exports = StencilMaskStack;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var WebGLManager = __webpack_require__(42),
	    RenderTarget = __webpack_require__(39),
	    CONST = __webpack_require__(14),
	    Quad = __webpack_require__(43),
	    math =  __webpack_require__(15);
	
	/**
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.WebGLManager
	 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
	 */
	function FilterManager(renderer)
	{
	    WebGLManager.call(this, renderer);
	
	    /**
	     * @member {object[]}
	     */
	    this.filterStack = [];
	
	    this.filterStack.push({
	        renderTarget:renderer.currentRenderTarget,
	        filter:[],
	        bounds:null
	    });
	
	    /**
	     * @member {PIXI.RenderTarget[]}
	     */
	    this.texturePool = [];
	
	    /**
	     * The size of the texture
	     *
	     * @member {PIXI.Rectangle}
	     */
	    // listen for context and update necessary buffers
	    //TODO make this dynamic!
	    //TODO test this out by forces power of two?
	    this.textureSize = new math.Rectangle(0, 0, renderer.width, renderer.height);
	
	    /**
	     * The current frame
	     *
	     * @member {PIXI.Rectangle}
	     */
	    this.currentFrame = null;
	}
	
	FilterManager.prototype = Object.create(WebGLManager.prototype);
	FilterManager.prototype.constructor = FilterManager;
	module.exports = FilterManager;
	
	
	/**
	 * Called when there is a WebGL context change.
	 *
	 */
	FilterManager.prototype.onContextChange = function ()
	{
	    this.texturePool.length = 0;
	
	    var gl = this.renderer.gl;
	    this.quad = new Quad(gl);
	};
	
	/**
	 * @param renderer {PIXI.WebGLRenderer}
	 * @param buffer {ArrayBuffer}
	 */
	FilterManager.prototype.setFilterStack = function ( filterStack )
	{
	    this.filterStack = filterStack;
	};
	
	/**
	 * Applies the filter and adds it to the current filter stack.
	 *
	 * @param target {PIXI.DisplayObject}
	 * @param filters {PIXI.AbstractFiler[]} the filters that will be pushed to the current filter stack
	 */
	FilterManager.prototype.pushFilter = function (target, filters)
	{
	    // get the bounds of the object..
	    // TODO replace clone with a copy to save object creation
	    var bounds = target.filterArea ? target.filterArea.clone() : target.getBounds();
	
	    //bounds = bounds.clone();
	
	    // round off the rectangle to get a nice smoooooooth filter :)
	    bounds.x = bounds.x | 0;
	    bounds.y = bounds.y | 0;
	    bounds.width = bounds.width | 0;
	    bounds.height = bounds.height | 0;
	
	
	    // padding!
	    var padding = filters[0].padding | 0;
	    bounds.x -= padding;
	    bounds.y -= padding;
	    bounds.width += padding * 2;
	    bounds.height += padding * 2;
	
	
	    if(this.renderer.currentRenderTarget.transform)
	    {
	        //TODO this will break if the renderTexture transform is anything other than a translation.
	        //Will need to take the full matrix transform into acount..
	        var transform = this.renderer.currentRenderTarget.transform;
	
	        bounds.x += transform.tx;
	        bounds.y += transform.ty;
	
	        this.capFilterArea( bounds );
	
	        bounds.x -= transform.tx;
	        bounds.y -= transform.ty;
	    }
	    else
	    {
	         this.capFilterArea( bounds );
	    }
	
	    if(bounds.width > 0 && bounds.height > 0)
	    {
	        this.currentFrame = bounds;
	
	        var texture = this.getRenderTarget();
	
	        this.renderer.setRenderTarget(texture);
	
	        // clear the texture..
	        texture.clear();
	
	        // TODO get rid of object creation!
	        this.filterStack.push({
	            renderTarget: texture,
	            filter: filters
	        });
	
	    }
	    else
	    {
	        // push somthing on to the stack that is empty
	        this.filterStack.push({
	            renderTarget: null,
	            filter: filters
	        });
	    }
	};
	
	
	/**
	 * Removes the last filter from the filter stack and returns it.
	 *
	 */
	FilterManager.prototype.popFilter = function ()
	{
	    var filterData = this.filterStack.pop();
	    var previousFilterData = this.filterStack[this.filterStack.length-1];
	
	    var input = filterData.renderTarget;
	
	    // if the renderTarget is null then we don't apply the filter as its offscreen
	    if(!filterData.renderTarget)
	    {
	        return;
	    }
	
	    var output = previousFilterData.renderTarget;
	
	    // use program
	    var gl = this.renderer.gl;
	
	
	    this.currentFrame = input.frame;
	
	    this.quad.map(this.textureSize, input.frame);
	
	
	    // TODO.. this probably only needs to be done once!
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);
	
	    var filters = filterData.filter;
	
	    // assuming all filters follow the correct format??
	    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
	    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
	    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
	
	    // restore the normal blendmode!
	    this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);
	
	    if (filters.length === 1)
	    {
	        // TODO (cengler) - There has to be a better way then setting this each time?
	        if (filters[0].uniforms.dimensions)
	        {
	            filters[0].uniforms.dimensions.value[0] = this.renderer.width;
	            filters[0].uniforms.dimensions.value[1] = this.renderer.height;
	            filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];
	            filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];
	        }
	
	        filters[0].applyFilter( this.renderer, input, output );
	        this.returnRenderTarget( input );
	
	    }
	    else
	    {
	        var flipTexture = input;
	        var flopTexture = this.getRenderTarget(true);
	
	        for (var i = 0; i < filters.length-1; i++)
	        {
	            var filter = filters[i];
	
	            // TODO (cengler) - There has to be a better way then setting this each time?
	            if (filter.uniforms.dimensions)
	            {
	                filter.uniforms.dimensions.value[0] = this.renderer.width;
	                filter.uniforms.dimensions.value[1] = this.renderer.height;
	                filter.uniforms.dimensions.value[2] = this.quad.vertices[0];
	                filter.uniforms.dimensions.value[3] = this.quad.vertices[5];
	            }
	
	            filter.applyFilter( this.renderer, flipTexture, flopTexture );
	
	            var temp = flipTexture;
	            flipTexture = flopTexture;
	            flopTexture = temp;
	        }
	
	        filters[filters.length-1].applyFilter( this.renderer, flipTexture, output );
	
	        this.returnRenderTarget( flipTexture );
	        this.returnRenderTarget( flopTexture );
	    }
	
	    return filterData.filter;
	};
	
	/**
	 * Grabs an render target from the internal pool
	 *
	 * @param clear {boolean} Whether or not we need to clear the RenderTarget
	 * @return {RenderTarget}
	 */
	FilterManager.prototype.getRenderTarget = function ( clear )
	{
	    var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);
	    renderTarget.frame = this.currentFrame;
	
	    if (clear)
	    {
	        renderTarget.clear(true);
	    }
	
	    return renderTarget;
	};
	
	/*
	 * Returns a RenderTarget to the internal pool
	 * @param renderTarget {RenderTarget} The RenderTarget we want to return to the pool
	 */
	FilterManager.prototype.returnRenderTarget = function (renderTarget)
	{
	    this.texturePool.push( renderTarget );
	};
	
	/*
	 * Applies the filter
	 * @param shader {Shader} The shader to upload
	 * @param inputTarget {RenderTarget}
	 * @param outputTarget {RenderTarget}
	 * @param clear {boolean} Whether or not we want to clear the outputTarget
	 */
	FilterManager.prototype.applyFilter = function (shader, inputTarget, outputTarget, clear)
	{
	    var gl = this.renderer.gl;
	
	    this.renderer.setRenderTarget(outputTarget);
	
	    if (clear)
	    {
	        outputTarget.clear();
	    }
	
	    // set the shader
	    this.renderer.shaderManager.setShader(shader);
	
	    // TODO (cengler) - Can this be cached and not `toArray`ed each frame?
	    shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);
	
	    //TODO can this be optimised?
	    shader.syncUniforms();
	/*
	    gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
	    gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
	    gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
	*/
	
	    gl.activeTexture(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);
	
	    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	    this.renderer.drawCount++;
	};
	
	/*
	 * Calculates the mapped matrix
	 * @param filterArea {Rectangle} The filter area
	 * @param sprite {Sprite} the target sprite
	 * @param outputMatrix {Matrix} @alvin
	 */
	// TODO playing around here.. this is temporary - (will end up in the shader)
	FilterManager.prototype.calculateMappedMatrix = function (filterArea, sprite, outputMatrix)
	{
	    var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),
	    texture = sprite._texture.baseTexture;
	
	    var mappedMatrix = outputMatrix.identity();
	
	    // scale..
	    var ratio = this.textureSize.height / this.textureSize.width;
	
	    mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height );
	
	    mappedMatrix.scale(1 , ratio);
	
	    var translateScaleX = (this.textureSize.width / texture.width);
	    var translateScaleY = (this.textureSize.height / texture.height);
	
	    worldTransform.tx /= texture.width * translateScaleX;
	    worldTransform.ty /= texture.width * translateScaleX;
	
	    worldTransform.invert();
	
	    mappedMatrix.prepend(worldTransform);
	
	    // apply inverse scale..
	    mappedMatrix.scale(1 , 1/ratio);
	
	    mappedMatrix.scale( translateScaleX , translateScaleY );
	
	    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
	
	    return mappedMatrix;
	
	    // Keeping the orginal as a reminder to me on how this works!
	    //
	    // var m = new math.Matrix();
	
	    // // scale..
	    // var ratio = this.textureSize.height / this.textureSize.width;
	
	    // m.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);
	
	
	    // m.scale(1 , ratio);
	
	
	    // var transform = wt.clone();
	
	    // var translateScaleX = (this.textureSize.width / 620);
	    // var translateScaleY = (this.textureSize.height / 380);
	
	    // transform.tx /= 620 * translateScaleX;
	    // transform.ty /= 620 * translateScaleX;
	
	    // transform.invert();
	
	    // transform.append(m);
	
	    // // apply inverse scale..
	    // transform.scale(1 , 1/ratio);
	
	    // transform.scale( translateScaleX , translateScaleY );
	
	    // return transform;
	};
	
	/*
	 * Constrains the filter area to the texture size
	 * @param filterArea {Rectangle} The filter area we want to cap
	 */
	FilterManager.prototype.capFilterArea = function (filterArea)
	{
	    if (filterArea.x < 0)
	    {
	        filterArea.width += filterArea.x;
	        filterArea.x = 0;
	    }
	
	    if (filterArea.y < 0)
	    {
	        filterArea.height += filterArea.y;
	        filterArea.y = 0;
	    }
	
	    if ( filterArea.x + filterArea.width > this.textureSize.width )
	    {
	        filterArea.width = this.textureSize.width - filterArea.x;
	    }
	
	    if ( filterArea.y + filterArea.height > this.textureSize.height )
	    {
	        filterArea.height = this.textureSize.height - filterArea.y;
	    }
	};
	
	/*
	 * Resizes all the render targets in the pool
	 * @param width {number} the new width
	 * @param height {number} the new height
	 */
	FilterManager.prototype.resize = function ( width, height )
	{
	    this.textureSize.width = width;
	    this.textureSize.height = height;
	
	    for (var i = 0; i < this.texturePool.length; i++)
	    {
	        this.texturePool[i].resize( width, height );
	    }
	};
	
	/**
	 * Destroys the filter and removes it from the filter stack.
	 *
	 */
	FilterManager.prototype.destroy = function ()
	{
	    this.quad.destroy();
	    
	    WebGLManager.prototype.destroy.call(this);
	    
	    this.filterStack = null;
	    this.offsetY = 0;
	
	    // destroy textures
	    for (var i = 0; i < this.texturePool.length; i++)
	    {
	        this.texturePool[i].destroy();
	    }
	
	    this.texturePool = null;
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * @class
	 * @memberof PIXI
	 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
	 */
	function WebGLManager(renderer)
	{
	    /**
	     * The renderer this manager works for.
	     *
	     * @member {PIXI.WebGLRenderer}
	     */
	    this.renderer = renderer;
	
	    this.renderer.on('context', this.onContextChange, this);
	}
	
	WebGLManager.prototype.constructor = WebGLManager;
	module.exports = WebGLManager;
	
	/**
	 * Generic method called when there is a WebGL context change.
	 *
	 */
	WebGLManager.prototype.onContextChange = function ()
	{
		// do some codes init!
	};
	
	/**
	 * Generic destroy methods to be overridden by the subclass
	 *
	 */
	WebGLManager.prototype.destroy = function ()
	{
	    this.renderer.off('context', this.onContextChange, this);
	
	    this.renderer = null;
	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Helper class to create a quad
	 *
	 * @class
	 * @memberof PIXI
	 * @param gl {WebGLRenderingContext} The gl context for this quad to use.
	 */
	function Quad(gl)
	{
	    /*
	     * the current WebGL drawing context
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;
	
	//    this.textures = new TextureUvs();
	
	    /**
	     * An array of vertices
	     *
	     * @member {Float32Array}
	     */
	    this.vertices = new Float32Array([
	        0,0,
	        200,0,
	        200,200,
	        0,200
	    ]);
	
	    /**
	     * The Uvs of the quad
	     *
	     * @member {Float32Array}
	     */
	    this.uvs = new Float32Array([
	        0,0,
	        1,0,
	        1,1,
	        0,1
	    ]);
	
	//    var white = (0xFFFFFF >> 16) + (0xFFFFFF & 0xff00) + ((0xFFFFFF & 0xff) << 16) + (1 * 255 << 24);
	    //TODO convert this to a 32 unsigned int array
	    /**
	     * The color components of the triangles
	     *
	     * @member {Float32Array}
	     */
	    this.colors = new Float32Array([
	        1,1,1,1,
	        1,1,1,1,
	        1,1,1,1,
	        1,1,1,1
	    ]);
	
	    /*
	     * @member {Uint16Array} An array containing the indices of the vertices
	     */
	    this.indices = new Uint16Array([
	        0, 1, 2, 0, 3, 2
	    ]);
	
	    /*
	     * @member {WebGLBuffer} The vertex buffer
	     */
	    this.vertexBuffer = gl.createBuffer();
	
	    /*
	     * @member {WebGLBuffer} The index buffer
	     */
	    this.indexBuffer = gl.createBuffer();
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);
	
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
	
	    this.upload();
	}
	
	Quad.prototype.constructor = Quad;
	
	/**
	 * Maps two Rectangle to the quad
	 * @param rect {PIXI.Rectangle} the first rectangle
	 * @param rect2 {PIXI.Rectangle} the second rectangle
	 */
	Quad.prototype.map = function(rect, rect2)
	{
	    var x = 0; //rect2.x / rect.width;
	    var y = 0; //rect2.y / rect.height;
	
	    this.uvs[0] = x;
	    this.uvs[1] = y;
	
	    this.uvs[2] = x + rect2.width / rect.width;
	    this.uvs[3] = y;
	
	    this.uvs[4] = x + rect2.width / rect.width;
	    this.uvs[5] = y + rect2.height / rect.height;
	
	    this.uvs[6] = x;
	    this.uvs[7] = y + rect2.height / rect.height;
	
	    /// -----
	    x = rect2.x;
	    y = rect2.y;
	
	    this.vertices[0] = x;
	    this.vertices[1] = y;
	
	    this.vertices[2] = x + rect2.width;
	    this.vertices[3] = y;
	
	    this.vertices[4] = x + rect2.width;
	    this.vertices[5] = y + rect2.height;
	
	    this.vertices[6] = x;
	    this.vertices[7] = y + rect2.height;
	
	    this.upload();
	};
	
	/**
	 * Binds the buffer and uploads the data
	 */
	Quad.prototype.upload = function()
	{
	    var gl = this.gl;
	
	    // TODO could probably be pushed into one upload!
	    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
	
	    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
	
	    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this.uvs);
	
	    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this.colors);
	};
	
	Quad.prototype.destroy = function()
	{
	    var gl = this.gl;
	    
	     gl.deleteBuffer(this.vertexBuffer);
	     gl.deleteBuffer(this.indexBuffer);
	};
	
	module.exports = Quad;
	
	


/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Creates a Canvas element of the given size.
	 *
	 * @class
	 * @memberof PIXI
	 * @param width {number} the width for the newly created canvas
	 * @param height {number} the height for the newly created canvas
	 */
	function CanvasBuffer(width, height)
	{
	    /**
	     * The Canvas object that belongs to this CanvasBuffer.
	     *
	     * @member {HTMLCanvasElement}
	     */
	    this.canvas = document.createElement('canvas');
	
	    /**
	     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
	     *
	     * @member {CanvasRenderingContext2D}
	     */
	    this.context = this.canvas.getContext('2d');
	
	    this.canvas.width = width;
	    this.canvas.height = height;
	}
	
	CanvasBuffer.prototype.constructor = CanvasBuffer;
	module.exports = CanvasBuffer;
	
	Object.defineProperties(CanvasBuffer.prototype, {
	    /**
	     * The width of the canvas buffer in pixels.
	     *
	     * @member {number}
	     * @memberof PIXI.CanvasBuffer#
	     */
	    width: {
	        get: function ()
	        {
	            return this.canvas.width;
	        },
	        set: function (val)
	        {
	            this.canvas.width = val;
	        }
	    },
	    /**
	     * The height of the canvas buffer in pixels.
	     *
	     * @member {number}
	     * @memberof PIXI.CanvasBuffer#
	     */
	    height: {
	        get: function ()
	        {
	            return this.canvas.height;
	        },
	        set: function (val)
	        {
	            this.canvas.height = val;
	        }
	    }
	});
	
	/**
	 * Clears the canvas that was created by the CanvasBuffer class.
	 *
	 * @private
	 */
	CanvasBuffer.prototype.clear = function ()
	{
	    this.context.setTransform(1, 0, 0, 1, 0, 0);
	    this.context.clearRect(0,0, this.canvas.width, this.canvas.height);
	};
	
	/**
	 * Resizes the canvas to the specified width and height.
	 *
	 * @param width {number} the new width of the canvas
	 * @param height {number} the new height of the canvas
	 */
	CanvasBuffer.prototype.resize = function (width, height)
	{
	    this.canvas.width = width;
	    this.canvas.height = height;
	};
	
	/**
	 * Destroys this canvas.
	 *
	 */
	CanvasBuffer.prototype.destroy = function ()
	{
	    this.context = null;
	    this.canvas = null;
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var math = __webpack_require__(15),
	    utils = __webpack_require__(24),
	    DisplayObject = __webpack_require__(33),
	    RenderTexture = __webpack_require__(34),
	    _tempMatrix = new math.Matrix();
	
	/**
	 * A Container represents a collection of display objects.
	 * It is the base class of all display objects that act as a container for other objects.
	 *
	 *```js
	 * var container = new PIXI.Container();
	 * container.addChild(sprite);
	 * ```
	 * @class
	 * @extends PIXI.DisplayObject
	 * @memberof PIXI
	 */
	function Container()
	{
	    DisplayObject.call(this);
	
	    /**
	     * The array of children of this container.
	     *
	     * @member {PIXI.DisplayObject[]}
	     * @readonly
	     */
	    this.children = [];
	}
	
	// constructor
	Container.prototype = Object.create(DisplayObject.prototype);
	Container.prototype.constructor = Container;
	module.exports = Container;
	
	Object.defineProperties(Container.prototype, {
	    /**
	     * The width of the Container, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.Container#
	     */
	    width: {
	        get: function ()
	        {
	            return this.scale.x * this.getLocalBounds().width;
	        },
	        set: function (value)
	        {
	
	            var width = this.getLocalBounds().width;
	
	            if (width !== 0)
	            {
	                this.scale.x = value / width;
	            }
	            else
	            {
	                this.scale.x = 1;
	            }
	
	
	            this._width = value;
	        }
	    },
	
	    /**
	     * The height of the Container, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.Container#
	     */
	    height: {
	        get: function ()
	        {
	            return  this.scale.y * this.getLocalBounds().height;
	        },
	        set: function (value)
	        {
	
	            var height = this.getLocalBounds().height;
	
	            if (height !== 0)
	            {
	                this.scale.y = value / height ;
	            }
	            else
	            {
	                this.scale.y = 1;
	            }
	
	            this._height = value;
	        }
	    }
	});
	
	/**
	 * Overridable method that can be used by Container subclasses whenever the children array is modified
	 *
	 * @private
	 */
	Container.prototype.onChildrenChange = function () {};
	
	/**
	 * Adds a child to the container.
	 * 
	 * You can also add multple items like so: myContainer.addChild(thinkOne, thingTwo, thingThree)
	 * @param child {PIXI.DisplayObject} The DisplayObject to add to the container
	 * @return {PIXI.DisplayObject} The child that was added.
	 */
	Container.prototype.addChild = function (child)
	{ 
	    var argumentsLength = arguments.length;
	
	    // if there is only one argument we can bypass looping through the them
	    if(argumentsLength > 1)
	    {
	        // loop through the arguments property and add all children
	        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
	        for (var i = 0; i < argumentsLength; i++)
	        {
	            this.addChild( arguments[i] );
	        }
	    }     
	    else
	    {
	        // if the child has a parent then lets remove it as Pixi objects can only exist in one place
	        if (child.parent)
	        {
	            child.parent.removeChild(child);
	        }
	
	        child.parent = this;
	        
	        this.children.push(child);
	
	        // TODO - lets either do all callbacks or all events.. not both!
	        this.onChildrenChange(this.children.length-1);
	        child.emit('added', this);
	    }
	
	    return child;
	};
	
	/**
	 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
	 *
	 * @param child {PIXI.DisplayObject} The child to add
	 * @param index {number} The index to place the child in
	 * @return {PIXI.DisplayObject} The child that was added.
	 */
	Container.prototype.addChildAt = function (child, index)
	{
	    if (index >= 0 && index <= this.children.length)
	    {
	        if (child.parent)
	        {
	            child.parent.removeChild(child);
	        }
	
	        child.parent = this;
	
	        this.children.splice(index, 0, child);
	
	        // TODO - lets either do all callbacks or all events.. not both!
	        this.onChildrenChange(index);
	        child.emit('added', this);
	
	        return child;
	    }
	    else
	    {
	        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);
	    }
	};
	
	/**
	 * Swaps the position of 2 Display Objects within this container.
	 *
	 * @param child {PIXI.DisplayObject}
	 * @param child2 {PIXI.DisplayObject}
	 */
	Container.prototype.swapChildren = function (child, child2)
	{
	    if (child === child2)
	    {
	        return;
	    }
	
	    var index1 = this.getChildIndex(child);
	    var index2 = this.getChildIndex(child2);
	
	    if (index1 < 0 || index2 < 0)
	    {
	        throw new Error('swapChildren: Both the supplied DisplayObjects must be children of the caller.');
	    }
	
	    this.children[index1] = child2;
	    this.children[index2] = child;
	    this.onChildrenChange(index1 < index2 ? index1 : index2);
	};
	
	/**
	 * Returns the index position of a child DisplayObject instance
	 *
	 * @param child {PIXI.DisplayObject} The DisplayObject instance to identify
	 * @return {number} The index position of the child display object to identify
	 */
	Container.prototype.getChildIndex = function (child)
	{
	    var index = this.children.indexOf(child);
	
	    if (index === -1)
	    {
	        throw new Error('The supplied DisplayObject must be a child of the caller');
	    }
	
	    return index;
	};
	
	/**
	 * Changes the position of an existing child in the display object container
	 *
	 * @param child {PIXI.DisplayObject} The child DisplayObject instance for which you want to change the index number
	 * @param index {number} The resulting index number for the child display object
	 */
	Container.prototype.setChildIndex = function (child, index)
	{
	    if (index < 0 || index >= this.children.length)
	    {
	        throw new Error('The supplied index is out of bounds');
	    }
	
	    var currentIndex = this.getChildIndex(child);
	
	    utils.removeItems(this.children, currentIndex, 1); // remove from old position
	    this.children.splice(index, 0, child); //add at new position
	    this.onChildrenChange(index);
	};
	
	/**
	 * Returns the child at the specified index
	 *
	 * @param index {number} The index to get the child at
	 * @return {PIXI.DisplayObject} The child at the given index, if any.
	 */
	Container.prototype.getChildAt = function (index)
	{
	    if (index < 0 || index >= this.children.length)
	    {
	        throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject is not a child of the caller');
	    }
	
	    return this.children[index];
	};
	
	/**
	 * Removes a child from the container.
	 *
	 * @param child {PIXI.DisplayObject} The DisplayObject to remove
	 * @return {PIXI.DisplayObject} The child that was removed.
	 */
	Container.prototype.removeChild = function (child)
	{
	    var argumentsLength = arguments.length;
	
	    // if there is only one argument we can bypass looping through the them
	    if(argumentsLength > 1)
	    {
	        // loop through the arguments property and add all children
	        // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
	        for (var i = 0; i < argumentsLength; i++)
	        {
	            this.removeChild( arguments[i] );
	        }
	    }     
	    else
	    {   
	        var index = this.children.indexOf(child);
	
	        if (index === -1)
	        {
	            return;
	        }
	
	        child.parent = null;
	        utils.removeItems(this.children, index, 1);
	
	        // TODO - lets either do all callbacks or all events.. not both!
	        this.onChildrenChange(index);
	        child.emit('removed', this);
	    }
	
	    return child;
	};
	
	/**
	 * Removes a child from the specified index position.
	 *
	 * @param index {number} The index to get the child from
	 * @return {PIXI.DisplayObject} The child that was removed.
	 */
	Container.prototype.removeChildAt = function (index)
	{
	    var child = this.getChildAt(index);
	
	    child.parent = null;
	    utils.removeItems(this.children, index, 1);
	
	    // TODO - lets either do all callbacks or all events.. not both!
	    this.onChildrenChange(index);
	    child.emit('removed', this);
	
	    return child;
	};
	
	/**
	 * Removes all children from this container that are within the begin and end indexes.
	 *
	 * @param beginIndex {number} The beginning position. Default value is 0.
	 * @param endIndex {number} The ending position. Default value is size of the container.
	 */
	Container.prototype.removeChildren = function (beginIndex, endIndex)
	{
	    var begin = beginIndex || 0;
	    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
	    var range = end - begin;
	    var removed, i;
	
	    if (range > 0 && range <= end)
	    {
	        removed = this.children.splice(begin, range);
	
	        for (i = 0; i < removed.length; ++i)
	        {
	            removed[i].parent = null;
	        }
	
	        this.onChildrenChange(beginIndex);
	
	        for (i = 0; i < removed.length; ++i)
	        {
	            removed[i].emit('removed', this);
	        }
	
	        return removed;
	    }
	    else if (range === 0 && this.children.length === 0)
	    {
	        return [];
	    }
	    else
	    {
	        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
	    }
	};
	
	/**
	 * Useful function that returns a texture of the display object that can then be used to create sprites
	 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
	 *
	 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} The renderer used to generate the texture.
	 * @param resolution {number} The resolution of the texture being generated
	 * @param scaleMode {number} See {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.Texture} a texture of the display object
	 */
	Container.prototype.generateTexture = function (renderer, resolution, scaleMode)
	{
	    var bounds = this.getLocalBounds();
	
	    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);
	
	    _tempMatrix.tx = -bounds.x;
	    _tempMatrix.ty = -bounds.y;
	
	    renderTexture.render(this, _tempMatrix);
	
	    return renderTexture;
	};
	
	/*
	 * Updates the transform on all children of this container for rendering
	 *
	 * @private
	 */
	Container.prototype.updateTransform = function ()
	{
	    if (!this.visible)
	    {
	        return;
	    }
	
	    this.displayObjectUpdateTransform();
	
	    for (var i = 0, j = this.children.length; i < j; ++i)
	    {
	        this.children[i].updateTransform();
	    }
	};
	
	// performance increase to avoid using call.. (10x faster)
	Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
	
	/**
	 * Retrieves the bounds of the Container as a rectangle. The bounds calculation takes all visible children into consideration.
	 *
	 * @return {PIXI.Rectangle} The rectangular bounding area
	 */
	Container.prototype.getBounds = function ()
	{
	    if(!this._currentBounds)
	    {
	
	        if (this.children.length === 0)
	        {
	            return math.Rectangle.EMPTY;
	        }
	
	        // TODO the bounds have already been calculated this render session so return what we have
	
	        var minX = Infinity;
	        var minY = Infinity;
	
	        var maxX = -Infinity;
	        var maxY = -Infinity;
	
	        var childBounds;
	        var childMaxX;
	        var childMaxY;
	
	        var childVisible = false;
	
	        for (var i = 0, j = this.children.length; i < j; ++i)
	        {
	            var child = this.children[i];
	
	            if (!child.visible)
	            {
	                continue;
	            }
	
	            childVisible = true;
	
	            childBounds = this.children[i].getBounds();
	
	            minX = minX < childBounds.x ? minX : childBounds.x;
	            minY = minY < childBounds.y ? minY : childBounds.y;
	
	            childMaxX = childBounds.width + childBounds.x;
	            childMaxY = childBounds.height + childBounds.y;
	
	            maxX = maxX > childMaxX ? maxX : childMaxX;
	            maxY = maxY > childMaxY ? maxY : childMaxY;
	        }
	
	        if (!childVisible)
	        {
	            return math.Rectangle.EMPTY;
	        }
	
	        var bounds = this._bounds;
	
	        bounds.x = minX;
	        bounds.y = minY;
	        bounds.width = maxX - minX;
	        bounds.height = maxY - minY;
	
	        this._currentBounds = bounds;
	    }
	
	    return this._currentBounds;
	};
	
	Container.prototype.containerGetBounds = Container.prototype.getBounds;
	
	/**
	 * Retrieves the non-global local bounds of the Container as a rectangle.
	 * The calculation takes all visible children into consideration.
	 *
	 * @return {PIXI.Rectangle} The rectangular bounding area
	 */
	Container.prototype.getLocalBounds = function ()
	{
	    var matrixCache = this.worldTransform;
	
	    this.worldTransform = math.Matrix.IDENTITY;
	
	    for (var i = 0, j = this.children.length; i < j; ++i)
	    {
	        this.children[i].updateTransform();
	    }
	
	    this.worldTransform = matrixCache;
	
	    this._currentBounds = null;
	
	    return this.getBounds( math.Matrix.IDENTITY );
	};
	
	/**
	 * Renders the object using the WebGL renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer} The renderer
	 */
	Container.prototype.renderWebGL = function (renderer)
	{
	
	    // if the object is not visible or the alpha is 0 then no need to render this element
	    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
	    {
	        return;
	    }
	
	    var i, j;
	
	    // do a quick check to see if this element has a mask or a filter.
	    if (this._mask || this._filters)
	    {
	        renderer.currentRenderer.flush();
	
	        // push filter first as we need to ensure the stencil buffer is correct for any masking
	        if (this._filters && this._filters.length)
	        {
	            renderer.filterManager.pushFilter(this, this._filters);
	        }
	
	        if (this._mask)
	        {
	            renderer.maskManager.pushMask(this, this._mask);
	        }
	
	        renderer.currentRenderer.start();
	
	        // add this object to the batch, only rendered if it has a texture.
	        this._renderWebGL(renderer);
	
	        // now loop through the children and make sure they get rendered
	        for (i = 0, j = this.children.length; i < j; i++)
	        {
	            this.children[i].renderWebGL(renderer);
	        }
	
	        renderer.currentRenderer.flush();
	
	        if (this._mask)
	        {
	            renderer.maskManager.popMask(this, this._mask);
	        }
	
	        if (this._filters)
	        {
	            renderer.filterManager.popFilter();
	
	        }
	        renderer.currentRenderer.start();
	    }
	    else
	    {
	        this._renderWebGL(renderer);
	
	        // simple render children!
	        for (i = 0, j = this.children.length; i < j; ++i)
	        {
	            this.children[i].renderWebGL(renderer);
	        }
	    }
	};
	
	/**
	 * To be overridden by the subclass
	 *
	 * @param renderer {PIXI.WebGLRenderer} The renderer
	 * @private
	 */
	Container.prototype._renderWebGL = function (renderer) // jshint unused:false
	{
	    // this is where content itself gets rendered...
	};
	
	/**
	 * To be overridden by the subclass
	 *
	 * @param renderer {PIXI.CanvasRenderer} The renderer
	 * @private
	 */
	Container.prototype._renderCanvas = function (renderer) // jshint unused:false
	{
	    // this is where content itself gets rendered...
	};
	
	
	/**
	 * Renders the object using the Canvas renderer
	 *
	 * @param renderer {PIXI.CanvasRenderer} The renderer
	 */
	Container.prototype.renderCanvas = function (renderer)
	{
	    // if not visible or the alpha is 0 then no need to render this
	    if (!this.visible || this.alpha <= 0 || !this.renderable)
	    {
	        return;
	    }
	
	    if (this._mask)
	    {
	        renderer.maskManager.pushMask(this._mask, renderer);
	    }
	
	    this._renderCanvas(renderer);
	    for (var i = 0, j = this.children.length; i < j; ++i)
	    {
	        this.children[i].renderCanvas(renderer);
	    }
	
	    if (this._mask)
	    {
	        renderer.maskManager.popMask(renderer);
	    }
	};
	
	/**
	 * Destroys the container
	 * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well
	 */
	Container.prototype.destroy = function (destroyChildren)
	{
	    DisplayObject.prototype.destroy.call(this);
	
	    if (destroyChildren)
	    {
	        for (var i = 0, j = this.children.length; i < j; ++i)
	        {
	            this.children[i].destroy(destroyChildren);
	        }
	    }
	
	    this.removeChildren();
	
	    this.children = null;
	};


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var math = __webpack_require__(15),
	    Texture = __webpack_require__(36),
	    Container = __webpack_require__(45),
	    CanvasTinter = __webpack_require__(47),
	    utils = __webpack_require__(24),
	    CONST = __webpack_require__(14),
	    tempPoint = new math.Point(),
	    GroupD8 = math.GroupD8,
	    canvasRenderWorldTransform = new math.Matrix();
	
	/**
	 * The Sprite object is the base for all textured objects that are rendered to the screen
	 *
	 * A sprite can be created directly from an image like this:
	 *
	 * ```js
	 * var sprite = new PIXI.Sprite.fromImage('assets/image.png');
	 * ```
	 *
	 * @class
	 * @extends PIXI.Container
	 * @memberof PIXI
	 * @param texture {PIXI.Texture} The texture for this sprite
	 */
	function Sprite(texture)
	{
	    Container.call(this);
	
	    /**
	     * The anchor sets the origin point of the texture.
	     * The default is 0,0 this means the texture's origin is the top left
	     * Setting the anchor to 0.5,0.5 means the texture's origin is centered
	     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
	     *
	     * @member {PIXI.Point}
	     */
	    this.anchor = new math.Point();
	
	    /**
	     * The texture that the sprite is using
	     *
	     * @member {PIXI.Texture}
	     * @private
	     */
	    this._texture = null;
	
	    /**
	     * The width of the sprite (this is initially set by the texture)
	     *
	     * @member {number}
	     * @private
	     */
	    this._width = 0;
	
	    /**
	     * The height of the sprite (this is initially set by the texture)
	     *
	     * @member {number}
	     * @private
	     */
	    this._height = 0;
	
	    /**
	     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
	     *
	     * @member {number}
	     * @default 0xFFFFFF
	     */
	    this.tint = 0xFFFFFF;
	
	    /**
	     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
	     *
	     * @member {number}
	     * @default PIXI.BLEND_MODES.NORMAL
	     * @see PIXI.BLEND_MODES
	     */
	    this.blendMode = CONST.BLEND_MODES.NORMAL;
	
	    /**
	     * The shader that will be used to render the sprite. Set to null to remove a current shader.
	     *
	     * @member {PIXI.AbstractFilter|PIXI.Shader}
	     */
	    this.shader = null;
	
	    /**
	     * An internal cached value of the tint.
	     *
	     * @member {number}
	     * @default 0xFFFFFF
	     */
	    this.cachedTint = 0xFFFFFF;
	
	    // call texture setter
	    this.texture = texture || Texture.EMPTY;
	}
	
	// constructor
	Sprite.prototype = Object.create(Container.prototype);
	Sprite.prototype.constructor = Sprite;
	module.exports = Sprite;
	
	Object.defineProperties(Sprite.prototype, {
	    /**
	     * The width of the sprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.Sprite#
	     */
	    width: {
	        get: function ()
	        {
	            return Math.abs(this.scale.x) * this.texture._frame.width;
	        },
	        set: function (value)
	        {
	            var sign = utils.sign(this.scale.x) || 1;
	            this.scale.x = sign * value / this.texture._frame.width;
	            this._width = value;
	        }
	    },
	
	    /**
	     * The height of the sprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.Sprite#
	     */
	    height: {
	        get: function ()
	        {
	            return  Math.abs(this.scale.y) * this.texture._frame.height;
	        },
	        set: function (value)
	        {
	            var sign = utils.sign(this.scale.y) || 1;
	            this.scale.y = sign * value / this.texture._frame.height;
	            this._height = value;
	        }
	    },
	
	    /**
	     * The texture that the sprite is using
	     *
	     * @member {PIXI.Texture}
	     * @memberof PIXI.Sprite#
	     */
	    texture: {
	        get: function ()
	        {
	            return  this._texture;
	        },
	        set: function (value)
	        {
	            if (this._texture === value)
	            {
	                return;
	            }
	
	            this._texture = value;
	            this.cachedTint = 0xFFFFFF;
	
	            if (value)
	            {
	                // wait for the texture to load
	                if (value.baseTexture.hasLoaded)
	                {
	                    this._onTextureUpdate();
	                }
	                else
	                {
	                    value.once('update', this._onTextureUpdate, this);
	                }
	            }
	        }
	    }
	});
	
	/**
	 * When the texture is updated, this event will fire to update the scale and frame
	 *
	 * @private
	 */
	Sprite.prototype._onTextureUpdate = function ()
	{
	    // so if _width is 0 then width was not set..
	    if (this._width)
	    {
	        this.scale.x = utils.sign(this.scale.x) * this._width / this.texture.frame.width;
	    }
	
	    if (this._height)
	    {
	        this.scale.y = utils.sign(this.scale.y) * this._height / this.texture.frame.height;
	    }
	};
	
	/**
	*
	* Renders the object using the WebGL renderer
	*
	* @param renderer {PIXI.WebGLRenderer}
	* @private
	*/
	Sprite.prototype._renderWebGL = function (renderer)
	{
	    renderer.setObjectRenderer(renderer.plugins.sprite);
	    renderer.plugins.sprite.render(this);
	};
	
	/**
	 * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.
	 *
	 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
	 * @return {PIXI.Rectangle} the framing rectangle
	 */
	Sprite.prototype.getBounds = function (matrix)
	{
	    if(!this._currentBounds)
	    {
	
	        var width = this._texture._frame.width;
	        var height = this._texture._frame.height;
	
	        var w0 = width * (1-this.anchor.x);
	        var w1 = width * -this.anchor.x;
	
	        var h0 = height * (1-this.anchor.y);
	        var h1 = height * -this.anchor.y;
	
	        var worldTransform = matrix || this.worldTransform ;
	
	        var a = worldTransform.a;
	        var b = worldTransform.b;
	        var c = worldTransform.c;
	        var d = worldTransform.d;
	        var tx = worldTransform.tx;
	        var ty = worldTransform.ty;
	
	        var minX,
	            maxX,
	            minY,
	            maxY;
	
	        //TODO - I am SURE this can be optimised, but the below is not accurate enough..
	        /*
	        if (b === 0 && c === 0)
	        {
	            // scale may be negative!
	            if (a < 0)
	            {
	                a *= -1;
	            }
	
	            if (d < 0)
	            {
	                d *= -1;
	            }
	
	            // this means there is no rotation going on right? RIGHT?
	            // if thats the case then we can avoid checking the bound values! yay
	            minX = a * w1 + tx;
	            maxX = a * w0 + tx;
	            minY = d * h1 + ty;
	            maxY = d * h0 + ty;
	        }
	        else
	        {
	        */
	
	        var x1 = a * w1 + c * h1 + tx;
	        var y1 = d * h1 + b * w1 + ty;
	
	        var x2 = a * w0 + c * h1 + tx;
	        var y2 = d * h1 + b * w0 + ty;
	
	        var x3 = a * w0 + c * h0 + tx;
	        var y3 = d * h0 + b * w0 + ty;
	
	        var x4 =  a * w1 + c * h0 + tx;
	        var y4 =  d * h0 + b * w1 + ty;
	
	        minX = x1;
	        minX = x2 < minX ? x2 : minX;
	        minX = x3 < minX ? x3 : minX;
	        minX = x4 < minX ? x4 : minX;
	
	        minY = y1;
	        minY = y2 < minY ? y2 : minY;
	        minY = y3 < minY ? y3 : minY;
	        minY = y4 < minY ? y4 : minY;
	
	        maxX = x1;
	        maxX = x2 > maxX ? x2 : maxX;
	        maxX = x3 > maxX ? x3 : maxX;
	        maxX = x4 > maxX ? x4 : maxX;
	
	        maxY = y1;
	        maxY = y2 > maxY ? y2 : maxY;
	        maxY = y3 > maxY ? y3 : maxY;
	        maxY = y4 > maxY ? y4 : maxY;
	
	        //}
	
	        // check for children
	        if(this.children.length)
	        {
	            var childBounds = this.containerGetBounds();
	
	            w0 = childBounds.x;
	            w1 = childBounds.x + childBounds.width;
	            h0 = childBounds.y;
	            h1 = childBounds.y + childBounds.height;
	
	            minX = (minX < w0) ? minX : w0;
	            minY = (minY < h0) ? minY : h0;
	
	            maxX = (maxX > w1) ? maxX : w1;
	            maxY = (maxY > h1) ? maxY : h1;
	        }
	
	        var bounds = this._bounds;
	
	        bounds.x = minX;
	        bounds.width = maxX - minX;
	
	        bounds.y = minY;
	        bounds.height = maxY - minY;
	
	        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
	        this._currentBounds = bounds;
	    }
	
	    return this._currentBounds;
	};
	
	/**
	 * Gets the local bounds of the sprite object.
	 *
	 */
	Sprite.prototype.getLocalBounds = function ()
	{
	    this._bounds.x = -this._texture._frame.width * this.anchor.x;
	    this._bounds.y = -this._texture._frame.height * this.anchor.y;
	    this._bounds.width = this._texture._frame.width;
	    this._bounds.height = this._texture._frame.height;
	    return this._bounds;
	};
	
	/**
	* Tests if a point is inside this sprite
	*
	* @param point {PIXI.Point} the point to test
	* @return {boolean} the result of the test
	*/
	Sprite.prototype.containsPoint = function( point )
	{
	    this.worldTransform.applyInverse(point,  tempPoint);
	
	    var width = this._texture._frame.width;
	    var height = this._texture._frame.height;
	    var x1 = -width * this.anchor.x;
	    var y1;
	
	    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
	    {
	        y1 = -height * this.anchor.y;
	
	        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
	        {
	            return true;
	        }
	    }
	
	    return false;
	};
	
	/**
	* Renders the object using the Canvas renderer
	*
	* @param renderer {PIXI.CanvasRenderer} The renderer
	* @private
	*/
	Sprite.prototype._renderCanvas = function (renderer)
	{
	    if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0)
	    {
	        return;
	    }
	
	    var compositeOperation = renderer.blendModes[this.blendMode];
	    if (compositeOperation !== renderer.context.globalCompositeOperation)
	    {
	        renderer.context.globalCompositeOperation = compositeOperation;
	    }
	
	    //  Ignore null sources
	    if (this.texture.valid)
	    {
	        var texture = this._texture,
	            wt = this.worldTransform,
	            dx,
	            dy,
	            width = texture.crop.width,
	            height = texture.crop.height;
	
	        renderer.context.globalAlpha = this.worldAlpha;
	
	        // If smoothingEnabled is supported and we need to change the smoothing property for this texture
	        var smoothingEnabled = texture.baseTexture.scaleMode === CONST.SCALE_MODES.LINEAR;
	        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)
	        {
	            renderer.context[renderer.smoothProperty] = smoothingEnabled;
	        }
	
	        //inline GroupD8.isSwapWidthHeight
	        if ((texture.rotate & 3) === 2) {
	            width = texture.crop.height;
	            height = texture.crop.width;
	        }
	        if (texture.trim) {
	            dx = texture.crop.width/2 + texture.trim.x - this.anchor.x * texture.trim.width;
	            dy = texture.crop.height/2 + texture.trim.y - this.anchor.y * texture.trim.height;
	        } else {
	            dx = (0.5 - this.anchor.x) * texture._frame.width;
	            dy = (0.5 - this.anchor.y) * texture._frame.height;
	        }
	        if(texture.rotate) {
	            wt.copy(canvasRenderWorldTransform);
	            wt = canvasRenderWorldTransform;
	            GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
	            // the anchor has already been applied above, so lets set it to zero
	            dx = 0;
	            dy = 0;
	        }
	        dx -= width/2;
	        dy -= height/2;
	        // Allow for pixel rounding
	        if (renderer.roundPixels)
	        {
	            renderer.context.setTransform(
	                wt.a,
	                wt.b,
	                wt.c,
	                wt.d,
	                (wt.tx * renderer.resolution) | 0,
	                (wt.ty * renderer.resolution) | 0
	            );
	
	            dx = dx | 0;
	            dy = dy | 0;
	        }
	        else
	        {
	
	            renderer.context.setTransform(
	                wt.a,
	                wt.b,
	                wt.c,
	                wt.d,
	                wt.tx * renderer.resolution,
	                wt.ty * renderer.resolution
	            );
	
	
	        }
	
	        var resolution = texture.baseTexture.resolution;
	
	        if (this.tint !== 0xFFFFFF)
	        {
	            if (this.cachedTint !== this.tint)
	            {
	                this.cachedTint = this.tint;
	
	                // TODO clean up caching - how to clean up the caches?
	                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
	            }
	
	            renderer.context.drawImage(
	                this.tintedTexture,
	                0,
	                0,
	                width * resolution,
	                height * resolution,
	                dx * renderer.resolution,
	                dy * renderer.resolution,
	                width * renderer.resolution,
	                height * renderer.resolution
	            );
	        }
	        else
	        {
	            renderer.context.drawImage(
	                texture.baseTexture.source,
	                texture.crop.x * resolution,
	                texture.crop.y * resolution,
	                width * resolution,
	                height * resolution,
	                dx  * renderer.resolution,
	                dy  * renderer.resolution,
	                width * renderer.resolution,
	                height * renderer.resolution
	            );
	        }
	    }
	};
	
	/**
	 * Destroys this sprite and optionally its texture
	 *
	 * @param [destroyTexture=false] {boolean} Should it destroy the current texture of the sprite as well
	 * @param [destroyBaseTexture=false] {boolean} Should it destroy the base texture of the sprite as well
	 */
	Sprite.prototype.destroy = function (destroyTexture, destroyBaseTexture)
	{
	    Container.prototype.destroy.call(this);
	
	    this.anchor = null;
	
	    if (destroyTexture)
	    {
	        this._texture.destroy(destroyBaseTexture);
	    }
	
	    this._texture = null;
	    this.shader = null;
	};
	
	// some helper functions..
	
	/**
	 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	 * The frame ids are created when a Texture packer file has been loaded
	 *
	 * @static
	 * @param frameId {string} The frame Id of the texture in the cache
	 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
	 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
	 */
	Sprite.fromFrame = function (frameId)
	{
	    var texture = utils.TextureCache[frameId];
	
	    if (!texture)
	    {
	        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
	    }
	
	    return new Sprite(texture);
	};
	
	/**
	 * Helper function that creates a sprite that will contain a texture based on an image url
	 * If the image is not in the texture cache it will be loaded
	 *
	 * @static
	 * @param imageId {string} The image url of the texture
	 * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
	 */
	Sprite.fromImage = function (imageId, crossorigin, scaleMode)
	{
	    return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(24);
	
	/**
	 * Utility methods for Sprite/Texture tinting.
	 * @static
	 * @class
	 * @memberof PIXI
	 */
	var CanvasTinter = {};
	module.exports = CanvasTinter;
	
	/**
	 * Basically this method just needs a sprite and a color and tints the sprite with the given color.
	 *
	 * @param sprite {PIXI.Sprite} the sprite to tint
	 * @param color {number} the color to use to tint the sprite with
	 * @return {HTMLCanvasElement} The tinted canvas
	 */
	CanvasTinter.getTintedTexture = function (sprite, color)
	{
	    var texture = sprite.texture;
	
	    color = CanvasTinter.roundColor(color);
	
	    var stringColor = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);
	
	    texture.tintCache = texture.tintCache || {};
	
	    if (texture.tintCache[stringColor])
	    {
	        return texture.tintCache[stringColor];
	    }
	
	     // clone texture..
	    var canvas = CanvasTinter.canvas || document.createElement('canvas');
	
	    //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
	    CanvasTinter.tintMethod(texture, color, canvas);
	
	    if (CanvasTinter.convertTintToImage)
	    {
	        // is this better?
	        var tintImage = new Image();
	        tintImage.src = canvas.toDataURL();
	
	        texture.tintCache[stringColor] = tintImage;
	    }
	    else
	    {
	        texture.tintCache[stringColor] = canvas;
	        // if we are not converting the texture to an image then we need to lose the reference to the canvas
	        CanvasTinter.canvas = null;
	    }
	
	    return canvas;
	};
	
	/**
	 * Tint a texture using the 'multiply' operation.
	 *
	 * @param texture {PIXI.Texture} the texture to tint
	 * @param color {number} the color to use to tint the sprite with
	 * @param canvas {HTMLCanvasElement} the current canvas
	 */
	CanvasTinter.tintWithMultiply = function (texture, color, canvas)
	{
	    var context = canvas.getContext( '2d' );
	
	    var resolution = texture.baseTexture.resolution;
	
	    var crop = texture.crop.clone();
	    crop.x *= resolution;
	    crop.y *= resolution;
	    crop.width *= resolution;
	    crop.height *= resolution;
	
	    canvas.width = crop.width;
	    canvas.height = crop.height;
	
	    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);
	
	    context.fillRect(0, 0, crop.width, crop.height);
	
	    context.globalCompositeOperation = 'multiply';
	
	    context.drawImage(
	        texture.baseTexture.source,
	        crop.x,
	        crop.y,
	        crop.width,
	        crop.height,
	        0,
	        0,
	        crop.width,
	        crop.height
	    );
	
	    context.globalCompositeOperation = 'destination-atop';
	
	    context.drawImage(
	        texture.baseTexture.source,
	        crop.x,
	        crop.y,
	        crop.width,
	        crop.height,
	        0,
	        0,
	        crop.width,
	        crop.height
	    );
	};
	
	/**
	 * Tint a texture using the 'overlay' operation.
	 *
	 * @param texture {PIXI.Texture} the texture to tint
	 * @param color {number} the color to use to tint the sprite with
	 * @param canvas {HTMLCanvasElement} the current canvas
	 */
	CanvasTinter.tintWithOverlay = function (texture, color, canvas)
	{
	    var context = canvas.getContext( '2d' );
	
	    var resolution = texture.baseTexture.resolution;
	
	    var crop = texture.crop.clone();
	    crop.x *= resolution;
	    crop.y *= resolution;
	    crop.width *= resolution;
	    crop.height *= resolution;
	
	    canvas.width = crop.width;
	    canvas.height = crop.height;
	
	    context.globalCompositeOperation = 'copy';
	    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);
	    context.fillRect(0, 0, crop.width, crop.height);
	
	    context.globalCompositeOperation = 'destination-atop';
	    context.drawImage(
	        texture.baseTexture.source,
	        crop.x,
	        crop.y,
	        crop.width,
	        crop.height,
	        0,
	        0,
	        crop.width,
	        crop.height
	    );
	
	    // context.globalCompositeOperation = 'copy';
	};
	
	/**
	 * Tint a texture pixel per pixel.
	 *
	 * @param texture {PIXI.Texture} the texture to tint
	 * @param color {number} the color to use to tint the sprite with
	 * @param canvas {HTMLCanvasElement} the current canvas
	 */
	CanvasTinter.tintWithPerPixel = function (texture, color, canvas)
	{
	    var context = canvas.getContext( '2d' );
	
	    var resolution = texture.baseTexture.resolution;
	
	    var crop = texture.crop.clone();
	    crop.x *= resolution;
	    crop.y *= resolution;
	    crop.width *= resolution;
	    crop.height *= resolution;
	
	    canvas.width = crop.width;
	    canvas.height = crop.height;
	
	    context.globalCompositeOperation = 'copy';
	    context.drawImage(
	        texture.baseTexture.source,
	        crop.x,
	        crop.y,
	        crop.width,
	        crop.height,
	        0,
	        0,
	        crop.width,
	        crop.height
	    );
	
	    var rgbValues = utils.hex2rgb(color);
	    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];
	
	    var pixelData = context.getImageData(0, 0, crop.width, crop.height);
	
	    var pixels = pixelData.data;
	
	    for (var i = 0; i < pixels.length; i += 4)
	    {
	        pixels[i+0] *= r;
	        pixels[i+1] *= g;
	        pixels[i+2] *= b;
	    }
	
	    context.putImageData(pixelData, 0, 0);
	};
	
	/**
	 * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
	 *
	 * @param color {number} the color to round, should be a hex color
	 */
	CanvasTinter.roundColor = function (color)
	{
	    var step = CanvasTinter.cacheStepsPerColorChannel;
	
	    var rgbValues = utils.hex2rgb(color);
	
	    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
	    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
	    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);
	
	    return utils.rgb2hex(rgbValues);
	};
	
	/**
	 * Number of steps which will be used as a cap when rounding colors.
	 *
	 * @member
	 */
	CanvasTinter.cacheStepsPerColorChannel = 8;
	
	/**
	 * Tint cache boolean flag.
	 *
	 * @member
	 */
	CanvasTinter.convertTintToImage = false;
	
	/**
	 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
	 *
	 * @member
	 */
	CanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();
	
	/**
	 * The tinting method that will be used.
	 *
	 */
	CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply :  CanvasTinter.tintWithPerPixel;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var Container = __webpack_require__(45),
	    CONST = __webpack_require__(14);
	
	/**
	 * The ParticleContainer class is a really fast version of the Container built solely for speed,
	 * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced
	 * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).
	 * Any other functionality like tinting, masking, etc will not work on sprites in this batch.
	 *
	 * It's extremely easy to use :
	 *
	 * ```js
	 * var container = new ParticleContainer();
	 *
	 * for (var i = 0; i < 100; ++i)
	 * {
	 *     var sprite = new PIXI.Sprite.fromImage("myImage.png");
	 *     container.addChild(sprite);
	 * }
	 * ```
	 *
	 * And here you have a hundred sprites that will be renderer at the speed of light.
	 *
	 * @class
	 * @extends PIXI.Container
	 * @memberof PIXI
	 * @param [maxSize=15000] {number} The maximum number of particles that can be renderer by the container.
	 * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.
	 * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.
	 * @param [properties.position=true] {boolean} When true, position be uploaded and applied.
	 * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.
	 * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.
	 * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.
	 * @param [batchSize=15000] {number} Number of particles per batch.
	 */
	function ParticleContainer(maxSize, properties, batchSize)
	{
	    Container.call(this);
	
	    batchSize = batchSize || 15000; //CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
	    maxSize = maxSize || 15000;
	
	    // Making sure the batch size is valid
	    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
	    // so max number of particles is 65536 / 4 = 16384
	    var maxBatchSize = 16384;
	    if (batchSize > maxBatchSize) {
	        batchSize = maxBatchSize;
	    }
	
	    if (batchSize > maxSize) {
	        batchSize = maxSize;
	    }
	
	    /**
	     * Set properties to be dynamic (true) / static (false)
	     *
	     * @member {boolean[]}
	     * @private
	     */
	    this._properties = [false, true, false, false, false];
	
	    /**
	     * @member {number}
	     * @private
	     */
	    this._maxSize = maxSize;
	
	    /**
	     * @member {number}
	     * @private
	     */
	    this._batchSize = batchSize;
	
	    /**
	     * @member {WebGLBuffer}
	     * @private
	     */
	    this._buffers = null;
	
	    /**
	     * @member {number}
	     * @private
	     */
	    this._bufferToUpdate = 0;
	
	    /**
	     * @member {boolean}
	     *
	     */
	    this.interactiveChildren = false;
	
	    /**
	     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
	     *
	     * @member {number}
	     * @default PIXI.BLEND_MODES.NORMAL
	     * @see PIXI.BLEND_MODES
	     */
	    this.blendMode = CONST.BLEND_MODES.NORMAL;
	
	    /**
	     * Used for canvas renderering. If true then the elements will be positioned at the nearest pixel. This provides a nice speed boost.
	     *
	     * @member {boolean}
	     * @default true;
	     */
	    this.roundPixels = true;
	
	    this.setProperties(properties);
	}
	
	ParticleContainer.prototype = Object.create(Container.prototype);
	ParticleContainer.prototype.constructor = ParticleContainer;
	module.exports = ParticleContainer;
	
	/**
	 * Sets the private properties array to dynamic / static based on the passed properties object
	 *
	 * @param properties {object} The properties to be uploaded
	 */
	ParticleContainer.prototype.setProperties = function(properties)
	{
	    if ( properties ) {
	        this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];
	        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
	        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
	        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
	        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];
	    }
	};
	
	/**
	 * Updates the object transform for rendering
	 *
	 * @private
	 */
	ParticleContainer.prototype.updateTransform = function ()
	{
	
	    // TODO don't need to!
	    this.displayObjectUpdateTransform();
	    //  PIXI.Container.prototype.updateTransform.call( this );
	};
	
	/**
	 * Renders the container using the WebGL renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer} The webgl renderer
	 * @private
	 */
	ParticleContainer.prototype.renderWebGL = function (renderer)
	{
	    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
	    {
	        return;
	    }
	
	    renderer.setObjectRenderer( renderer.plugins.particle );
	    renderer.plugins.particle.render( this );
	};
	
	/**
	 * Set the flag that static data should be updated to true
	 *
	 * @private
	 */
	ParticleContainer.prototype.onChildrenChange = function (smallestChildIndex)
	{
	    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
	    if (bufferIndex < this._bufferToUpdate) {
	        this._bufferToUpdate = bufferIndex;
	    }
	};
	
	/**
	 * Renders the object using the Canvas renderer
	 *
	 * @param renderer {PIXI.CanvasRenderer} The canvas renderer
	 * @private
	 */
	ParticleContainer.prototype.renderCanvas = function (renderer)
	{
	    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
	    {
	        return;
	    }
	
	    var context = renderer.context;
	    var transform = this.worldTransform;
	    var isRotated = true;
	
	    var positionX = 0;
	    var positionY = 0;
	
	    var finalWidth = 0;
	    var finalHeight = 0;
	
	    var compositeOperation = renderer.blendModes[this.blendMode];
	    if (compositeOperation !== context.globalCompositeOperation)
	    {
	        context.globalCompositeOperation = compositeOperation;
	    }
	
	    context.globalAlpha = this.worldAlpha;
	
	    this.displayObjectUpdateTransform();
	
	    for (var i = 0; i < this.children.length; ++i)
	    {
	        var child = this.children[i];
	
	        if (!child.visible)
	        {
	            continue;
	        }
	
	        var frame = child.texture.frame;
	
	        context.globalAlpha = this.worldAlpha * child.alpha;
	
	        if (child.rotation % (Math.PI * 2) === 0)
	        {
	            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
	            if (isRotated)
	            {
	                context.setTransform(
	                    transform.a,
	                    transform.b,
	                    transform.c,
	                    transform.d,
	                    transform.tx,
	                    transform.ty
	                );
	
	                isRotated = false;
	            }
	
	            positionX = ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5);
	            positionY = ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5);
	
	            finalWidth = frame.width * child.scale.x;
	            finalHeight = frame.height * child.scale.y;
	
	        }
	        else
	        {
	            if (!isRotated)
	            {
	                isRotated = true;
	            }
	
	            child.displayObjectUpdateTransform();
	
	            var childTransform = child.worldTransform;
	
	            if (renderer.roundPixels)
	            {
	                context.setTransform(
	                    childTransform.a,
	                    childTransform.b,
	                    childTransform.c,
	                    childTransform.d,
	                    childTransform.tx | 0,
	                    childTransform.ty | 0
	                );
	            }
	            else
	            {
	                context.setTransform(
	                    childTransform.a,
	                    childTransform.b,
	                    childTransform.c,
	                    childTransform.d,
	                    childTransform.tx,
	                    childTransform.ty
	                );
	            }
	
	            positionX = ((child.anchor.x) * (-frame.width) + 0.5);
	            positionY = ((child.anchor.y) * (-frame.height) + 0.5);
	
	            finalWidth = frame.width;
	            finalHeight = frame.height;
	        }
	
	        context.drawImage(
	            child.texture.baseTexture.source,
	            frame.x,
	            frame.y,
	            frame.width,
	            frame.height,
	            positionX,
	            positionY,
	            finalWidth,
	            finalHeight
	        );
	    }
	};
	
	/**
	 * Destroys the container
	 *
	 * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well
	 */
	ParticleContainer.prototype.destroy = function () {
	    Container.prototype.destroy.apply(this, arguments);
	
	    if (this._buffers) {
	        for (var i = 0; i < this._buffers.length; ++i) {
	            this._buffers[i].destroy();
	        }
	    }
	
	    this._properties = null;
	    this._buffers = null;
	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectRenderer = __webpack_require__(50),
	    WebGLRenderer = __webpack_require__(51),
	    CONST = __webpack_require__(14);
	
	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's SpriteRenderer:
	 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteRenderer.java
	 */
	
	/**
	 * Renderer dedicated to drawing and batching sprites.
	 *
	 * @class
	 * @private
	 * @memberof PIXI
	 * @extends PIXI.ObjectRenderer
	 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
	 */
	function SpriteRenderer(renderer)
	{
	    ObjectRenderer.call(this, renderer);
	
	    /**
	     * Number of values sent in the vertex buffer.
	     * positionX, positionY, colorR, colorG, colorB = 5
	     *
	     * @member {number}
	     */
	    this.vertSize = 5;
	
	    /**
	     * The size of the vertex information in bytes.
	     *
	     * @member {number}
	     */
	    this.vertByteSize = this.vertSize * 4;
	
	    /**
	     * The number of images in the SpriteBatch before it flushes.
	     *
	     * @member {number}
	     */
	    this.size = CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
	
	    // the total number of bytes in our batch
	    var numVerts = (this.size * 4) * this.vertByteSize;
	
	    // the total number of indices in our batch, there are 6 points per quad.
	    var numIndices = this.size * 6;
	
	    /**
	     * Holds the vertex data that will be sent to the vertex shader.
	     *
	     * @member {ArrayBuffer}
	     */
	    this.vertices = new ArrayBuffer(numVerts);
	
	    /**
	     * View on the vertices as a Float32Array for positions
	     *
	     * @member {Float32Array}
	     */
	    this.positions = new Float32Array(this.vertices);
	
	    /**
	     * View on the vertices as a Uint32Array for colors
	     *
	     * @member {Uint32Array}
	     */
	    this.colors = new Uint32Array(this.vertices);
	
	    /**
	     * Holds the indices of the geometry (quads) to draw
	     *
	     * @member {Uint16Array}
	     */
	    this.indices = new Uint16Array(numIndices);
	
	    // fill the indices with the quads to draw
	    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
	    {
	        this.indices[i + 0] = j + 0;
	        this.indices[i + 1] = j + 1;
	        this.indices[i + 2] = j + 2;
	        this.indices[i + 3] = j + 0;
	        this.indices[i + 4] = j + 2;
	        this.indices[i + 5] = j + 3;
	    }
	
	    /**
	     * The current size of the batch, each render() call adds to this number.
	     *
	     * @member {number}
	     */
	    this.currentBatchSize = 0;
	
	    /**
	     * The current sprites in the batch.
	     *
	     * @member {PIXI.Sprite[]}
	     */
	    this.sprites = [];
	
	    /**
	     * The default shader that is used if a sprite doesn't have a more specific one.
	     *
	     * @member {PIXI.Shader}
	     */
	    this.shader = null;
	}
	
	SpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);
	SpriteRenderer.prototype.constructor = SpriteRenderer;
	module.exports = SpriteRenderer;
	
	WebGLRenderer.registerPlugin('sprite', SpriteRenderer);
	
	/**
	 * Sets up the renderer context and necessary buffers.
	 *
	 * @private
	 * @param gl {WebGLRenderingContext} the current WebGL drawing context
	 */
	SpriteRenderer.prototype.onContextChange = function ()
	{
	    var gl = this.renderer.gl;
	
	    // setup default shader
	    this.shader = this.renderer.shaderManager.defaultShader;
	
	    // create a couple of buffers
	    this.vertexBuffer = gl.createBuffer();
	    this.indexBuffer = gl.createBuffer();
	
	    //upload the index data
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
	
	    this.currentBlendMode = 99999;
	};
	
	/**
	 * Renders the sprite object.
	 *
	 * @param sprite {PIXI.Sprite} the sprite to render when using this spritebatch
	 */
	SpriteRenderer.prototype.render = function (sprite)
	{
	    var texture = sprite._texture;
	
	    //TODO set blend modes..
	    // check texture..
	    if (this.currentBatchSize >= this.size)
	    {
	        this.flush();
	    }
	
	    // get the uvs for the texture
	    var uvs = texture._uvs;
	
	    // if the uvs have not updated then no point rendering just yet!
	    if (!uvs)
	    {
	        return;
	    }
	
	    // TODO trim??
	    var aX = sprite.anchor.x;
	    var aY = sprite.anchor.y;
	
	    var w0, w1, h0, h1;
	
	    if (texture.trim && sprite.tileScale === undefined)
	    {
	        // if the sprite is trimmed and is not a tilingsprite then we need to add the extra space before transforming the sprite coords..
	        var trim = texture.trim;
	
	        w1 = trim.x - aX * trim.width;
	        w0 = w1 + texture.crop.width;
	
	        h1 = trim.y - aY * trim.height;
	        h0 = h1 + texture.crop.height;
	
	    }
	    else
	    {
	        w0 = (texture._frame.width ) * (1-aX);
	        w1 = (texture._frame.width ) * -aX;
	
	        h0 = texture._frame.height * (1-aY);
	        h1 = texture._frame.height * -aY;
	    }
	
	    var index = this.currentBatchSize * this.vertByteSize;
	
	    var worldTransform = sprite.worldTransform;
	
	    var a = worldTransform.a;
	    var b = worldTransform.b;
	    var c = worldTransform.c;
	    var d = worldTransform.d;
	    var tx = worldTransform.tx;
	    var ty = worldTransform.ty;
	
	    var colors = this.colors;
	    var positions = this.positions;
	
	    if (this.renderer.roundPixels)
	    {
	        var resolution = this.renderer.resolution;
	
	        // xy
	        positions[index] = (((a * w1 + c * h1 + tx) * resolution) | 0) / resolution;
	        positions[index+1] = (((d * h1 + b * w1 + ty) * resolution) | 0) / resolution;
	
	        // xy
	        positions[index+5] = (((a * w0 + c * h1 + tx) * resolution) | 0) / resolution;
	        positions[index+6] = (((d * h1 + b * w0 + ty) * resolution) | 0) / resolution;
	
	         // xy
	        positions[index+10] = (((a * w0 + c * h0 + tx) * resolution) | 0) / resolution;
	        positions[index+11] = (((d * h0 + b * w0 + ty) * resolution) | 0) / resolution;
	
	        // xy
	        positions[index+15] = (((a * w1 + c * h0 + tx) * resolution) | 0) / resolution;
	        positions[index+16] = (((d * h0 + b * w1 + ty) * resolution) | 0) / resolution;
	    }
	    else
	    {
	
	        // xy
	        positions[index] = a * w1 + c * h1 + tx;
	        positions[index+1] = d * h1 + b * w1 + ty;
	
	        // xy
	        positions[index+5] = a * w0 + c * h1 + tx;
	        positions[index+6] = d * h1 + b * w0 + ty;
	
	         // xy
	        positions[index+10] = a * w0 + c * h0 + tx;
	        positions[index+11] = d * h0 + b * w0 + ty;
	
	        // xy
	        positions[index+15] = a * w1 + c * h0 + tx;
	        positions[index+16] = d * h0 + b * w1 + ty;
	    }
	
	    // uv
	    positions[index+2] = uvs.x0;
	    positions[index+3] = uvs.y0;
	
	    // uv
	    positions[index+7] = uvs.x1;
	    positions[index+8] = uvs.y1;
	
	     // uv
	    positions[index+12] = uvs.x2;
	    positions[index+13] = uvs.y2;
	
	    // uv
	    positions[index+17] = uvs.x3;
	    positions[index+18] = uvs.y3;
	
	    // color and alpha
	    var tint = sprite.tint;
	    colors[index+4] = colors[index+9] = colors[index+14] = colors[index+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);
	
	    // increment the batchsize
	    this.sprites[this.currentBatchSize++] = sprite;
	};
	
	/**
	 * Renders the content and empties the current batch.
	 *
	 */
	SpriteRenderer.prototype.flush = function ()
	{
	    // If the batch is length 0 then return as there is nothing to draw
	    if (this.currentBatchSize === 0)
	    {
	        return;
	    }
	
	    var gl = this.renderer.gl;
	    var shader;
	
	    // upload the verts to the buffer
	    if (this.currentBatchSize > ( this.size * 0.5 ) )
	    {
	        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
	    }
	    else
	    {
	        var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
	        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
	    }
	
	    var nextTexture, nextBlendMode, nextShader;
	    var batchSize = 0;
	    var start = 0;
	
	    var currentBaseTexture = null;
	    var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;
	    var currentShader = null;
	
	    var blendSwap = false;
	    var shaderSwap = false;
	    var sprite;
	
	    for (var i = 0, j = this.currentBatchSize; i < j; i++)
	    {
	
	        sprite = this.sprites[i];
	
	        nextTexture = sprite._texture.baseTexture;
	        nextBlendMode = sprite.blendMode;
	        nextShader = sprite.shader || this.shader;
	
	        blendSwap = currentBlendMode !== nextBlendMode;
	        shaderSwap = currentShader !== nextShader; // should I use uidS???
	
	        if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap)
	        {
	            this.renderBatch(currentBaseTexture, batchSize, start);
	
	            start = i;
	            batchSize = 0;
	            currentBaseTexture = nextTexture;
	
	            if (blendSwap)
	            {
	                currentBlendMode = nextBlendMode;
	                this.renderer.blendModeManager.setBlendMode( currentBlendMode );
	            }
	
	            if (shaderSwap)
	            {
	                currentShader = nextShader;
	
	
	
	                shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;
	
	                if (!shader)
	                {
	                    shader = currentShader.getShader(this.renderer);
	
	                }
	
	                // set shader function???
	                this.renderer.shaderManager.setShader(shader);
	
	                //TODO - i KNOW this can be optimised! Once v3 is stable il look at this next...
	                shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);
	                //Make this a little more dynamic / intelligent!
	                shader.syncUniforms();
	
	                //TODO investigate some kind of texture state managment??
	                // need to make sure this texture is the active one for all the batch swaps..
	                gl.activeTexture(gl.TEXTURE0);
	
	                // both thease only need to be set if they are changing..
	                // set the projection
	                //gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));
	
	
	            }
	        }
	
	        batchSize++;
	    }
	
	    this.renderBatch(currentBaseTexture, batchSize, start);
	
	    // then reset the batch!
	    this.currentBatchSize = 0;
	};
	
	/**
	 * Draws the currently batches sprites.
	 *
	 * @private
	 * @param texture {PIXI.Texture}
	 * @param size {number}
	 * @param startIndex {number}
	 */
	SpriteRenderer.prototype.renderBatch = function (texture, size, startIndex)
	{
	    if (size === 0)
	    {
	        return;
	    }
	
	    var gl = this.renderer.gl;
	
	    if (!texture._glTextures[gl.id])
	    {
	        this.renderer.updateTexture(texture);
	    }
	    else
	    {
	        // bind the current texture
	        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
	    }
	
	    // now draw those suckas!
	    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
	
	    // increment the draw count
	    this.renderer.drawCount++;
	};
	
	/**
	 * Starts a new sprite batch.
	 *
	 */
	SpriteRenderer.prototype.start = function ()
	{
	    var gl = this.renderer.gl;
	
	    // bind the main texture
	
	
	    // bind the buffers
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	
	    // this is the same for each shader?
	    var stride =  this.vertByteSize;
	    gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
	    gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
	
	    // color attributes will be interpreted as unsigned bytes and normalized
	    gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);
	};
	
	/**
	 * Destroys the SpriteBatch.
	 *
	 */
	SpriteRenderer.prototype.destroy = function ()
	{
	    this.renderer.gl.deleteBuffer(this.vertexBuffer);
	    this.renderer.gl.deleteBuffer(this.indexBuffer);
	
	    ObjectRenderer.prototype.destroy.call(this);
	
	    this.shader.destroy();
	
	    this.renderer = null;
	
	    this.vertices = null;
	    this.positions = null;
	    this.colors = null;
	    this.indices = null;
	
	    this.vertexBuffer = null;
	    this.indexBuffer = null;
	
	    this.sprites = null;
	    this.shader = null;
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var WebGLManager = __webpack_require__(42);
	
	/**
	 * Base for a common object renderer that can be used as a system renderer plugin.
	 *
	 * @class
	 * @extends PIXI.WebGLManager
	 * @memberof PIXI
	 * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.
	 */
	function ObjectRenderer(renderer)
	{
	    WebGLManager.call(this, renderer);
	}
	
	
	ObjectRenderer.prototype = Object.create(WebGLManager.prototype);
	ObjectRenderer.prototype.constructor = ObjectRenderer;
	module.exports = ObjectRenderer;
	
	/**
	 * Starts the renderer and sets the shader
	 *
	 */
	ObjectRenderer.prototype.start = function ()
	{
	    // set the shader..
	};
	
	/**
	 * Stops the renderer
	 *
	 */
	ObjectRenderer.prototype.stop = function ()
	{
	    this.flush();
	};
	
	/**
	 * flushes
	 *
	 */
	ObjectRenderer.prototype.flush = function ()
	{
	    // flush!
	};
	
	/**
	 * Renders an object
	 *
	 * @param object {PIXI.DisplayObject} The object to render.
	 */
	ObjectRenderer.prototype.render = function (object) // jshint unused:false
	{
	    // render the object
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var SystemRenderer = __webpack_require__(52),
	    ShaderManager = __webpack_require__(53),
	    MaskManager = __webpack_require__(58),
	    StencilManager = __webpack_require__(61),
	    FilterManager = __webpack_require__(41),
	    BlendModeManager = __webpack_require__(62),
	    RenderTarget = __webpack_require__(39),
	    ObjectRenderer = __webpack_require__(50),
	    FXAAFilter = __webpack_require__(63),
	    utils = __webpack_require__(24),
	    CONST = __webpack_require__(14);
	
	/**
	 * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
	 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
	 * So no need for Sprite Batches or Sprite Clouds.
	 * Don't forget to add the view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.SystemRenderer
	 * @param [width=0] {number} the width of the canvas view
	 * @param [height=0] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used
	 * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always look as great
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass. If you wish to set this to false, you *must* set preserveDrawingBuffer to `true`.
	 * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if
	 *      you need to call toDataUrl on the webgl context.
	 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
	 */
	function WebGLRenderer(width, height, options)
	{
	    options = options || {};
	
	    SystemRenderer.call(this, 'WebGL', width, height, options);
	
	    /**
	     * The type of this renderer as a standardised const
	     *
	     * @member {number}
	     *
	     */
	    this.type = CONST.RENDERER_TYPE.WEBGL;
	
	    this.handleContextLost = this.handleContextLost.bind(this);
	    this.handleContextRestored = this.handleContextRestored.bind(this);
	
	    this.view.addEventListener('webglcontextlost', this.handleContextLost, false);
	    this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);
	
	    //TODO possibility to force FXAA as it may offer better performance?
	    /**
	     * Does it use FXAA ?
	     *
	     * @member {boolean}
	     * @private
	     */
	    this._useFXAA = !!options.forceFXAA && options.antialias;
	
	    /**
	     * The fxaa filter
	     *
	     * @member {PIXI.FXAAFilter}
	     * @private
	     */
	    this._FXAAFilter = null;
	
	    /**
	     * The options passed in to create a new webgl context.
	     *
	     * @member {object}
	     * @private
	     */
	    this._contextOptions = {
	        alpha: this.transparent,
	        antialias: options.antialias,
	        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',
	        stencil: true,
	        preserveDrawingBuffer: options.preserveDrawingBuffer
	    };
	
	    /**
	     * Counter for the number of draws made each frame
	     *
	     * @member {number}
	     */
	    this.drawCount = 0;
	
	    /**
	     * Deals with managing the shader programs and their attribs.
	     *
	     * @member {PIXI.ShaderManager}
	     */
	    this.shaderManager = new ShaderManager(this);
	
	    /**
	     * Manages the masks using the stencil buffer.
	     *
	     * @member {PIXI.MaskManager}
	     */
	    this.maskManager = new MaskManager(this);
	
	    /**
	     * Manages the stencil buffer.
	     *
	     * @member {PIXI.StencilManager}
	     */
	    this.stencilManager = new StencilManager(this);
	
	    /**
	     * Manages the filters.
	     *
	     * @member {PIXI.FilterManager}
	     */
	    this.filterManager = new FilterManager(this);
	
	
	    /**
	     * Manages the blendModes
	     *
	     * @member {PIXI.BlendModeManager}
	     */
	    this.blendModeManager = new BlendModeManager(this);
	
	    /**
	     * Holds the current render target
	     *
	     * @member {PIXI.RenderTarget}
	     */
	    this.currentRenderTarget = null;
	
	    /**
	     * The currently active ObjectRenderer.
	     *
	     * @member {PIXI.ObjectRenderer}
	     */
	    this.currentRenderer = new ObjectRenderer(this);
	
	    this.initPlugins();
	
	    // initialize the context so it is ready for the managers.
	    this._createContext();
	    this._initContext();
	
	    // map some webGL blend modes..
	    this._mapGlModes();
	
	    // track textures in the renderer so we can no longer listen to them on destruction.
	    this._managedTextures = [];
	
	    /**
	     * An array of render targets
	     * @member {PIXI.RenderTarget[]}
	     * @private
	     */
	    this._renderTargetStack = [];
	}
	
	// constructor
	WebGLRenderer.prototype = Object.create(SystemRenderer.prototype);
	WebGLRenderer.prototype.constructor = WebGLRenderer;
	module.exports = WebGLRenderer;
	utils.pluginTarget.mixin(WebGLRenderer);
	
	WebGLRenderer.glContextId = 0;
	
	/**
	 * Creates the gl context.
	 *
	 * @private
	 */
	WebGLRenderer.prototype._createContext = function () {
	    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);
	    this.gl = gl;
	
	    if (!gl)
	    {
	        // fail, not able to get a context
	        throw new Error('This browser does not support webGL. Try using the canvas renderer');
	    }
	
	    this.glContextId = WebGLRenderer.glContextId++;
	    gl.id = this.glContextId;
	    gl.renderer = this;
	};
	
	/**
	 * Creates the WebGL context
	 *
	 * @private
	 */
	WebGLRenderer.prototype._initContext = function ()
	{
	    var gl = this.gl;
	
	    // set up the default pixi settings..
	    gl.disable(gl.DEPTH_TEST);
	    gl.disable(gl.CULL_FACE);
	    gl.enable(gl.BLEND);
	
	    this.renderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);
	
	    this.setRenderTarget(this.renderTarget);
	
	    this.emit('context', gl);
	
	    // setup the width/height properties and gl viewport
	    this.resize(this.width, this.height);
	
	    if(!this._useFXAA)
	    {
	        this._useFXAA = (this._contextOptions.antialias && ! gl.getContextAttributes().antialias);
	    }
	
	
	    if(this._useFXAA)
	    {
	        window.console.warn('FXAA antialiasing being used instead of native antialiasing');
	        this._FXAAFilter = [new FXAAFilter()];
	    }
	};
	
	/**
	 * Renders the object to its webGL view
	 *
	 * @param object {PIXI.DisplayObject} the object to be rendered
	 */
	WebGLRenderer.prototype.render = function (object)
	{
	
	    this.emit('prerender');
	
	    // no point rendering if our context has been blown up!
	    if (this.gl.isContextLost())
	    {
	        return;
	    }
	
	    this.drawCount = 0;
	
	    this._lastObjectRendered = object;
	
	    if(this._useFXAA)
	    {
	        this._FXAAFilter[0].uniforms.resolution.value.x = this.width;
	        this._FXAAFilter[0].uniforms.resolution.value.y = this.height;
	        object.filterArea = this.renderTarget.size;
	        object.filters = this._FXAAFilter;
	    }
	
	    var cacheParent = object.parent;
	    object.parent = this._tempDisplayObjectParent;
	
	    // update the scene graph
	    object.updateTransform();
	
	    object.parent = cacheParent;
	
	    var gl = this.gl;
	
	    // make sure we are bound to the main frame buffer
	    this.setRenderTarget(this.renderTarget);
	
	    if (this.clearBeforeRender)
	    {
	        if (this.transparent)
	        {
	            gl.clearColor(0, 0, 0, 0);
	        }
	        else
	        {
	            gl.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1);
	        }
	
	        gl.clear(gl.COLOR_BUFFER_BIT);
	    }
	
	    this.renderDisplayObject(object, this.renderTarget);//this.projection);
	
	    this.emit('postrender');
	};
	
	/**
	 * Renders a Display Object.
	 *
	 * @param displayObject {PIXI.DisplayObject} The DisplayObject to render
	 * @param renderTarget {PIXI.RenderTarget} The render target to use to render this display object
	 *
	 */
	WebGLRenderer.prototype.renderDisplayObject = function (displayObject, renderTarget, clear)//projection, buffer)
	{
	    // TODO is this needed...
	    //this.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);
	    this.setRenderTarget(renderTarget);
	
	    if(clear)
	    {
	        renderTarget.clear();
	    }
	
	    // start the filter manager
	    this.filterManager.setFilterStack( renderTarget.filterStack );
	
	    // render the scene!
	    displayObject.renderWebGL(this);
	
	    // finish the current renderer..
	    this.currentRenderer.flush();
	};
	
	/**
	 * Changes the current renderer to the one given in parameter
	 *
	 * @param objectRenderer {PIXI.ObjectRenderer} The object renderer to use.
	 */
	WebGLRenderer.prototype.setObjectRenderer = function (objectRenderer)
	{
	    if (this.currentRenderer === objectRenderer)
	    {
	        return;
	    }
	
	    this.currentRenderer.stop();
	    this.currentRenderer = objectRenderer;
	    this.currentRenderer.start();
	};
	
	/**
	 * Changes the current render target to the one given in parameter
	 *
	 * @param renderTarget {PIXI.RenderTarget} the new render target
	 */
	WebGLRenderer.prototype.setRenderTarget = function (renderTarget)
	{
	    if( this.currentRenderTarget === renderTarget)
	    {
	        return;
	    }
	    // TODO - maybe down the line this should be a push pos thing? Leaving for now though.
	    this.currentRenderTarget = renderTarget;
	    this.currentRenderTarget.activate();
	    this.stencilManager.setMaskStack( renderTarget.stencilMaskStack );
	};
	
	
	/**
	 * Resizes the webGL view to the specified width and height.
	 *
	 * @param width {number} the new width of the webGL view
	 * @param height {number} the new height of the webGL view
	 */
	WebGLRenderer.prototype.resize = function (width, height)
	{
	    SystemRenderer.prototype.resize.call(this, width, height);
	
	    this.filterManager.resize(width, height);
	    this.renderTarget.resize(width, height);
	
	    if(this.currentRenderTarget === this.renderTarget)
	    {
	        this.renderTarget.activate();
	        this.gl.viewport(0, 0, this.width, this.height);
	    }
	};
	
	/**
	 * Updates and/or Creates a WebGL texture for the renderer's context.
	 *
	 * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to update
	 */
	WebGLRenderer.prototype.updateTexture = function (texture)
	{
	    texture = texture.baseTexture || texture;
	
	    if (!texture.hasLoaded)
	    {
	        return;
	    }
	
	    var gl = this.gl;
	
	    if (!texture._glTextures[gl.id])
	    {
	        texture._glTextures[gl.id] = gl.createTexture();
	        texture.on('update', this.updateTexture, this);
	        texture.on('dispose', this.destroyTexture, this);
	        this._managedTextures.push(texture);
	    }
	
	
	    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
	
	    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
	    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
	
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
	
	
	    if (texture.mipmap && texture.isPowerOfTwo)
	    {
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
	        gl.generateMipmap(gl.TEXTURE_2D);
	    }
	    else
	    {
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
	    }
	
	    if (!texture.isPowerOfTwo)
	    {
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    }
	    else
	    {
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	    }
	
	    return  texture._glTextures[gl.id];
	};
	
	/**
	 * Deletes the texture from WebGL
	 *
	 * @param texture {PIXI.BaseTexture|PIXI.Texture} the texture to destroy
	 */
	WebGLRenderer.prototype.destroyTexture = function (texture, _skipRemove)
	{
	    texture = texture.baseTexture || texture;
	
	    if (!texture.hasLoaded)
	    {
	        return;
	    }
	
	    if (texture._glTextures[this.gl.id])
	    {
	        this.gl.deleteTexture(texture._glTextures[this.gl.id]);
	        delete texture._glTextures[this.gl.id];
	
	        if (!_skipRemove)
	        {
	            var i = this._managedTextures.indexOf(texture);
	            if (i !== -1) {
	                utils.removeItems(this._managedTextures, i, 1);
	            }
	        }
	    }
	};
	
	/**
	 * Handles a lost webgl context
	 *
	 * @private
	 */
	WebGLRenderer.prototype.handleContextLost = function (event)
	{
	    event.preventDefault();
	};
	
	/**
	 * Handles a restored webgl context
	 *
	 * @private
	 */
	WebGLRenderer.prototype.handleContextRestored = function ()
	{
	    this._initContext();
	
	    // empty all the old gl textures as they are useless now
	    for (var i = 0; i < this._managedTextures.length; ++i)
	    {
	        var texture = this._managedTextures[i];
	        if (texture._glTextures[this.gl.id])
	        {
	            delete texture._glTextures[this.gl.id];
	        }
	    }
	};
	
	/**
	 * Removes everything from the renderer (event listeners, spritebatch, etc...)
	 *
	 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
	 */
	WebGLRenderer.prototype.destroy = function (removeView)
	{
	    this.destroyPlugins();
	
	    // remove listeners
	    this.view.removeEventListener('webglcontextlost', this.handleContextLost);
	    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);
	
	    // destroy managed textures
	    for (var i = 0; i < this._managedTextures.length; ++i)
	    {
	        var texture = this._managedTextures[i];
	        this.destroyTexture(texture, true);
	        texture.off('update', this.updateTexture, this);
	        texture.off('dispose', this.destroyTexture, this);
	    }
	
	    // call base destroy
	    SystemRenderer.prototype.destroy.call(this, removeView);
	
	    this.uid = 0;
	
	    // destroy the managers
	    this.shaderManager.destroy();
	    this.maskManager.destroy();
	    this.stencilManager.destroy();
	    this.filterManager.destroy();
	    this.blendModeManager.destroy();
	
	    this.shaderManager = null;
	    this.maskManager = null;
	    this.filterManager = null;
	    this.blendModeManager = null;
	    this.currentRenderer = null;
	
	    this.handleContextLost = null;
	    this.handleContextRestored = null;
	
	    this._contextOptions = null;
	
	    this._managedTextures = null;
	
	    this.drawCount = 0;
	
	    this.gl.useProgram(null);
	
	    this.gl.flush();
	
	    this.gl = null;
	};
	
	/**
	 * Maps Pixi blend modes to WebGL blend modes. It works only for pre-multiplied textures.
	 *
	 * @private
	 */
	WebGLRenderer.prototype._mapGlModes = function ()
	{
	    var gl = this.gl;
	
	    if (!this.blendModes)
	    {
	        this.blendModes = {};
	
	        this.blendModes[CONST.BLEND_MODES.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.ADD]           = [gl.ONE,       gl.DST_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.SCREEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_COLOR];
	        this.blendModes[CONST.BLEND_MODES.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	        this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
	    }
	
	    if (!this.drawModes)
	    {
	        this.drawModes = {};
	
	        this.drawModes[CONST.DRAW_MODES.POINTS]         = gl.POINTS;
	        this.drawModes[CONST.DRAW_MODES.LINES]          = gl.LINES;
	        this.drawModes[CONST.DRAW_MODES.LINE_LOOP]      = gl.LINE_LOOP;
	        this.drawModes[CONST.DRAW_MODES.LINE_STRIP]     = gl.LINE_STRIP;
	        this.drawModes[CONST.DRAW_MODES.TRIANGLES]      = gl.TRIANGLES;
	        this.drawModes[CONST.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
	        this.drawModes[CONST.DRAW_MODES.TRIANGLE_FAN]   = gl.TRIANGLE_FAN;
	    }
	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(24),
	    math = __webpack_require__(15),
	    CONST = __webpack_require__(14),
	    EventEmitter = __webpack_require__(25);
	
	/**
	 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
	 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @memberof PIXI
	 * @param system {string} The name of the system this renderer is for.
	 * @param [width=800] {number} the width of the canvas view
	 * @param [height=600] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.
	 * @param [options.backgroundColor=0x000000] {number} The background color of the rendered area (shown if not transparent).
	 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
	 */
	function SystemRenderer(system, width, height, options)
	{
	    EventEmitter.call(this);
	
	    utils.sayHello(system);
	
	    // prepare options
	    if (options)
	    {
	        for (var i in CONST.DEFAULT_RENDER_OPTIONS)
	        {
	            if (typeof options[i] === 'undefined')
	            {
	                options[i] = CONST.DEFAULT_RENDER_OPTIONS[i];
	            }
	        }
	    }
	    else
	    {
	        options = CONST.DEFAULT_RENDER_OPTIONS;
	    }
	
	    /**
	     * The type of the renderer.
	     *
	     * @member {number}
	     * @default PIXI.RENDERER_TYPE.UNKNOWN
	     * @see PIXI.RENDERER_TYPE
	     */
	    this.type = CONST.RENDERER_TYPE.UNKNOWN;
	
	    /**
	     * The width of the canvas view
	     *
	     * @member {number}
	     * @default 800
	     */
	    this.width = width || 800;
	
	    /**
	     * The height of the canvas view
	     *
	     * @member {number}
	     * @default 600
	     */
	    this.height = height || 600;
	
	    /**
	     * The canvas element that everything is drawn to
	     *
	     * @member {HTMLCanvasElement}
	     */
	    this.view = options.view || document.createElement('canvas');
	
	    /**
	     * The resolution of the renderer
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.resolution = options.resolution;
	
	    /**
	     * Whether the render view is transparent
	     *
	     * @member {boolean}
	     */
	    this.transparent = options.transparent;
	
	    /**
	     * Whether the render view should be resized automatically
	     *
	     * @member {boolean}
	     */
	    this.autoResize = options.autoResize || false;
	
	    /**
	     * Tracks the blend modes useful for this renderer.
	     *
	     * @member {object<string, mixed>}
	     */
	    this.blendModes = null;
	
	    /**
	     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
	     *
	     * @member {boolean}
	     */
	    this.preserveDrawingBuffer = options.preserveDrawingBuffer;
	
	    /**
	     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
	     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
	     * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.
	     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
	     *
	     * @member {boolean}
	     * @default
	     */
	    this.clearBeforeRender = options.clearBeforeRender;
	
	    /**
	     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
	     * Handy for crisp pixel art and speed on legacy devices.
	     *
	     * @member {boolean}
	     */
	    this.roundPixels = options.roundPixels;
	
	    /**
	     * The background color as a number.
	     *
	     * @member {number}
	     * @private
	     */
	    this._backgroundColor = 0x000000;
	
	    /**
	     * The background color as an [R, G, B] array.
	     *
	     * @member {number[]}
	     * @private
	     */
	    this._backgroundColorRgb = [0, 0, 0];
	
	    /**
	     * The background color as a string.
	     *
	     * @member {string}
	     * @private
	     */
	    this._backgroundColorString = '#000000';
	
	    this.backgroundColor = options.backgroundColor || this._backgroundColor; // run bg color setter
	
	    /**
	     * This temporary display object used as the parent of the currently being rendered item
	     *
	     * @member {PIXI.DisplayObject}
	     * @private
	     */
	    this._tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};
	
	    /**
	     * The last root object that the renderer tried to render.
	     *
	     * @member {PIXI.DisplayObject}
	     * @private
	     */
	    this._lastObjectRendered = this._tempDisplayObjectParent;
	}
	
	// constructor
	SystemRenderer.prototype = Object.create(EventEmitter.prototype);
	SystemRenderer.prototype.constructor = SystemRenderer;
	module.exports = SystemRenderer;
	
	Object.defineProperties(SystemRenderer.prototype, {
	    /**
	     * The background color to fill if not transparent
	     *
	     * @member {number}
	     * @memberof PIXI.SystemRenderer#
	     */
	    backgroundColor:
	    {
	        get: function ()
	        {
	            return this._backgroundColor;
	        },
	        set: function (val)
	        {
	            this._backgroundColor = val;
	            this._backgroundColorString = utils.hex2string(val);
	            utils.hex2rgb(val, this._backgroundColorRgb);
	        }
	    }
	});
	
	/**
	 * Resizes the canvas view to the specified width and height
	 *
	 * @param width {number} the new width of the canvas view
	 * @param height {number} the new height of the canvas view
	 */
	SystemRenderer.prototype.resize = function (width, height) {
	    this.width = width * this.resolution;
	    this.height = height * this.resolution;
	
	    this.view.width = this.width;
	    this.view.height = this.height;
	
	    if (this.autoResize)
	    {
	        this.view.style.width = this.width / this.resolution + 'px';
	        this.view.style.height = this.height / this.resolution + 'px';
	    }
	};
	
	/**
	 * Removes everything from the renderer and optionally removes the Canvas DOM element.
	 *
	 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
	 */
	SystemRenderer.prototype.destroy = function (removeView) {
	    if (removeView && this.view.parentNode)
	    {
	        this.view.parentNode.removeChild(this.view);
	    }
	
	    this.type = CONST.RENDERER_TYPE.UNKNOWN;
	
	    this.width = 0;
	    this.height = 0;
	
	    this.view = null;
	
	    this.resolution = 0;
	
	    this.transparent = false;
	
	    this.autoResize = false;
	
	    this.blendModes = null;
	
	    this.preserveDrawingBuffer = false;
	    this.clearBeforeRender = false;
	
	    this.roundPixels = false;
	
	    this._backgroundColor = 0;
	    this._backgroundColorRgb = null;
	    this._backgroundColorString = null;
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var WebGLManager = __webpack_require__(42),
	    TextureShader = __webpack_require__(54),
	    ComplexPrimitiveShader = __webpack_require__(56),
	    PrimitiveShader = __webpack_require__(57),
	    utils = __webpack_require__(24);
	
	/**
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.WebGLManager
	 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
	 */
	function ShaderManager(renderer)
	{
	    WebGLManager.call(this, renderer);
	
	    /**
	     * @member {number}
	     */
	    this.maxAttibs = 10;
	
	    /**
	     * @member {any[]}
	     */
	    this.attribState = [];
	
	    /**
	     * @member {any[]}
	     */
	    this.tempAttribState = [];
	
	    for (var i = 0; i < this.maxAttibs; i++)
	    {
	        this.attribState[i] = false;
	    }
	
	    /**
	     * @member {any[]}
	     */
	    this.stack = [];
	
	    /**
	     * @member {number}
	     * @private
	     */
	    this._currentId = -1;
	
	    /**
	     * @member {PIXI.Shader}
	     * @private
	     */
	    this.currentShader = null;
	
	//    this.initPlugins();
	}
	
	ShaderManager.prototype = Object.create(WebGLManager.prototype);
	ShaderManager.prototype.constructor = ShaderManager;
	utils.pluginTarget.mixin(ShaderManager);
	
	module.exports = ShaderManager;
	
	/**
	 * Called when there is a WebGL context change.
	 *
	 */
	ShaderManager.prototype.onContextChange = function ()
	{
	    this.initPlugins();
	
	    var gl = this.renderer.gl;
	
	    // get the maximum number of attribute correctly as this tends to vary
	    this.maxAttibs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	
	    this.attribState = [];
	
	    for (var i = 0; i < this.maxAttibs; i++)
	    {
	        this.attribState[i] = false;
	    }
	
	    // TODO - Why are these not plugins? We can't decouple primitives unless they are....
	    this.defaultShader = new TextureShader(this);
	    this.primitiveShader = new PrimitiveShader(this);
	    this.complexPrimitiveShader = new ComplexPrimitiveShader(this);
	};
	
	/**
	 * Takes the attributes given in parameters and uploads them.
	 *
	 * @param attribs {any[]} attribs
	 */
	ShaderManager.prototype.setAttribs = function (attribs)
	{
	    // reset temp state
	    var i;
	
	    for (i = 0; i < this.tempAttribState.length; i++)
	    {
	        this.tempAttribState[i] = false;
	    }
	
	    // set the new attribs
	    for (var a in attribs)
	    {
	        this.tempAttribState[attribs[a]] = true;
	    }
	
	    var gl = this.renderer.gl;
	
	    for (i = 0; i < this.attribState.length; i++)
	    {
	        if (this.attribState[i] !== this.tempAttribState[i])
	        {
	            this.attribState[i] = this.tempAttribState[i];
	
	            if (this.attribState[i])
	            {
	                gl.enableVertexAttribArray(i);
	            }
	            else
	            {
	                gl.disableVertexAttribArray(i);
	            }
	        }
	    }
	};
	
	/**
	 * Sets the current shader.
	 *
	 * @param shader {PIXI.Shader} the shader to upload
	 */
	ShaderManager.prototype.setShader = function (shader)
	{
	    if (this._currentId === shader.uid)
	    {
	        return false;
	    }
	
	    this._currentId = shader.uid;
	
	    this.currentShader = shader;
	
	    this.renderer.gl.useProgram(shader.program);
	    this.setAttribs(shader.attributes);
	
	    return true;
	};
	
	/**
	 * Destroys this object.
	 *
	 */
	ShaderManager.prototype.destroy = function ()
	{
	    this.primitiveShader.destroy();
	    this.complexPrimitiveShader.destroy();
	    WebGLManager.prototype.destroy.call(this);
	
	    this.destroyPlugins();
	
	    this.attribState = null;
	
	    this.tempAttribState = null;
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var Shader = __webpack_require__(55);
	
	/**
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.Shader
	 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
	 * @param [vertexSrc] {string} The source of the vertex shader.
	 * @param [fragmentSrc] {string} The source of the fragment shader.
	 * @param [customUniforms] {object} Custom uniforms to use to augment the built-in ones.
	 * @param [fragmentSrc] {string} The source of the fragment shader.
	 */
	function TextureShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes)
	{
	    var uniforms = {
	
	        uSampler:           { type: 'sampler2D', value: 0 },
	        projectionMatrix:   { type: 'mat3', value: new Float32Array([1, 0, 0,
	                                                                     0, 1, 0,
	                                                                     0, 0, 1]) }
	    };
	
	    if (customUniforms)
	    {
	        for (var u in customUniforms)
	        {
	            uniforms[u] = customUniforms[u];
	        }
	    }
	
	
	    var attributes = {
	        aVertexPosition:    0,
	        aTextureCoord:      0,
	        aColor:             0
	    };
	
	    if (customAttributes)
	    {
	        for (var a in customAttributes)
	        {
	            attributes[a] = customAttributes[a];
	        }
	    }
	
	    /**
	     * The vertex shader.
	     *
	     * @member {string}
	     */
	    vertexSrc = vertexSrc || TextureShader.defaultVertexSrc;
	
	    /**
	     * The fragment shader.
	     *
	     * @member {string}
	     */
	    fragmentSrc = fragmentSrc || TextureShader.defaultFragmentSrc;
	
	    Shader.call(this, shaderManager, vertexSrc, fragmentSrc, uniforms, attributes);
	}
	
	// constructor
	TextureShader.prototype = Object.create(Shader.prototype);
	TextureShader.prototype.constructor = TextureShader;
	module.exports = TextureShader;
	
	/**
	 * The default vertex shader source
	 *
	 * @static
	 * @constant
	 */
	TextureShader.defaultVertexSrc = [
	    'precision lowp float;',
	    'attribute vec2 aVertexPosition;',
	    'attribute vec2 aTextureCoord;',
	    'attribute vec4 aColor;',
	
	    'uniform mat3 projectionMatrix;',
	
	    'varying vec2 vTextureCoord;',
	    'varying vec4 vColor;',
	
	    'void main(void){',
	    '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
	    '   vTextureCoord = aTextureCoord;',
	    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
	    '}'
	].join('\n');
	
	/**
	 * The default fragment shader source
	 *
	 * @static
	 * @constant
	 */
	TextureShader.defaultFragmentSrc = [
	    'precision lowp float;',
	
	    'varying vec2 vTextureCoord;',
	    'varying vec4 vColor;',
	
	    'uniform sampler2D uSampler;',
	
	    'void main(void){',
	    '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
	    '}'
	].join('\n');


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/*global console */
	var utils = __webpack_require__(24);
	
	/**
	 * Base shader class for PIXI managed shaders.
	 *
	 * @class
	 * @memberof PIXI
	 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
	 * @param [vertexSrc] {string} The source of the vertex shader.
	 * @param [fragmentSrc] {string} The source of the fragment shader.
	 * @param [uniforms] {object} Uniforms for this shader.
	 * @param [attributes] {object} Attributes for this shader.
	 */
	function Shader(shaderManager, vertexSrc, fragmentSrc, uniforms, attributes)
	{
	    if (!vertexSrc || !fragmentSrc)
	    {
	         throw new Error('Pixi.js Error. Shader requires vertexSrc and fragmentSrc');
	    }
	
	    /**
	     * A unique id
	     * @member {number}
	     * @readonly
	     */
	    this.uid = utils.uid();
	
	    /**
	     * The current WebGL drawing context
	     * @member {WebGLRenderingContext}
	     * @readonly
	     */
	    this.gl = shaderManager.renderer.gl;
	
	    //TODO maybe we should pass renderer rather than shader manger?? food for thought..
	    this.shaderManager = shaderManager;
	
	    /**
	     * The WebGL program.
	     *
	     * @member {WebGLProgram}
	     * @readonly
	     */
	    this.program = null;
	
	    /**
	     * The uniforms as an object
	     * @member {object}
	     * @private
	     */
	    this.uniforms = uniforms || {};
	
	    /**
	     * The attributes as an object
	     * @member {object}
	     * @private
	     */
	    this.attributes = attributes || {};
	
	    /**
	     * Internal texture counter
	     * @member {number}
	     * @private
	     */
	    this.textureCount = 1;
	
	    /**
	     * The vertex shader as an array of strings
	     *
	     * @member {string}
	     */
	    this.vertexSrc = vertexSrc;
	
	    /**
	     * The fragment shader as an array of strings
	     *
	     * @member {string}
	     */
	    this.fragmentSrc = fragmentSrc;
	
	    this.init();
	}
	
	Shader.prototype.constructor = Shader;
	module.exports = Shader;
	
	/**
	 * Creates the shader and uses it
	 *
	 */
	Shader.prototype.init = function ()
	{
	    this.compile();
	
	    this.gl.useProgram(this.program);
	
	    this.cacheUniformLocations(Object.keys(this.uniforms));
	    this.cacheAttributeLocations(Object.keys(this.attributes));
	};
	
	/**
	 * Caches the locations of the uniform for reuse.
	 *
	 * @param keys {string} the uniforms to cache
	 */
	Shader.prototype.cacheUniformLocations = function (keys)
	{
	    for (var i = 0; i < keys.length; ++i)
	    {
	        this.uniforms[keys[i]]._location = this.gl.getUniformLocation(this.program, keys[i]);
	    }
	};
	
	/**
	 * Caches the locations of the attribute for reuse.
	 *
	 * @param keys {string} the attributes to cache
	 */
	Shader.prototype.cacheAttributeLocations = function (keys)
	{
	    for (var i = 0; i < keys.length; ++i)
	    {
	        this.attributes[keys[i]] = this.gl.getAttribLocation(this.program, keys[i]);
	    }
	
	    // TODO: Check if this is needed anymore...
	
	    // Begin worst hack eva //
	
	    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
	    // maybe its something to do with the current state of the gl context.
	    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
	    // If theres any webGL people that know why could happen please help :)
	    // if (this.attributes.aColor === -1){
	    //     this.attributes.aColor = 2;
	    // }
	
	    // End worst hack eva //
	};
	
	/**
	 * Attaches the shaders and creates the program.
	 *
	 * @return {WebGLProgram}
	 */
	Shader.prototype.compile = function ()
	{
	    var gl = this.gl;
	
	    var glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexSrc);
	    var glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentSrc);
	
	    var program = gl.createProgram();
	
	    gl.attachShader(program, glVertShader);
	    gl.attachShader(program, glFragShader);
	    gl.linkProgram(program);
	
	    // if linking fails, then log and cleanup
	    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
	    {
	        console.error('Pixi.js Error: Could not initialize shader.');
	        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
	        console.error('gl.getError()', gl.getError());
	
	        // if there is a program info log, log it
	        if (gl.getProgramInfoLog(program) !== '')
	        {
	            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
	        }
	
	        gl.deleteProgram(program);
	        program = null;
	    }
	
	    // clean up some shaders
	    gl.deleteShader(glVertShader);
	    gl.deleteShader(glFragShader);
	
	    return (this.program = program);
	};
	
	/*
	Shader.prototype.buildSync = function ()
	{
	   // var str = ""
	
	   // str =  "Shader.prototype.syncUniforms = function()";
	   // str += "{\n";
	
	    for (var key in this.uniforms)
	    {
	        var uniform = this.uniforms[key];
	
	        Object.defineProperty(this, key, {
	
	            get: function ()
	            {
	                return uniform.value
	            },
	            set: function (value)
	            {
	                this.setUniform(uniform, value);
	            }
	        });
	
	        console.log( makePropSetter( key, " bloop", uniform.type )  )
	  //      Object.def
	        //    location = uniform._location,
	          //  value = uniform.value,
	            //i, il;
	
	    //    str += "gl.uniform1i(this.uniforms."+ key +"._location, this.uniforms." + key + ".value );\n"
	
	    }
	
	}*/
	
	/**
	* Adds a new uniform
	*
	* @param uniform {object} the new uniform to attach
	*/
	Shader.prototype.syncUniform = function (uniform)
	{
	    var location = uniform._location,
	        value = uniform.value,
	        gl = this.gl,
	        i, il;
	
	    switch (uniform.type)
	    {
	        case 'b':
	        case 'bool':
	        case 'boolean':
	            gl.uniform1i(location, value ? 1 : 0);
	            break;
	
	        // single int value
	        case 'i':
	        case '1i':
	            gl.uniform1i(location, value);
	            break;
	
	        // single float value
	        case 'f':
	        case '1f':
	            gl.uniform1f(location, value);
	            break;
	
	        // Float32Array(2) or JS Arrray
	        case '2f':
	            gl.uniform2f(location, value[0], value[1]);
	            break;
	
	        // Float32Array(3) or JS Arrray
	        case '3f':
	            gl.uniform3f(location, value[0], value[1], value[2]);
	            break;
	
	        // Float32Array(4) or JS Arrray
	        case '4f':
	            gl.uniform4f(location, value[0], value[1], value[2], value[3]);
	            break;
	
	        // a 2D Point object
	        case 'v2':
	            gl.uniform2f(location, value.x, value.y);
	            break;
	
	        // a 3D Point object
	        case 'v3':
	            gl.uniform3f(location, value.x, value.y, value.z);
	            break;
	
	        // a 4D Point object
	        case 'v4':
	            gl.uniform4f(location, value.x, value.y, value.z, value.w);
	            break;
	
	        // Int32Array or JS Array
	        case '1iv':
	            gl.uniform1iv(location, value);
	            break;
	
	        // Int32Array or JS Array
	        case '2iv':
	            gl.uniform2iv(location, value);
	            break;
	
	        // Int32Array or JS Array
	        case '3iv':
	            gl.uniform3iv(location, value);
	            break;
	
	        // Int32Array or JS Array
	        case '4iv':
	            gl.uniform4iv(location, value);
	            break;
	
	        // Float32Array or JS Array
	        case '1fv':
	            gl.uniform1fv(location, value);
	            break;
	
	        // Float32Array or JS Array
	        case '2fv':
	            gl.uniform2fv(location, value);
	            break;
	
	        // Float32Array or JS Array
	        case '3fv':
	            gl.uniform3fv(location, value);
	            break;
	
	        // Float32Array or JS Array
	        case '4fv':
	            gl.uniform4fv(location, value);
	            break;
	
	        // Float32Array or JS Array
	        case 'm2':
	        case 'mat2':
	        case 'Matrix2fv':
	            gl.uniformMatrix2fv(location, uniform.transpose, value);
	            break;
	
	        // Float32Array or JS Array
	        case 'm3':
	        case 'mat3':
	        case 'Matrix3fv':
	
	            gl.uniformMatrix3fv(location, uniform.transpose, value);
	            break;
	
	        // Float32Array or JS Array
	        case 'm4':
	        case 'mat4':
	        case 'Matrix4fv':
	            gl.uniformMatrix4fv(location, uniform.transpose, value);
	            break;
	
	        // a Color Value
	        case 'c':
	            if (typeof value === 'number')
	            {
	                value = utils.hex2rgb(value);
	            }
	
	            gl.uniform3f(location, value[0], value[1], value[2]);
	            break;
	
	        // flat array of integers (JS or typed array)
	        case 'iv1':
	            gl.uniform1iv(location, value);
	            break;
	
	        // flat array of integers with 3 x N size (JS or typed array)
	        case 'iv':
	            gl.uniform3iv(location, value);
	            break;
	
	        // flat array of floats (JS or typed array)
	        case 'fv1':
	            gl.uniform1fv(location, value);
	            break;
	
	        // flat array of floats with 3 x N size (JS or typed array)
	        case 'fv':
	            gl.uniform3fv(location, value);
	            break;
	
	        // array of 2D Point objects
	        case 'v2v':
	            if (!uniform._array)
	            {
	                uniform._array = new Float32Array(2 * value.length);
	            }
	
	            for (i = 0, il = value.length; i < il; ++i)
	            {
	                uniform._array[i * 2]       = value[i].x;
	                uniform._array[i * 2 + 1]   = value[i].y;
	            }
	
	            gl.uniform2fv(location, uniform._array);
	            break;
	
	        // array of 3D Point objects
	        case 'v3v':
	            if (!uniform._array)
	            {
	                uniform._array = new Float32Array(3 * value.length);
	            }
	
	            for (i = 0, il = value.length; i < il; ++i)
	            {
	                uniform._array[i * 3]       = value[i].x;
	                uniform._array[i * 3 + 1]   = value[i].y;
	                uniform._array[i * 3 + 2]   = value[i].z;
	
	            }
	
	            gl.uniform3fv(location, uniform._array);
	            break;
	
	        // array of 4D Point objects
	        case 'v4v':
	            if (!uniform._array)
	            {
	                uniform._array = new Float32Array(4 * value.length);
	            }
	
	            for (i = 0, il = value.length; i < il; ++i)
	            {
	                uniform._array[i * 4]       = value[i].x;
	                uniform._array[i * 4 + 1]   = value[i].y;
	                uniform._array[i * 4 + 2]   = value[i].z;
	                uniform._array[i * 4 + 3]   = value[i].w;
	
	            }
	
	            gl.uniform4fv(location, uniform._array);
	            break;
	
	        // PIXI.Texture
	        case 't':
	        case 'sampler2D':
	
	            if (!uniform.value || !uniform.value.baseTexture.hasLoaded)
	            {
	                break;
	            }
	
	            // activate this texture
	            gl.activeTexture(gl['TEXTURE' + this.textureCount]);
	
	            var texture = uniform.value.baseTexture._glTextures[gl.id];
	
	            if (!texture)
	            {
	                this.initSampler2D(uniform);
	
	                // set the textur to the newly created one..
	                texture = uniform.value.baseTexture._glTextures[gl.id];
	            }
	
	            // bind the texture
	            gl.bindTexture(gl.TEXTURE_2D, texture);
	
	            // set uniform to texture index
	            gl.uniform1i(uniform._location, this.textureCount);
	
	            // increment next texture id
	            this.textureCount++;
	
	            break;
	
	        default:
	            console.warn('Pixi.js Shader Warning: Unknown uniform type: ' + uniform.type);
	    }
	};
	
	/**
	 * Updates the shader uniform values.
	 *
	 */
	Shader.prototype.syncUniforms = function ()
	{
	    this.textureCount = 1;
	
	    for (var key in this.uniforms)
	    {
	        this.syncUniform(this.uniforms[key]);
	    }
	};
	
	
	/**
	 * Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
	 *
	 */
	Shader.prototype.initSampler2D = function (uniform)
	{
	    var gl = this.gl;
	
	    var texture = uniform.value.baseTexture;
	
	    if(!texture.hasLoaded)
	    {
	        return;
	    }
	
	
	
	    if (uniform.textureData)
	    {
	
	        //TODO move this...
	        var data = uniform.textureData;
	
	        texture._glTextures[gl.id] = gl.createTexture();
	
	        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
	
	        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
	        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
	        // GLTextureLinear = mag/min linear, wrap clamp
	        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
	        // GLTextureNearest = mag/min nearest, wrap clamp
	        // AudioTexture = whatever + luminance + width 512, height 2, border 0
	        // KeyTexture = whatever + luminance + width 256, height 2, border 0
	
	        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
	        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT
	
	        gl.texImage2D(gl.TEXTURE_2D, 0, data.luminance ? gl.LUMINANCE : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
	
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, data.magFilter ? data.magFilter : gl.LINEAR );
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE );
	
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE);
	    }
	    else
	    {
	        this.shaderManager.renderer.updateTexture(texture);
	    }
	};
	
	/**
	 * Destroys the shader.
	 *
	 */
	Shader.prototype.destroy = function ()
	{
	    this.gl.deleteProgram(this.program);
	
	    this.gl = null;
	    this.uniforms = null;
	    this.attributes = null;
	
	    this.vertexSrc = null;
	    this.fragmentSrc = null;
	};
	
	Shader.prototype._glCompile = function (type, src)
	{
	    var shader = this.gl.createShader(type);
	
	    this.gl.shaderSource(shader, src);
	    this.gl.compileShader(shader);
	
	    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS))
	    {
	        console.log(this.gl.getShaderInfoLog(shader));
	        return null;
	    }
	
	    return shader;
	};


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var Shader = __webpack_require__(55);
	
	/**
	 * This shader is used to draw complex primitive shapes for {@link PIXI.Graphics}.
	 *
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.Shader
	 * @param shaderManager {PIXI.ShaderManager} The webgl shader manager this shader works for.
	 */
	function ComplexPrimitiveShader(shaderManager)
	{
	    Shader.call(this,
	        shaderManager,
	        // vertex shader
	        [
	            'attribute vec2 aVertexPosition;',
	
	            'uniform mat3 translationMatrix;',
	            'uniform mat3 projectionMatrix;',
	
	            'uniform vec3 tint;',
	            'uniform float alpha;',
	            'uniform vec3 color;',
	
	            'varying vec4 vColor;',
	
	            'void main(void){',
	            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
	            '   vColor = vec4(color * alpha * tint, alpha);',//" * vec4(tint * alpha, alpha);',
	            '}'
	        ].join('\n'),
	        // fragment shader
	        [
	            'precision mediump float;',
	
	            'varying vec4 vColor;',
	
	            'void main(void){',
	            '   gl_FragColor = vColor;',
	            '}'
	        ].join('\n'),
	        // custom uniforms
	        {
	            tint:   { type: '3f', value: [0, 0, 0] },
	            alpha:  { type: '1f', value: 0 },
	            color:  { type: '3f', value: [0,0,0] },
	            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
	            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
	        },
	        // attributes
	        {
	            aVertexPosition:0
	        }
	    );
	}
	
	ComplexPrimitiveShader.prototype = Object.create(Shader.prototype);
	ComplexPrimitiveShader.prototype.constructor = ComplexPrimitiveShader;
	module.exports = ComplexPrimitiveShader;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var Shader = __webpack_require__(55);
	
	/**
	 * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
	 *
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.Shader
	 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
	 */
	function PrimitiveShader(shaderManager)
	{
	    Shader.call(this,
	        shaderManager,
	        // vertex shader
	        [
	            'attribute vec2 aVertexPosition;',
	            'attribute vec4 aColor;',
	
	            'uniform mat3 translationMatrix;',
	            'uniform mat3 projectionMatrix;',
	
	            'uniform float alpha;',
	            'uniform float flipY;',
	            'uniform vec3 tint;',
	
	            'varying vec4 vColor;',
	
	            'void main(void){',
	            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
	            '   vColor = aColor * vec4(tint * alpha, alpha);',
	            '}'
	        ].join('\n'),
	        // fragment shader
	        [
	            'precision mediump float;',
	
	            'varying vec4 vColor;',
	
	            'void main(void){',
	            '   gl_FragColor = vColor;',
	            '}'
	        ].join('\n'),
	        // custom uniforms
	        {
	            tint:   { type: '3f', value: [0, 0, 0] },
	            alpha:  { type: '1f', value: 0 },
	            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
	            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
	        },
	        // custom attributes
	        {
	            aVertexPosition:0,
	            aColor:0
	        }
	    );
	}
	
	PrimitiveShader.prototype = Object.create(Shader.prototype);
	PrimitiveShader.prototype.constructor = PrimitiveShader;
	module.exports = PrimitiveShader;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var WebGLManager = __webpack_require__(42),
	    AlphaMaskFilter = __webpack_require__(59);
	
	/**
	 * @class
	 * @memberof PIXI
	 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
	 */
	function MaskManager(renderer)
	{
	    WebGLManager.call(this, renderer);
	
	    this.stencilStack = [];
	    this.reverse = true;
	    this.count = 0;
	
	    this.alphaMaskPool = [];
	}
	
	MaskManager.prototype = Object.create(WebGLManager.prototype);
	MaskManager.prototype.constructor = MaskManager;
	module.exports = MaskManager;
	
	/**
	 * Applies the Mask and adds it to the current filter stack.
	 *
	 * @param graphics {PIXI.Graphics}
	 * @param webGLData {any[]}
	 */
	MaskManager.prototype.pushMask = function (target, maskData)
	{
	    if (maskData.texture)
	    {
	        this.pushSpriteMask(target, maskData);
	    }
	    else
	    {
	        this.pushStencilMask(target, maskData);
	    }
	
	};
	
	/**
	 * Removes the last mask from the mask stack and doesn't return it.
	 *
	 * @param target {PIXI.RenderTarget}
	 * @param maskData {any[]}
	 */
	MaskManager.prototype.popMask = function (target, maskData)
	{
	    if (maskData.texture)
	    {
	        this.popSpriteMask(target, maskData);
	    }
	    else
	    {
	        this.popStencilMask(target, maskData);
	    }
	};
	
	/**
	 * Applies the Mask and adds it to the current filter stack.
	 *
	 * @param target {PIXI.RenderTarget}
	 * @param maskData {any[]}
	 */
	MaskManager.prototype.pushSpriteMask = function (target, maskData)
	{
	    var alphaMaskFilter = this.alphaMaskPool.pop();
	
	    if (!alphaMaskFilter)
	    {
	        alphaMaskFilter = [new AlphaMaskFilter(maskData)];
	    }
	
	    alphaMaskFilter[0].maskSprite = maskData;
	    this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
	};
	
	/**
	 * Removes the last filter from the filter stack and doesn't return it.
	 *
	 */
	MaskManager.prototype.popSpriteMask = function ()
	{
	    var filters = this.renderer.filterManager.popFilter();
	
	    this.alphaMaskPool.push(filters);
	};
	
	
	/**
	 * Applies the Mask and adds it to the current filter stack.
	 *
	 * @param target {PIXI.RenderTarget}
	 * @param maskData {any[]}
	 */
	MaskManager.prototype.pushStencilMask = function (target, maskData)
	{
	    this.renderer.stencilManager.pushMask(maskData);
	};
	
	/**
	 * Removes the last filter from the filter stack and doesn't return it.
	 *
	 * @param target {PIXI.RenderTarget}
	 * @param maskData {any[]}
	 */
	MaskManager.prototype.popStencilMask = function (target, maskData)
	{
	    this.renderer.stencilManager.popMask(maskData);
	};
	


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractFilter = __webpack_require__(60),
	    math =  __webpack_require__(15);
	
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The SpriteMaskFilter class
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI
	 * @param sprite {PIXI.Sprite} the target sprite
	 */
	function SpriteMaskFilter(sprite)
	{
	    var maskMatrix = new math.Matrix();
	
	    AbstractFilter.call(this,
	        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
	        "precision lowp float;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    original *= (masky.r * masky.a * alpha * clip);\n    gl_FragColor = original;\n}\n",
	        {
	            mask:           { type: 'sampler2D', value: sprite._texture },
	            alpha:          { type: 'f', value: 1},
	            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) }
	        }
	    );
	
	    this.maskSprite = sprite;
	    this.maskMatrix = maskMatrix;
	}
	
	SpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);
	SpriteMaskFilter.prototype.constructor = SpriteMaskFilter;
	module.exports = SpriteMaskFilter;
	
	/**
	 * Applies the filter
	 *
	 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
	 * @param input {PIXI.RenderTarget}
	 * @param output {PIXI.RenderTarget}
	 */
	SpriteMaskFilter.prototype.applyFilter = function (renderer, input, output)
	{
	    var filterManager = renderer.filterManager;
	
	    this.uniforms.mask.value = this.maskSprite._texture;
	
	    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);
	
	    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
	    this.uniforms.alpha.value = this.maskSprite.worldAlpha;
	
	    var shader = this.getShader(renderer);
	     // draw the filter...
	    filterManager.applyFilter(shader, input, output);
	};
	
	
	Object.defineProperties(SpriteMaskFilter.prototype, {
	    /**
	     * The texture used for the displacement map. Must be power of 2 sized texture.
	     *
	     * @member {PIXI.Texture}
	     * @memberof PIXI.SpriteMaskFilter#
	     */
	    map: {
	        get: function ()
	        {
	            return this.uniforms.mask.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.mask.value = value;
	        }
	    },
	
	    /**
	     * The offset used to move the displacement map.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.SpriteMaskFilter#
	     */
	    offset: {
	        get: function()
	        {
	            return this.uniforms.offset.value;
	        },
	        set: function(value)
	        {
	            this.uniforms.offset.value = value;
	        }
	    }
	});


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var DefaultShader = __webpack_require__(54);
	
	/**
	 * This is the base class for creating a PIXI filter. Currently only WebGL supports filters.
	 * If you want to make a custom filter this should be your base class.
	 *
	 * @class
	 * @memberof PIXI
	 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
	 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
	 * @param uniforms {object} An object containing the uniforms for this filter.
	 */
	function AbstractFilter(vertexSrc, fragmentSrc, uniforms)
	{
	
	    /**
	     * An array of shaders
	     * @member {PIXI.Shader[]}
	     * @private
	     */
	    this.shaders = [];
	
	    /**
	     * The extra padding that the filter might need
	     * @member {number}
	     */
	    this.padding = 0;
	
	    /**
	     * The uniforms as an object
	     * @member {object}
	     */
	    this.uniforms = uniforms || {};
	
	
	    /**
	     * The code of the vertex shader
	     * @member {string[]}
	     * @private
	     */
	    this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;
	
	    /**
	     * The code of the frament shader
	     * @member {string[]}
	     * @private
	     */
	    this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc;
	
	    //TODO a reminder - would be cool to have lower res filters as this would give better performance.
	
	    //typeof fragmentSrc === 'string' ? fragmentSrc.split('') : (fragmentSrc || []);
	
	}
	
	AbstractFilter.prototype.constructor = AbstractFilter;
	module.exports = AbstractFilter;
	
	/**
	 * Grabs a shader from the current renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the shader from
	 */
	AbstractFilter.prototype.getShader = function (renderer)
	{
	    var gl = renderer.gl;
	
	    var shader = this.shaders[gl.id];
	
	    if (!shader)
	    {
	        shader = new DefaultShader(renderer.shaderManager,
	            this.vertexSrc,
	            this.fragmentSrc,
	            this.uniforms,
	            this.attributes
	        );
	
	        this.shaders[gl.id] = shader;
	    }
	
	    return shader;
	};
	
	/**
	 * Applies the filter
	 *
	 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
	 * @param input {PIXI.RenderTarget}
	 * @param output {PIXI.RenderTarget}
	 * @param clear {boolean} Whether or not we want to clear the outputTarget
	 */
	AbstractFilter.prototype.applyFilter = function (renderer, input, output, clear)
	{
	    var shader = this.getShader(renderer);
	
	    renderer.filterManager.applyFilter(shader, input, output, clear);
	};
	
	/**
	 * Syncs a uniform between the class object and the shaders.
	 *
	 */
	AbstractFilter.prototype.syncUniform = function (uniform)
	{
	    for (var i = 0, j = this.shaders.length; i < j; ++i)
	    {
	        this.shaders[i].syncUniform(uniform);
	    }
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var WebGLManager = __webpack_require__(42),
	    utils = __webpack_require__(24);
	
	/**
	 * @class
	 * @memberof PIXI
	 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
	 */
	function WebGLMaskManager(renderer)
	{
	    WebGLManager.call(this, renderer);
	    this.stencilMaskStack = null;
	}
	
	WebGLMaskManager.prototype = Object.create(WebGLManager.prototype);
	WebGLMaskManager.prototype.constructor = WebGLMaskManager;
	module.exports = WebGLMaskManager;
	
	/**
	 * Changes the mask stack that is used by this manager.
	 *
	 * @param stencilMaskStack {PIXI.StencilMaskStack} The mask stack
	 */
	WebGLMaskManager.prototype.setMaskStack = function ( stencilMaskStack )
	{
	    this.stencilMaskStack = stencilMaskStack;
	
	    var gl = this.renderer.gl;
	
	    if (stencilMaskStack.stencilStack.length === 0)
	    {
	        gl.disable(gl.STENCIL_TEST);
	    }
	    else
	    {
	        gl.enable(gl.STENCIL_TEST);
	    }
	};
	
	/**
	 * Applies the Mask and adds it to the current filter stack. @alvin
	 *
	 * @param graphics {PIXI.Graphics}
	 * @param webGLData {any[]}
	 */
	WebGLMaskManager.prototype.pushStencil = function (graphics, webGLData)
	{
	    this.renderer.currentRenderTarget.attachStencilBuffer();
	
	    var gl = this.renderer.gl,
	        sms = this.stencilMaskStack;
	
	    this.bindGraphics(graphics, webGLData);
	
	    if (sms.stencilStack.length === 0)
	    {
	        gl.enable(gl.STENCIL_TEST);
	        gl.clear(gl.STENCIL_BUFFER_BIT);
	        sms.reverse = true;
	        sms.count = 0;
	    }
	
	    sms.stencilStack.push(webGLData);
	
	    var level = sms.count;
	
	    gl.colorMask(false, false, false, false);
	
	    gl.stencilFunc(gl.ALWAYS,0,0xFF);
	    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);
	
	    // draw the triangle strip!
	
	    if (webGLData.mode === 1)
	    {
	        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
	
	        if (sms.reverse)
	        {
	            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
	            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
	        }
	        else
	        {
	            gl.stencilFunc(gl.EQUAL,level, 0xFF);
	            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
	        }
	
	        // draw a quad to increment..
	        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
	
	        if (sms.reverse)
	        {
	            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
	        }
	        else
	        {
	            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
	        }
	
	        sms.reverse = !sms.reverse;
	    }
	    else
	    {
	        if (!sms.reverse)
	        {
	            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
	            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
	        }
	        else
	        {
	            gl.stencilFunc(gl.EQUAL,level, 0xFF);
	            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
	        }
	
	        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
	
	        if (!sms.reverse)
	        {
	            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
	        }
	        else
	        {
	            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
	        }
	    }
	
	    gl.colorMask(true, true, true, true);
	    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);
	
	    sms.count++;
	};
	
	/**
	 * TODO this does not belong here!
	 *
	 * @param graphics {PIXI.Graphics}
	 * @param webGLData {any[]}
	 */
	WebGLMaskManager.prototype.bindGraphics = function (graphics, webGLData)
	{
	    //if (this._currentGraphics === graphics)return;
	    var gl = this.renderer.gl;
	
	     // bind the graphics object..
	    var shader;// = this.renderer.shaderManager.plugins.primitiveShader;
	
	    if (webGLData.mode === 1)
	    {
	        shader = this.renderer.shaderManager.complexPrimitiveShader;
	
	        this.renderer.shaderManager.setShader(shader);
	
	        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));
	
	        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));
	
	        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));
	
	        gl.uniform3fv(shader.uniforms.color._location, webGLData.color);
	
	        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);
	
	        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
	
	        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);
	
	
	        // now do the rest..
	        // set the index buffer!
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
	    }
	    else
	    {
	        //this.renderer.shaderManager.activatePrimitiveShader();
	        shader = this.renderer.shaderManager.primitiveShader;
	
	        this.renderer.shaderManager.setShader(shader);
	
	        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));
	
	        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));
	
	        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));
	
	        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);
	
	        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
	
	        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
	        gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);
	
	        // set the index buffer!
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
	    }
	};
	
	/**
	 * TODO @alvin
	 * @param graphics {PIXI.Graphics}
	 * @param webGLData {any[]}
	 */
	WebGLMaskManager.prototype.popStencil = function (graphics, webGLData)
	{
	    var gl = this.renderer.gl,
	        sms = this.stencilMaskStack;
	
	    sms.stencilStack.pop();
	
	    sms.count--;
	
	    if (sms.stencilStack.length === 0)
	    {
	        // the stack is empty!
	        gl.disable(gl.STENCIL_TEST);
	
	    }
	    else
	    {
	
	        var level = sms.count;
	
	        this.bindGraphics(graphics, webGLData);
	
	        gl.colorMask(false, false, false, false);
	
	        if (webGLData.mode === 1)
	        {
	            sms.reverse = !sms.reverse;
	
	            if (sms.reverse)
	            {
	                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
	                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
	            }
	            else
	            {
	                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
	                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
	            }
	
	            // draw a quad to increment..
	            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
	
	            gl.stencilFunc(gl.ALWAYS,0,0xFF);
	            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);
	
	            // draw the triangle strip!
	            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
	
	            this.renderer.drawCount += 2;
	
	            if (!sms.reverse)
	            {
	                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
	            }
	            else
	            {
	                gl.stencilFunc(gl.EQUAL,level, 0xFF);
	            }
	
	        }
	        else
	        {
	          //  console.log("<<>>")
	            if (!sms.reverse)
	            {
	                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
	                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
	            }
	            else
	            {
	                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
	                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
	            }
	
	            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
	
	            this.renderer.drawCount++;
	
	            if (!sms.reverse)
	            {
	                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
	            }
	            else
	            {
	                gl.stencilFunc(gl.EQUAL,level, 0xFF);
	            }
	        }
	
	        gl.colorMask(true, true, true, true);
	        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);
	
	
	    }
	};
	
	/**
	 * Destroys the mask stack.
	 *
	 */
	WebGLMaskManager.prototype.destroy = function ()
	{
	    WebGLManager.prototype.destroy.call(this);
	
	    this.stencilMaskStack.stencilStack = null;
	};
	
	/**
	 * Applies the Mask and adds it to the current filter stack.
	 *
	 * @param maskData {any[]} The mask data structure to use
	 */
	WebGLMaskManager.prototype.pushMask = function (maskData)
	{
	
	
	    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
	
	    if (maskData.dirty)
	    {
	        this.renderer.plugins.graphics.updateGraphics(maskData, this.renderer.gl);
	    }
	
	    if (!maskData._webGL[this.renderer.gl.id].data.length)
	    {
	        return;
	    }
	
	    this.pushStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);
	};
	
	/**
	 * Removes the last filter from the filter stack and doesn't return it.
	 *
	 * @param maskData {any[]}
	 */
	WebGLMaskManager.prototype.popMask = function (maskData)
	{
	    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
	
	    this.popStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0]);
	};
	


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var WebGLManager = __webpack_require__(42);
	
	/**
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.WebGlManager
	 * @param renderer {PIXI.WebGLRenderer} The renderer this manager works for.
	 */
	function BlendModeManager(renderer)
	{
	    WebGLManager.call(this, renderer);
	
	    /**
	     * @member {number}
	     */
	    this.currentBlendMode = 99999;
	}
	
	BlendModeManager.prototype = Object.create(WebGLManager.prototype);
	BlendModeManager.prototype.constructor = BlendModeManager;
	module.exports = BlendModeManager;
	
	/**
	 * Sets-up the given blendMode from WebGL's point of view.
	 *
	 * @param blendMode {number} the blendMode, should be a Pixi const, such as `PIXI.BLEND_MODES.ADD`. See
	 *  {@link PIXI.BLEND_MODES} for possible values.
	 */
	BlendModeManager.prototype.setBlendMode = function (blendMode)
	{
	    if (this.currentBlendMode === blendMode)
	    {
	        return false;
	    }
	
	    this.currentBlendMode = blendMode;
	
	    var mode = this.renderer.blendModes[this.currentBlendMode];
	    this.renderer.gl.blendFunc(mode[0], mode[1]);
	
	    return true;
	};


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var AbstractFilter = __webpack_require__(60);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 *
	 * Basic FXAA implementation based on the code on geeks3d.com with the
	 * modification that the texture2DLod stuff was removed since it's
	 * unsupported by WebGL.
	 *
	 * --
	 * From:
	 * https://github.com/mitsuhiko/webgl-meincraft
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI
	 *
	 */
	function FXAAFilter()
	{
	    AbstractFilter.call(this,
	        // vertex shader
	        "\nprecision mediump float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform vec2 resolution;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\n            out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n   vResolution = resolution;\n\n   //compute the texture coords and send them to varyings\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",
	        // fragment shader
	        "precision lowp float;\n\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE,\n            vec2 v_rgbSW, vec2 v_rgbSE,\n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform sampler2D uSampler;\n\n\nvoid main(void){\n\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n}\n",
	        // uniforms
	        {
	            resolution: { type: 'v2', value: { x: 1, y: 1 } }
	        }
	    );
	
	}
	
	FXAAFilter.prototype = Object.create(AbstractFilter.prototype);
	FXAAFilter.prototype.constructor = FXAAFilter;
	module.exports = FXAAFilter;
	
	/**
	 * Applies the filter
	 *
	 * @param renderer {PIXI.WebGLRenderer} The renderer to retrieve the filter from
	 * @param input {PIXI.RenderTarget}
	 * @param output {PIXI.RenderTarget}
	 */
	FXAAFilter.prototype.applyFilter = function (renderer, input, output)
	{
	    var filterManager = renderer.filterManager;
	
	    var shader = this.getShader( renderer );
	     // draw the filter...
	    filterManager.applyFilter(shader, input, output);
	};


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectRenderer = __webpack_require__(50),
	    WebGLRenderer = __webpack_require__(51),
	    ParticleShader = __webpack_require__(65),
	    ParticleBuffer = __webpack_require__(66),
	    math            = __webpack_require__(15);
	
	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's ParticleRenderer:
	 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java
	 */
	
	/**
	 *
	 * @class
	 * @private
	 * @memberof PIXI
	 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
	 */
	function ParticleRenderer(renderer)
	{
	    ObjectRenderer.call(this, renderer);
	
	    // 65535 is max vertex index in the index buffer (see ParticleRenderer)
	    // so max number of particles is 65536 / 4 = 16384
	    // and max number of element in the index buffer is 16384 * 6 = 98304
	    // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
	    var numIndices = 98304;
	
	    /**
	     * Holds the indices
	     *
	     * @member {Uint16Array}
	     */
	    this.indices = new Uint16Array(numIndices);
	
	    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
	    {
	        this.indices[i + 0] = j + 0;
	        this.indices[i + 1] = j + 1;
	        this.indices[i + 2] = j + 2;
	        this.indices[i + 3] = j + 0;
	        this.indices[i + 4] = j + 2;
	        this.indices[i + 5] = j + 3;
	    }
	
	    /**
	     * The default shader that is used if a sprite doesn't have a more specific one.
	     *
	     * @member {PIXI.Shader}
	     */
	    this.shader = null;
	
	    this.indexBuffer = null;
	
	    this.properties = null;
	
	    this.tempMatrix = new math.Matrix();
	}
	
	ParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);
	ParticleRenderer.prototype.constructor = ParticleRenderer;
	module.exports = ParticleRenderer;
	
	WebGLRenderer.registerPlugin('particle', ParticleRenderer);
	
	/**
	 * When there is a WebGL context change
	 *
	 * @private
	 */
	ParticleRenderer.prototype.onContextChange = function ()
	{
	    var gl = this.renderer.gl;
	
	    // setup default shader
	    this.shader = new ParticleShader(this.renderer.shaderManager);
	
	    this.indexBuffer = gl.createBuffer();
	
	    // 65535 is max index, so 65535 / 6 = 10922.
	
	    //upload the index data
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
	
	    this.properties = [
	        // verticesData
	        {
	            attribute:this.shader.attributes.aVertexPosition,
	            size:2,
	            uploadFunction:this.uploadVertices,
	            offset:0
	        },
	        // positionData
	        {
	            attribute:this.shader.attributes.aPositionCoord,
	            size:2,
	            uploadFunction:this.uploadPosition,
	            offset:0
	        },
	        // rotationData
	        {
	            attribute:this.shader.attributes.aRotation,
	            size:1,
	            uploadFunction:this.uploadRotation,
	            offset:0
	        },
	        // uvsData
	        {
	            attribute:this.shader.attributes.aTextureCoord,
	            size:2,
	            uploadFunction:this.uploadUvs,
	            offset:0
	        },
	        // alphaData
	        {
	            attribute:this.shader.attributes.aColor,
	            size:1,
	            uploadFunction:this.uploadAlpha,
	            offset:0
	        }
	    ];
	};
	
	/**
	 * Starts a new particle batch.
	 *
	 */
	ParticleRenderer.prototype.start = function ()
	{
	    var gl = this.renderer.gl;
	
	    // bind the main texture
	    gl.activeTexture(gl.TEXTURE0);
	
	    // bind the buffers
	
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	
	    var shader = this.shader;
	
	    this.renderer.shaderManager.setShader(shader);
	};
	
	
	/**
	 * Renders the particle container object.
	 *
	 * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer
	 */
	ParticleRenderer.prototype.render = function (container)
	{
	    var children = container.children,
	        totalChildren = children.length,
	        maxSize = container._maxSize,
	        batchSize = container._batchSize;
	
	    if(totalChildren === 0)
	    {
	        return;
	    }
	    else if(totalChildren > maxSize)
	    {
	        totalChildren = maxSize;
	    }
	
	    if(!container._buffers)
	    {
	        container._buffers = this.generateBuffers( container );
	    }
	
	    // if the uvs have not updated then no point rendering just yet!
	    this.renderer.blendModeManager.setBlendMode(container.blendMode);
	
	    var gl = this.renderer.gl;
	
	    var m =  container.worldTransform.copy( this.tempMatrix );
	    m.prepend( this.renderer.currentRenderTarget.projectionMatrix );
	    gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));
	    gl.uniform1f(this.shader.uniforms.uAlpha._location, container.worldAlpha);
	
	
	    // make sure the texture is bound..
	    var baseTexture = children[0]._texture.baseTexture;
	
	    if (!baseTexture._glTextures[gl.id])
	    {
	        // if the texture has not updated then lets not upload any static properties
	        if(!this.renderer.updateTexture(baseTexture))
	        {
	            return;
	        }
	
	        if(!container._properties[0] || !container._properties[3])
	        {
	            container._bufferToUpdate = 0;
	        }
	    }
	    else
	    {
	        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
	    }
	
	    // now lets upload and render the buffers..
	    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)
	    {
	        var amount = ( totalChildren - i);
	        if(amount > batchSize)
	        {
	            amount = batchSize;
	        }
	
	        var buffer = container._buffers[j];
	
	        // we always upload the dynamic
	        buffer.uploadDynamic(children, i, amount);
	
	        // we only upload the static content when we have to!
	        if(container._bufferToUpdate === j)
	        {
	            buffer.uploadStatic(children, i, amount);
	            container._bufferToUpdate = j + 1;
	        }
	
	        // bind the buffer
	        buffer.bind( this.shader );
	
	         // now draw those suckas!
	        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
	        this.renderer.drawCount++;
	    }
	};
	
	/**
	 * Creates one particle buffer for each child in the container we want to render and updates internal properties
	 *
	 * @param container {PIXI.ParticleContainer} The container to render using this ParticleRenderer
	 */
	ParticleRenderer.prototype.generateBuffers = function (container)
	{
	    var gl = this.renderer.gl,
	        buffers = [],
	        size = container._maxSize,
	        batchSize = container._batchSize,
	        dynamicPropertyFlags = container._properties,
	        i;
	
	    for (i = 0; i < size; i += batchSize)
	    {
	        buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));
	    }
	
	    return buffers;
	};
	
	/**
	 * Uploads the verticies.
	 *
	 * @param children {PIXI.DisplayObject[]} the array of display objects to render
	 * @param startIndex {number} the index to start from in the children array
	 * @param amount {number} the amount of children that will have their vertices uploaded
	 * @param array {number[]}
	 * @param stride {number}
	 * @param offset {number}
	 */
	ParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset)
	{
	    var sprite,
	        texture,
	        trim,
	        sx,
	        sy,
	        w0, w1, h0, h1;
	
	    for (var i = 0; i < amount; i++) {
	
	        sprite = children[startIndex + i];
	        texture = sprite._texture;
	        sx = sprite.scale.x;
	        sy = sprite.scale.y;
	
	        if (texture.trim)
	        {
	            // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
	            trim = texture.trim;
	
	            w1 = trim.x - sprite.anchor.x * trim.width;
	            w0 = w1 + texture.crop.width;
	
	            h1 = trim.y - sprite.anchor.y * trim.height;
	            h0 = h1 + texture.crop.height;
	        }
	        else
	        {
	            w0 = (texture._frame.width ) * (1-sprite.anchor.x);
	            w1 = (texture._frame.width ) * -sprite.anchor.x;
	
	            h0 = texture._frame.height * (1-sprite.anchor.y);
	            h1 = texture._frame.height * -sprite.anchor.y;
	        }
	
	        array[offset] = w1 * sx;
	        array[offset + 1] = h1 * sy;
	
	        array[offset + stride] = w0 * sx;
	        array[offset + stride + 1] = h1 * sy;
	
	        array[offset + stride * 2] = w0 * sx;
	        array[offset + stride * 2 + 1] = h0 * sy;
	
	        array[offset + stride * 3] = w1 * sx;
	        array[offset + stride * 3 + 1] = h0 * sy;
	
	        offset += stride * 4;
	    }
	
	};
	
	/**
	 *
	 * @param children {PIXI.DisplayObject[]} the array of display objects to render
	 * @param startIndex {number} the index to start from in the children array
	 * @param amount {number} the amount of children that will have their positions uploaded
	 * @param array {number[]}
	 * @param stride {number}
	 * @param offset {number}
	 */
	ParticleRenderer.prototype.uploadPosition = function (children,startIndex, amount, array, stride, offset)
	{
	    for (var i = 0; i < amount; i++)
	    {
	        var spritePosition = children[startIndex + i].position;
	
	        array[offset] = spritePosition.x;
	        array[offset + 1] = spritePosition.y;
	
	        array[offset + stride] = spritePosition.x;
	        array[offset + stride + 1] = spritePosition.y;
	
	        array[offset + stride * 2] = spritePosition.x;
	        array[offset + stride * 2 + 1] = spritePosition.y;
	
	        array[offset + stride * 3] = spritePosition.x;
	        array[offset + stride * 3 + 1] = spritePosition.y;
	
	        offset += stride * 4;
	    }
	
	};
	
	/**
	 *
	 * @param children {PIXI.DisplayObject[]} the array of display objects to render
	 * @param startIndex {number} the index to start from in the children array
	 * @param amount {number} the amount of children that will have their rotation uploaded
	 * @param array {number[]}
	 * @param stride {number}
	 * @param offset {number}
	 */
	ParticleRenderer.prototype.uploadRotation = function (children,startIndex, amount, array, stride, offset)
	{
	    for (var i = 0; i < amount; i++)
	    {
	        var spriteRotation = children[startIndex + i].rotation;
	
	
	        array[offset] = spriteRotation;
	        array[offset + stride] = spriteRotation;
	        array[offset + stride * 2] = spriteRotation;
	        array[offset + stride * 3] = spriteRotation;
	
	        offset += stride * 4;
	    }
	};
	
	/**
	 *
	 * @param children {PIXI.DisplayObject[]} the array of display objects to render
	 * @param startIndex {number} the index to start from in the children array
	 * @param amount {number} the amount of children that will have their Uvs uploaded
	 * @param array {number[]}
	 * @param stride {number}
	 * @param offset {number}
	 */
	ParticleRenderer.prototype.uploadUvs = function (children,startIndex, amount, array, stride, offset)
	{
	    for (var i = 0; i < amount; i++)
	    {
	        var textureUvs = children[startIndex + i]._texture._uvs;
	
	        if (textureUvs)
	        {
	            array[offset] = textureUvs.x0;
	            array[offset + 1] = textureUvs.y0;
	
	            array[offset + stride] = textureUvs.x1;
	            array[offset + stride + 1] = textureUvs.y1;
	
	            array[offset + stride * 2] = textureUvs.x2;
	            array[offset + stride * 2 + 1] = textureUvs.y2;
	
	            array[offset + stride * 3] = textureUvs.x3;
	            array[offset + stride * 3 + 1] = textureUvs.y3;
	
	            offset += stride * 4;
	        }
	        else
	        {
	            //TODO you know this can be easier!
	            array[offset] = 0;
	            array[offset + 1] = 0;
	
	            array[offset + stride] = 0;
	            array[offset + stride + 1] = 0;
	
	            array[offset + stride * 2] = 0;
	            array[offset + stride * 2 + 1] = 0;
	
	            array[offset + stride * 3] = 0;
	            array[offset + stride * 3 + 1] = 0;
	
	            offset += stride * 4;
	        }
	    }
	};
	
	/**
	 *
	 * @param children {PIXI.DisplayObject[]} the array of display objects to render
	 * @param startIndex {number} the index to start from in the children array
	 * @param amount {number} the amount of children that will have their alpha uploaded
	 * @param array {number[]}
	 * @param stride {number}
	 * @param offset {number}
	 */
	ParticleRenderer.prototype.uploadAlpha = function (children,startIndex, amount, array, stride, offset)
	{
	     for (var i = 0; i < amount; i++)
	     {
	        var spriteAlpha = children[startIndex + i].alpha;
	
	        array[offset] = spriteAlpha;
	        array[offset + stride] = spriteAlpha;
	        array[offset + stride * 2] = spriteAlpha;
	        array[offset + stride * 3] = spriteAlpha;
	
	        offset += stride * 4;
	    }
	};
	
	
	/**
	 * Destroys the ParticleRenderer.
	 *
	 */
	ParticleRenderer.prototype.destroy = function ()
	{
	    if (this.renderer.gl) {
	        this.renderer.gl.deleteBuffer(this.indexBuffer);
	    }
	
	    ObjectRenderer.prototype.destroy.apply(this, arguments);
	
	    this.shader.destroy();
	
	    this.indices = null;
	    this.tempMatrix = null;
	};


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var TextureShader = __webpack_require__(54);
	
	/**
	 * @class
	 * @extends PIXI.TextureShader
	 * @memberof PIXI
	 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
	 */
	function ParticleShader(shaderManager)
	{
	    TextureShader.call(this,
	        shaderManager,
	        // vertex shader
	        [
	            'attribute vec2 aVertexPosition;',
	            'attribute vec2 aTextureCoord;',
	            'attribute float aColor;',
	
	            'attribute vec2 aPositionCoord;',
	            'attribute vec2 aScale;',
	            'attribute float aRotation;',
	
	            'uniform mat3 projectionMatrix;',
	
	            'varying vec2 vTextureCoord;',
	            'varying float vColor;',
	
	            'void main(void){',
	            '   vec2 v = aVertexPosition;',
	
	            '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);',
	            '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);',
	            '   v = v + aPositionCoord;',
	
	            '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);',
	
	            '   vTextureCoord = aTextureCoord;',
	            '   vColor = aColor;',
	            '}'
	        ].join('\n'),
	        // hello
	         [
	            'precision lowp float;',
	
	            'varying vec2 vTextureCoord;',
	            'varying float vColor;',
	
	            'uniform sampler2D uSampler;',
	            'uniform float uAlpha;',
	
	            'void main(void){',
	            '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uAlpha;',
	            '  if (color.a == 0.0) discard;',
	            '  gl_FragColor = color;',
	            '}'
	        ].join('\n'),
	        // custom uniforms
	        {
	            uAlpha:  { type: '1f', value: 1 }
	        },
	        // custom attributes
	        {
	            aPositionCoord: 0,
	           // aScale:         0,
	            aRotation:      0
	        }
	    );
	
	    // TEMP HACK
	
	}
	
	ParticleShader.prototype = Object.create(TextureShader.prototype);
	ParticleShader.prototype.constructor = ParticleShader;
	
	module.exports = ParticleShader;


/***/ },
/* 66 */
/***/ function(module, exports) {

	
	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's ParticleBuffer:
	 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java
	 */
	
	/**
	 * The particle buffer manages the static and dynamic buffers for a particle container.
	 *
	 * @class
	 * @private
	 * @memberof PIXI
	 */
	function ParticleBuffer(gl, properties, dynamicPropertyFlags, size)
	{
	    /**
	     * The current WebGL drawing context.
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;
	
	    /**
	     * Size of a single vertex.
	     *
	     * @member {number}
	     */
	    this.vertSize = 2;
	
	    /**
	     * Size of a single vertex in bytes.
	     *
	     * @member {number}
	     */
	    this.vertByteSize = this.vertSize * 4;
	
	    /**
	     * The number of particles the buffer can hold
	     *
	     * @member {number}
	     */
	    this.size = size;
	
	    /**
	     * A list of the properties that are dynamic.
	     *
	     * @member {object[]}
	     */
	    this.dynamicProperties = [];
	
	    /**
	     * A list of the properties that are static.
	     *
	     * @member {object[]}
	     */
	    this.staticProperties = [];
	
	    for (var i = 0; i < properties.length; i++)
	    {
	        var property = properties[i];
	
	        if(dynamicPropertyFlags[i])
	        {
	            this.dynamicProperties.push(property);
	        }
	        else
	        {
	            this.staticProperties.push(property);
	        }
	    }
	
	    this.staticStride = 0;
	    this.staticBuffer = null;
	    this.staticData = null;
	
	    this.dynamicStride = 0;
	    this.dynamicBuffer = null;
	    this.dynamicData = null;
	
	    this.initBuffers();
	
	}
	
	ParticleBuffer.prototype.constructor = ParticleBuffer;
	module.exports = ParticleBuffer;
	
	/**
	 * Sets up the renderer context and necessary buffers.
	 *
	 * @private
	 */
	ParticleBuffer.prototype.initBuffers = function ()
	{
	    var gl = this.gl;
	    var i;
	    var property;
	
	    var dynamicOffset = 0;
	    this.dynamicStride = 0;
	
	    for (i = 0; i < this.dynamicProperties.length; i++)
	    {
	        property = this.dynamicProperties[i];
	
	        property.offset = dynamicOffset;
	        dynamicOffset += property.size;
	        this.dynamicStride += property.size;
	    }
	
	    this.dynamicData = new Float32Array( this.size * this.dynamicStride * 4);
	    this.dynamicBuffer = gl.createBuffer();
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, this.dynamicData, gl.DYNAMIC_DRAW);
	
	
	    // static //
	    var staticOffset = 0;
	    this.staticStride = 0;
	
	    for (i = 0; i < this.staticProperties.length; i++)
	    {
	        property = this.staticProperties[i];
	
	        property.offset = staticOffset;
	        staticOffset += property.size;
	        this.staticStride += property.size;
	    }
	
	    this.staticData = new Float32Array( this.size * this.staticStride * 4);
	    this.staticBuffer = gl.createBuffer();
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, this.staticData, gl.DYNAMIC_DRAW);
	};
	
	/**
	 * Uploads the dynamic properties.
	 *
	 */
	ParticleBuffer.prototype.uploadDynamic = function(children, startIndex, amount)
	{
	    var gl = this.gl;
	
	    for (var i = 0; i < this.dynamicProperties.length; i++)
	    {
	        var property = this.dynamicProperties[i];
	        property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset);
	    }
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
	    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dynamicData);
	};
	
	/**
	 * Uploads the static properties.
	 *
	 */
	ParticleBuffer.prototype.uploadStatic = function(children, startIndex, amount)
	{
	    var gl = this.gl;
	
	    for (var i = 0; i < this.staticProperties.length; i++)
	    {
	        var property = this.staticProperties[i];
	        property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset);
	    }
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
	    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.staticData);
	};
	
	/**
	 * Binds the buffers to the GPU
	 *
	 */
	ParticleBuffer.prototype.bind = function ()
	{
	    var gl = this.gl;
	    var i, property;
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
	
	    for (i = 0; i < this.dynamicProperties.length; i++)
	    {
	        property = this.dynamicProperties[i];
	        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.dynamicStride * 4, property.offset * 4);
	    }
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
	
	    for (i = 0; i < this.staticProperties.length; i++)
	    {
	        property = this.staticProperties[i];
	        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.staticStride * 4, property.offset * 4);
	    }
	};
	
	/**
	 * Destroys the ParticleBuffer.
	 *
	 */
	ParticleBuffer.prototype.destroy = function ()
	{
	    this.dynamicProperties = null;
	    this.dynamicData = null;
	    this.gl.deleteBuffer(this.dynamicBuffer);
	
	    this.staticProperties = null;
	    this.staticData = null;
	    this.gl.deleteBuffer(this.staticBuffer);
	};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var Sprite = __webpack_require__(46),
	    Texture = __webpack_require__(36),
	    math = __webpack_require__(15),
	    utils = __webpack_require__(24),
	    CONST = __webpack_require__(14);
	
	/**
	 * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
	 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
	 *
	 * A Text can be created directly from a string and a style object
	 *
	 * ```js
	 * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});
	 * ```
	 *
	 * @class
	 * @extends PIXI.Sprite
	 * @memberof PIXI
	 * @param text {string} The copy that you would like the text to display
	 * @param [style] {object} The style parameters
	 * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font
	 * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
	 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
	 * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
	 * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
	 * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
	 * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true
	 * @param [style.letterSpacing=0] {number} The amount of spacing between letters, default is 0
	 * @param [style.breakWords=false] {boolean} Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
	 * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
	 * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
	 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
	 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
	 * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
	 * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius
	 * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
	 *      prevent this from happening by adding padding to the top and bottom of text height.
	 * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
	 * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
	 *      spiked text issues. Default is 'miter' (creates a sharp corner).
	 * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
	 *      or increase the spikiness of rendered text.
	 */
	function Text(text, style, resolution)
	{
	    /**
	     * The canvas element that everything is drawn to
	     *
	     * @member {HTMLCanvasElement}
	     */
	    this.canvas = document.createElement('canvas');
	
	    /**
	     * The canvas 2d context that everything is drawn with
	     * @member {HTMLCanvasElement}
	     */
	    this.context = this.canvas.getContext('2d');
	
	    /**
	     * The resolution of the canvas.
	     * @member {number}
	     */
	    this.resolution = resolution || CONST.RESOLUTION;
	
	    /**
	     * Private tracker for the current text.
	     *
	     * @member {string}
	     * @private
	     */
	    this._text = null;
	
	    /**
	     * Private tracker for the current style.
	     *
	     * @member {object}
	     * @private
	     */
	    this._style = null;
	
	    var texture = Texture.fromCanvas(this.canvas);
	    texture.trim = new math.Rectangle();
	    Sprite.call(this, texture);
	
	    this.text = text;
	    this.style = style;
	}
	
	// constructor
	Text.prototype = Object.create(Sprite.prototype);
	Text.prototype.constructor = Text;
	module.exports = Text;
	
	Text.fontPropertiesCache = {};
	Text.fontPropertiesCanvas = document.createElement('canvas');
	Text.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');
	
	Object.defineProperties(Text.prototype, {
	    /**
	     * The width of the Text, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.Text#
	     */
	    width: {
	        get: function ()
	        {
	            if (this.dirty)
	            {
	                this.updateText();
	            }
	
	            return this.scale.x * this._texture._frame.width;
	        },
	        set: function (value)
	        {
	            this.scale.x = value / this._texture._frame.width;
	            this._width = value;
	        }
	    },
	
	    /**
	     * The height of the Text, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.Text#
	     */
	    height: {
	        get: function ()
	        {
	            if (this.dirty)
	            {
	                this.updateText();
	            }
	
	            return  this.scale.y * this._texture._frame.height;
	        },
	        set: function (value)
	        {
	            this.scale.y = value / this._texture._frame.height;
	            this._height = value;
	        }
	    },
	
	    /**
	     * Set the style of the text
	     *
	     * @param [style] {object} The style parameters
	     * @param [style.font='bold 20pt Arial'] {string} The style and size of the font
	     * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'
	     * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
	     * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'
	     * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
	     * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
	     * @param [style.wordWrapWidth=100] {number} The width at which text will wrap
	     * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
	     * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
	     * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
	     * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow
	     * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
	     * @param [style.dropShadowBlur=0] {number} Set a shadow blur radius
	     * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
	     *      prevent this from happening by adding padding to the top and bottom of text height.
	     * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
	     * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
	     *      spiked text issues. Default is 'miter' (creates a sharp corner).
	     * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
	     *      or increase the spikiness of rendered text.
	     * @memberof PIXI.Text#
	     */
	    style: {
	        get: function ()
	        {
	            return this._style;
	        },
	        set: function (style)
	        {
	            style = style || {};
	
	            if (typeof style.fill === 'number') {
	                style.fill = utils.hex2string(style.fill);
	            }
	
	            if (typeof style.stroke === 'number') {
	                style.stroke = utils.hex2string(style.stroke);
	            }
	
	            if (typeof style.dropShadowColor === 'number') {
	                style.dropShadowColor = utils.hex2string(style.dropShadowColor);
	            }
	
	            style.font = style.font || 'bold 20pt Arial';
	            style.fill = style.fill || 'black';
	            style.align = style.align || 'left';
	            style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/pixijs/pixi.js/issues/136
	            style.strokeThickness = style.strokeThickness || 0;
	            style.wordWrap = style.wordWrap || false;
	            style.wordWrapWidth = style.wordWrapWidth || 100;
	            style.breakWords = style.breakWords || false;
	            style.letterSpacing = style.letterSpacing || 0;
	
	            style.dropShadow = style.dropShadow || false;
	            style.dropShadowColor = style.dropShadowColor || '#000000';
	            style.dropShadowAngle = style.dropShadowAngle !== undefined ? style.dropShadowAngle : Math.PI / 6;
	            style.dropShadowDistance = style.dropShadowDistance !== undefined ? style.dropShadowDistance : 5;
	            style.dropShadowBlur = style.dropShadowBlur !== undefined ? style.dropShadowBlur : 0; //shadowBlur is '0' by default according to HTML
	
	            style.padding = style.padding || 0;
	
	            style.textBaseline = style.textBaseline || 'alphabetic';
	
	            style.lineJoin = style.lineJoin || 'miter';
	            style.miterLimit = style.miterLimit || 10;
	
	            this._style = style;
	            this.dirty = true;
	        }
	    },
	
	    /**
	     * Set the copy for the text object. To split a line you can use '\n'.
	     *
	     * @param text {string} The copy that you would like the text to display
	     * @memberof PIXI.Text#
	     */
	    text: {
	        get: function()
	        {
	            return this._text;
	        },
	        set: function (text){
	            text = text.toString() || ' ';
	            if (this._text === text)
	            {
	                return;
	            }
	            this._text = text;
	            this.dirty = true;
	        }
	    }
	});
	
	/**
	 * Renders text and updates it when needed
	 *
	 * @private
	 */
	Text.prototype.updateText = function ()
	{
	    var style = this._style;
	    this.context.font = style.font;
	
	    // word wrap
	    // preserve original text
	    var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;
	
	    // split text into lines
	    var lines = outputText.split(/(?:\r\n|\r|\n)/);
	
	    // calculate text width
	    var lineWidths = new Array(lines.length);
	    var maxLineWidth = 0;
	    var fontProperties = this.determineFontProperties(style.font);
	    for (var i = 0; i < lines.length; i++)
	    {
	        var lineWidth = this.context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);
	        lineWidths[i] = lineWidth;
	        maxLineWidth = Math.max(maxLineWidth, lineWidth);
	    }
	
	    var width = maxLineWidth + style.strokeThickness;
	    if (style.dropShadow)
	    {
	        width += style.dropShadowDistance;
	    }
	
	    this.canvas.width = Math.ceil( ( width + this.context.lineWidth ) * this.resolution );
	
	    // calculate text height
	    var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;
	
	    var height = lineHeight * lines.length;
	    if (style.dropShadow)
	    {
	        height += style.dropShadowDistance;
	    }
	
	    this.canvas.height = Math.ceil( ( height + this._style.padding * 2 ) * this.resolution );
	
	    this.context.scale( this.resolution, this.resolution);
	
	    if (navigator.isCocoonJS)
	    {
	        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	
	    }
	
	    //this.context.fillStyle="#FF0000";
	    //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
	
	    this.context.font = style.font;
	    this.context.strokeStyle = style.stroke;
	    this.context.lineWidth = style.strokeThickness;
	    this.context.textBaseline = style.textBaseline;
	    this.context.lineJoin = style.lineJoin;
	    this.context.miterLimit = style.miterLimit;
	
	    var linePositionX;
	    var linePositionY;
	
	    if (style.dropShadow)
	    {
	        if (style.dropShadowBlur > 0) {
	            this.context.shadowColor = style.dropShadowColor;
	            this.context.shadowBlur = style.dropShadowBlur;
	        } else {
	            this.context.fillStyle = style.dropShadowColor;
	        }
	
	        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
	        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
	
	        for (i = 0; i < lines.length; i++)
	        {
	            linePositionX = style.strokeThickness / 2;
	            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;
	
	            if (style.align === 'right')
	            {
	                linePositionX += maxLineWidth - lineWidths[i];
	            }
	            else if (style.align === 'center')
	            {
	                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
	            }
	
	            if (style.fill)
	            {
	                this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + style.padding);
	            }
	        }
	    }
	
	    //set canvas text styles
	    this.context.fillStyle = style.fill;
	
	    //draw lines line by line
	    for (i = 0; i < lines.length; i++)
	    {
	        linePositionX = style.strokeThickness / 2;
	        linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;
	
	        if (style.align === 'right')
	        {
	            linePositionX += maxLineWidth - lineWidths[i];
	        }
	        else if (style.align === 'center')
	        {
	            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
	        }
	
	        if (style.stroke && style.strokeThickness)
	        {
	            this.drawLetterSpacing(lines[i], linePositionX, linePositionY + style.padding, true);
	        }
	
	        if (style.fill)
	        {
	            this.drawLetterSpacing(lines[i], linePositionX, linePositionY + style.padding);
	        }
	    }
	
	    this.updateTexture();
	};
	
	/**
	 * Render the text with letter-spacing.
	 *
	 * @private
	 */
	Text.prototype.drawLetterSpacing = function(text, x, y, isStroke)
	{
	    var style = this._style;
	
	    // letterSpacing of 0 means normal
	    var letterSpacing = style.letterSpacing;
	
	    if (letterSpacing === 0)
	    {
	        if (isStroke)
	        {
	            this.context.strokeText(text, x, y);
	        }
	        else
	        {
	            this.context.fillText(text, x, y);
	        }
	        return;
	    }
	
	    var characters = String.prototype.split.call(text, ''),
	        index = 0,
	        current,
	        currentPosition = x;
	
	    while (index < text.length)
	    {
	        current = characters[index++];
	        if (isStroke) 
	        {
	            this.context.strokeText(current, currentPosition, y);
	        }
	        else
	        {
	            this.context.fillText(current, currentPosition, y);
	        }
	        currentPosition += this.context.measureText(current).width + letterSpacing;
	    }
	};
	
	/**
	 * Updates texture size based on canvas size
	 *
	 * @private
	 */
	Text.prototype.updateTexture = function ()
	{
	    var texture = this._texture;
	    var style = this._style;
	
	    texture.baseTexture.hasLoaded = true;
	    texture.baseTexture.resolution = this.resolution;
	
	    texture.baseTexture.width = this.canvas.width / this.resolution;
	    texture.baseTexture.height = this.canvas.height / this.resolution;
	    texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;
	    texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;
	
	    texture.trim.x = 0;
	    texture.trim.y = -style.padding;
	
	    texture.trim.width = texture._frame.width;
	    texture.trim.height = texture._frame.height - style.padding*2;
	
	    this._width = this.canvas.width / this.resolution;
	    this._height = this.canvas.height / this.resolution;
	
	    texture.baseTexture.emit('update',  texture.baseTexture);
	
	    this.dirty = false;
	};
	
	/**
	 * Renders the object using the WebGL renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer}
	 */
	Text.prototype.renderWebGL = function (renderer)
	{
	    if (this.dirty)
	    {
	        //this.resolution = 1//renderer.resolution;
	
	        this.updateText();
	    }
	
	    Sprite.prototype.renderWebGL.call(this, renderer);
	};
	
	/**
	 * Renders the object using the Canvas renderer
	 *
	 * @param renderer {PIXI.CanvasRenderer}
	 * @private
	 */
	Text.prototype._renderCanvas = function (renderer)
	{
	    if (this.dirty)
	    {
	     //   this.resolution = 1//renderer.resolution;
	
	        this.updateText();
	    }
	
	    Sprite.prototype._renderCanvas.call(this, renderer);
	};
	
	/**
	 * Calculates the ascent, descent and fontSize of a given fontStyle
	 *
	 * @param fontStyle {object}
	 * @private
	 */
	Text.prototype.determineFontProperties = function (fontStyle)
	{
	    var properties = Text.fontPropertiesCache[fontStyle];
	
	    if (!properties)
	    {
	        properties = {};
	
	        var canvas = Text.fontPropertiesCanvas;
	        var context = Text.fontPropertiesContext;
	
	        context.font = fontStyle;
	
	        var width = Math.ceil(context.measureText('|Mq').width);
	        var baseline = Math.ceil(context.measureText('M').width);
	        var height = 2 * baseline;
	
	        baseline = baseline * 1.4 | 0;
	
	        canvas.width = width;
	        canvas.height = height;
	
	        context.fillStyle = '#f00';
	        context.fillRect(0, 0, width, height);
	
	        context.font = fontStyle;
	
	        context.textBaseline = 'alphabetic';
	        context.fillStyle = '#000';
	        context.fillText('|Mq', 0, baseline);
	
	        var imagedata = context.getImageData(0, 0, width, height).data;
	        var pixels = imagedata.length;
	        var line = width * 4;
	
	        var i, j;
	
	        var idx = 0;
	        var stop = false;
	
	        // ascent. scan from top to bottom until we find a non red pixel
	        for (i = 0; i < baseline; i++)
	        {
	            for (j = 0; j < line; j += 4)
	            {
	                if (imagedata[idx + j] !== 255)
	                {
	                    stop = true;
	                    break;
	                }
	            }
	            if (!stop)
	            {
	                idx += line;
	            }
	            else
	            {
	                break;
	            }
	        }
	
	        properties.ascent = baseline - i;
	
	        idx = pixels - line;
	        stop = false;
	
	        // descent. scan from bottom to top until we find a non red pixel
	        for (i = height; i > baseline; i--)
	        {
	            for (j = 0; j < line; j += 4)
	            {
	                if (imagedata[idx + j] !== 255)
	                {
	                    stop = true;
	                    break;
	                }
	            }
	            if (!stop)
	            {
	                idx -= line;
	            }
	            else
	            {
	                break;
	            }
	        }
	
	        properties.descent = i - baseline;
	        properties.fontSize = properties.ascent + properties.descent;
	
	        Text.fontPropertiesCache[fontStyle] = properties;
	    }
	
	    return properties;
	};
	
	/**
	 * Applies newlines to a string to have it optimally fit into the horizontal
	 * bounds set by the Text object's wordWrapWidth property.
	 *
	 * @param text {string}
	 * @private
	 */
	Text.prototype.wordWrap = function (text)
	{
	    // Greedy wrapping algorithm that will wrap words as the line grows longer
	    // than its horizontal bounds.
	    var result = '';
	    var lines = text.split('\n');
	    var wordWrapWidth = this._style.wordWrapWidth;
	    for (var i = 0; i < lines.length; i++)
	    {
	        var spaceLeft = wordWrapWidth;
	        var words = lines[i].split(' ');
	        for (var j = 0; j < words.length; j++)
	        {
	            var wordWidth = this.context.measureText(words[j]).width;
	            if (this._style.breakWords && wordWidth > wordWrapWidth) 
	            {
	                // Word should be split in the middle
	                var characters = words[j].split('');
	                for (var c = 0; c < characters.length; c++) 
	                {
	                  var characterWidth = this.context.measureText(characters[c]).width;
	                  if (characterWidth > spaceLeft) 
	                  {
	                    result += '\n' + characters[c];
	                    spaceLeft = wordWrapWidth - characterWidth;
	                  } 
	                  else 
	                  {
	                    if (c === 0) 
	                    {
	                      result += ' ';
	                    }
	                    result += characters[c];
	                    spaceLeft -= characterWidth;
	                  }
	                }
	            }
	            else 
	            {
	                var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
	                if (j === 0 || wordWidthWithSpace > spaceLeft)
	                {
	                    // Skip printing the newline if it's the first word of the line that is
	                    // greater than the word wrap width.
	                    if (j > 0)
	                    {
	                        result += '\n';
	                    }
	                    result += words[j];
	                    spaceLeft = wordWrapWidth - wordWidth;
	                }
	                else
	                {
	                    spaceLeft -= wordWidthWithSpace;
	                    result += ' ' + words[j];
	                }
	            }
	        }
	
	        if (i < lines.length-1)
	        {
	            result += '\n';
	        }
	    }
	    return result;
	};
	
	/**
	 * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
	 *
	 * @param matrix {PIXI.Matrix} the transformation matrix of the Text
	 * @return {PIXI.Rectangle} the framing rectangle
	 */
	Text.prototype.getBounds = function (matrix)
	{
	    if (this.dirty)
	    {
	        this.updateText();
	    }
	
	    return Sprite.prototype.getBounds.call(this, matrix);
	};
	
	/**
	 * Destroys this text object.
	 *
	 * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well
	 */
	Text.prototype.destroy = function (destroyBaseTexture)
	{
	    // make sure to reset the the context and canvas.. dont want this hanging around in memory!
	    this.context = null;
	    this.canvas = null;
	
	    this._style = null;
	
	    this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
	};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var Container = __webpack_require__(45),
	    Texture = __webpack_require__(36),
	    CanvasBuffer = __webpack_require__(44),
	    CanvasGraphics = __webpack_require__(69),
	    GraphicsData = __webpack_require__(70),
	    math = __webpack_require__(15),
	    CONST = __webpack_require__(14),
	    tempPoint = new math.Point();
	
	/**
	 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
	 * rectangles to the display, and to color and fill them.
	 *
	 * @class
	 * @extends PIXI.Container
	 * @memberof PIXI
	 */
	function Graphics()
	{
	    Container.call(this);
	
	    /**
	     * The alpha value used when filling the Graphics object.
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.fillAlpha = 1;
	
	    /**
	     * The width (thickness) of any lines drawn.
	     *
	     * @member {number}
	     * @default 0
	     */
	    this.lineWidth = 0;
	
	    /**
	     * The color of any lines drawn.
	     *
	     * @member {string}
	     * @default 0
	     */
	    this.lineColor = 0;
	
	    /**
	     * Graphics data
	     *
	     * @member {PIXI.GraphicsData[]}
	     * @private
	     */
	    this.graphicsData = [];
	
	    /**
	     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.
	     *
	     * @member {number}
	     * @default 0xFFFFFF
	     */
	    this.tint = 0xFFFFFF;
	
	    /**
	     * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.
	     *
	     * @member {number}
	     * @private
	     * @default 0xFFFFFF
	     */
	    this._prevTint = 0xFFFFFF;
	
	    /**
	     * The blend mode to be applied to the graphic shape. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
	     *
	     * @member {number}
	     * @default PIXI.BLEND_MODES.NORMAL;
	     * @see PIXI.BLEND_MODES
	     */
	    this.blendMode = CONST.BLEND_MODES.NORMAL;
	
	    /**
	     * Current path
	     *
	     * @member {PIXI.GraphicsData}
	     * @private
	     */
	    this.currentPath = null;
	
	    /**
	     * Array containing some WebGL-related properties used by the WebGL renderer.
	     *
	     * @member {object<number, object>}
	     * @private
	     */
	    // TODO - _webgl should use a prototype object, not a random undocumented object...
	    this._webGL = {};
	
	    /**
	     * Whether this shape is being used as a mask.
	     *
	     * @member {boolean}
	     */
	    this.isMask = false;
	
	    /**
	     * The bounds' padding used for bounds calculation.
	     *
	     * @member {number}
	     */
	    this.boundsPadding = 0;
	
	    /**
	     * A cache of the local bounds to prevent recalculation.
	     *
	     * @member {PIXI.Rectangle}
	     * @private
	     */
	    this._localBounds = new math.Rectangle(0,0,1,1);
	
	    /**
	     * Used to detect if the graphics object has changed. If this is set to true then the graphics
	     * object will be recalculated.
	     *
	     * @member {boolean}
	     * @private
	     */
	    this.dirty = true;
	
	    /**
	     * Used to detect if the WebGL graphics object has changed. If this is set to true then the
	     * graphics object will be recalculated.
	     *
	     * @member {boolean}
	     * @private
	     */
	    this.glDirty = false;
	
	    this.boundsDirty = true;
	
	    /**
	     * Used to detect if the cached sprite object needs to be updated.
	     *
	     * @member {boolean}
	     * @private
	     */
	    this.cachedSpriteDirty = false;
	
	    /**
	     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
	     * This is useful if your graphics element does not change often, as it will speed up the rendering
	     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
	     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
	     * you are constantly redrawing the graphics element.
	     *
	     * @name cacheAsBitmap
	     * @member {boolean}
	     * @memberof PIXI.Graphics#
	     * @default false
	     */
	}
	
	// constructor
	Graphics.prototype = Object.create(Container.prototype);
	Graphics.prototype.constructor = Graphics;
	module.exports = Graphics;
	
	/**
	 * Creates a new Graphics object with the same values as this one.
	 * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
	 *
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.clone = function ()
	{
	    var clone = new Graphics();
	
	    clone.renderable    = this.renderable;
	    clone.fillAlpha     = this.fillAlpha;
	    clone.lineWidth     = this.lineWidth;
	    clone.lineColor     = this.lineColor;
	    clone.tint          = this.tint;
	    clone.blendMode     = this.blendMode;
	    clone.isMask        = this.isMask;
	    clone.boundsPadding = this.boundsPadding;
	    clone.dirty         = true;
	    clone.glDirty       = true;
	    clone.cachedSpriteDirty = this.cachedSpriteDirty;
	
	    // copy graphics data
	    for (var i = 0; i < this.graphicsData.length; ++i)
	    {
	        clone.graphicsData.push(this.graphicsData[i].clone());
	    }
	
	    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];
	
	    clone.updateLocalBounds();
	
	    return clone;
	};
	
	/**
	 * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
	 *
	 * @param lineWidth {number} width of the line to draw, will update the objects stored style
	 * @param color {number} color of the line to draw, will update the objects stored style
	 * @param alpha {number} alpha of the line to draw, will update the objects stored style
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.lineStyle = function (lineWidth, color, alpha)
	{
	    this.lineWidth = lineWidth || 0;
	    this.lineColor = color || 0;
	    this.lineAlpha = (alpha === undefined) ? 1 : alpha;
	
	    if (this.currentPath)
	    {
	        if (this.currentPath.shape.points.length)
	        {
	            // halfway through a line? start a new one!
	            var shape = new math.Polygon(this.currentPath.shape.points.slice(-2));
	            shape.closed = false;
	            this.drawShape(shape);
	        }
	        else
	        {
	            // otherwise its empty so lets just set the line properties
	            this.currentPath.lineWidth = this.lineWidth;
	            this.currentPath.lineColor = this.lineColor;
	            this.currentPath.lineAlpha = this.lineAlpha;
	        }
	    }
	
	    return this;
	};
	
	/**
	 * Moves the current drawing position to x, y.
	 *
	 * @param x {number} the X coordinate to move to
	 * @param y {number} the Y coordinate to move to
	 * @return {PIXI.Graphics}
	  */
	Graphics.prototype.moveTo = function (x, y)
	{
	    var shape = new math.Polygon([x,y]);
	    shape.closed = false;
	    this.drawShape(shape);
	
	    return this;
	};
	
	/**
	 * Draws a line using the current line style from the current drawing position to (x, y);
	 * The current drawing position is then set to (x, y).
	 *
	 * @param x {number} the X coordinate to draw to
	 * @param y {number} the Y coordinate to draw to
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.lineTo = function (x, y)
	{
	    this.currentPath.shape.points.push(x, y);
	    this.dirty = true;
	
	    return this;
	};
	
	/**
	 * Calculate the points for a quadratic bezier curve and then draws it.
	 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
	 *
	 * @param cpX {number} Control point x
	 * @param cpY {number} Control point y
	 * @param toX {number} Destination point x
	 * @param toY {number} Destination point y
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY)
	{
	    if (this.currentPath)
	    {
	        if (this.currentPath.shape.points.length === 0)
	        {
	            this.currentPath.shape.points = [0, 0];
	        }
	    }
	    else
	    {
	        this.moveTo(0,0);
	    }
	
	    var xa,
	        ya,
	        n = 20,
	        points = this.currentPath.shape.points;
	
	    if (points.length === 0)
	    {
	        this.moveTo(0, 0);
	    }
	
	    var fromX = points[points.length-2];
	    var fromY = points[points.length-1];
	
	    var j = 0;
	    for (var i = 1; i <= n; ++i)
	    {
	        j = i / n;
	
	        xa = fromX + ( (cpX - fromX) * j );
	        ya = fromY + ( (cpY - fromY) * j );
	
	        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),
	                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );
	    }
	
	    this.dirty = this.boundsDirty = true;
	
	    return this;
	};
	
	/**
	 * Calculate the points for a bezier curve and then draws it.
	 *
	 * @param cpX {number} Control point x
	 * @param cpY {number} Control point y
	 * @param cpX2 {number} Second Control point x
	 * @param cpY2 {number} Second Control point y
	 * @param toX {number} Destination point x
	 * @param toY {number} Destination point y
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY)
	{
	    if (this.currentPath)
	    {
	        if (this.currentPath.shape.points.length === 0)
	        {
	            this.currentPath.shape.points = [0, 0];
	        }
	    }
	    else
	    {
	        this.moveTo(0,0);
	    }
	
	    var n = 20,
	        dt,
	        dt2,
	        dt3,
	        t2,
	        t3,
	        points = this.currentPath.shape.points;
	
	    var fromX = points[points.length-2];
	    var fromY = points[points.length-1];
	
	    var j = 0;
	
	    for (var i = 1; i <= n; ++i)
	    {
	        j = i / n;
	
	        dt = (1 - j);
	        dt2 = dt * dt;
	        dt3 = dt2 * dt;
	
	        t2 = j * j;
	        t3 = t2 * j;
	
	        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
	                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
	    }
	
	    this.dirty = this.boundsDirty = true;
	
	    return this;
	};
	
	/**
	 * The arcTo() method creates an arc/curve between two tangents on the canvas.
	 *
	 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
	 *
	 * @param x1 {number} The x-coordinate of the beginning of the arc
	 * @param y1 {number} The y-coordinate of the beginning of the arc
	 * @param x2 {number} The x-coordinate of the end of the arc
	 * @param y2 {number} The y-coordinate of the end of the arc
	 * @param radius {number} The radius of the arc
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius)
	{
	    if (this.currentPath)
	    {
	        if (this.currentPath.shape.points.length === 0)
	        {
	            this.currentPath.shape.points.push(x1, y1);
	        }
	    }
	    else
	    {
	        this.moveTo(x1, y1);
	    }
	
	    var points = this.currentPath.shape.points,
	        fromX = points[points.length-2],
	        fromY = points[points.length-1],
	        a1 = fromY - y1,
	        b1 = fromX - x1,
	        a2 = y2   - y1,
	        b2 = x2   - x1,
	        mm = Math.abs(a1 * b2 - b1 * a2);
	
	    if (mm < 1.0e-8 || radius === 0)
	    {
	        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)
	        {
	            points.push(x1, y1);
	        }
	    }
	    else
	    {
	        var dd = a1 * a1 + b1 * b1,
	            cc = a2 * a2 + b2 * b2,
	            tt = a1 * a2 + b1 * b2,
	            k1 = radius * Math.sqrt(dd) / mm,
	            k2 = radius * Math.sqrt(cc) / mm,
	            j1 = k1 * tt / dd,
	            j2 = k2 * tt / cc,
	            cx = k1 * b2 + k2 * b1,
	            cy = k1 * a2 + k2 * a1,
	            px = b1 * (k2 + j1),
	            py = a1 * (k2 + j1),
	            qx = b2 * (k1 + j2),
	            qy = a2 * (k1 + j2),
	            startAngle = Math.atan2(py - cy, px - cx),
	            endAngle   = Math.atan2(qy - cy, qx - cx);
	
	        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
	    }
	
	    this.dirty = this.boundsDirty = true;
	
	    return this;
	};
	
	/**
	 * The arc method creates an arc/curve (used to create circles, or parts of circles).
	 *
	 * @param cx {number} The x-coordinate of the center of the circle
	 * @param cy {number} The y-coordinate of the center of the circle
	 * @param radius {number} The radius of the circle
	 * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
	 * @param endAngle {number} The ending angle, in radians
	 * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)
	{
	    anticlockwise = anticlockwise || false;
	
	    if (startAngle === endAngle)
	    {
	        return this;
	    }
	
	    if( !anticlockwise && endAngle <= startAngle )
	    {
	        endAngle += Math.PI * 2;
	    }
	    else if( anticlockwise && startAngle <= endAngle )
	    {
	        startAngle += Math.PI * 2;
	    }
	
	    var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);
	    var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;
	
	    if(sweep === 0)
	    {
	        return this;
	    }
	
	    var startX = cx + Math.cos(startAngle) * radius;
	    var startY = cy + Math.sin(startAngle) * radius;
	
	    if (this.currentPath)
	    {
	        this.currentPath.shape.points.push(startX, startY);
	    }
	    else
	    {
	        this.moveTo(startX, startY);
	    }
	
	    var points = this.currentPath.shape.points;
	
	    var theta = sweep/(segs*2);
	    var theta2 = theta*2;
	
	    var cTheta = Math.cos(theta);
	    var sTheta = Math.sin(theta);
	
	    var segMinus = segs - 1;
	
	    var remainder = ( segMinus % 1 ) / segMinus;
	
	    for(var i=0; i<=segMinus; i++)
	    {
	        var real =  i + remainder * i;
	
	
	        var angle = ((theta) + startAngle + (theta2 * real));
	
	        var c = Math.cos(angle);
	        var s = -Math.sin(angle);
	
	        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,
	                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);
	    }
	
	    this.dirty = this.boundsDirty = true;
	
	    return this;
	};
	
	/**
	 * Specifies a simple one-color fill that subsequent calls to other Graphics methods
	 * (such as lineTo() or drawCircle()) use when drawing.
	 *
	 * @param color {number} the color of the fill
	 * @param alpha {number} the alpha of the fill
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.beginFill = function (color, alpha)
	{
	    this.filling = true;
	    this.fillColor = color || 0;
	    this.fillAlpha = (alpha === undefined) ? 1 : alpha;
	
	    if (this.currentPath)
	    {
	        if (this.currentPath.shape.points.length <= 2)
	        {
	            this.currentPath.fill = this.filling;
	            this.currentPath.fillColor = this.fillColor;
	            this.currentPath.fillAlpha = this.fillAlpha;
	        }
	    }
	    return this;
	};
	
	/**
	 * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
	 *
	 * @return {Graphics}
	 */
	Graphics.prototype.endFill = function ()
	{
	    this.filling = false;
	    this.fillColor = null;
	    this.fillAlpha = 1;
	
	    return this;
	};
	
	/**
	 *
	 * @param x {number} The X coord of the top-left of the rectangle
	 * @param y {number} The Y coord of the top-left of the rectangle
	 * @param width {number} The width of the rectangle
	 * @param height {number} The height of the rectangle
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.drawRect = function ( x, y, width, height )
	{
	    this.drawShape(new math.Rectangle(x,y, width, height));
	
	    return this;
	};
	
	/**
	 *
	 * @param x {number} The X coord of the top-left of the rectangle
	 * @param y {number} The Y coord of the top-left of the rectangle
	 * @param width {number} The width of the rectangle
	 * @param height {number} The height of the rectangle
	 * @param radius {number} Radius of the rectangle corners
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.drawRoundedRect = function ( x, y, width, height, radius )
	{
	    this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));
	
	    return this;
	};
	
	/**
	 * Draws a circle.
	 *
	 * @param x {number} The X coordinate of the center of the circle
	 * @param y {number} The Y coordinate of the center of the circle
	 * @param radius {number} The radius of the circle
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.drawCircle = function (x, y, radius)
	{
	    this.drawShape(new math.Circle(x,y, radius));
	
	    return this;
	};
	
	/**
	 * Draws an ellipse.
	 *
	 * @param x {number} The X coordinate of the center of the ellipse
	 * @param y {number} The Y coordinate of the center of the ellipse
	 * @param width {number} The half width of the ellipse
	 * @param height {number} The half height of the ellipse
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.drawEllipse = function (x, y, width, height)
	{
	    this.drawShape(new math.Ellipse(x, y, width, height));
	
	    return this;
	};
	
	/**
	 * Draws a polygon using the given path.
	 *
	 * @param path {number[]|PIXI.Point[]} The path data used to construct the polygon.
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.drawPolygon = function (path)
	{
	    // prevents an argument assignment deopt
	    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
	    var points = path;
	
	    var closed = true;
	
	    if (points instanceof math.Polygon)
	    {
	        closed = points.closed;
	        points = points.points;
	    }
	
	    if (!Array.isArray(points))
	    {
	        // prevents an argument leak deopt
	        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
	        points = new Array(arguments.length);
	
	        for (var i = 0; i < points.length; ++i)
	        {
	            points[i] = arguments[i];
	        }
	    }
	
	    var shape = new math.Polygon(points);
	    shape.closed = closed;
	
	    this.drawShape(shape);
	
	    return this;
	};
	
	/**
	 * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
	 *
	 * @return {PIXI.Graphics}
	 */
	Graphics.prototype.clear = function ()
	{
	    this.lineWidth = 0;
	    this.filling = false;
	
	    this.dirty = true;
	    this.clearDirty = true;
	    this.graphicsData = [];
	
	    return this;
	};
	
	/**
	 * Useful function that returns a texture of the graphics object that can then be used to create sprites
	 * This can be quite useful if your geometry is complicated and needs to be reused multiple times.
	 *
	 * @param resolution {number} The resolution of the texture being generated
	 * @param scaleMode {number} Should be one of the scaleMode consts
	 * @return {PIXI.Texture} a texture of the graphics object
	 */
	Graphics.prototype.generateTexture = function (renderer, resolution, scaleMode)
	{
	
	    resolution = resolution || 1;
	
	    var bounds = this.getLocalBounds();
	
	    var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);
	
	    var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);
	    texture.baseTexture.resolution = resolution;
	
	    canvasBuffer.context.scale(resolution, resolution);
	
	    canvasBuffer.context.translate(-bounds.x,-bounds.y);
	
	    CanvasGraphics.renderGraphics(this, canvasBuffer.context);
	
	    return texture;
	};
	
	/**
	 * Renders the object using the WebGL renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer}
	 * @private
	 */
	Graphics.prototype._renderWebGL = function (renderer)
	{
	    // if the sprite is not visible or the alpha is 0 then no need to render this element
	
	    // this code may still be needed so leaving for now..
	    //
	    /*
	    if (this._cacheAsBitmap)
	    {
	        if (this.dirty || this.cachedSpriteDirty)
	        {
	            this._generateCachedSprite();
	
	            // we will also need to update the texture on the gpu too!
	            this.updateCachedSpriteTexture();
	
	            this.cachedSpriteDirty = false;
	            this.dirty = false;
	        }
	
	        this._cachedSprite.worldAlpha = this.worldAlpha;
	
	        Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);
	
	        return;
	    }
	
	    */
	
	    if (this.glDirty)
	    {
	        this.dirty = true;
	        this.glDirty = false;
	    }
	
	    renderer.setObjectRenderer(renderer.plugins.graphics);
	    renderer.plugins.graphics.render(this);
	
	};
	
	/**
	 * Renders the object using the Canvas renderer
	 *
	 * @param renderer {PIXI.CanvasRenderer}
	 * @private
	 */
	Graphics.prototype._renderCanvas = function (renderer)
	{
	    if (this.isMask === true)
	    {
	        return;
	    }
	
	    // if the tint has changed, set the graphics object to dirty.
	    if (this._prevTint !== this.tint) {
	        this.dirty = true;
	    }
	
	    // this code may still be needed so leaving for now..
	    //
	    /*
	    if (this._cacheAsBitmap)
	    {
	        if (this.dirty || this.cachedSpriteDirty)
	        {
	            this._generateCachedSprite();
	
	            // we will also need to update the texture
	            this.updateCachedSpriteTexture();
	
	            this.cachedSpriteDirty = false;
	            this.dirty = false;
	        }
	
	        this._cachedSprite.alpha = this.alpha;
	
	        Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);
	
	        return;
	    }
	    */
	    var context = renderer.context;
	    var transform = this.worldTransform;
	
	    var compositeOperation = renderer.blendModes[this.blendMode];
	    if (compositeOperation !== context.globalCompositeOperation)
	    {
	        context.globalCompositeOperation = compositeOperation;
	    }
	
	    var resolution = renderer.resolution;
	    context.setTransform(
	        transform.a * resolution,
	        transform.b * resolution,
	        transform.c * resolution,
	        transform.d * resolution,
	        transform.tx * resolution,
	        transform.ty * resolution
	    );
	
	    CanvasGraphics.renderGraphics(this, context);
	};
	
	/**
	 * Retrieves the bounds of the graphic shape as a rectangle object
	 *
	 * @param [matrix] {PIXI.Matrix} The world transform matrix to use, defaults to this
	 *  object's worldTransform.
	 * @return {PIXI.Rectangle} the rectangular bounding area
	 */
	Graphics.prototype.getBounds = function (matrix)
	{
	    if(!this._currentBounds)
	    {
	
	        // return an empty object if the item is a mask!
	        if (!this.renderable)
	        {
	            return math.Rectangle.EMPTY;
	        }
	
	        if (this.boundsDirty)
	        {
	            this.updateLocalBounds();
	
	            this.glDirty = true;
	            this.cachedSpriteDirty = true;
	            this.boundsDirty = false;
	        }
	
	        var bounds = this._localBounds;
	
	        var w0 = bounds.x;
	        var w1 = bounds.width + bounds.x;
	
	        var h0 = bounds.y;
	        var h1 = bounds.height + bounds.y;
	
	        var worldTransform = matrix || this.worldTransform;
	
	        var a = worldTransform.a;
	        var b = worldTransform.b;
	        var c = worldTransform.c;
	        var d = worldTransform.d;
	        var tx = worldTransform.tx;
	        var ty = worldTransform.ty;
	
	        var x1 = a * w1 + c * h1 + tx;
	        var y1 = d * h1 + b * w1 + ty;
	
	        var x2 = a * w0 + c * h1 + tx;
	        var y2 = d * h1 + b * w0 + ty;
	
	        var x3 = a * w0 + c * h0 + tx;
	        var y3 = d * h0 + b * w0 + ty;
	
	        var x4 =  a * w1 + c * h0 + tx;
	        var y4 =  d * h0 + b * w1 + ty;
	
	        var maxX = x1;
	        var maxY = y1;
	
	        var minX = x1;
	        var minY = y1;
	
	        minX = x2 < minX ? x2 : minX;
	        minX = x3 < minX ? x3 : minX;
	        minX = x4 < minX ? x4 : minX;
	
	        minY = y2 < minY ? y2 : minY;
	        minY = y3 < minY ? y3 : minY;
	        minY = y4 < minY ? y4 : minY;
	
	        maxX = x2 > maxX ? x2 : maxX;
	        maxX = x3 > maxX ? x3 : maxX;
	        maxX = x4 > maxX ? x4 : maxX;
	
	        maxY = y2 > maxY ? y2 : maxY;
	        maxY = y3 > maxY ? y3 : maxY;
	        maxY = y4 > maxY ? y4 : maxY;
	
	        this._bounds.x = minX;
	        this._bounds.width = maxX - minX;
	
	        this._bounds.y = minY;
	        this._bounds.height = maxY - minY;
	
	        this._currentBounds = this._bounds;
	    }
	
	    return this._currentBounds;
	};
	
	/**
	* Tests if a point is inside this graphics object
	*
	* @param point {PIXI.Point} the point to test
	* @return {boolean} the result of the test
	*/
	Graphics.prototype.containsPoint = function( point )
	{
	    this.worldTransform.applyInverse(point,  tempPoint);
	
	    var graphicsData = this.graphicsData;
	
	    for (var i = 0; i < graphicsData.length; i++)
	    {
	        var data = graphicsData[i];
	
	        if (!data.fill)
	        {
	            continue;
	        }
	
	        // only deal with fills..
	        if (data.shape)
	        {
	            if ( data.shape.contains( tempPoint.x, tempPoint.y ) )
	            {
	                return true;
	            }
	        }
	    }
	
	    return false;
	};
	
	/**
	 * Update the bounds of the object
	 *
	 */
	Graphics.prototype.updateLocalBounds = function ()
	{
	    var minX = Infinity;
	    var maxX = -Infinity;
	
	    var minY = Infinity;
	    var maxY = -Infinity;
	
	    if (this.graphicsData.length)
	    {
	        var shape, points, x, y, w, h;
	
	        for (var i = 0; i < this.graphicsData.length; i++)
	        {
	            var data = this.graphicsData[i];
	            var type = data.type;
	            var lineWidth = data.lineWidth;
	            shape = data.shape;
	
	            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC)
	            {
	                x = shape.x - lineWidth/2;
	                y = shape.y - lineWidth/2;
	                w = shape.width + lineWidth;
	                h = shape.height + lineWidth;
	
	                minX = x < minX ? x : minX;
	                maxX = x + w > maxX ? x + w : maxX;
	
	                minY = y < minY ? y : minY;
	                maxY = y + h > maxY ? y + h : maxY;
	            }
	            else if (type === CONST.SHAPES.CIRC)
	            {
	                x = shape.x;
	                y = shape.y;
	                w = shape.radius + lineWidth/2;
	                h = shape.radius + lineWidth/2;
	
	                minX = x - w < minX ? x - w : minX;
	                maxX = x + w > maxX ? x + w : maxX;
	
	                minY = y - h < minY ? y - h : minY;
	                maxY = y + h > maxY ? y + h : maxY;
	            }
	            else if (type === CONST.SHAPES.ELIP)
	            {
	                x = shape.x;
	                y = shape.y;
	                w = shape.width + lineWidth/2;
	                h = shape.height + lineWidth/2;
	
	                minX = x - w < minX ? x - w : minX;
	                maxX = x + w > maxX ? x + w : maxX;
	
	                minY = y - h < minY ? y - h : minY;
	                maxY = y + h > maxY ? y + h : maxY;
	            }
	            else
	            {
	                // POLY
	                points = shape.points;
	
	                for (var j = 0; j < points.length; j += 2)
	                {
	                    x = points[j];
	                    y = points[j+1];
	
	                    minX = x-lineWidth < minX ? x-lineWidth : minX;
	                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;
	
	                    minY = y-lineWidth < minY ? y-lineWidth : minY;
	                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;
	                }
	            }
	        }
	    }
	    else
	    {
	        minX = 0;
	        maxX = 0;
	        minY = 0;
	        maxY = 0;
	    }
	
	    var padding = this.boundsPadding;
	
	    this._localBounds.x = minX - padding;
	    this._localBounds.width = (maxX - minX) + padding * 2;
	
	    this._localBounds.y = minY - padding;
	    this._localBounds.height = (maxY - minY) + padding * 2;
	};
	
	/**
	 * Generates the cached sprite when the sprite has cacheAsBitmap = true
	 *
	 * @private
	 */
	/*
	Graphics.prototype._generateCachedSprite = function ()
	{
	    var bounds = this.getLocalBounds();
	
	    if (!this._cachedSprite)
	    {
	        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);
	        var texture = Texture.fromCanvas(canvasBuffer.canvas);
	
	        this._cachedSprite = new Sprite(texture);
	        this._cachedSprite.buffer = canvasBuffer;
	
	        this._cachedSprite.worldTransform = this.worldTransform;
	    }
	    else
	    {
	        this._cachedSprite.buffer.resize(bounds.width, bounds.height);
	    }
	
	    // leverage the anchor to account for the offset of the element
	    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
	    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );
	
	    // this._cachedSprite.buffer.context.save();
	    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);
	
	    // make sure we set the alpha of the graphics to 1 for the render..
	    this.worldAlpha = 1;
	
	    // now render the graphic..
	    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
	
	    this._cachedSprite.alpha = this.alpha;
	};
	*/
	/**
	 * Updates texture size based on canvas size
	 *
	 * @private
	 */
	/*
	Graphics.prototype.updateCachedSpriteTexture = function ()
	{
	    var cachedSprite = this._cachedSprite;
	    var texture = cachedSprite.texture;
	    var canvas = cachedSprite.buffer.canvas;
	
	    texture.baseTexture.width = canvas.width;
	    texture.baseTexture.height = canvas.height;
	    texture.crop.width = texture.frame.width = canvas.width;
	    texture.crop.height = texture.frame.height = canvas.height;
	
	    cachedSprite._width = canvas.width;
	    cachedSprite._height = canvas.height;
	
	    // update the dirty base textures
	    texture.baseTexture.dirty();
	};*/
	
	/**
	 * Destroys a previous cached sprite.
	 *
	 */
	/*
	Graphics.prototype.destroyCachedSprite = function ()
	{
	    this._cachedSprite.texture.destroy(true);
	
	    // let the gc collect the unused sprite
	    // TODO could be object pooled!
	    this._cachedSprite = null;
	};*/
	
	/**
	 * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param shape {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.
	 * @return {PIXI.GraphicsData} The generated GraphicsData object.
	 */
	Graphics.prototype.drawShape = function (shape)
	{
	    if (this.currentPath)
	    {
	        // check current path!
	        if (this.currentPath.shape.points.length <= 2)
	        {
	            this.graphicsData.pop();
	        }
	    }
	
	    this.currentPath = null;
	
	    var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);
	
	    this.graphicsData.push(data);
	
	    if (data.type === CONST.SHAPES.POLY)
	    {
	        data.shape.closed = data.shape.closed || this.filling;
	        this.currentPath = data;
	    }
	
	    this.dirty = this.boundsDirty = true;
	
	    return data;
	};
	
	/**
	 * Destroys the Graphics object.
	 */
	Graphics.prototype.destroy = function () {
	    Container.prototype.destroy.apply(this, arguments);
	
	    // destroy each of the GraphicsData objects
	    for (var i = 0; i < this.graphicsData.length; ++i) {
	        this.graphicsData[i].destroy();
	    }
	
	    // for each webgl data entry, destroy the WebGLGraphicsData
	    for (var id in this._webgl) {
	        for (var j = 0; j < this._webgl[id].data.length; ++j) {
	            this._webgl[id].data[j].destroy();
	        }
	    }
	
	    this.graphicsData = null;
	
	    this.currentPath = null;
	    this._webgl = null;
	    this._localBounds = null;
	};


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var CONST = __webpack_require__(14);
	
	/**
	 * A set of functions used by the canvas renderer to draw the primitive graphics data.
	 * @static
	 * @class
	 * @memberof PIXI
	 */
	var CanvasGraphics = {};
	module.exports = CanvasGraphics;
	
	/*
	 * Renders a Graphics object to a canvas.
	 *
	 * @param graphics {PIXI.Graphics} the actual graphics object to render
	 * @param context {CanvasRenderingContext2D} the 2d drawing method of the canvas
	 */
	CanvasGraphics.renderGraphics = function (graphics, context)
	{
	    var worldAlpha = graphics.worldAlpha;
	
	    if (graphics.dirty)
	    {
	        this.updateGraphicsTint(graphics);
	        graphics.dirty = false;
	    }
	
	    for (var i = 0; i < graphics.graphicsData.length; i++)
	    {
	        var data = graphics.graphicsData[i];
	        var shape = data.shape;
	
	        var fillColor = data._fillTint;
	        var lineColor = data._lineTint;
	
	        context.lineWidth = data.lineWidth;
	
	        if (data.type === CONST.SHAPES.POLY)
	        {
	            context.beginPath();
	
	            var points = shape.points;
	
	            context.moveTo(points[0], points[1]);
	
	            for (var j=1; j < points.length/2; j++)
	            {
	                context.lineTo(points[j * 2], points[j * 2 + 1]);
	            }
	
	            if (shape.closed)
	            {
	                context.lineTo(points[0], points[1]);
	            }
	
	            // if the first and last point are the same close the path - much neater :)
	            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
	            {
	                context.closePath();
	            }
	
	            if (data.fill)
	            {
	                context.globalAlpha = data.fillAlpha * worldAlpha;
	                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
	                context.fill();
	            }
	            if (data.lineWidth)
	            {
	                context.globalAlpha = data.lineAlpha * worldAlpha;
	                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
	                context.stroke();
	            }
	        }
	        else if (data.type === CONST.SHAPES.RECT)
	        {
	
	            if (data.fillColor || data.fillColor === 0)
	            {
	                context.globalAlpha = data.fillAlpha * worldAlpha;
	                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
	                context.fillRect(shape.x, shape.y, shape.width, shape.height);
	
	            }
	            if (data.lineWidth)
	            {
	                context.globalAlpha = data.lineAlpha * worldAlpha;
	                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
	                context.strokeRect(shape.x, shape.y, shape.width, shape.height);
	            }
	        }
	        else if (data.type === CONST.SHAPES.CIRC)
	        {
	            // TODO - need to be Undefined!
	            context.beginPath();
	            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);
	            context.closePath();
	
	            if (data.fill)
	            {
	                context.globalAlpha = data.fillAlpha * worldAlpha;
	                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
	                context.fill();
	            }
	            if (data.lineWidth)
	            {
	                context.globalAlpha = data.lineAlpha * worldAlpha;
	                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
	                context.stroke();
	            }
	        }
	        else if (data.type === CONST.SHAPES.ELIP)
	        {
	            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
	
	            var w = shape.width * 2;
	            var h = shape.height * 2;
	
	            var x = shape.x - w/2;
	            var y = shape.y - h/2;
	
	            context.beginPath();
	
	            var kappa = 0.5522848,
	                ox = (w / 2) * kappa, // control point offset horizontal
	                oy = (h / 2) * kappa, // control point offset vertical
	                xe = x + w,           // x-end
	                ye = y + h,           // y-end
	                xm = x + w / 2,       // x-middle
	                ym = y + h / 2;       // y-middle
	
	            context.moveTo(x, ym);
	            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
	            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
	            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
	            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
	
	            context.closePath();
	
	            if (data.fill)
	            {
	                context.globalAlpha = data.fillAlpha * worldAlpha;
	                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
	                context.fill();
	            }
	            if (data.lineWidth)
	            {
	                context.globalAlpha = data.lineAlpha * worldAlpha;
	                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
	                context.stroke();
	            }
	        }
	        else if (data.type === CONST.SHAPES.RREC)
	        {
	            var rx = shape.x;
	            var ry = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var radius = shape.radius;
	
	            var maxRadius = Math.min(width, height) / 2 | 0;
	            radius = radius > maxRadius ? maxRadius : radius;
	
	            context.beginPath();
	            context.moveTo(rx, ry + radius);
	            context.lineTo(rx, ry + height - radius);
	            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
	            context.lineTo(rx + width - radius, ry + height);
	            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
	            context.lineTo(rx + width, ry + radius);
	            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
	            context.lineTo(rx + radius, ry);
	            context.quadraticCurveTo(rx, ry, rx, ry + radius);
	            context.closePath();
	
	            if (data.fillColor || data.fillColor === 0)
	            {
	                context.globalAlpha = data.fillAlpha * worldAlpha;
	                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
	                context.fill();
	
	            }
	            if (data.lineWidth)
	            {
	                context.globalAlpha = data.lineAlpha * worldAlpha;
	                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
	                context.stroke();
	            }
	        }
	    }
	};
	
	/*
	 * Renders a graphics mask
	 *
	 * @private
	 * @param graphics {PIXI.Graphics} the graphics which will be used as a mask
	 * @param context {CanvasRenderingContext2D} the context 2d method of the canvas
	 */
	CanvasGraphics.renderGraphicsMask = function (graphics, context)
	{
	    var len = graphics.graphicsData.length;
	
	    if (len === 0)
	    {
	        return;
	    }
	
	    context.beginPath();
	
	    for (var i = 0; i < len; i++)
	    {
	        var data = graphics.graphicsData[i];
	        var shape = data.shape;
	
	        if (data.type === CONST.SHAPES.POLY)
	        {
	
	            var points = shape.points;
	
	            context.moveTo(points[0], points[1]);
	
	            for (var j=1; j < points.length/2; j++)
	            {
	                context.lineTo(points[j * 2], points[j * 2 + 1]);
	            }
	
	            // if the first and last point are the same close the path - much neater :)
	            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
	            {
	                context.closePath();
	            }
	
	        }
	        else if (data.type === CONST.SHAPES.RECT)
	        {
	            context.rect(shape.x, shape.y, shape.width, shape.height);
	            context.closePath();
	        }
	        else if (data.type === CONST.SHAPES.CIRC)
	        {
	            // TODO - need to be Undefined!
	            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
	            context.closePath();
	        }
	        else if (data.type === CONST.SHAPES.ELIP)
	        {
	
	            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
	
	            var w = shape.width * 2;
	            var h = shape.height * 2;
	
	            var x = shape.x - w/2;
	            var y = shape.y - h/2;
	
	            var kappa = 0.5522848,
	                ox = (w / 2) * kappa, // control point offset horizontal
	                oy = (h / 2) * kappa, // control point offset vertical
	                xe = x + w,           // x-end
	                ye = y + h,           // y-end
	                xm = x + w / 2,       // x-middle
	                ym = y + h / 2;       // y-middle
	
	            context.moveTo(x, ym);
	            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
	            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
	            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
	            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
	            context.closePath();
	        }
	        else if (data.type === CONST.SHAPES.RREC)
	        {
	
	            var rx = shape.x;
	            var ry = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var radius = shape.radius;
	
	            var maxRadius = Math.min(width, height) / 2 | 0;
	            radius = radius > maxRadius ? maxRadius : radius;
	
	            context.moveTo(rx, ry + radius);
	            context.lineTo(rx, ry + height - radius);
	            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
	            context.lineTo(rx + width - radius, ry + height);
	            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
	            context.lineTo(rx + width, ry + radius);
	            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
	            context.lineTo(rx + radius, ry);
	            context.quadraticCurveTo(rx, ry, rx, ry + radius);
	            context.closePath();
	        }
	    }
	};
	
	/*
	 * Updates the tint of a graphics object
	 *
	 * @private
	 * @param graphics {PIXI.Graphics} the graphics that will have its tint updated
	 *
	 */
	CanvasGraphics.updateGraphicsTint = function (graphics)
	{
	    if (graphics.tint === 0xFFFFFF && graphics._prevTint === graphics.tint)
	    {
	        return;
	    }
	    graphics._prevTint = graphics.tint;
	
	    var tintR = (graphics.tint >> 16 & 0xFF) / 255;
	    var tintG = (graphics.tint >> 8 & 0xFF) / 255;
	    var tintB = (graphics.tint & 0xFF)/ 255;
	
	    for (var i = 0; i < graphics.graphicsData.length; i++)
	    {
	        var data = graphics.graphicsData[i];
	
	        var fillColor = data.fillColor | 0;
	        var lineColor = data.lineColor | 0;
	
	        /*
	        var colorR = (fillColor >> 16 & 0xFF) / 255;
	        var colorG = (fillColor >> 8 & 0xFF) / 255;
	        var colorB = (fillColor & 0xFF) / 255;
	
	        colorR *= tintR;
	        colorG *= tintG;
	        colorB *= tintB;
	
	        fillColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);
	
	        colorR = (lineColor >> 16 & 0xFF) / 255;
	        colorG = (lineColor >> 8 & 0xFF) / 255;
	        colorB = (lineColor & 0xFF) / 255;
	
	        colorR *= tintR;
	        colorG *= tintG;
	        colorB *= tintB;
	
	        lineColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);
	        */
	
	        // super inline cos im an optimization NAZI :)
	        data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (fillColor & 0xFF) / 255 * tintB*255);
	        data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (lineColor & 0xFF) / 255 * tintB*255);
	
	    }
	};
	


/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * A GraphicsData object.
	 *
	 * @class
	 * @memberof PIXI
	 * @param lineWidth {number} the width of the line to draw
	 * @param lineColor {number} the color of the line to draw
	 * @param lineAlpha {number} the alpha of the line to draw
	 * @param fillColor {number} the color of the fill
	 * @param fillAlpha {number} the alpha of the fill
	 * @param fill      {boolean} whether or not the shape is filled with a colour
	 * @param shape     {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.
	 */
	function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape)
	{
	    /*
	     * @member {number} the width of the line to draw
	     */
	    this.lineWidth = lineWidth;
	
	    /*
	     * @member {number} the color of the line to draw
	     */
	    this.lineColor = lineColor;
	    /*
	     * @member {number} the alpha of the line to draw
	     */
	    this.lineAlpha = lineAlpha;
	    /*
	     * @member {number} cached tint of the line to draw
	     */
	    this._lineTint = lineColor;
	
	    /*
	     * @member {number} the color of the fill
	     */
	    this.fillColor = fillColor;
	
	    /*
	     * @member {number} the alpha of the fill
	     */
	    this.fillAlpha = fillAlpha;
	
	    /*
	     * @member {number} cached tint of the fill
	     */
	    this._fillTint = fillColor;
	
	    /*
	     * @member {boolean} whether or not the shape is filled with a colour
	     */
	    this.fill = fill;
	
	    /*
	     * @member {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Line|PIXI.Polygon} The shape object to draw.
	     */
	    this.shape = shape;
	
	    /*
	     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,
	     */
	    this.type = shape.type;
	}
	
	GraphicsData.prototype.constructor = GraphicsData;
	module.exports = GraphicsData;
	
	/**
	 * Creates a new GraphicsData object with the same values as this one.
	 *
	 * @return {PIXI.GraphicsData}
	 */
	GraphicsData.prototype.clone = function ()
	{
	    return new GraphicsData(
	        this.lineWidth,
	        this.lineColor,
	        this.lineAlpha,
	        this.fillColor,
	        this.fillAlpha,
	        this.fill,
	        this.shape
	    );
	};
	
	/**
	 * Destroys the Graphics data.
	 */
	GraphicsData.prototype.destroy = function () {
	    this.shape = null;
	};


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(24),
	    math = __webpack_require__(15),
	    CONST = __webpack_require__(14),
	    ObjectRenderer = __webpack_require__(50),
	    WebGLRenderer = __webpack_require__(51),
	    WebGLGraphicsData = __webpack_require__(72),
	    earcut = __webpack_require__(73);
	
	/**
	 * Renders the graphics object.
	 *
	 * @class
	 * @private
	 * @memberof PIXI
	 * @extends PIXI.ObjectRenderer
	 * @param renderer {PIXI.WebGLRenderer} The renderer this object renderer works for.
	 */
	function GraphicsRenderer(renderer)
	{
	    ObjectRenderer.call(this, renderer);
	
	    this.graphicsDataPool = [];
	
	    this.primitiveShader = null;
	    this.complexPrimitiveShader = null;
	
	    /**
	     * This is the maximum number of points a poly can contain before it is rendered as a complex polygon (using the stencil buffer)
	     * @type {Number}
	     */
	    this.maximumSimplePolySize = 200;
	}
	
	GraphicsRenderer.prototype = Object.create(ObjectRenderer.prototype);
	GraphicsRenderer.prototype.constructor = GraphicsRenderer;
	module.exports = GraphicsRenderer;
	
	WebGLRenderer.registerPlugin('graphics', GraphicsRenderer);
	
	/**
	 * Called when there is a WebGL context change
	 *
	 * @private
	 *
	 */
	GraphicsRenderer.prototype.onContextChange = function()
	{
	
	};
	
	/**
	 * Destroys this renderer.
	 *
	 */
	GraphicsRenderer.prototype.destroy = function () {
	    ObjectRenderer.prototype.destroy.call(this);
	
	    for (var i = 0; i < this.graphicsDataPool.length; ++i) {
	        this.graphicsDataPool[i].destroy();
	    }
	
	    this.graphicsDataPool = null;
	};
	
	/**
	 * Renders a graphics object.
	 *
	 * @param graphics {PIXI.Graphics} The graphics object to render.
	 */
	GraphicsRenderer.prototype.render = function(graphics)
	{
	    var renderer = this.renderer;
	    var gl = renderer.gl;
	
	    var shader = renderer.shaderManager.plugins.primitiveShader,
	        webGLData;
	
	    if (graphics.dirty || !graphics._webGL[gl.id])
	    {
	        this.updateGraphics(graphics);
	    }
	
	    var webGL = graphics._webGL[gl.id];
	
	    // This  could be speeded up for sure!
	
	    renderer.blendModeManager.setBlendMode( graphics.blendMode );
	
	//    var matrix =  graphics.worldTransform.clone();
	//    var matrix =  renderer.currentRenderTarget.projectionMatrix.clone();
	//    matrix.append(graphics.worldTransform);
	
	    for (var i = 0, n = webGL.data.length; i < n; i++)
	    {
	        webGLData = webGL.data[i];
	
	        if (webGL.data[i].mode === 1)
	        {
	
	            renderer.stencilManager.pushStencil(graphics, webGLData);
	
	            gl.uniform1f(renderer.shaderManager.complexPrimitiveShader.uniforms.alpha._location, graphics.worldAlpha * webGLData.alpha);
	
	            // render quad..
	            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
	
	            renderer.stencilManager.popStencil(graphics, webGLData);
	        }
	        else
	        {
	
	            shader = renderer.shaderManager.primitiveShader;
	
	            renderer.shaderManager.setShader( shader );//activatePrimitiveShader();
	
	            gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));
	
	            gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));
	
	            gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));
	
	            gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);
	
	
	            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
	
	            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
	            gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);
	
	            // set the index buffer!
	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
	            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
	        }
	
	        renderer.drawCount++;
	    }
	};
	
	/**
	 * Updates the graphics object
	 *
	 * @private
	 * @param graphics {PIXI.Graphics} The graphics object to update
	 */
	GraphicsRenderer.prototype.updateGraphics = function(graphics)
	{
	    var gl = this.renderer.gl;
	
	     // get the contexts graphics object
	    var webGL = graphics._webGL[gl.id];
	
	    // if the graphics object does not exist in the webGL context time to create it!
	    if (!webGL)
	    {
	        webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};
	    }
	
	    // flag the graphics as not dirty as we are about to update it...
	    graphics.dirty = false;
	
	    var i;
	
	    // if the user cleared the graphics object we will need to clear every object
	    if (graphics.clearDirty)
	    {
	        graphics.clearDirty = false;
	
	        // loop through and return all the webGLDatas to the object pool so than can be reused later on
	        for (i = 0; i < webGL.data.length; i++)
	        {
	            var graphicsData = webGL.data[i];
	            graphicsData.reset();
	            this.graphicsDataPool.push( graphicsData );
	        }
	
	        // clear the array and reset the index..
	        webGL.data = [];
	        webGL.lastIndex = 0;
	    }
	
	    var webGLData;
	
	    // loop through the graphics datas and construct each one..
	    // if the object is a complex fill then the new stencil buffer technique will be used
	    // other wise graphics objects will be pushed into a batch..
	    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)
	    {
	        var data = graphics.graphicsData[i];
	
	        if (data.type === CONST.SHAPES.POLY)
	        {
	            // need to add the points the the graphics object..
	            data.points = data.shape.points.slice();
	            if (data.shape.closed)
	            {
	                // close the poly if the value is true!
	                if (data.points[0] !== data.points[data.points.length-2] || data.points[1] !== data.points[data.points.length-1])
	                {
	                    data.points.push(data.points[0], data.points[1]);
	                }
	            }
	
	            // MAKE SURE WE HAVE THE CORRECT TYPE..
	            if (data.fill)
	            {
	                if (data.points.length >= 6)
	                {
	                    if (data.points.length < this.maximumSimplePolySize * 2)
	                    {
	                        webGLData = this.switchMode(webGL, 0);
	
	                        var canDrawUsingSimple = this.buildPoly(data, webGLData);
	
	                        if (!canDrawUsingSimple)
	                        {
	                            webGLData = this.switchMode(webGL, 1);
	                            this.buildComplexPoly(data, webGLData);
	                        }
	
	                    }
	                    else
	                    {
	                        webGLData = this.switchMode(webGL, 1);
	                        this.buildComplexPoly(data, webGLData);
	                    }
	                }
	            }
	
	            if (data.lineWidth > 0)
	            {
	                webGLData = this.switchMode(webGL, 0);
	                this.buildLine(data, webGLData);
	            }
	        }
	        else
	        {
	            webGLData = this.switchMode(webGL, 0);
	
	            if (data.type === CONST.SHAPES.RECT)
	            {
	                this.buildRectangle(data, webGLData);
	            }
	            else if (data.type === CONST.SHAPES.CIRC || data.type === CONST.SHAPES.ELIP)
	            {
	                this.buildCircle(data, webGLData);
	            }
	            else if (data.type === CONST.SHAPES.RREC)
	            {
	                this.buildRoundedRectangle(data, webGLData);
	            }
	        }
	
	        webGL.lastIndex++;
	    }
	
	    // upload all the dirty data...
	    for (i = 0; i < webGL.data.length; i++)
	    {
	        webGLData = webGL.data[i];
	
	        if (webGLData.dirty)
	        {
	            webGLData.upload();
	        }
	    }
	};
	
	/**
	 *
	 *
	 * @private
	 * @param webGL {WebGLRenderingContext} the current WebGL drawing context
	 * @param type {number} TODO @Alvin
	 */
	GraphicsRenderer.prototype.switchMode = function (webGL, type)
	{
	    var webGLData;
	
	    if (!webGL.data.length)
	    {
	        webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
	        webGLData.mode = type;
	        webGL.data.push(webGLData);
	    }
	    else
	    {
	        webGLData = webGL.data[webGL.data.length-1];
	
	        if ((webGLData.points.length > 320000) || webGLData.mode !== type || type === 1)
	        {
	            webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
	            webGLData.mode = type;
	            webGL.data.push(webGLData);
	        }
	    }
	
	    webGLData.dirty = true;
	
	    return webGLData;
	};
	
	/**
	 * Builds a rectangle to draw
	 *
	 * @private
	 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
	 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
	 */
	GraphicsRenderer.prototype.buildRectangle = function (graphicsData, webGLData)
	{
	    // --- //
	    // need to convert points to a nice regular data
	    //
	    var rectData = graphicsData.shape;
	    var x = rectData.x;
	    var y = rectData.y;
	    var width = rectData.width;
	    var height = rectData.height;
	
	    if (graphicsData.fill)
	    {
	        var color = utils.hex2rgb(graphicsData.fillColor);
	        var alpha = graphicsData.fillAlpha;
	
	        var r = color[0] * alpha;
	        var g = color[1] * alpha;
	        var b = color[2] * alpha;
	
	        var verts = webGLData.points;
	        var indices = webGLData.indices;
	
	        var vertPos = verts.length/6;
	
	        // start
	        verts.push(x, y);
	        verts.push(r, g, b, alpha);
	
	        verts.push(x + width, y);
	        verts.push(r, g, b, alpha);
	
	        verts.push(x , y + height);
	        verts.push(r, g, b, alpha);
	
	        verts.push(x + width, y + height);
	        verts.push(r, g, b, alpha);
	
	        // insert 2 dead triangles..
	        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);
	    }
	
	    if (graphicsData.lineWidth)
	    {
	        var tempPoints = graphicsData.points;
	
	        graphicsData.points = [x, y,
	                  x + width, y,
	                  x + width, y + height,
	                  x, y + height,
	                  x, y];
	
	
	        this.buildLine(graphicsData, webGLData);
	
	        graphicsData.points = tempPoints;
	    }
	};
	
	/**
	 * Builds a rounded rectangle to draw
	 *
	 * @private
	 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
	 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
	 */
	GraphicsRenderer.prototype.buildRoundedRectangle = function (graphicsData, webGLData)
	{
	    var rrectData = graphicsData.shape;
	    var x = rrectData.x;
	    var y = rrectData.y;
	    var width = rrectData.width;
	    var height = rrectData.height;
	
	    var radius = rrectData.radius;
	
	    var recPoints = [];
	    recPoints.push(x, y + radius);
	    this.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
	    this.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
	    this.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
	    this.quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);
	
	    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
	    // TODO - fix this properly, this is not very elegant.. but it works for now.
	
	    if (graphicsData.fill)
	    {
	        var color = utils.hex2rgb(graphicsData.fillColor);
	        var alpha = graphicsData.fillAlpha;
	
	        var r = color[0] * alpha;
	        var g = color[1] * alpha;
	        var b = color[2] * alpha;
	
	        var verts = webGLData.points;
	        var indices = webGLData.indices;
	
	        var vecPos = verts.length/6;
	
	        var triangles = earcut(recPoints, null, 2);
	
	        var i = 0;
	        for (i = 0; i < triangles.length; i+=3)
	        {
	            indices.push(triangles[i] + vecPos);
	            indices.push(triangles[i] + vecPos);
	            indices.push(triangles[i+1] + vecPos);
	            indices.push(triangles[i+2] + vecPos);
	            indices.push(triangles[i+2] + vecPos);
	        }
	
	        for (i = 0; i < recPoints.length; i++)
	        {
	            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
	        }
	    }
	
	    if (graphicsData.lineWidth)
	    {
	        var tempPoints = graphicsData.points;
	
	        graphicsData.points = recPoints;
	
	        this.buildLine(graphicsData, webGLData);
	
	        graphicsData.points = tempPoints;
	    }
	};
	
	/**
	 * Calculate the points for a quadratic bezier curve. (helper function..)
	 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
	 *
	 * @private
	 * @param fromX {number} Origin point x
	 * @param fromY {number} Origin point x
	 * @param cpX {number} Control point x
	 * @param cpY {number} Control point y
	 * @param toX {number} Destination point x
	 * @param toY {number} Destination point y
	 * @param [out] {number[]} The output array to add points into. If not passed, a new array is created.
	 * @return {number[]} an array of points
	 */
	GraphicsRenderer.prototype.quadraticBezierCurve = function (fromX, fromY, cpX, cpY, toX, toY, out)
	{
	    var xa,
	        ya,
	        xb,
	        yb,
	        x,
	        y,
	        n = 20,
	        points = out || [];
	
	    function getPt(n1 , n2, perc) {
	        var diff = n2 - n1;
	
	        return n1 + ( diff * perc );
	    }
	
	    var j = 0;
	    for (var i = 0; i <= n; i++ ) {
	        j = i / n;
	
	        // The Green Line
	        xa = getPt( fromX , cpX , j );
	        ya = getPt( fromY , cpY , j );
	        xb = getPt( cpX , toX , j );
	        yb = getPt( cpY , toY , j );
	
	        // The Black Dot
	        x = getPt( xa , xb , j );
	        y = getPt( ya , yb , j );
	
	        points.push(x, y);
	    }
	
	    return points;
	};
	
	/**
	 * Builds a circle to draw
	 *
	 * @private
	 * @param graphicsData {PIXI.Graphics} The graphics object to draw
	 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
	 */
	GraphicsRenderer.prototype.buildCircle = function (graphicsData, webGLData)
	{
	    // need to convert points to a nice regular data
	    var circleData = graphicsData.shape;
	    var x = circleData.x;
	    var y = circleData.y;
	    var width;
	    var height;
	
	    // TODO - bit hacky??
	    if (graphicsData.type === CONST.SHAPES.CIRC)
	    {
	        width = circleData.radius;
	        height = circleData.radius;
	    }
	    else
	    {
	        width = circleData.width;
	        height = circleData.height;
	    }
	
	    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
	    var seg = (Math.PI * 2) / totalSegs ;
	
	    var i = 0;
	
	    if (graphicsData.fill)
	    {
	        var color = utils.hex2rgb(graphicsData.fillColor);
	        var alpha = graphicsData.fillAlpha;
	
	        var r = color[0] * alpha;
	        var g = color[1] * alpha;
	        var b = color[2] * alpha;
	
	        var verts = webGLData.points;
	        var indices = webGLData.indices;
	
	        var vecPos = verts.length/6;
	
	        indices.push(vecPos);
	
	        for (i = 0; i < totalSegs + 1 ; i++)
	        {
	            verts.push(x,y, r, g, b, alpha);
	
	            verts.push(x + Math.sin(seg * i) * width,
	                       y + Math.cos(seg * i) * height,
	                       r, g, b, alpha);
	
	            indices.push(vecPos++, vecPos++);
	        }
	
	        indices.push(vecPos-1);
	    }
	
	    if (graphicsData.lineWidth)
	    {
	        var tempPoints = graphicsData.points;
	
	        graphicsData.points = [];
	
	        for (i = 0; i < totalSegs + 1; i++)
	        {
	            graphicsData.points.push(x + Math.sin(seg * i) * width,
	                                     y + Math.cos(seg * i) * height);
	        }
	
	        this.buildLine(graphicsData, webGLData);
	
	        graphicsData.points = tempPoints;
	    }
	};
	
	/**
	 * Builds a line to draw
	 *
	 * @private
	 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
	 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
	 */
	GraphicsRenderer.prototype.buildLine = function (graphicsData, webGLData)
	{
	    // TODO OPTIMISE!
	    var i = 0;
	    var points = graphicsData.points;
	
	    if (points.length === 0)
	    {
	        return;
	    }
	    // if the line width is an odd number add 0.5 to align to a whole pixel
	    // commenting this out fixes #711 and #1620
	    // if (graphicsData.lineWidth%2)
	    // {
	    //     for (i = 0; i < points.length; i++)
	    //     {
	    //         points[i] += 0.5;
	    //     }
	    // }
	
	    // get first and last point.. figure out the middle!
	    var firstPoint = new math.Point(points[0], points[1]);
	    var lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);
	
	    // if the first point is the last point - gonna have issues :)
	    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)
	    {
	        // need to clone as we are going to slightly modify the shape..
	        points = points.slice();
	
	        points.pop();
	        points.pop();
	
	        lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);
	
	        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;
	        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;
	
	        points.unshift(midPointX, midPointY);
	        points.push(midPointX, midPointY);
	    }
	
	    var verts = webGLData.points;
	    var indices = webGLData.indices;
	    var length = points.length / 2;
	    var indexCount = points.length;
	    var indexStart = verts.length/6;
	
	    // DRAW the Line
	    var width = graphicsData.lineWidth / 2;
	
	    // sort color
	    var color = utils.hex2rgb(graphicsData.lineColor);
	    var alpha = graphicsData.lineAlpha;
	    var r = color[0] * alpha;
	    var g = color[1] * alpha;
	    var b = color[2] * alpha;
	
	    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
	    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
	    var a1, b1, c1, a2, b2, c2;
	    var denom, pdist, dist;
	
	    p1x = points[0];
	    p1y = points[1];
	
	    p2x = points[2];
	    p2y = points[3];
	
	    perpx = -(p1y - p2y);
	    perpy =  p1x - p2x;
	
	    dist = Math.sqrt(perpx*perpx + perpy*perpy);
	
	    perpx /= dist;
	    perpy /= dist;
	    perpx *= width;
	    perpy *= width;
	
	    // start
	    verts.push(p1x - perpx , p1y - perpy,
	                r, g, b, alpha);
	
	    verts.push(p1x + perpx , p1y + perpy,
	                r, g, b, alpha);
	
	    for (i = 1; i < length-1; i++)
	    {
	        p1x = points[(i-1)*2];
	        p1y = points[(i-1)*2 + 1];
	
	        p2x = points[(i)*2];
	        p2y = points[(i)*2 + 1];
	
	        p3x = points[(i+1)*2];
	        p3y = points[(i+1)*2 + 1];
	
	        perpx = -(p1y - p2y);
	        perpy = p1x - p2x;
	
	        dist = Math.sqrt(perpx*perpx + perpy*perpy);
	        perpx /= dist;
	        perpy /= dist;
	        perpx *= width;
	        perpy *= width;
	
	        perp2x = -(p2y - p3y);
	        perp2y = p2x - p3x;
	
	        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);
	        perp2x /= dist;
	        perp2y /= dist;
	        perp2x *= width;
	        perp2y *= width;
	
	        a1 = (-perpy + p1y) - (-perpy + p2y);
	        b1 = (-perpx + p2x) - (-perpx + p1x);
	        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
	        a2 = (-perp2y + p3y) - (-perp2y + p2y);
	        b2 = (-perp2x + p2x) - (-perp2x + p3x);
	        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
	
	        denom = a1*b2 - a2*b1;
	
	        if (Math.abs(denom) < 0.1 )
	        {
	
	            denom+=10.1;
	            verts.push(p2x - perpx , p2y - perpy,
	                r, g, b, alpha);
	
	            verts.push(p2x + perpx , p2y + perpy,
	                r, g, b, alpha);
	
	            continue;
	        }
	
	        px = (b1*c2 - b2*c1)/denom;
	        py = (a2*c1 - a1*c2)/denom;
	
	
	        pdist = (px -p2x) * (px -p2x) + (py -p2y) * (py -p2y);
	
	
	        if (pdist > 140 * 140)
	        {
	            perp3x = perpx - perp2x;
	            perp3y = perpy - perp2y;
	
	            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);
	            perp3x /= dist;
	            perp3y /= dist;
	            perp3x *= width;
	            perp3y *= width;
	
	            verts.push(p2x - perp3x, p2y -perp3y);
	            verts.push(r, g, b, alpha);
	
	            verts.push(p2x + perp3x, p2y +perp3y);
	            verts.push(r, g, b, alpha);
	
	            verts.push(p2x - perp3x, p2y -perp3y);
	            verts.push(r, g, b, alpha);
	
	            indexCount++;
	        }
	        else
	        {
	
	            verts.push(px , py);
	            verts.push(r, g, b, alpha);
	
	            verts.push(p2x - (px-p2x), p2y - (py - p2y));
	            verts.push(r, g, b, alpha);
	        }
	    }
	
	    p1x = points[(length-2)*2];
	    p1y = points[(length-2)*2 + 1];
	
	    p2x = points[(length-1)*2];
	    p2y = points[(length-1)*2 + 1];
	
	    perpx = -(p1y - p2y);
	    perpy = p1x - p2x;
	
	    dist = Math.sqrt(perpx*perpx + perpy*perpy);
	    perpx /= dist;
	    perpy /= dist;
	    perpx *= width;
	    perpy *= width;
	
	    verts.push(p2x - perpx , p2y - perpy);
	    verts.push(r, g, b, alpha);
	
	    verts.push(p2x + perpx , p2y + perpy);
	    verts.push(r, g, b, alpha);
	
	    indices.push(indexStart);
	
	    for (i = 0; i < indexCount; i++)
	    {
	        indices.push(indexStart++);
	    }
	
	    indices.push(indexStart-1);
	};
	
	/**
	 * Builds a complex polygon to draw
	 *
	 * @private
	 * @param graphicsData {PIXI.Graphics} The graphics object containing all the necessary properties
	 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
	 */
	GraphicsRenderer.prototype.buildComplexPoly = function (graphicsData, webGLData)
	{
	    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..
	    var points = graphicsData.points.slice();
	
	    if (points.length < 6)
	    {
	        return;
	    }
	
	    // get first and last point.. figure out the middle!
	    var indices = webGLData.indices;
	    webGLData.points = points;
	    webGLData.alpha = graphicsData.fillAlpha;
	    webGLData.color = utils.hex2rgb(graphicsData.fillColor);
	
	    // calclate the bounds..
	    var minX = Infinity;
	    var maxX = -Infinity;
	
	    var minY = Infinity;
	    var maxY = -Infinity;
	
	    var x,y;
	
	    // get size..
	    for (var i = 0; i < points.length; i+=2)
	    {
	        x = points[i];
	        y = points[i+1];
	
	        minX = x < minX ? x : minX;
	        maxX = x > maxX ? x : maxX;
	
	        minY = y < minY ? y : minY;
	        maxY = y > maxY ? y : maxY;
	    }
	
	    // add a quad to the end cos there is no point making another buffer!
	    points.push(minX, minY,
	                maxX, minY,
	                maxX, maxY,
	                minX, maxY);
	
	    // push a quad onto the end..
	
	    //TODO - this aint needed!
	    var length = points.length / 2;
	    for (i = 0; i < length; i++)
	    {
	        indices.push( i );
	    }
	
	};
	
	/**
	 * Builds a polygon to draw
	 *
	 * @private
	 * @param graphicsData {PIXI.WebGLGraphicsData} The graphics object containing all the necessary properties
	 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
	 */
	GraphicsRenderer.prototype.buildPoly = function (graphicsData, webGLData)
	{
	    var points = graphicsData.points;
	
	    if (points.length < 6)
	    {
	        return;
	    }
	
	    // get first and last point.. figure out the middle!
	    var verts = webGLData.points;
	    var indices = webGLData.indices;
	
	    var length = points.length / 2;
	
	    // sort color
	    var color = utils.hex2rgb(graphicsData.fillColor);
	    var alpha = graphicsData.fillAlpha;
	    var r = color[0] * alpha;
	    var g = color[1] * alpha;
	    var b = color[2] * alpha;
	
	    var triangles = earcut(points, null, 2);
	
	    if (!triangles) {
	        return false;
	    }
	
	    var vertPos = verts.length / 6;
	
	    var i = 0;
	
	    for (i = 0; i < triangles.length; i+=3)
	    {
	        indices.push(triangles[i] + vertPos);
	        indices.push(triangles[i] + vertPos);
	        indices.push(triangles[i+1] + vertPos);
	        indices.push(triangles[i+2] +vertPos);
	        indices.push(triangles[i+2] + vertPos);
	    }
	
	    for (i = 0; i < length; i++)
	    {
	        verts.push(points[i * 2], points[i * 2 + 1],
	                   r, g, b, alpha);
	    }
	
	    return true;
	};


/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * An object containing WebGL specific properties to be used by the WebGL renderer
	 *
	 * @class
	 * @memberof PIXI
	 * @param gl {WebGLRenderingContext} the current WebGL drawing context
	 * @private
	 */
	function WebGLGraphicsData(gl) {
	
	    /**
	     * The current WebGL drawing context
	     *
	     * @member {WebGLRenderingContext}
	     */
	    this.gl = gl;
	
	    //TODO does this need to be split before uploding??
	    /**
	     * An array of color components (r,g,b)
	     * @member {number[]}
	     */
	    this.color = [0,0,0]; // color split!
	
	    /**
	     * An array of points to draw
	     * @member {PIXI.Point[]}
	     */
	    this.points = [];
	
	    /**
	     * The indices of the vertices
	     * @member {number[]}
	     */
	    this.indices = [];
	    /**
	     * The main buffer
	     * @member {WebGLBuffer}
	     */
	    this.buffer = gl.createBuffer();
	
	    /**
	     * The index buffer
	     * @member {WebGLBuffer}
	     */
	    this.indexBuffer = gl.createBuffer();
	
	    /**
	     * todo @alvin
	     * @member {number}
	     */
	    this.mode = 1;
	
	    /**
	     * The alpha of the graphics
	     * @member {number}
	     */
	    this.alpha = 1;
	
	    /**
	     * Whether this graphics is dirty or not
	     * @member {boolean}
	     */
	    this.dirty = true;
	
	    this.glPoints = null;
	    this.glIndices = null;
	}
	
	WebGLGraphicsData.prototype.constructor = WebGLGraphicsData;
	module.exports = WebGLGraphicsData;
	
	/**
	 * Resets the vertices and the indices
	 */
	WebGLGraphicsData.prototype.reset = function () {
	    this.points.length = 0;
	    this.indices.length = 0;
	};
	
	/**
	 * Binds the buffers and uploads the data
	 */
	WebGLGraphicsData.prototype.upload = function () {
	    var gl = this.gl;
	
	//    this.lastIndex = graphics.graphicsData.length;
	    this.glPoints = new Float32Array(this.points);
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
	    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);
	
	    this.glIndices = new Uint16Array(this.indices);
	
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndices, gl.STATIC_DRAW);
	
	    this.dirty = false;
	};
	
	WebGLGraphicsData.prototype.destroy = function () {
	    this.color = null;
	    this.points = null;
	    this.indices = null;
	
	    this.gl.deleteBuffer(this.buffer);
	    this.gl.deleteBuffer(this.indexBuffer);
	    
	    this.gl = null;
	
	    this.buffer = null;
	    this.indexBuffer = null;
	
	    this.glPoints = null;
	    this.glIndices = null;
	};


/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = earcut;
	
	function earcut(data, holeIndices, dim) {
	
	    dim = dim || 2;
	
	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList(data, 0, outerLen, dim, true),
	        triangles = [];
	
	    if (!outerNode) return triangles;
	
	    var minX, minY, maxX, maxY, x, y, size;
	
	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
	
	    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];
	
	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }
	
	        // minX, minY and size are later used to transform coords into integers for z-order calculation
	        size = Math.max(maxX - minX, maxY - minY);
	    }
	
	    earcutLinked(outerNode, triangles, dim, minX, minY, size);
	
	    return triangles;
	}
	
	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList(data, start, end, dim, clockwise) {
	    var i, last;
	
	    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
	        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	    } else {
	        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	    }
	
	    if (last && equals(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }
	
	    return last;
	}
	
	// eliminate colinear or duplicate points
	function filterPoints(start, end) {
	    if (!start) return start;
	    if (!end) end = start;
	
	    var p = start,
	        again;
	    do {
	        again = false;
	
	        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) return null;
	            again = true;
	
	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);
	
	    return end;
	}
	
	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
	    if (!ear) return;
	
	    // interlink polygon nodes in z-order
	    if (!pass && size) indexCurve(ear, minX, minY, size);
	
	    var stop = ear,
	        prev, next;
	
	    // iterate through ears, slicing them one by one
	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;
	
	        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
	            // cut off the triangle
	            triangles.push(prev.i / dim);
	            triangles.push(ear.i / dim);
	            triangles.push(next.i / dim);
	
	            removeNode(ear);
	
	            // skipping the next vertice leads to less sliver triangles
	            ear = next.next;
	            stop = next.next;
	
	            continue;
	        }
	
	        ear = next;
	
	        // if we looped through the whole remaining polygon and can't find any more ears
	        if (ear === stop) {
	            // try filtering points and slicing again
	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
	
	            // if this didn't work, try curing all small self-intersections locally
	            } else if (pass === 1) {
	                ear = cureLocalIntersections(ear, triangles, dim);
	                earcutLinked(ear, triangles, dim, minX, minY, size, 2);
	
	            // as a last resort, try splitting the remaining polygon into two
	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, size);
	            }
	
	            break;
	        }
	    }
	}
	
	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar(ear) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;
	
	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
	
	    // now make sure we don't have other points inside the potential ear
	    var p = ear.next.next;
	
	    while (p !== ear.prev) {
	        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }
	
	    return true;
	}
	
	function isEarHashed(ear, minX, minY, size) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;
	
	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
	
	    // triangle bbox; min & max are calculated like this for speed
	    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
	        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
	        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
	        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
	
	    // z-order range for the current triangle bbox;
	    var minZ = zOrder(minTX, minTY, minX, minY, size),
	        maxZ = zOrder(maxTX, maxTY, minX, minY, size);
	
	    // first look for points inside the triangle in increasing z-order
	    var p = ear.nextZ;
	
	    while (p && p.z <= maxZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.nextZ;
	    }
	
	    // then look for points in decreasing z-order
	    p = ear.prevZ;
	
	    while (p && p.z >= minZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }
	
	    return true;
	}
	
	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev,
	            b = p.next.next;
	
	        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
	
	            triangles.push(a.i / dim);
	            triangles.push(p.i / dim);
	            triangles.push(b.i / dim);
	
	            // remove two nodes involved
	            removeNode(p);
	            removeNode(p.next);
	
	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);
	
	    return p;
	}
	
	// try splitting polygon into two and triangulate them independently
	function splitEarcut(start, triangles, dim, minX, minY, size) {
	    // look for a valid diagonal that divides the polygon into two
	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {
	                // split the polygon in two by the diagonal
	                var c = splitPolygon(a, b);
	
	                // filter colinear points around the cuts
	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);
	
	                // run earcut on each half
	                earcutLinked(a, triangles, dim, minX, minY, size);
	                earcutLinked(c, triangles, dim, minX, minY, size);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}
	
	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    var queue = [],
	        i, len, start, end, list;
	
	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost(list));
	    }
	
	    queue.sort(compareX);
	
	    // process holes from left to right
	    for (i = 0; i < queue.length; i++) {
	        eliminateHole(queue[i], outerNode);
	        outerNode = filterPoints(outerNode, outerNode.next);
	    }
	
	    return outerNode;
	}
	
	function compareX(a, b) {
	    return a.x - b.x;
	}
	
	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole(hole, outerNode) {
	    outerNode = findHoleBridge(hole, outerNode);
	    if (outerNode) {
	        var b = splitPolygon(outerNode, hole);
	        filterPoints(b, b.next);
	    }
	}
	
	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge(hole, outerNode) {
	    var p = outerNode,
	        hx = hole.x,
	        hy = hole.y,
	        qx = -Infinity,
	        m;
	
	    // find a segment intersected by a ray from the hole's leftmost point to the left;
	    // segment's endpoint with lesser x will be potential connection point
	    do {
	        if (hy <= p.y && hy >= p.next.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                if (x === hx) {
	                    if (hy === p.y) return p;
	                    if (hy === p.next.y) return p.next;
	                }
	                m = p.x < p.next.x ? p : p.next;
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);
	
	    if (!m) return null;
	
	    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
	
	    // look for points inside the triangle of hole point, segment intersection and endpoint;
	    // if there are no points found, we have a valid connection;
	    // otherwise choose the point of the minimum angle with the ray as connection point
	
	    var stop = m,
	        mx = m.x,
	        my = m.y,
	        tanMin = Infinity,
	        tan;
	
	    p = m.next;
	
	    while (p !== stop) {
	        if (hx >= p.x && p.x >= mx &&
	                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
	
	            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
	
	            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
	                m = p;
	                tanMin = tan;
	            }
	        }
	
	        p = p.next;
	    }
	
	    return m;
	}
	
	// interlink polygon nodes in z-order
	function indexCurve(start, minX, minY, size) {
	    var p = start;
	    do {
	        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);
	
	    p.prevZ.nextZ = null;
	    p.prevZ = null;
	
	    sortLinked(p);
	}
	
	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked(list) {
	    var i, p, q, e, tail, numMerges, pSize, qSize,
	        inSize = 1;
	
	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;
	
	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }
	
	            qSize = inSize;
	
	            while (pSize > 0 || (qSize > 0 && q)) {
	
	                if (pSize === 0) {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                } else if (qSize === 0 || !q) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else if (p.z <= q.z) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }
	
	                if (tail) tail.nextZ = e;
	                else list = e;
	
	                e.prevZ = tail;
	                tail = e;
	            }
	
	            p = q;
	        }
	
	        tail.nextZ = null;
	        inSize *= 2;
	
	    } while (numMerges > 1);
	
	    return list;
	}
	
	// z-order of a point given coords and size of the data bounding box
	function zOrder(x, y, minX, minY, size) {
	    // coords are transformed into non-negative 15-bit integer range
	    x = 32767 * (x - minX) / size;
	    y = 32767 * (y - minY) / size;
	
	    x = (x | (x << 8)) & 0x00FF00FF;
	    x = (x | (x << 4)) & 0x0F0F0F0F;
	    x = (x | (x << 2)) & 0x33333333;
	    x = (x | (x << 1)) & 0x55555555;
	
	    y = (y | (y << 8)) & 0x00FF00FF;
	    y = (y | (y << 4)) & 0x0F0F0F0F;
	    y = (y | (y << 2)) & 0x33333333;
	    y = (y | (y << 1)) & 0x55555555;
	
	    return x | (y << 1);
	}
	
	// find the leftmost node of a polygon ring
	function getLeftmost(start) {
	    var p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x) leftmost = p;
	        p = p.next;
	    } while (p !== start);
	
	    return leftmost;
	}
	
	// check if a point lies within a convex triangle
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
	           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
	           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}
	
	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
	           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	}
	
	// signed area of a triangle
	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}
	
	// check if two points are equal
	function equals(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}
	
	// check if two segments intersect
	function intersects(p1, q1, p2, q2) {
	    if ((equals(p1, q1) && equals(p2, q2)) ||
	        (equals(p1, q2) && equals(p2, q1))) return true;
	    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
	           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	}
	
	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
	                intersects(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);
	
	    return false;
	}
	
	// check if a polygon diagonal is locally inside the polygon
	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ?
	        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
	        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}
	
	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside(a, b) {
	    var p = a,
	        inside = false,
	        px = (a.x + b.x) / 2,
	        py = (a.y + b.y) / 2;
	    do {
	        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
	            inside = !inside;
	        p = p.next;
	    } while (p !== a);
	
	    return inside;
	}
	
	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon(a, b) {
	    var a2 = new Node(a.i, a.x, a.y),
	        b2 = new Node(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;
	
	    a.next = b;
	    b.prev = a;
	
	    a2.next = an;
	    an.prev = a2;
	
	    b2.next = a2;
	    a2.prev = b2;
	
	    bp.next = b2;
	    b2.prev = bp;
	
	    return b2;
	}
	
	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode(i, x, y, last) {
	    var p = new Node(i, x, y);
	
	    if (!last) {
	        p.prev = p;
	        p.next = p;
	
	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}
	
	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;
	
	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}
	
	function Node(i, x, y) {
	    // vertice index in coordinates array
	    this.i = i;
	
	    // vertex coordinates
	    this.x = x;
	    this.y = y;
	
	    // previous and next vertice nodes in a polygon ring
	    this.prev = null;
	    this.next = null;
	
	    // z-order curve value
	    this.z = null;
	
	    // previous and next nodes in z-order
	    this.prevZ = null;
	    this.nextZ = null;
	
	    // indicates whether this is a steiner point
	    this.steiner = false;
	}
	
	// return a percentage difference between the polygon area and its triangulation area;
	// used to verify correctness of triangulation
	earcut.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
	
	    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea(data, start, end, dim));
	        }
	    }
	
	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs(
	            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
	            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }
	
	    return polygonArea === 0 && trianglesArea === 0 ? 0 :
	        Math.abs((trianglesArea - polygonArea) / polygonArea);
	};
	
	function signedArea(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}
	
	// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
	earcut.flatten = function (data) {
	    var dim = data[0][0].length,
	        result = {vertices: [], holes: [], dimensions: dim},
	        holeIndex = 0;
	
	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var SystemRenderer = __webpack_require__(52),
	    CanvasMaskManager = __webpack_require__(75),
	    utils = __webpack_require__(24),
	    math = __webpack_require__(15),
	    CONST = __webpack_require__(14);
	
	/**
	 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
	 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @memberof PIXI
	 * @extends PIXI.SystemRenderer
	 * @param [width=800] {number} the width of the canvas view
	 * @param [height=600] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.
	 * @param [options.roundPixels=false] {boolean} If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
	 */
	function CanvasRenderer(width, height, options)
	{
	    options = options || {};
	
	    SystemRenderer.call(this, 'Canvas', width, height, options);
	
	    this.type = CONST.RENDERER_TYPE.CANVAS;
	
	    /**
	     * The canvas 2d context that everything is drawn with.
	     *
	     * @member {CanvasRenderingContext2D}
	     */
	    this.context = this.view.getContext('2d', { alpha: this.transparent });
	
	    /**
	     * Boolean flag controlling canvas refresh.
	     *
	     * @member {boolean}
	     */
	    this.refresh = true;
	
	    /**
	     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
	     *
	     * @member {PIXI.CanvasMaskManager}
	     */
	    this.maskManager = new CanvasMaskManager();
	
	    /**
	     * The canvas property used to set the canvas smoothing property.
	     *
	     * @member {string}
	     */
	    this.smoothProperty = 'imageSmoothingEnabled';
	
	    if (!this.context.imageSmoothingEnabled)
	    {
	        if (this.context.webkitImageSmoothingEnabled)
	        {
	            this.smoothProperty = 'webkitImageSmoothingEnabled';
	        }
	        else if (this.context.mozImageSmoothingEnabled)
	        {
	            this.smoothProperty = 'mozImageSmoothingEnabled';
	        }
	        else if (this.context.oImageSmoothingEnabled)
	        {
	            this.smoothProperty = 'oImageSmoothingEnabled';
	        }
	        else if (this.context.msImageSmoothingEnabled)
	        {
	            this.smoothProperty = 'msImageSmoothingEnabled';
	        }
	    }
	
	    this.initPlugins();
	
	    this._mapBlendModes();
	
	    /**
	     * This temporary display object used as the parent of the currently being rendered item
	     *
	     * @member {PIXI.DisplayObject}
	     * @private
	     */
	    this._tempDisplayObjectParent = {
	        worldTransform: new math.Matrix(),
	        worldAlpha: 1
	    };
	
	
	    this.resize(width, height);
	}
	
	// constructor
	CanvasRenderer.prototype = Object.create(SystemRenderer.prototype);
	CanvasRenderer.prototype.constructor = CanvasRenderer;
	module.exports = CanvasRenderer;
	utils.pluginTarget.mixin(CanvasRenderer);
	
	/**
	 * Renders the object to this canvas view
	 *
	 * @param object {PIXI.DisplayObject} the object to be rendered
	 */
	CanvasRenderer.prototype.render = function (object)
	{
	    this.emit('prerender');
	
	    var cacheParent = object.parent;
	
	    this._lastObjectRendered = object;
	
	    object.parent = this._tempDisplayObjectParent;
	
	    // update the scene graph
	    object.updateTransform();
	
	    object.parent = cacheParent;
	
	    this.context.setTransform(1, 0, 0, 1, 0, 0);
	
	    this.context.globalAlpha = 1;
	
	    this.context.globalCompositeOperation = this.blendModes[CONST.BLEND_MODES.NORMAL];
	
	    if (navigator.isCocoonJS && this.view.screencanvas)
	    {
	        this.context.fillStyle = 'black';
	        this.context.clear();
	    }
	
	    if (this.clearBeforeRender)
	    {
	        if (this.transparent)
	        {
	            this.context.clearRect(0, 0, this.width, this.height);
	        }
	        else
	        {
	            this.context.fillStyle = this._backgroundColorString;
	            this.context.fillRect(0, 0, this.width , this.height);
	        }
	    }
	
	    this.renderDisplayObject(object, this.context);
	
	    this.emit('postrender');
	};
	
	/**
	 * Removes everything from the renderer and optionally removes the Canvas DOM element.
	 *
	 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
	 */
	CanvasRenderer.prototype.destroy = function (removeView)
	{
	    this.destroyPlugins();
	
	    // call the base destroy
	    SystemRenderer.prototype.destroy.call(this, removeView);
	
	    this.context = null;
	
	    this.refresh = true;
	
	    this.maskManager.destroy();
	    this.maskManager = null;
	
	    this.smoothProperty = null;
	};
	
	/**
	 * Renders a display object
	 *
	 * @param displayObject {PIXI.DisplayObject} The displayObject to render
	 * @private
	 */
	CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context)
	{
	    var tempContext = this.context;
	
	    this.context = context;
	    displayObject.renderCanvas(this);
	    this.context = tempContext;
	};
	
	/**
	 * @extends PIXI.SystemRenderer#resize
	 *
	 * @param {number} w
	 * @param {number} h
	 */
	CanvasRenderer.prototype.resize = function (w, h)
	{
	    SystemRenderer.prototype.resize.call(this, w, h);
	
	    //reset the scale mode.. oddly this seems to be reset when the canvas is resized.
	    //surely a browser bug?? Let pixi fix that for you..
	    if(this.smoothProperty)
	    {
	        this.context[this.smoothProperty] = (CONST.SCALE_MODES.DEFAULT === CONST.SCALE_MODES.LINEAR);
	    }
	
	};
	
	/**
	 * Maps Pixi blend modes to canvas blend modes.
	 *
	 * @private
	 */
	CanvasRenderer.prototype._mapBlendModes = function ()
	{
	    if (!this.blendModes)
	    {
	        this.blendModes = {};
	
	        if (utils.canUseNewCanvasBlendModes())
	        {
	            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
	            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'multiply';
	            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'screen';
	            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'overlay';
	            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'darken';
	            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'lighten';
	            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'color-dodge';
	            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'color-burn';
	            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'hard-light';
	            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'soft-light';
	            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'difference';
	            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'exclusion';
	            this.blendModes[CONST.BLEND_MODES.HUE]           = 'hue';
	            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'saturate';
	            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'color';
	            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'luminosity';
	        }
	        else
	        {
	            // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
	            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
	            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.HUE]           = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'source-over';
	            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'source-over';
	        }
	    }
	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var CanvasGraphics = __webpack_require__(69);
	
	/**
	 * A set of functions used to handle masking.
	 *
	 * @class
	 * @memberof PIXI
	 */
	function CanvasMaskManager()
	{}
	
	CanvasMaskManager.prototype.constructor = CanvasMaskManager;
	module.exports = CanvasMaskManager;
	
	/**
	 * This method adds it to the current stack of masks.
	 *
	 * @param maskData {object} the maskData that will be pushed
	 * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.
	 */
	CanvasMaskManager.prototype.pushMask = function (maskData, renderer)
	{
	
	    renderer.context.save();
	
	    var cacheAlpha = maskData.alpha;
	    var transform = maskData.worldTransform;
	    var resolution = renderer.resolution;
	
	    renderer.context.setTransform(
	        transform.a * resolution,
	        transform.b * resolution,
	        transform.c * resolution,
	        transform.d * resolution,
	        transform.tx * resolution,
	        transform.ty * resolution
	    );
	
	    //TODO suport sprite alpha masks??
	    //lots of effort required. If demand is great enough..
	    if(!maskData.texture)
	    {
	        CanvasGraphics.renderGraphicsMask(maskData, renderer.context);
	        renderer.context.clip();
	    }
	
	    maskData.worldAlpha = cacheAlpha;
	};
	
	/**
	 * Restores the current drawing context to the state it was before the mask was applied.
	 *
	 * @param renderer {PIXI.WebGLRenderer|PIXI.CanvasRenderer} The renderer context to use.
	 */
	CanvasMaskManager.prototype.popMask = function (renderer)
	{
	    renderer.context.restore();
	};
	
	CanvasMaskManager.prototype.destroy = function () {};


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file        Main export of the PIXI extras library
	 * @author      Mat Groves <mat@goodboydigital.com>
	 * @copyright   2013-2015 GoodBoyDigital
	 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
	 */
	
	__webpack_require__(77);
	__webpack_require__(78);
	__webpack_require__(79);
	
	/**
	 * @namespace PIXI.extras
	 */
	module.exports = {
	    MovieClip:      __webpack_require__(80),
	    TilingSprite:   __webpack_require__(81),
	    BitmapText:     __webpack_require__(82)
	};


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    DisplayObject = core.DisplayObject,
	    _tempMatrix = new core.Matrix();
	
	DisplayObject.prototype._cacheAsBitmap = false;
	DisplayObject.prototype._originalRenderWebGL = null;
	DisplayObject.prototype._originalRenderCanvas = null;
	
	DisplayObject.prototype._originalUpdateTransform = null;
	DisplayObject.prototype._originalHitTest = null;
	DisplayObject.prototype._originalDestroy = null;
	DisplayObject.prototype._cachedSprite = null;
	
	Object.defineProperties(DisplayObject.prototype, {
	
	    /**
	     * Set this to true if you want this display object to be cached as a bitmap.
	     * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.
	     * To remove simply set this property to 'false'
	     *
	     * @member {boolean}
	     * @memberof PIXI.DisplayObject#
	     */
	    cacheAsBitmap: {
	        get: function ()
	        {
	            return this._cacheAsBitmap;
	        },
	        set: function (value)
	        {
	            if (this._cacheAsBitmap === value)
	            {
	                return;
	            }
	
	            this._cacheAsBitmap = value;
	
	            if (value)
	            {
	                this._originalRenderWebGL = this.renderWebGL;
	                this._originalRenderCanvas = this.renderCanvas;
	
	                this._originalUpdateTransform = this.updateTransform;
	                this._originalGetBounds = this.getBounds;
	
	                this._originalDestroy = this.destroy;
	
	                this._originalContainsPoint = this.containsPoint;
	
	                this.renderWebGL = this._renderCachedWebGL;
	                this.renderCanvas = this._renderCachedCanvas;
	
	                this.destroy = this._cacheAsBitmapDestroy;
	
	            }
	            else
	            {
	                if (this._cachedSprite)
	                {
	                    this._destroyCachedDisplayObject();
	                }
	
	                this.renderWebGL = this._originalRenderWebGL;
	                this.renderCanvas = this._originalRenderCanvas;
	                this.getBounds = this._originalGetBounds;
	
	                this.destroy = this._originalDestroy;
	
	                this.updateTransform = this._originalUpdateTransform;
	                this.containsPoint = this._originalContainsPoint;
	            }
	        }
	    }
	});
	/**
	* Renders a cached version of the sprite with WebGL
	*
	* @param renderer {PIXI.WebGLRenderer} the WebGL renderer
	* @private
	*/
	DisplayObject.prototype._renderCachedWebGL = function (renderer)
	{
	    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
	    {
	        return;
	    }
	
	    this._initCachedDisplayObject( renderer );
	
	    this._cachedSprite.worldAlpha = this.worldAlpha;
	
	    renderer.setObjectRenderer(renderer.plugins.sprite);
	    renderer.plugins.sprite.render( this._cachedSprite );
	};
	
	/**
	* Prepares the WebGL renderer to cache the sprite
	*
	* @param renderer {PIXI.WebGLRenderer} the WebGL renderer
	* @private
	*/
	DisplayObject.prototype._initCachedDisplayObject = function (renderer)
	{
	    if(this._cachedSprite)
	    {
	        return;
	    }
	
	    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
	    renderer.currentRenderer.flush();
	    //this.filters= [];
	    // next we find the dimensions of the untransformed object
	    // this function also calls updatetransform on all its children as part of the measuring. This means we don't need to update the transform again in this function
	    // TODO pass an object to clone too? saves having to create a new one each time!
	    var bounds = this.getLocalBounds().clone();
	
	    // add some padding!
	    if(this._filters)
	    {
	        var padding = this._filters[0].padding;
	        bounds.x -= padding;
	        bounds.y -= padding;
	
	        bounds.width += padding * 2;
	        bounds.height += padding * 2;
	    }
	
	    // for now we cache the current renderTarget that the webGL renderer is currently using.
	    // this could be more elegent..
	    var cachedRenderTarget = renderer.currentRenderTarget;
	    // We also store the filter stack - I will definitely look to change how this works a little later down the line.
	    var stack = renderer.filterManager.filterStack;
	
	    // this renderTexture will be used to store the cached DisplayObject
	    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);
	
	    // need to set //
	    var m = _tempMatrix;
	
	    m.tx = -bounds.x;
	    m.ty = -bounds.y;
	
	
	
	    // set all properties to there original so we can render to a texture
	    this.renderWebGL = this._originalRenderWebGL;
	
	    renderTexture.render(this, m, true, true);
	
	    // now restore the state be setting the new properties
	    renderer.setRenderTarget(cachedRenderTarget);
	    renderer.filterManager.filterStack = stack;
	
	    this.renderWebGL     = this._renderCachedWebGL;
	    this.updateTransform = this.displayObjectUpdateTransform;
	    this.getBounds       = this._getCachedBounds;
	
	
	    // create our cached sprite
	    this._cachedSprite = new core.Sprite(renderTexture);
	    this._cachedSprite.worldTransform = this.worldTransform;
	    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
	    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );
	
	    // restore the transform of the cached sprite to avoid the nasty flicker..
	    this.updateTransform();
	
	    // map the hit test..
	    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
	};
	
	/**
	* Renders a cached version of the sprite with canvas
	*
	* @param renderer {PIXI.CanvasRenderer} the Canvas renderer
	* @private
	*/
	DisplayObject.prototype._renderCachedCanvas = function (renderer)
	{
	    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
	    {
	        return;
	    }
	
	    this._initCachedDisplayObjectCanvas( renderer );
	
	    this._cachedSprite.worldAlpha = this.worldAlpha;
	
	    this._cachedSprite.renderCanvas(renderer);
	};
	
	//TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..
	/**
	* Prepares the Canvas renderer to cache the sprite
	*
	* @param renderer {PIXI.CanvasRenderer} the Canvas renderer
	* @private
	*/
	DisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer)
	{
	    if(this._cachedSprite)
	    {
	        return;
	    }
	
	    //get bounds actually transforms the object for us already!
	    var bounds = this.getLocalBounds();
	
	    var cachedRenderTarget = renderer.context;
	
	    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);
	
	    // need to set //
	    var m = _tempMatrix;
	
	    m.tx = -bounds.x;
	    m.ty = -bounds.y;
	
	    // set all properties to there original so we can render to a texture
	    this.renderCanvas = this._originalRenderCanvas;
	
	    renderTexture.render(this, m, true);
	
	    // now restore the state be setting the new properties
	    renderer.context = cachedRenderTarget;
	
	    this.renderCanvas = this._renderCachedCanvas;
	    this.updateTransform = this.displayObjectUpdateTransform;
	    this.getBounds  = this._getCachedBounds;
	
	
	    // create our cached sprite
	    this._cachedSprite = new core.Sprite(renderTexture);
	    this._cachedSprite.worldTransform = this.worldTransform;
	    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
	    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );
	
	    this.updateTransform();
	
	    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
	};
	
	/**
	* Calculates the bounds of the cached sprite
	*
	* @private
	*/
	DisplayObject.prototype._getCachedBounds = function ()
	{
	    this._cachedSprite._currentBounds = null;
	
	    return this._cachedSprite.getBounds();
	};
	
	/**
	* Destroys the cached sprite.
	*
	* @private
	*/
	DisplayObject.prototype._destroyCachedDisplayObject = function ()
	{
	    this._cachedSprite._texture.destroy();
	    this._cachedSprite = null;
	};
	
	DisplayObject.prototype._cacheAsBitmapDestroy = function ()
	{
	    this.cacheAsBitmap = false;
	    this._originalDestroy();
	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	/**
	 * The instance name of the object.
	 *
	 * @memberof PIXI.DisplayObject#
	 * @member {string}
	 */
	core.DisplayObject.prototype.name = null;
	
	/**
	* Returns the display object in the container
	*
	* @memberof PIXI.Container#
	* @param name {string} instance name
	* @return {PIXI.DisplayObject}
	*/
	core.Container.prototype.getChildByName = function (name)
	{
	    for (var i = 0; i < this.children.length; i++)
	    {
	        if (this.children[i].name === name)
	        {
	            return this.children[i];
	        }
	    }
	    return null;
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	/**
	* Returns the global position of the displayObject
	*
	* @memberof PIXI.DisplayObject#
	* @param point {Point} the point to write the global value to. If null a new point will be returned
	* @return {Point}
	*/
	core.DisplayObject.prototype.getGlobalPosition = function (point)
	{
	    point = point || new core.Point();
	
	    if(this.parent)
	    {
	        this.displayObjectUpdateTransform();
	
	        point.x = this.worldTransform.tx;
	        point.y = this.worldTransform.ty;
	    }
	    else
	    {
	        point.x = this.position.x;
	        point.y = this.position.y;
	    }
	
	    return point;
	};


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	/**
	 * A MovieClip is a simple way to display an animation depicted by a list of textures.
	 *
	 * ```js
	 * var alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
	 * var textureArray = [];
	 *
	 * for (var i=0; i < 4; i++)
	 * {
	 *      var texture = PIXI.Texture.fromImage(alienImages[i]);
	 *      textureArray.push(texture);
	 * };
	 *
	 * var mc = new PIXI.MovieClip(textureArray);
	 * ```
	 *
	 * @class
	 * @extends PIXI.Sprite
	 * @memberof PIXI.extras
	 * @param textures {PIXI.Texture[]|Object[]} an array of {@link PIXI.Texture} or frame objects that make up the animation
	 * @param textures[].texture {PIXI.Texture} the {@link PIXI.Texture} of the frame
	 * @param textures[].time {number} the duration of the frame in ms
	 */
	function MovieClip(textures)
	{
	    core.Sprite.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);
	
	    /**
	     * @private
	     */
	    this._textures = null;
	
	    /**
	     * @private
	     */
	    this._durations = null;
	
	    this.textures = textures;
	
	    /**
	     * The speed that the MovieClip will play at. Higher is faster, lower is slower
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.animationSpeed = 1;
	
	    /**
	     * Whether or not the movie clip repeats after playing.
	     *
	     * @member {boolean}
	     * @default true
	     */
	    this.loop = true;
	
	    /**
	     * Function to call when a MovieClip finishes playing
	     *
	     * @method
	     * @memberof PIXI.extras.MovieClip#
	     */
	    this.onComplete = null;
	
	    /**
	     * Elapsed time since animation has been started, used internally to display current texture
	     *
	     * @member {number}
	     * @private
	     */
	    this._currentTime = 0;
	
	    /**
	     * Indicates if the MovieClip is currently playing
	     *
	     * @member {boolean}
	     * @readonly
	     */
	    this.playing = false;
	}
	
	// constructor
	MovieClip.prototype = Object.create(core.Sprite.prototype);
	MovieClip.prototype.constructor = MovieClip;
	module.exports = MovieClip;
	
	Object.defineProperties(MovieClip.prototype, {
	    /**
	     * totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
	     * assigned to the MovieClip.
	     *
	     * @member {number}
	     * @memberof PIXI.extras.MovieClip#
	     * @default 0
	     * @readonly
	     */
	    totalFrames: {
	        get: function()
	        {
	            return this._textures.length;
	        }
	    },
	
	    /**
	     * The array of textures used for this MovieClip
	     *
	     * @member {PIXI.Texture[]}
	     * @memberof PIXI.extras.MovieClip#
	     *
	     */
	    textures: {
	        get: function ()
	        {
	            return this._textures;
	        },
	        set: function (value)
	        {
	            if(value[0] instanceof core.Texture)
	            {
	                this._textures = value;
	                this._durations = null;
	            }
	            else
	            {
	                this._textures = [];
	                this._durations = [];
	                for(var i = 0; i < value.length; i++)
	                {
	                    this._textures.push(value[i].texture);
	                    this._durations.push(value[i].time);
	                }
	            }
	        }
	    },
	
	    /**
	    * The MovieClips current frame index
	    *
	    * @member {number}
	    * @memberof PIXI.extras.MovieClip#
	    * @readonly
	    */
	    currentFrame: {
	        get: function ()
	        {
	            var currentFrame = Math.floor(this._currentTime) % this._textures.length;
	            if (currentFrame < 0)
	            {
	                currentFrame += this._textures.length;
	            }
	            return currentFrame;
	        }
	    }
	
	});
	
	/**
	 * Stops the MovieClip
	 *
	 */
	MovieClip.prototype.stop = function ()
	{
	    if(!this.playing)
	    {
	        return;
	    }
	
	    this.playing = false;
	    core.ticker.shared.remove(this.update, this);
	};
	
	/**
	 * Plays the MovieClip
	 *
	 */
	MovieClip.prototype.play = function ()
	{
	    if(this.playing)
	    {
	        return;
	    }
	
	    this.playing = true;
	    core.ticker.shared.add(this.update, this);
	};
	
	/**
	 * Stops the MovieClip and goes to a specific frame
	 *
	 * @param frameNumber {number} frame index to stop at
	 */
	MovieClip.prototype.gotoAndStop = function (frameNumber)
	{
	    this.stop();
	
	    this._currentTime = frameNumber;
	
	    this._texture = this._textures[this.currentFrame];
	};
	
	/**
	 * Goes to a specific frame and begins playing the MovieClip
	 *
	 * @param frameNumber {number} frame index to start at
	 */
	MovieClip.prototype.gotoAndPlay = function (frameNumber)
	{
	    this._currentTime = frameNumber;
	
	    this.play();
	};
	
	/*
	 * Updates the object transform for rendering
	 * @private
	 */
	MovieClip.prototype.update = function (deltaTime)
	{
	    var elapsed = this.animationSpeed * deltaTime;
	
	    if (this._durations !== null)
	    {
	        var lag = this._currentTime % 1 * this._durations[this.currentFrame];
	
	        lag += elapsed / 60 * 1000;
	
	        while (lag < 0)
	        {
	            this._currentTime--;
	            lag += this._durations[this.currentFrame];
	        }
	
	        var sign = Math.sign(this.animationSpeed * deltaTime);
	        this._currentTime = Math.floor(this._currentTime);
	
	        while (lag >= this._durations[this.currentFrame])
	        {
	            lag -= this._durations[this.currentFrame] * sign;
	            this._currentTime += sign;
	        }
	
	        this._currentTime += lag / this._durations[this.currentFrame];
	    }
	    else
	    {
	        this._currentTime += elapsed;
	    }
	
	    if (this._currentTime < 0 && !this.loop)
	    {
	        this.gotoAndStop(0);
	
	        if (this.onComplete)
	        {
	            this.onComplete();
	        }
	    }
	    else if (this._currentTime >= this._textures.length && !this.loop)
	    {
	        this.gotoAndStop(this._textures.length - 1);
	
	        if (this.onComplete)
	        {
	            this.onComplete();
	        }
	    }
	    else
	    {
	        this._texture = this._textures[this.currentFrame];
	    }
	
	};
	
	/*
	 * Stops the MovieClip and destroys it
	 *
	 */
	MovieClip.prototype.destroy = function ( )
	{
	    this.stop();
	    core.Sprite.prototype.destroy.call(this);
	};
	
	/**
	 * A short hand way of creating a movieclip from an array of frame ids
	 *
	 * @static
	 * @param frames {string[]} the array of frames ids the movieclip will use as its texture frames
	 */
	MovieClip.fromFrames = function (frames)
	{
	    var textures = [];
	
	    for (var i = 0; i < frames.length; ++i)
	    {
	        textures.push(new core.Texture.fromFrame(frames[i]));
	    }
	
	    return new MovieClip(textures);
	};
	
	/**
	 * A short hand way of creating a movieclip from an array of image ids
	 *
	 * @static
	 * @param images {string[]} the array of image urls the movieclip will use as its texture frames
	 */
	MovieClip.fromImages = function (images)
	{
	    var textures = [];
	
	    for (var i = 0; i < images.length; ++i)
	    {
	        textures.push(new core.Texture.fromImage(images[i]));
	    }
	
	    return new MovieClip(textures);
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    // a sprite use dfor rendering textures..
	    tempPoint = new core.Point(),
	    CanvasTinter = __webpack_require__(47);
	
	/**
	 * A tiling sprite is a fast way of rendering a tiling image
	 *
	 * @class
	 * @extends PIXI.Sprite
	 * @memberof PIXI.extras
	 * @param texture {Texture} the texture of the tiling sprite
	 * @param width {number}  the width of the tiling sprite
	 * @param height {number} the height of the tiling sprite
	 */
	function TilingSprite(texture, width, height)
	{
	    core.Sprite.call(this, texture);
	
	    /**
	     * The scaling of the image that is being tiled
	     *
	     * @member {PIXI.Point}
	     */
	    this.tileScale = new core.Point(1,1);
	
	
	    /**
	     * The offset position of the image that is being tiled
	     *
	     * @member {PIXI.Point}
	     */
	    this.tilePosition = new core.Point(0,0);
	
	    ///// private
	
	    /**
	     * The with of the tiling sprite
	     *
	     * @member {number}
	     * @private
	     */
	    this._width = width || 100;
	
	    /**
	     * The height of the tiling sprite
	     *
	     * @member {number}
	     * @private
	     */
	    this._height = height || 100;
	
	    /**
	     * An internal WebGL UV cache.
	     *
	     * @member {PIXI.TextureUvs}
	     * @private
	     */
	    this._uvs = new core.TextureUvs();
	
	    this._canvasPattern = null;
	
	    //TODO move..
	    this.shader = new core.AbstractFilter(
	
	      [
	        'precision lowp float;',
	        'attribute vec2 aVertexPosition;',
	        'attribute vec2 aTextureCoord;',
	        'attribute vec4 aColor;',
	
	        'uniform mat3 projectionMatrix;',
	
	        'uniform vec4 uFrame;',
	        'uniform vec4 uTransform;',
	
	        'varying vec2 vTextureCoord;',
	        'varying vec4 vColor;',
	
	        'void main(void){',
	        '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
	
	        '   vec2 coord = aTextureCoord;',
	        '   coord -= uTransform.xy;',
	        '   coord /= uTransform.zw;',
	        '   vTextureCoord = coord;',
	
	        '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
	        '}'
	      ].join('\n'),
	      [
	        'precision lowp float;',
	
	        'varying vec2 vTextureCoord;',
	        'varying vec4 vColor;',
	
	        'uniform sampler2D uSampler;',
	        'uniform vec4 uFrame;',
	        'uniform vec2 uPixelSize;',
	
	        'void main(void){',
	
	        '   vec2 coord = mod(vTextureCoord, uFrame.zw);',
	        '   coord = clamp(coord, uPixelSize, uFrame.zw - uPixelSize);',
	        '   coord += uFrame.xy;',
	
	        '   gl_FragColor =  texture2D(uSampler, coord) * vColor ;',
	        '}'
	      ].join('\n'),
	
	            // set the uniforms
	            {
	                uFrame: { type: '4fv', value: [0,0,1,1] },
	                uTransform: { type: '4fv', value: [0,0,1,1] },
	                uPixelSize : { type : '2fv', value: [1, 1]}
	            }
	      );
	}
	
	TilingSprite.prototype = Object.create(core.Sprite.prototype);
	TilingSprite.prototype.constructor = TilingSprite;
	module.exports = TilingSprite;
	
	
	Object.defineProperties(TilingSprite.prototype, {
	    /**
	     * The width of the sprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.extras.TilingSprite#
	     */
	    width: {
	        get: function ()
	        {
	            return this._width;
	        },
	        set: function (value)
	        {
	            this._width = value;
	        }
	    },
	
	    /**
	     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
	     *
	     * @member {number}
	     * @memberof PIXI.extras.TilingSprite#
	     */
	    height: {
	        get: function ()
	        {
	            return this._height;
	        },
	        set: function (value)
	        {
	            this._height = value;
	        }
	    }
	});
	
	TilingSprite.prototype._onTextureUpdate = function ()
	{
	    return;
	};
	
	
	/**
	 * Renders the object using the WebGL renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer}
	 * @private
	 */
	TilingSprite.prototype._renderWebGL = function (renderer)
	{
	    // tweak our texture temporarily..
	    var texture = this._texture;
	
	    if(!texture || !texture._uvs)
	    {
	        return;
	    }
	
	    var tempUvs = texture._uvs,
	        tempWidth = texture._frame.width,
	        tempHeight = texture._frame.height,
	        tw = texture.baseTexture.width,
	        th = texture.baseTexture.height;
	
	    texture._uvs = this._uvs;
	    texture._frame.width = this.width;
	    texture._frame.height = this.height;
	
	    this.shader.uniforms.uPixelSize.value[0] = 1.0/tw;
	    this.shader.uniforms.uPixelSize.value[1] = 1.0/th;
	
	    this.shader.uniforms.uFrame.value[0] = tempUvs.x0;
	    this.shader.uniforms.uFrame.value[1] = tempUvs.y0;
	    this.shader.uniforms.uFrame.value[2] = tempUvs.x1 - tempUvs.x0;
	    this.shader.uniforms.uFrame.value[3] = tempUvs.y2 - tempUvs.y0;
	
	    this.shader.uniforms.uTransform.value[0] = (this.tilePosition.x % (tempWidth * this.tileScale.x)) / this._width;
	    this.shader.uniforms.uTransform.value[1] = (this.tilePosition.y % (tempHeight * this.tileScale.y)) / this._height;
	    this.shader.uniforms.uTransform.value[2] = ( tw / this._width ) * this.tileScale.x;
	    this.shader.uniforms.uTransform.value[3] = ( th / this._height ) * this.tileScale.y;
	
	    renderer.setObjectRenderer(renderer.plugins.sprite);
	    renderer.plugins.sprite.render(this);
	
	    texture._uvs = tempUvs;
	    texture._frame.width = tempWidth;
	    texture._frame.height = tempHeight;
	};
	
	/**
	 * Renders the object using the Canvas renderer
	 *
	 * @param renderer {PIXI.CanvasRenderer} a reference to the canvas renderer
	 * @private
	 */
	TilingSprite.prototype._renderCanvas = function (renderer)
	{
	    var texture = this._texture;
	
	    if (!texture.baseTexture.hasLoaded)
	    {
	      return;
	    }
	
	    var context = renderer.context,
	        transform = this.worldTransform,
	        resolution = renderer.resolution,
	        baseTexture = texture.baseTexture,
	        modX = (this.tilePosition.x / this.tileScale.x) % texture._frame.width,
	        modY = (this.tilePosition.y / this.tileScale.y) % texture._frame.height;
	
	    // create a nice shiny pattern!
	    // TODO this needs to be refreshed if texture changes..
	    if(!this._canvasPattern)
	    {
	        // cut an object from a spritesheet..
	        var tempCanvas = new core.CanvasBuffer(texture._frame.width * resolution, texture._frame.height * resolution);
	
	        // Tint the tiling sprite
	        if (this.tint !== 0xFFFFFF)
	        {
	            if (this.cachedTint !== this.tint)
	            {
	                this.cachedTint = this.tint;
	
	                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
	            }
	            tempCanvas.context.drawImage(this.tintedTexture, 0, 0);
	        }
	        else
	        {
	            tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x * resolution, -texture._frame.y * resolution);
	        }
	        this._canvasPattern = tempCanvas.context.createPattern( tempCanvas.canvas, 'repeat' );
	    }
	
	    // set context state..
	    context.globalAlpha = this.worldAlpha;
	    context.setTransform(transform.a * resolution,
	                       transform.b * resolution,
	                       transform.c * resolution,
	                       transform.d * resolution,
	                       transform.tx * resolution,
	                       transform.ty * resolution);
	
	    // TODO - this should be rolled into the setTransform above..
	    context.scale(this.tileScale.x / resolution, this.tileScale.y / resolution);
	
	    context.translate(modX + (this.anchor.x * -this._width ),
	                      modY + (this.anchor.y * -this._height));
	
	    // check blend mode
	    var compositeOperation = renderer.blendModes[this.blendMode];
	    if (compositeOperation !== renderer.context.globalCompositeOperation)
	    {
	        context.globalCompositeOperation = compositeOperation;
	    }
	
	    // fill the pattern!
	    context.fillStyle = this._canvasPattern;
	    context.fillRect(-modX,
	                     -modY,
	                     this._width * resolution / this.tileScale.x,
	                     this._height * resolution / this.tileScale.y);
	
	
	    //TODO - pretty sure this can be deleted...
	    //context.translate(-this.tilePosition.x + (this.anchor.x * this._width), -this.tilePosition.y + (this.anchor.y * this._height));
	    //context.scale(1 / this.tileScale.x, 1 / this.tileScale.y);
	};
	
	
	/**
	 * Returns the framing rectangle of the sprite as a Rectangle object
	*
	 * @return {PIXI.Rectangle} the framing rectangle
	 */
	TilingSprite.prototype.getBounds = function ()
	{
	    var width = this._width;
	    var height = this._height;
	
	    var w0 = width * (1-this.anchor.x);
	    var w1 = width * -this.anchor.x;
	
	    var h0 = height * (1-this.anchor.y);
	    var h1 = height * -this.anchor.y;
	
	    var worldTransform = this.worldTransform;
	
	    var a = worldTransform.a;
	    var b = worldTransform.b;
	    var c = worldTransform.c;
	    var d = worldTransform.d;
	    var tx = worldTransform.tx;
	    var ty = worldTransform.ty;
	
	    var x1 = a * w1 + c * h1 + tx;
	    var y1 = d * h1 + b * w1 + ty;
	
	    var x2 = a * w0 + c * h1 + tx;
	    var y2 = d * h1 + b * w0 + ty;
	
	    var x3 = a * w0 + c * h0 + tx;
	    var y3 = d * h0 + b * w0 + ty;
	
	    var x4 =  a * w1 + c * h0 + tx;
	    var y4 =  d * h0 + b * w1 + ty;
	
	    var minX,
	        maxX,
	        minY,
	        maxY;
	
	    minX = x1;
	    minX = x2 < minX ? x2 : minX;
	    minX = x3 < minX ? x3 : minX;
	    minX = x4 < minX ? x4 : minX;
	
	    minY = y1;
	    minY = y2 < minY ? y2 : minY;
	    minY = y3 < minY ? y3 : minY;
	    minY = y4 < minY ? y4 : minY;
	
	    maxX = x1;
	    maxX = x2 > maxX ? x2 : maxX;
	    maxX = x3 > maxX ? x3 : maxX;
	    maxX = x4 > maxX ? x4 : maxX;
	
	    maxY = y1;
	    maxY = y2 > maxY ? y2 : maxY;
	    maxY = y3 > maxY ? y3 : maxY;
	    maxY = y4 > maxY ? y4 : maxY;
	
	    var bounds = this._bounds;
	
	    bounds.x = minX;
	    bounds.width = maxX - minX;
	
	    bounds.y = minY;
	    bounds.height = maxY - minY;
	
	    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
	    this._currentBounds = bounds;
	
	    return bounds;
	};
	
	/**
	 * Checks if a point is inside this tiling sprite
	 * @param point {PIXI.Point} the point to check
	 */
	TilingSprite.prototype.containsPoint = function( point )
	{
	    this.worldTransform.applyInverse(point,  tempPoint);
	
	    var width = this._width;
	    var height = this._height;
	    var x1 = -width * this.anchor.x;
	    var y1;
	
	    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
	    {
	        y1 = -height * this.anchor.y;
	
	        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
	        {
	            return true;
	        }
	    }
	
	    return false;
	};
	
	/**
	 * Destroys this tiling sprite
	 *
	 */
	TilingSprite.prototype.destroy = function () {
	    core.Sprite.prototype.destroy.call(this);
	
	    this.tileScale = null;
	    this._tileScaleOffset = null;
	    this.tilePosition = null;
	
	    this._uvs = null;
	};
	
	/**
	 * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
	 * The frame ids are created when a Texture packer file has been loaded
	 *
	 * @static
	 * @param frameId {string} The frame Id of the texture in the cache
	 * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
	 * @param width {number}  the width of the tiling sprite
	 * @param height {number} the height of the tiling sprite
	 */
	TilingSprite.fromFrame = function (frameId,width,height)
	{
	    var texture = core.utils.TextureCache[frameId];
	
	    if (!texture)
	    {
	        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
	    }
	
	    return new TilingSprite(texture,width,height);
	};
	
	/**
	 * Helper function that creates a sprite that will contain a texture based on an image url
	 * If the image is not in the texture cache it will be loaded
	 *
	 * @static
	 * @param imageId {string} The image url of the texture
	 * @param width {number}  the width of the tiling sprite
	 * @param height {number} the height of the tiling sprite
	 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
	 * @param [scaleMode=PIXI.SCALE_MODES.DEFAULT] {number} if you want to specify the scale mode, see {@link PIXI.SCALE_MODES} for possible values
	 * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
	 */
	TilingSprite.fromImage = function (imageId, width, height, crossorigin, scaleMode)
	{
	    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode),width,height);
	};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	/**
	 * A BitmapText object will create a line or multiple lines of text using bitmap font. To
	 * split a line you can use '\n', '\r' or '\r\n' in your string. You can generate the fnt files using:
	 *
	 * A BitmapText can only be created when the font is loaded
	 *
	 * ```js
	 * // in this case the font is in a file called 'desyrel.fnt'
	 * var bitmapText = new PIXI.extras.BitmapText("text using a fancy font!", {font: "35px Desyrel", align: "right"});
	 * ```
	 *
	 *
	 * http://www.angelcode.com/products/bmfont/ for windows or
	 * http://www.bmglyph.com/ for mac.
	 *
	 * @class
	 * @extends PIXI.Container
	 * @memberof PIXI.extras
	 * @param text {string} The copy that you would like the text to display
	 * @param style {object} The style parameters
	 * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form
	 *      "24px FontName" or "FontName" or as an object with explicit name/size properties.
	 * @param [style.font.name] {string} The bitmap font id
	 * @param [style.font.size] {number} The size of the font in pixels, e.g. 24
	 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect
	 *      single line text
	 * @param [style.tint=0xFFFFFF] {number} The tint color
	 */
	function BitmapText(text, style)
	{
	    core.Container.call(this);
	
	    style = style || {};
	
	    /**
	     * The width of the overall text, different from fontSize,
	     * which is defined in the style object
	     *
	     * @member {number}
	     * @readOnly
	     */
	    this.textWidth = 0;
	
	    /**
	     * The height of the overall text, different from fontSize,
	     * which is defined in the style object
	     *
	     * @member {number}
	     * @readOnly
	     */
	    this.textHeight = 0;
	
	    /**
	     * Private tracker for the letter sprite pool.
	     *
	     * @member {PIXI.Sprite[]}
	     * @private
	     */
	    this._glyphs = [];
	
	    /**
	     * Private tracker for the current style.
	     *
	     * @member {object}
	     * @private
	     */
	    this._font = {
	        tint: style.tint !== undefined ? style.tint : 0xFFFFFF,
	        align: style.align || 'left',
	        name: null,
	        size: 0
	    };
	
	    /**
	     * Private tracker for the current font.
	     *
	     * @member {object}
	     * @private
	     */
	    this.font = style.font; // run font setter
	
	    /**
	     * Private tracker for the current text.
	     *
	     * @member {string}
	     * @private
	     */
	    this._text = text;
	
	    /**
	     * The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.
	     * Disable by setting value to 0
	     *
	     * @member {number}
	     */
	    this.maxWidth = 0;
	
	    /**
	     * The max line height. This is useful when trying to use the total height of the Text, ie: when trying to vertically align.
	     *
	     * @member {number}
	     */
	    this.maxLineHeight = 0;
	
	    /**
	     * The dirty state of this object.
	     *
	     * @member {boolean}
	     */
	    this.dirty = false;
	
	    this.updateText();
	}
	
	// constructor
	BitmapText.prototype = Object.create(core.Container.prototype);
	BitmapText.prototype.constructor = BitmapText;
	module.exports = BitmapText;
	
	Object.defineProperties(BitmapText.prototype, {
	    /**
	     * The tint of the BitmapText object
	     *
	     * @member {number}
	     * @memberof PIXI.extras.BitmapText#
	     */
	    tint: {
	        get: function ()
	        {
	            return this._font.tint;
	        },
	        set: function (value)
	        {
	            this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;
	
	            this.dirty = true;
	        }
	    },
	
	    /**
	     * The alignment of the BitmapText object
	     *
	     * @member {string}
	     * @default 'left'
	     * @memberof PIXI.extras.BitmapText#
	     */
	    align: {
	        get: function ()
	        {
	            return this._font.align;
	        },
	        set: function (value)
	        {
	            this._font.align = value || 'left';
	
	            this.dirty = true;
	        }
	    },
	
	    /**
	     * The font descriptor of the BitmapText object
	     *
	     * @member {Font}
	     * @memberof PIXI.extras.BitmapText#
	     */
	    font: {
	        get: function ()
	        {
	            return this._font;
	        },
	        set: function (value)
	        {
	            if (!value) {
	                return;
	            }
	
	            if (typeof value === 'string') {
	                value = value.split(' ');
	
	                this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
	                this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;
	            }
	            else {
	                this._font.name = value.name;
	                this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);
	            }
	
	            this.dirty = true;
	        }
	    },
	
	    /**
	     * The text of the BitmapText object
	     *
	     * @member {string}
	     * @memberof PIXI.extras.BitmapText#
	     */
	    text: {
	        get: function ()
	        {
	            return this._text;
	        },
	        set: function (value)
	        {
	            value = value.toString() || ' ';
	            if (this._text === value)
	            {
	                return;
	            }
	            this._text = value;
	            this.dirty = true;
	        }
	    }
	});
	
	/**
	 * Renders text and updates it when needed
	 *
	 * @private
	 */
	BitmapText.prototype.updateText = function ()
	{
	    var data = BitmapText.fonts[this._font.name];
	    var pos = new core.Point();
	    var prevCharCode = null;
	    var chars = [];
	    var lastLineWidth = 0;
	    var maxLineWidth = 0;
	    var lineWidths = [];
	    var line = 0;
	    var scale = this._font.size / data.size;
	    var lastSpace = -1;
	    var maxLineHeight = 0;
	
	    for (var i = 0; i < this.text.length; i++)
	    {
	        var charCode = this.text.charCodeAt(i);
	        lastSpace = /(\s)/.test(this.text.charAt(i)) ? i : lastSpace;
	
	        if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i)))
	        {
	            lineWidths.push(lastLineWidth);
	            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
	            line++;
	
	            pos.x = 0;
	            pos.y += data.lineHeight;
	            prevCharCode = null;
	            continue;
	        }
	
	        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)
	        {
	            core.utils.removeItems(chars, lastSpace, i - lastSpace);
	            i = lastSpace;
	            lastSpace = -1;
	
	            lineWidths.push(lastLineWidth);
	            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
	            line++;
	
	            pos.x = 0;
	            pos.y += data.lineHeight;
	            prevCharCode = null;
	            continue;
	        }
	
	        var charData = data.chars[charCode];
	
	        if (!charData)
	        {
	            continue;
	        }
	
	        if (prevCharCode && charData.kerning[prevCharCode])
	        {
	            pos.x += charData.kerning[prevCharCode];
	        }
	
	        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});
	        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);
	        pos.x += charData.xAdvance;
	        maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));
	        prevCharCode = charCode;
	    }
	
	    lineWidths.push(lastLineWidth);
	    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
	
	    var lineAlignOffsets = [];
	
	    for (i = 0; i <= line; i++)
	    {
	        var alignOffset = 0;
	
	        if (this._font.align === 'right')
	        {
	            alignOffset = maxLineWidth - lineWidths[i];
	        }
	        else if (this._font.align === 'center')
	        {
	            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
	        }
	
	        lineAlignOffsets.push(alignOffset);
	    }
	
	    var lenChars = chars.length;
	    var tint = this.tint;
	
	    for (i = 0; i < lenChars; i++)
	    {
	        var c = this._glyphs[i]; // get the next glyph sprite
	
	        if (c)
	        {
	            c.texture = chars[i].texture;
	        }
	        else
	        {
	            c = new core.Sprite(chars[i].texture);
	            this._glyphs.push(c);
	        }
	
	        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
	        c.position.y = chars[i].position.y * scale;
	        c.scale.x = c.scale.y = scale;
	        c.tint = tint;
	
	        if (!c.parent)
	        {
	            this.addChild(c);
	        }
	    }
	
	    // remove unnecessary children.
	    for (i = lenChars; i < this._glyphs.length; ++i)
	    {
	        this.removeChild(this._glyphs[i]);
	    }
	
	    this.textWidth = maxLineWidth * scale;
	    this.textHeight = (pos.y + data.lineHeight) * scale;
	    this.maxLineHeight = maxLineHeight * scale;
	};
	
	/**
	 * Updates the transform of this object
	 *
	 * @private
	 */
	BitmapText.prototype.updateTransform = function ()
	{
	    this.validate();
	    this.containerUpdateTransform();
	};
	
	/**
	 * Validates text before calling parent's getLocalBounds
	 *
	 * @return {PIXI.Rectangle} The rectangular bounding area
	 */
	
	BitmapText.prototype.getLocalBounds = function()
	{
	    this.validate();
	    return core.Container.prototype.getLocalBounds.call(this);
	};
	
	/**
	 * Updates text when needed
	 *
	 * @private
	 */
	BitmapText.prototype.validate = function()
	{
	    if (this.dirty)
	    {
	        this.updateText();
	        this.dirty = false;
	    }
	};
	
	BitmapText.fonts = {};


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file        Main export of the PIXI filters library
	 * @author      Mat Groves <mat@goodboydigital.com>
	 * @copyright   2013-2015 GoodBoyDigital
	 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
	 */
	
	/**
	 * @namespace PIXI.filters
	 */
	module.exports = {
	    AsciiFilter:        __webpack_require__(84),
	    BloomFilter:        __webpack_require__(85),
	    BlurFilter:         __webpack_require__(88),
	    BlurXFilter:        __webpack_require__(86),
	    BlurYFilter:        __webpack_require__(87),
	    BlurDirFilter:      __webpack_require__(89),
	    ColorMatrixFilter:  __webpack_require__(90),
	    ColorStepFilter:    __webpack_require__(91),
	    ConvolutionFilter:  __webpack_require__(92),
	    CrossHatchFilter:   __webpack_require__(93),
	    DisplacementFilter: __webpack_require__(94),
	    DotScreenFilter:    __webpack_require__(95),
	    GrayFilter:         __webpack_require__(96),
	    DropShadowFilter:   __webpack_require__(97),
	    InvertFilter:       __webpack_require__(99),
	    NoiseFilter:        __webpack_require__(100),
	    PixelateFilter:     __webpack_require__(101),
	    RGBSplitFilter:     __webpack_require__(102),
	    ShockwaveFilter:    __webpack_require__(103),
	    SepiaFilter:        __webpack_require__(104),
	    SmartBlurFilter:    __webpack_require__(105),
	    TiltShiftFilter:    __webpack_require__(106),
	    TiltShiftXFilter:   __webpack_require__(107),
	    TiltShiftYFilter:   __webpack_require__(109),
	    TwistFilter:        __webpack_require__(110)
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	// TODO (cengler) - The Y is flipped in this shader for some reason.
	
	/**
	 * @author Vico @vicocotea
	 * original shader : https://www.shadertoy.com/view/lssGDj by @movAX13h
	 */
	
	/**
	 * An ASCII filter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function AsciiFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nuniform vec4 dimensions;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n    {\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy;\n\n    vec3 col = texture2D(uSampler, floor( uv / pixelSize ) * pixelSize / dimensions.xy).rgb;\n\n    float gray = (col.r + col.g + col.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    vec2 p = mod( uv / ( pixelSize * 0.5 ), 2.0) - vec2(1.0);\n    col = col * character(n, p);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n",
	        // custom uniforms
	        {
	            dimensions: { type: '4fv', value: new Float32Array([0, 0, 0, 0]) },
	            pixelSize:  { type: '1f', value: 8 }
	        }
	    );
	}
	
	AsciiFilter.prototype = Object.create(core.AbstractFilter.prototype);
	AsciiFilter.prototype.constructor = AsciiFilter;
	module.exports = AsciiFilter;
	
	Object.defineProperties(AsciiFilter.prototype, {
	    /**
	     * The pixel size used by the filter.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.AsciiFilter#
	     */
	    size: {
	        get: function ()
	        {
	            return this.uniforms.pixelSize.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.pixelSize.value = value;
	        }
	    }
	});


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    BlurXFilter = __webpack_require__(86),
	    BlurYFilter = __webpack_require__(87);
	
	/**
	 * The BloomFilter applies a Gaussian blur to an object.
	 * The strength of the blur can be set for x- and y-axis separately.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function BloomFilter()
	{
	    core.AbstractFilter.call(this);
	
	    this.blurXFilter = new BlurXFilter();
	    this.blurYFilter = new BlurYFilter();
	
	    this.defaultFilter = new core.AbstractFilter();
	}
	
	BloomFilter.prototype = Object.create(core.AbstractFilter.prototype);
	BloomFilter.prototype.constructor = BloomFilter;
	module.exports = BloomFilter;
	
	BloomFilter.prototype.applyFilter = function (renderer, input, output)
	{
	    var renderTarget = renderer.filterManager.getRenderTarget(true);
	
	    //TODO - copyTexSubImage2D could be used here?
	    this.defaultFilter.applyFilter(renderer, input, output);
	
	    this.blurXFilter.applyFilter(renderer, input, renderTarget);
	
	    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.SCREEN);
	
	    this.blurYFilter.applyFilter(renderer, renderTarget, output);
	
	    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);
	
	    renderer.filterManager.returnRenderTarget(renderTarget);
	};
	
	Object.defineProperties(BloomFilter.prototype, {
	    /**
	     * Sets the strength of both the blurX and blurY properties simultaneously
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.BloomFilter#
	     * @default 2
	     */
	    blur: {
	        get: function ()
	        {
	            return this.blurXFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurXFilter.blur = this.blurYFilter.blur = value;
	        }
	    },
	
	    /**
	     * Sets the strength of the blurX property
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.BloomFilter#
	     * @default 2
	     */
	    blurX: {
	        get: function ()
	        {
	            return this.blurXFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurXFilter.blur = value;
	        }
	    },
	
	    /**
	     * Sets the strength of the blurY property
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.BloomFilter#
	     * @default 2
	     */
	    blurY: {
	        get: function ()
	        {
	            return this.blurYFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurYFilter.blur = value;
	        }
	    }
	});


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The BlurXFilter applies a horizontal Gaussian blur to an object.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function BlurXFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
	        // fragment shader
	        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n",
	        // set the uniforms
	        {
	            strength: { type: '1f', value: 1 }
	        }
	    );
	
	    /**
	     * Sets the number of passes for blur. More passes means higher quaility bluring.
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.passes = 1;
	
	    this.strength = 4;
	}
	
	BlurXFilter.prototype = Object.create(core.AbstractFilter.prototype);
	BlurXFilter.prototype.constructor = BlurXFilter;
	module.exports = BlurXFilter;
	
	BlurXFilter.prototype.applyFilter = function (renderer, input, output, clear)
	{
	    var shader = this.getShader(renderer);
	
	    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);
	
	    if(this.passes === 1)
	    {
	        renderer.filterManager.applyFilter(shader, input, output, clear);
	    }
	    else
	    {
	        var renderTarget = renderer.filterManager.getRenderTarget(true);
	        var flip = input;
	        var flop = renderTarget;
	
	        for(var i = 0; i < this.passes-1; i++)
	        {
	            renderer.filterManager.applyFilter(shader, flip, flop, true);
	
	           var temp = flop;
	           flop = flip;
	           flip = temp;
	        }
	
	        renderer.filterManager.applyFilter(shader, flip, output, clear);
	
	        renderer.filterManager.returnRenderTarget(renderTarget);
	    }
	};
	
	
	Object.defineProperties(BlurXFilter.prototype, {
	    /**
	     * Sets the strength of both the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.BlurXFilter#
	     * @default 2
	     */
	    blur: {
	        get: function ()
	        {
	            return  this.strength;
	        },
	        set: function (value)
	        {
	            this.padding =  Math.abs(value) * 0.5;
	            this.strength = value;
	        }
	    }
	});


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The BlurYFilter applies a horizontal Gaussian blur to an object.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function BlurYFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
	        // fragment shader
	        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n",
	        // set the uniforms
	        {
	            strength: { type: '1f', value: 1 }
	        }
	    );
	
	    this.passes = 1;
	    this.strength = 4;
	}
	
	BlurYFilter.prototype = Object.create(core.AbstractFilter.prototype);
	BlurYFilter.prototype.constructor = BlurYFilter;
	module.exports = BlurYFilter;
	
	BlurYFilter.prototype.applyFilter = function (renderer, input, output, clear)
	{
	    var shader = this.getShader(renderer);
	
	    this.uniforms.strength.value = Math.abs(this.strength) / 4 / this.passes * (input.frame.height / input.size.height);
	
	    if(this.passes === 1)
	    {
	        renderer.filterManager.applyFilter(shader, input, output, clear);
	    }
	    else
	    {
	        var renderTarget = renderer.filterManager.getRenderTarget(true);
	        var flip = input;
	        var flop = renderTarget;
	
	        for(var i = 0; i < this.passes-1; i++)
	        {
	            renderer.filterManager.applyFilter(shader, flip, flop, true);
	
	           var temp = flop;
	           flop = flip;
	           flip = temp;
	        }
	
	        renderer.filterManager.applyFilter(shader, flip, output, clear);
	
	        renderer.filterManager.returnRenderTarget(renderTarget);
	    }
	};
	
	
	Object.defineProperties(BlurYFilter.prototype, {
	    /**
	     * Sets the strength of both the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.BlurYFilter#
	     * @default 2
	     */
	    blur: {
	        get: function ()
	        {
	            return  this.strength;
	        },
	        set: function (value)
	        {
	            this.padding = Math.abs(value) * 0.5;
	            this.strength = value;
	        }
	    }
	});


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    BlurXFilter = __webpack_require__(86),
	    BlurYFilter = __webpack_require__(87);
	
	/**
	 * The BlurFilter applies a Gaussian blur to an object.
	 * The strength of the blur can be set for x- and y-axis separately.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function BlurFilter()
	{
	    core.AbstractFilter.call(this);
	
	    this.blurXFilter = new BlurXFilter();
	    this.blurYFilter = new BlurYFilter();
	}
	
	BlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
	BlurFilter.prototype.constructor = BlurFilter;
	module.exports = BlurFilter;
	
	BlurFilter.prototype.applyFilter = function (renderer, input, output)
	{
	    var renderTarget = renderer.filterManager.getRenderTarget(true);
	
	    this.blurXFilter.applyFilter(renderer, input, renderTarget);
	    this.blurYFilter.applyFilter(renderer, renderTarget, output);
	
	    renderer.filterManager.returnRenderTarget(renderTarget);
	};
	
	Object.defineProperties(BlurFilter.prototype, {
	    /**
	     * Sets the strength of both the blurX and blurY properties simultaneously
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.BlurFilter#
	     * @default 2
	     */
	    blur: {
	        get: function ()
	        {
	            return this.blurXFilter.blur;
	        },
	        set: function (value)
	        {
	            this.padding = Math.abs(value) * 0.5;
	            this.blurXFilter.blur = this.blurYFilter.blur = value;
	        }
	    },
	
	    /**
	     * Sets the number of passes for blur. More passes means higher quaility bluring.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.BlurYFilter#
	     * @default 1
	     */
	    passes: {
	        get: function ()
	        {
	            return  this.blurXFilter.passes;
	        },
	        set: function (value)
	        {
	            this.blurXFilter.passes = this.blurYFilter.passes = value;
	        }
	    },
	
	    /**
	     * Sets the strength of the blurX property
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.BlurFilter#
	     * @default 2
	     */
	    blurX: {
	        get: function ()
	        {
	            return this.blurXFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurXFilter.blur = value;
	        }
	    },
	
	    /**
	     * Sets the strength of the blurY property
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.BlurFilter#
	     * @default 2
	     */
	    blurY: {
	        get: function ()
	        {
	            return this.blurYFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurYFilter.blur = value;
	        }
	    }
	});


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	
	/**
	 * The BlurDirFilter applies a Gaussian blur toward a direction to an object.
	 *
	 * @class
	 * @param {number} dirX
	 * @param {number} dirY
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function BlurDirFilter(dirX, dirY)
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform float dirX;\nuniform float dirY;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[3];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[0] = aTextureCoord + vec2( (0.004 * strength) * dirX, (0.004 * strength) * dirY );\n    vBlurTexCoords[1] = aTextureCoord + vec2( (0.008 * strength) * dirX, (0.008 * strength) * dirY );\n    vBlurTexCoords[2] = aTextureCoord + vec2( (0.012 * strength) * dirX, (0.012 * strength) * dirY );\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
	        // fragment shader
	        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[3];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vTextureCoord     ) * 0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0]) * 0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1]) * 0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2]) * 0.004431848411938341;\n}\n",
	        // set the uniforms
	        {
	            strength: { type: '1f', value: 1 },
	            dirX: { type: '1f', value: dirX || 0 },
	            dirY: { type: '1f', value: dirY || 0 }
	        }
	    );
	
	    this.defaultFilter = new core.AbstractFilter();
	
	    /**
	     * Sets the number of passes for blur. More passes means higher quaility bluring.
	     *
	     * @member {number}
	     * @default 1
	     */
	    this.passes = 1;
	
	    /**
	     * Sets the X direction of the blur
	     *
	     * @member {number}
	     * @default 0
	     */
	    this.dirX = dirX || 0;
	
	    /**
	     * Sets the Y direction of the blur
	     *
	     * @member {number}
	     * @default 0
	     */
	    this.dirY = dirY || 0;
	
	    this.strength = 4;
	}
	
	BlurDirFilter.prototype = Object.create(core.AbstractFilter.prototype);
	BlurDirFilter.prototype.constructor = BlurDirFilter;
	module.exports = BlurDirFilter;
	
	BlurDirFilter.prototype.applyFilter = function (renderer, input, output, clear) {
	
	    var shader = this.getShader(renderer);
	
	    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);
	
	    if (this.passes === 1) {
	        renderer.filterManager.applyFilter(shader, input, output, clear);
	    } else {
	        var renderTarget = renderer.filterManager.getRenderTarget(true);
	
	        renderer.filterManager.applyFilter(shader, input, renderTarget, clear);
	
	        for(var i = 0; i < this.passes-2; i++)
	        {
	            //this.uniforms.strength.value = this.strength / 4 / (this.passes+(i*2)) * (input.frame.width / input.size.width);
	            renderer.filterManager.applyFilter(shader, renderTarget, renderTarget, clear);
	        }
	
	        renderer.filterManager.applyFilter(shader, renderTarget, output, clear);
	
	        renderer.filterManager.returnRenderTarget(renderTarget);
	    }
	};
	
	
	Object.defineProperties(BlurDirFilter.prototype, {
	    /**
	     * Sets the strength of both the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.BlurDirFilter#
	     * @default 2
	     */
	    blur: {
	        get: function ()
	        {
	            return this.strength;
	        },
	        set: function (value)
	        {
	            this.padding = value * 0.5;
	            this.strength = value;
	        }
	    },
	    /**
	     * Sets the X direction of the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.BlurYFilter#
	     * @default 0
	     */
	    dirX: {
	        get: function ()
	        {
	            return this.dirX;
	        },
	        set: function (value)
	        {
	            this.uniforms.dirX.value = value;
	        }
	    },
	    /**
	     * Sets the Y direction of the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.BlurDirFilter#
	     * @default 0
	     */
	    dirY: {
	        get: function ()
	        {
	            return this.dirY;
	        },
	        set: function (value)
	        {
	            this.uniforms.dirY.value = value;
	        }
	    }
	});


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The ColorMatrixFilter class lets you apply a 5x4 matrix transformation on the RGBA
	 * color and alpha values of every pixel on your displayObject to produce a result
	 * with a new set of RGBA color and alpha values. It's pretty powerful!
	 *
	 * ```js
	 *  var colorMatrix = new PIXI.ColorMatrixFilter();
	 *  container.filters = [colorMatrix];
	 *  colorMatrix.contrast(2);
	 * ```
	 * @author Clment Chenebault <clement@goodboydigital.com>
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function ColorMatrixFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[25];\n\nvoid main(void)\n{\n\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor.r = (m[0] * c.r);\n        gl_FragColor.r += (m[1] * c.g);\n        gl_FragColor.r += (m[2] * c.b);\n        gl_FragColor.r += (m[3] * c.a);\n        gl_FragColor.r += m[4] * c.a;\n\n    gl_FragColor.g = (m[5] * c.r);\n        gl_FragColor.g += (m[6] * c.g);\n        gl_FragColor.g += (m[7] * c.b);\n        gl_FragColor.g += (m[8] * c.a);\n        gl_FragColor.g += m[9] * c.a;\n\n     gl_FragColor.b = (m[10] * c.r);\n        gl_FragColor.b += (m[11] * c.g);\n        gl_FragColor.b += (m[12] * c.b);\n        gl_FragColor.b += (m[13] * c.a);\n        gl_FragColor.b += m[14] * c.a;\n\n     gl_FragColor.a = (m[15] * c.r);\n        gl_FragColor.a += (m[16] * c.g);\n        gl_FragColor.a += (m[17] * c.b);\n        gl_FragColor.a += (m[18] * c.a);\n        gl_FragColor.a += m[19] * c.a;\n\n}\n",
	        // custom uniforms
	        {
	            m: {
	                type: '1fv', value: [
	                    1, 0, 0, 0, 0,
	                    0, 1, 0, 0, 0,
	                    0, 0, 1, 0, 0,
	                    0, 0, 0, 1, 0
	                ]
	            }
	        }
	    );
	}
	
	ColorMatrixFilter.prototype = Object.create(core.AbstractFilter.prototype);
	ColorMatrixFilter.prototype.constructor = ColorMatrixFilter;
	module.exports = ColorMatrixFilter;
	
	
	/**
	 * Transforms current matrix and set the new one
	 *
	 * @param matrix {number[]} (mat 5x4)
	 * @param multiply {boolean} if true, current matrix and matrix are multiplied. If false, just set the current matrix with @param matrix
	 */
	ColorMatrixFilter.prototype._loadMatrix = function (matrix, multiply)
	{
	    multiply = !!multiply;
	
	    var newMatrix = matrix;
	
	    if (multiply) {
	        this._multiply(newMatrix, this.uniforms.m.value, matrix);
	        newMatrix = this._colorMatrix(newMatrix);
	    }
	
	    // set the new matrix
	    this.uniforms.m.value = newMatrix;
	};
	
	/**
	 * Multiplies two mat5's
	 *
	 * @param out {number[]} (mat 5x4) the receiving matrix
	 * @param a {number[]} (mat 5x4) the first operand
	 * @param b {number[]} (mat 5x4) the second operand
	 * @returns out {number[]} (mat 5x4)
	 */
	ColorMatrixFilter.prototype._multiply = function (out, a, b)
	{
	
	    // Red Channel
	    out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
	    out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
	    out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
	    out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
	    out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]);
	
	    // Green Channel
	    out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
	    out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
	    out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
	    out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
	    out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]);
	
	    // Blue Channel
	    out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
	    out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
	    out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
	    out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
	    out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]);
	
	    // Alpha Channel
	    out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
	    out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
	    out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
	    out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
	    out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]);
	
	    return out;
	};
	
	/**
	 * Create a Float32 Array and normalize the offset component to 0-1
	 *
	 * @param matrix {number[]} (mat 5x4)
	 * @return m {number[]} (mat 5x4) with all values between 0-1
	 */
	ColorMatrixFilter.prototype._colorMatrix = function (matrix)
	{
	    // Create a Float32 Array and normalize the offset component to 0-1
	    var m = new Float32Array(matrix);
	    m[4] /= 255;
	    m[9] /= 255;
	    m[14] /= 255;
	    m[19] /= 255;
	
	    return m;
	};
	
	/**
	 * Adjusts brightness
	 *
	 * @param b {number} value of the brigthness (0 is black)
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.brightness = function (b, multiply)
	{
	    var matrix = [
	        b, 0, 0, 0, 0,
	        0, b, 0, 0, 0,
	        0, 0, b, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Set the matrices in grey scales
	 *
	 * @param scale {number} value of the grey (0 is black)
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.greyscale = function (scale, multiply)
	{
	    var matrix = [
	        scale, scale, scale, 0, 0,
	        scale, scale, scale, 0, 0,
	        scale, scale, scale, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	//Americanized alias
	ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
	
	/**
	 * Set the black and white matrice
	 * Multiply the current matrix
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.blackAndWhite = function (multiply)
	{
	    var matrix = [
	        0.3, 0.6, 0.1, 0, 0,
	        0.3, 0.6, 0.1, 0, 0,
	        0.3, 0.6, 0.1, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Set the hue property of the color
	 *
	 * @param rotation {number} in degrees
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.hue = function (rotation, multiply)
	{
	    rotation = (rotation || 0) / 180 * Math.PI;
	    var cos = Math.cos(rotation),
	        sin = Math.sin(rotation);
	
	    // luminanceRed, luminanceGreen, luminanceBlue
	    var lumR = 0.213, // or 0.3086
	        lumG = 0.715, // or 0.6094
	        lumB = 0.072; // or 0.0820
	
	    var matrix = [
	        lumR + cos * (1 - lumR) + sin * (-lumR), lumG + cos * (-lumG) + sin * (-lumG), lumB + cos * (-lumB) + sin * (1 - lumB), 0, 0,
	        lumR + cos * (-lumR) + sin * (0.143), lumG + cos * (1 - lumG) + sin * (0.140), lumB + cos * (-lumB) + sin * (-0.283), 0, 0,
	        lumR + cos * (-lumR) + sin * (-(1 - lumR)), lumG + cos * (-lumG) + sin * (lumG), lumB + cos * (1 - lumB) + sin * (lumB), 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	
	/**
	 * Set the contrast matrix, increase the separation between dark and bright
	 * Increase contrast : shadows darker and highlights brighter
	 * Decrease contrast : bring the shadows up and the highlights down
	 *
	 * @param amount {number} value of the contrast
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.contrast = function (amount, multiply)
	{
	    var v = (amount || 0) + 1;
	    var o = -128 * (v - 1);
	
	    var matrix = [
	        v, 0, 0, 0, o,
	        0, v, 0, 0, o,
	        0, 0, v, 0, o,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Set the saturation matrix, increase the separation between colors
	 * Increase saturation : increase contrast, brightness, and sharpness
	 *
	 * @param amount {number}
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.saturate = function (amount, multiply)
	{
	    var x = (amount || 0) * 2 / 3 + 1;
	    var y = ((x - 1) * -0.5);
	
	    var matrix = [
	        x, y, y, 0, 0,
	        y, x, y, 0, 0,
	        y, y, x, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Desaturate image (remove color)
	 *
	 * Call the saturate function
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.desaturate = function (multiply) // jshint unused:false
	{
	    this.saturate(-1);
	};
	
	/**
	 * Negative image (inverse of classic rgb matrix)
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.negative = function (multiply)
	{
	    var matrix = [
	        0, 1, 1, 0, 0,
	        1, 0, 1, 0, 0,
	        1, 1, 0, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Sepia image
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.sepia = function (multiply)
	{
	    var matrix = [
	        0.393, 0.7689999, 0.18899999, 0, 0,
	        0.349, 0.6859999, 0.16799999, 0, 0,
	        0.272, 0.5339999, 0.13099999, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.technicolor = function (multiply)
	{
	    var matrix = [
	        1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
	        -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
	        -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Polaroid filter
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.polaroid = function (multiply)
	{
	    var matrix = [
	        1.438, -0.062, -0.062, 0, 0,
	        -0.122, 1.378, -0.122, 0, 0,
	        -0.016, -0.016, 1.483, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Filter who transforms : Red -> Blue and Blue -> Red
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.toBGR = function (multiply)
	{
	    var matrix = [
	        0, 0, 1, 0, 0,
	        0, 1, 0, 0, 0,
	        1, 0, 0, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.kodachrome = function (multiply)
	{
	    var matrix = [
	        1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
	        -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
	        -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/**
	 * Brown delicious browni filter (thanks Dominic Szablewski)
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.browni = function (multiply)
	{
	    var matrix = [
	        0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
	        -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
	        0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/*
	 * Vintage filter (thanks Dominic Szablewski)
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.vintage = function (multiply)
	{
	    var matrix = [
	        0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
	        0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
	        0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/*
	 * We don't know exactly what it does, kind of gradient map, but funny to play with!
	 *
	 * @param desaturation {number}
	 * @param toned {number}
	 * @param lightColor {string} (example : "0xFFE580")
	 * @param darkColor {string}  (example : "0xFFE580")
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.colorTone = function (desaturation, toned, lightColor, darkColor, multiply)
	{
	    desaturation = desaturation || 0.2;
	    toned = toned || 0.15;
	    lightColor = lightColor || 0xFFE580;
	    darkColor = darkColor || 0x338000;
	
	    var lR = ((lightColor >> 16) & 0xFF) / 255;
	    var lG = ((lightColor >> 8) & 0xFF) / 255;
	    var lB = (lightColor & 0xFF) / 255;
	
	    var dR = ((darkColor >> 16) & 0xFF) / 255;
	    var dG = ((darkColor >> 8) & 0xFF) / 255;
	    var dB = (darkColor & 0xFF) / 255;
	
	    var matrix = [
	        0.3, 0.59, 0.11, 0, 0,
	        lR, lG, lB, desaturation, 0,
	        dR, dG, dB, toned, 0,
	        lR - dR, lG - dG, lB - dB, 0, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/*
	 * Night effect
	 *
	 * @param intensity {number}
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.night = function (intensity, multiply)
	{
	    intensity = intensity || 0.1;
	    var matrix = [
	        intensity * ( -2.0), -intensity, 0, 0, 0,
	        -intensity, 0, intensity, 0, 0,
	        0, intensity, intensity * 2.0, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	
	/*
	 * Predator effect
	 *
	 * Erase the current matrix by setting a new indepent one
	 *
	 * @param amount {number} how much the predator feels his future victim
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.predator = function (amount, multiply)
	{
	    var matrix = [
	        11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount,
	        -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount,
	        -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/*
	 * LSD effect
	 *
	 * Multiply the current matrix
	 *
	 * @param amount {number} How crazy is your effect
	 * @param multiply {boolean} refer to ._loadMatrix() method
	 */
	ColorMatrixFilter.prototype.lsd = function (multiply)
	{
	    var matrix = [
	        2, -0.4, 0.5, 0, 0,
	        -0.5, 2, -0.4, 0, 0,
	        -0.4, -0.5, 3, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, multiply);
	};
	
	/*
	 * Erase the current matrix by setting the default one
	 *
	 */
	ColorMatrixFilter.prototype.reset = function ()
	{
	    var matrix = [
	        1, 0, 0, 0, 0,
	        0, 1, 0, 0, 0,
	        0, 0, 1, 0, 0,
	        0, 0, 0, 1, 0
	    ];
	
	    this._loadMatrix(matrix, false);
	};
	
	
	Object.defineProperties(ColorMatrixFilter.prototype, {
	    /**
	     * Sets the matrix of the color matrix filter
	     *
	     * @member {number[]}
	     * @memberof PIXI.filters.ColorMatrixFilter#
	     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
	     */
	    matrix: {
	        get: function ()
	        {
	            return this.uniforms.m.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.m.value = value;
	        }
	    }
	});


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function ColorStepFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float step;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    color = floor(color * step) / step;\n\n    gl_FragColor = color;\n}\n",
	        // custom uniforms
	        {
	            step: { type: '1f', value: 5 }
	        }
	    );
	}
	
	ColorStepFilter.prototype = Object.create(core.AbstractFilter.prototype);
	ColorStepFilter.prototype.constructor = ColorStepFilter;
	module.exports = ColorStepFilter;
	
	Object.defineProperties(ColorStepFilter.prototype, {
	    /**
	     * The number of steps to reduce the palette by.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.ColorStepFilter#
	     */
	    step: {
	        get: function ()
	        {
	            return this.uniforms.step.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.step.value = value;
	        }
	    }
	});


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The ConvolutionFilter class applies a matrix convolution filter effect.
	 * A convolution combines pixels in the input image with neighboring pixels to produce a new image.
	 * A wide variety of image effects can be achieved through convolutions, including blurring, edge
	 * detection, sharpening, embossing, and beveling. The matrix should be specified as a 9 point Array.
	 * See http://docs.gimp.org/en/plug-in-convmatrix.html for more info.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 * @param matrix {number[]} An array of values used for matrix transformation. Specified as a 9 point Array.
	 * @param width {number} Width of the object you are transforming
	 * @param height {number} Height of the object you are transforming
	 */
	function ConvolutionFilter(matrix, width, height)
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n",
	        // custom uniforms
	        {
	            matrix:     { type: '1fv', value: new Float32Array(matrix) },
	            texelSize:  { type: 'v2', value: { x: 1 / width, y: 1 / height } }
	        }
	    );
	}
	
	ConvolutionFilter.prototype = Object.create(core.AbstractFilter.prototype);
	ConvolutionFilter.prototype.constructor = ConvolutionFilter;
	module.exports = ConvolutionFilter;
	
	Object.defineProperties(ConvolutionFilter.prototype, {
	    /**
	     * An array of values used for matrix transformation. Specified as a 9 point Array.
	     *
	     * @member {number[]}
	     * @memberof PIXI.filters.ConvolutionFilter#
	     */
	    matrix: {
	        get: function ()
	        {
	            return this.uniforms.matrix.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.matrix.value = new Float32Array(value);
	        }
	    },
	
	    /**
	     * Width of the object you are transforming
	     *
	     * @member {number}
	     * @memberof PIXI.filters.ConvolutionFilter#
	     */
	    width: {
	        get: function ()
	        {
	            return 1/this.uniforms.texelSize.value.x;
	        },
	        set: function (value)
	        {
	            this.uniforms.texelSize.value.x = 1/value;
	        }
	    },
	
	    /**
	     * Height of the object you are transforming
	     *
	     * @member {number}
	     * @memberof PIXI.filters.ConvolutionFilter#
	     */
	    height: {
	        get: function ()
	        {
	            return 1/this.uniforms.texelSize.value.y;
	        },
	        set: function (value)
	        {
	            this.uniforms.texelSize.value.y = 1/value;
	        }
	    }
	});


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * A Cross Hatch effect filter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function CrossHatchFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n"
	    );
	}
	
	CrossHatchFilter.prototype = Object.create(core.AbstractFilter.prototype);
	CrossHatchFilter.prototype.constructor = CrossHatchFilter;
	module.exports = CrossHatchFilter;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
	 * You can use this filter to apply all manor of crazy warping effects
	 * Currently the r property of the texture is used to offset the x and the g property of the texture is used to offset the y.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 * @param sprite {PIXI.Sprite} the sprite used for the displacement map. (make sure its added to the scene!)
	 */
	function DisplacementFilter(sprite, scale)
	{
	    var maskMatrix = new core.Matrix();
	    sprite.renderable = false;
	
	    core.AbstractFilter.call(this,
	        // vertex shader
	        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vMapCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nvoid main(void)\n{\n   vec4 map =  texture2D(mapSampler, vMapCoord);\n\n   map -= 0.5;\n   map.xy *= scale;\n\n   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y));\n}\n",
	        // uniforms
	        {
	            mapSampler:     { type: 'sampler2D', value: sprite.texture },
	            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) },
	            scale:          { type: 'v2', value: { x: 1, y: 1 } }
	        }
	    );
	
	    this.maskSprite = sprite;
	    this.maskMatrix = maskMatrix;
	
	    if (scale === null || scale === undefined)
	    {
	        scale = 20;
	    }
	
	    this.scale = new core.Point(scale, scale);
	}
	
	DisplacementFilter.prototype = Object.create(core.AbstractFilter.prototype);
	DisplacementFilter.prototype.constructor = DisplacementFilter;
	module.exports = DisplacementFilter;
	
	DisplacementFilter.prototype.applyFilter = function (renderer, input, output)
	{
	    var filterManager = renderer.filterManager;
	
	    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);
	
	    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
	    this.uniforms.scale.value.x = this.scale.x * (1/input.frame.width);
	    this.uniforms.scale.value.y = this.scale.y * (1/input.frame.height);
	
	    var shader = this.getShader(renderer);
	     // draw the filter...
	    filterManager.applyFilter(shader, input, output);
	};
	
	
	Object.defineProperties(DisplacementFilter.prototype, {
	    /**
	     * The texture used for the displacement map. Must be power of 2 sized texture.
	     *
	     * @member {PIXI.Texture}
	     * @memberof PIXI.filters.DisplacementFilter#
	     */
	    map: {
	        get: function ()
	        {
	            return this.uniforms.mapSampler.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.mapSampler.value = value;
	
	        }
	    }
	});


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * @author Mat Groves http://matgroves.com/ @Doormat23
	 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js
	 */
	
	/**
	 * This filter applies a dotscreen effect making display objects appear to be made out of
	 * black and white halftone dots like an old printer.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function DotScreenFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 dimensions;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * dimensions.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n",
	        // custom uniforms
	        {
	            scale:      { type: '1f', value: 1 },
	            angle:      { type: '1f', value: 5 },
	            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
	        }
	    );
	}
	
	DotScreenFilter.prototype = Object.create(core.AbstractFilter.prototype);
	DotScreenFilter.prototype.constructor = DotScreenFilter;
	module.exports = DotScreenFilter;
	
	Object.defineProperties(DotScreenFilter.prototype, {
	    /**
	     * The scale of the effect.
	     * @member {number}
	     * @memberof PIXI.filters.DotScreenFilter#
	     */
	    scale: {
	        get: function ()
	        {
	            return this.uniforms.scale.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.scale.value = value;
	        }
	    },
	
	    /**
	     * The radius of the effect.
	     * @member {number}
	     * @memberof PIXI.filters.DotScreenFilter#
	     */
	    angle: {
	        get: function ()
	        {
	            return this.uniforms.angle.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.angle.value = value;
	        }
	    }
	});


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * This greyscales the palette of your Display Objects.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function GrayFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float gray;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);\n}\n",
	        // set the uniforms
	        {
	            gray: { type: '1f', value: 1 }
	        }
	    );
	}
	
	GrayFilter.prototype = Object.create(core.AbstractFilter.prototype);
	GrayFilter.prototype.constructor = GrayFilter;
	module.exports = GrayFilter;
	
	Object.defineProperties(GrayFilter.prototype, {
	    /**
	     * The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.GrayFilter#
	     */
	    gray: {
	        get: function ()
	        {
	            return this.uniforms.gray.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.gray.value = value;
	        }
	    }
	});


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    BlurXFilter = __webpack_require__(86),
	    BlurYTintFilter = __webpack_require__(98);
	
	/**
	 * The DropShadowFilter applies a Gaussian blur to an object.
	 * The strength of the blur can be set for x- and y-axis separately.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function DropShadowFilter()
	{
	    core.AbstractFilter.call(this);
	
	    this.blurXFilter = new BlurXFilter();
	    this.blurYTintFilter = new BlurYTintFilter();
	
	    this.defaultFilter = new core.AbstractFilter();
	
	    this.padding = 30;
	
	    this._dirtyPosition = true;
	    this._angle = 45 * Math.PI / 180;
	    this._distance = 10;
	    this.alpha = 0.75;
	    this.hideObject = false;
	    this.blendMode = core.BLEND_MODES.MULTIPLY;
	}
	
	DropShadowFilter.prototype = Object.create(core.AbstractFilter.prototype);
	DropShadowFilter.prototype.constructor = DropShadowFilter;
	module.exports = DropShadowFilter;
	
	DropShadowFilter.prototype.applyFilter = function (renderer, input, output)
	{
	    var renderTarget = renderer.filterManager.getRenderTarget(true);
	
	    //TODO - copyTexSubImage2D could be used here?
	    if(this._dirtyPosition)
	    {
	        this._dirtyPosition = false;
	
	        this.blurYTintFilter.uniforms.offset.value[0] = Math.sin(this._angle) * this._distance;
	        this.blurYTintFilter.uniforms.offset.value[1] = Math.cos(this._angle) * this._distance;
	    }
	
	    this.blurXFilter.applyFilter(renderer, input, renderTarget);
	
	    renderer.blendModeManager.setBlendMode(this.blendMode);
	
	    this.blurYTintFilter.applyFilter(renderer, renderTarget, output);
	
	    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);
	
	    if(!this.hideObject)
	    {
	
	        this.defaultFilter.applyFilter(renderer, input, output);
	    }
	
	
	    renderer.filterManager.returnRenderTarget(renderTarget);
	};
	
	Object.defineProperties(DropShadowFilter.prototype, {
	    /**
	     * Sets the strength of both the blurX and blurY properties simultaneously
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.DropShadowFilter#
	     * @default 2
	     */
	    blur: {
	        get: function ()
	        {
	            return this.blurXFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurXFilter.blur = this.blurYTintFilter.blur = value;
	        }
	    },
	
	    /**
	     * Sets the strength of the blurX property
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.DropShadowFilter#
	     * @default 2
	     */
	    blurX: {
	        get: function ()
	        {
	            return this.blurXFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurXFilter.blur = value;
	        }
	    },
	
	    /**
	     * Sets the strength of the blurY property
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.DropShadowFilter#
	     * @default 2
	     */
	    blurY: {
	        get: function ()
	        {
	            return this.blurYTintFilter.blur;
	        },
	        set: function (value)
	        {
	            this.blurYTintFilter.blur = value;
	        }
	    },
	
	    /**
	     * Sets the color of the shadow
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.DropShadowFilter#
	     */
	    color: {
	        get: function ()
	        {
	            return  core.utils.rgb2hex( this.blurYTintFilter.uniforms.color.value );
	        },
	        set: function (value)
	        {
	            this.blurYTintFilter.uniforms.color.value = core.utils.hex2rgb(value);
	        }
	    },
	
	    /**
	     * Sets the alpha of the shadow
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.DropShadowFilter#
	     */
	    alpha: {
	        get: function ()
	        {
	            return  this.blurYTintFilter.uniforms.alpha.value;
	        },
	        set: function (value)
	        {
	            this.blurYTintFilter.uniforms.alpha.value = value;
	        }
	    },
	
	    /**
	     * Sets the distance of the shadow
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.DropShadowFilter#
	     */
	    distance: {
	        get: function ()
	        {
	            return  this._distance;
	        },
	        set: function (value)
	        {
	            this._dirtyPosition = true;
	            this._distance = value;
	        }
	    },
	
	    /**
	     * Sets the angle of the shadow
	     *
	     * @member {number}
	     * @memberOf PIXI.filters.DropShadowFilter#
	     */
	    angle: {
	        get: function ()
	        {
	            return  this._angle;
	        },
	        set: function (value)
	        {
	            this._dirtyPosition = true;
	            this._angle = value;
	        }
	    }
	});


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The BlurYTintFilter applies a vertical Gaussian blur to an object.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function BlurYTintFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform vec2 offset;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition+offset), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
	        // fragment shader
	        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform vec3 color;\nuniform float alpha;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec4 sum = vec4(0.0);\n\n    sum += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    sum += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    sum += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    sum += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    sum += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n\n    gl_FragColor = vec4( color.rgb * sum.a * alpha, sum.a * alpha );\n}\n",
	        // set the uniforms
	        {
	            blur: { type: '1f', value: 1 / 512 },
	            color: { type: 'c', value: [0,0,0]},
	            alpha: { type: '1f', value: 0.7 },
	            offset: { type: '2f', value:[5, 5]},
	            strength: { type: '1f', value:1}
	        }
	    );
	
	    this.passes = 1;
	    this.strength = 4;
	}
	
	BlurYTintFilter.prototype = Object.create(core.AbstractFilter.prototype);
	BlurYTintFilter.prototype.constructor = BlurYTintFilter;
	module.exports = BlurYTintFilter;
	
	BlurYTintFilter.prototype.applyFilter = function (renderer, input, output, clear)
	{
	    var shader = this.getShader(renderer);
	
	    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.height / input.size.height);
	
	    if(this.passes === 1)
	    {
	        renderer.filterManager.applyFilter(shader, input, output, clear);
	    }
	    else
	    {
	        var renderTarget = renderer.filterManager.getRenderTarget(true);
	        var flip = input;
	        var flop = renderTarget;
	
	        for(var i = 0; i < this.passes-1; i++)
	        {
	            renderer.filterManager.applyFilter(shader, flip, flop, clear);
	
	           var temp = flop;
	           flop = flip;
	           flip = temp;
	        }
	
	        renderer.filterManager.applyFilter(shader, flip, output, clear);
	
	        renderer.filterManager.returnRenderTarget(renderTarget);
	    }
	};
	
	
	Object.defineProperties(BlurYTintFilter.prototype, {
	    /**
	     * Sets the strength of both the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.BlurYTintFilter#
	     * @default 2
	     */
	    blur: {
	        get: function ()
	        {
	            return  this.strength;
	        },
	        set: function (value)
	        {
	            this.padding = value * 0.5;
	            this.strength = value;
	        }
	    }
	});


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * This inverts your Display Objects colors.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function InvertFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform float invert;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);\n}\n",
	        // custom uniforms
	        {
	            invert: { type: '1f', value: 1 }
	        }
	    );
	}
	
	InvertFilter.prototype = Object.create(core.AbstractFilter.prototype);
	InvertFilter.prototype.constructor = InvertFilter;
	module.exports = InvertFilter;
	
	Object.defineProperties(InvertFilter.prototype, {
	    /**
	     * The strength of the invert. `1` will fully invert the colors, and
	     * `0` will make the object its normal color.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.InvertFilter#
	     */
	    invert: {
	        get: function ()
	        {
	            return this.uniforms.invert.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.invert.value = value;
	        }
	    }
	});


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * @author Vico @vicocotea
	 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js
	 */
	
	/**
	 * A Noise effect filter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function NoiseFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float noise;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    float diff = (rand(vTextureCoord) - 0.5) * noise;\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    gl_FragColor = color;\n}\n",
	        // custom uniforms
	        {
	            noise: { type: '1f', value: 0.5 }
	        }
	    );
	}
	
	NoiseFilter.prototype = Object.create(core.AbstractFilter.prototype);
	NoiseFilter.prototype.constructor = NoiseFilter;
	module.exports = NoiseFilter;
	
	Object.defineProperties(NoiseFilter.prototype, {
	    /**
	     * The amount of noise to apply.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.NoiseFilter#
	     * @default 0.5
	     */
	    noise: {
	        get: function ()
	        {
	            return this.uniforms.noise.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.noise.value = value;
	        }
	    }
	});


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * This filter applies a pixelate effect making display objects appear 'blocky'.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function PixelateFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 dimensions;\nuniform vec2 pixelSize;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord;\n\n    vec2 size = dimensions.xy / pixelSize;\n\n    vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;\n\n    gl_FragColor = texture2D(uSampler, color);\n}\n",
	        // custom uniforms
	        {
	            dimensions: { type: '4fv',  value: new Float32Array([0, 0, 0, 0]) },
	            pixelSize:  { type: 'v2',   value: { x: 10, y: 10 } }
	        }
	    );
	}
	
	PixelateFilter.prototype = Object.create(core.AbstractFilter.prototype);
	PixelateFilter.prototype.constructor = PixelateFilter;
	module.exports = PixelateFilter;
	
	Object.defineProperties(PixelateFilter.prototype, {
	    /**
	     * This a point that describes the size of the blocks.
	     * x is the width of the block and y is the height.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.filters.PixelateFilter#
	     */
	    size: {
	        get: function ()
	        {
	            return this.uniforms.pixelSize.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.pixelSize.value = value;
	        }
	    }
	});


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * An RGB Split Filter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function RGBSplitFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 dimensions;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n",
	        // custom uniforms
	        {
	            red:        { type: 'v2', value: { x: 20, y: 20 } },
	            green:      { type: 'v2', value: { x: -20, y: 20 } },
	            blue:       { type: 'v2', value: { x: 20, y: -20 } },
	            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
	        }
	    );
	}
	
	RGBSplitFilter.prototype = Object.create(core.AbstractFilter.prototype);
	RGBSplitFilter.prototype.constructor = RGBSplitFilter;
	module.exports = RGBSplitFilter;
	
	Object.defineProperties(RGBSplitFilter.prototype, {
	    /**
	     * Red channel offset.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.filters.RGBSplitFilter#
	     */
	    red: {
	        get: function ()
	        {
	            return this.uniforms.red.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.red.value = value;
	        }
	    },
	
	    /**
	     * Green channel offset.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.filters.RGBSplitFilter#
	     */
	    green: {
	        get: function ()
	        {
	            return this.uniforms.green.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.green.value = value;
	        }
	    },
	
	    /**
	     * Blue offset.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.filters.RGBSplitFilter#
	     */
	    blue: {
	        get: function ()
	        {
	            return this.uniforms.blue.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.blue.value = value;
	        }
	    }
	});


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA
	 * color and alpha values of every pixel on your displayObject to produce a result
	 * with a new set of RGBA color and alpha values. It's pretty powerful!
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function ShockwaveFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nuniform vec2 center;\nuniform vec3 params; // 10.0, 0.8, 0.1\nuniform float time;\n\nvoid main()\n{\n    vec2 uv = vTextureCoord;\n    vec2 texCoord = uv;\n\n    float dist = distance(uv, center);\n\n    if ( (dist <= (time + params.z)) && (dist >= (time - params.z)) )\n    {\n        float diff = (dist - time);\n        float powDiff = 1.0 - pow(abs(diff*params.x), params.y);\n\n        float diffTime = diff  * powDiff;\n        vec2 diffUV = normalize(uv - center);\n        texCoord = uv + (diffUV * diffTime);\n    }\n\n    gl_FragColor = texture2D(uSampler, texCoord);\n}\n",
	        // custom uniforms
	        {
	            center: { type: 'v2', value: { x: 0.5, y: 0.5 } },
	            params: { type: 'v3', value: { x: 10, y: 0.8, z: 0.1 } },
	            time: { type: '1f', value: 0 }
	        }
	    );
	}
	
	ShockwaveFilter.prototype = Object.create(core.AbstractFilter.prototype);
	ShockwaveFilter.prototype.constructor = ShockwaveFilter;
	module.exports = ShockwaveFilter;
	
	Object.defineProperties(ShockwaveFilter.prototype, {
	    /**
	     * Sets the center of the shockwave in normalized screen coords. That is
	     * (0,0) is the top-left and (1,1) is the bottom right.
	     *
	     * @member {object<string, number>}
	     * @memberof PIXI.filters.ShockwaveFilter#
	     */
	    center: {
	        get: function ()
	        {
	            return this.uniforms.center.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.center.value = value;
	        }
	    },
	    /**
	     * Sets the params of the shockwave. These modify the look and behavior of
	     * the shockwave as it ripples out.
	     *
	     * @member {object<string, number>}
	     * @memberof PIXI.filters.ShockwaveFilter#
	     */
	    params: {
	        get: function ()
	        {
	            return this.uniforms.params.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.params.value = value;
	        }
	    },
	    /**
	     * Sets the elapsed time of the shockwave. This controls the speed at which
	     * the shockwave ripples out.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.ShockwaveFilter#
	     */
	    time: {
	        get: function ()
	        {
	            return this.uniforms.time.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.time.value = value;
	        }
	    }
	});


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * This applies a sepia effect to your Display Objects.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function SepiaFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float sepia;\n\nconst mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);\n}\n",
	        // custom uniforms
	        {
	            sepia: { type: '1f', value: 1 }
	        }
	    );
	}
	
	SepiaFilter.prototype = Object.create(core.AbstractFilter.prototype);
	SepiaFilter.prototype.constructor = SepiaFilter;
	module.exports = SepiaFilter;
	
	Object.defineProperties(SepiaFilter.prototype, {
	    /**
	     * The strength of the sepia. `1` will apply the full sepia effect, and
	     * `0` will make the object its normal color.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.SepiaFilter#
	     */
	    sepia: {
	        get: function ()
	        {
	            return this.uniforms.sepia.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.sepia.value = value;
	        }
	    }
	});


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * A Smart Blur Filter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function SmartBlurFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 delta;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta * percent);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n",
	        // uniforms
	        {
	          delta: { type: 'v2', value: { x: 0.1, y: 0.0 } }
	        }
	    );
	}
	
	SmartBlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
	SmartBlurFilter.prototype.constructor = SmartBlurFilter;
	module.exports = SmartBlurFilter;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    TiltShiftXFilter = __webpack_require__(107),
	    TiltShiftYFilter = __webpack_require__(109);
	
	/**
	 * @author Vico @vicocotea
	 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
	 */
	
	/**
	 * A TiltShift Filter. Manages the pass of both a TiltShiftXFilter and TiltShiftYFilter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function TiltShiftFilter()
	{
	    core.AbstractFilter.call(this);
	
	    this.tiltShiftXFilter = new TiltShiftXFilter();
	    this.tiltShiftYFilter = new TiltShiftYFilter();
	}
	
	TiltShiftFilter.prototype = Object.create(core.AbstractFilter.prototype);
	TiltShiftFilter.prototype.constructor = TiltShiftFilter;
	module.exports = TiltShiftFilter;
	
	TiltShiftFilter.prototype.applyFilter = function (renderer, input, output)
	{
	    var renderTarget = renderer.filterManager.getRenderTarget(true);
	
	    this.tiltShiftXFilter.applyFilter(renderer, input, renderTarget);
	
	    this.tiltShiftYFilter.applyFilter(renderer, renderTarget, output);
	
	    renderer.filterManager.returnRenderTarget(renderTarget);
	};
	
	Object.defineProperties(TiltShiftFilter.prototype, {
	    /**
	     * The strength of the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TiltShiftFilter#
	     */
	    blur: {
	        get: function ()
	        {
	            return this.tiltShiftXFilter.blur;
	        },
	        set: function (value)
	        {
	            this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = value;
	        }
	    },
	
	    /**
	     * The strength of the gradient blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TiltShiftFilter#
	     */
	    gradientBlur: {
	        get: function ()
	        {
	            return this.tiltShiftXFilter.gradientBlur;
	        },
	        set: function (value)
	        {
	            this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = value;
	        }
	    },
	
	    /**
	     * The Y value to start the effect at.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TiltShiftFilter#
	     */
	    start: {
	        get: function ()
	        {
	            return this.tiltShiftXFilter.start;
	        },
	        set: function (value)
	        {
	            this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = value;
	        }
	    },
	
	    /**
	     * The Y value to end the effect at.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TiltShiftFilter#
	     */
	    end: {
	        get: function ()
	        {
	            return this.tiltShiftXFilter.end;
	        },
	        set: function (value)
	        {
	            this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = value;
	        }
	    }
	});


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var TiltShiftAxisFilter = __webpack_require__(108);
	
	/**
	 * @author Vico @vicocotea
	 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
	 */
	
	/**
	 * A TiltShiftXFilter.
	 *
	 * @class
	 * @extends PIXI.TiltShiftAxisFilter
	 * @memberof PIXI.filters
	 */
	function TiltShiftXFilter()
	{
	    TiltShiftAxisFilter.call(this);
	}
	
	TiltShiftXFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
	TiltShiftXFilter.prototype.constructor = TiltShiftXFilter;
	module.exports = TiltShiftXFilter;
	
	/**
	 * Updates the filter delta values.
	 *
	 */
	TiltShiftXFilter.prototype.updateDelta = function ()
	{
	    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
	    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
	    var d = Math.sqrt(dx * dx + dy * dy);
	
	    this.uniforms.delta.value.x = dx / d;
	    this.uniforms.delta.value.y = dy / d;
	};


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * @author Vico @vicocotea
	 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
	 */
	
	/**
	 * A TiltShiftAxisFilter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function TiltShiftAxisFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n",
	        // custom uniforms
	        {
	            blur:           { type: '1f', value: 100 },
	            gradientBlur:   { type: '1f', value: 600 },
	            start:          { type: 'v2', value: { x: 0,    y: window.innerHeight / 2 } },
	            end:            { type: 'v2', value: { x: 600,  y: window.innerHeight / 2 } },
	            delta:          { type: 'v2', value: { x: 30,   y: 30 } },
	            texSize:        { type: 'v2', value: { x: window.innerWidth, y: window.innerHeight } }
	        }
	    );
	
	    this.updateDelta();
	}
	
	TiltShiftAxisFilter.prototype = Object.create(core.AbstractFilter.prototype);
	TiltShiftAxisFilter.prototype.constructor = TiltShiftAxisFilter;
	module.exports = TiltShiftAxisFilter;
	
	/**
	 * Updates the filter delta values.
	 * This is overridden in the X and Y filters, does nothing for this class.
	 *
	 */
	TiltShiftAxisFilter.prototype.updateDelta = function ()
	{
	    this.uniforms.delta.value.x = 0;
	    this.uniforms.delta.value.y = 0;
	};
	
	Object.defineProperties(TiltShiftAxisFilter.prototype, {
	    /**
	     * The strength of the blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TiltShiftAxisFilter#
	     */
	    blur: {
	        get: function ()
	        {
	            return this.uniforms.blur.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.blur.value = value;
	        }
	    },
	
	    /**
	     * The strength of the gradient blur.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TiltShiftAxisFilter#
	     */
	    gradientBlur: {
	        get: function ()
	        {
	            return this.uniforms.gradientBlur.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.gradientBlur.value = value;
	        }
	    },
	
	    /**
	     * The X value to start the effect at.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.filters.TiltShiftAxisFilter#
	     */
	    start: {
	        get: function ()
	        {
	            return this.uniforms.start.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.start.value = value;
	            this.updateDelta();
	        }
	    },
	
	    /**
	     * The X value to end the effect at.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.filters.TiltShiftAxisFilter#
	     */
	    end: {
	        get: function ()
	        {
	            return this.uniforms.end.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.end.value = value;
	            this.updateDelta();
	        }
	    }
	});


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var TiltShiftAxisFilter = __webpack_require__(108);
	
	/**
	 * @author Vico @vicocotea
	 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
	 */
	
	/**
	 * A TiltShiftYFilter.
	 *
	 * @class
	 * @extends PIXI.TiltShiftAxisFilter
	 * @memberof PIXI.filters
	 */
	function TiltShiftYFilter()
	{
	    TiltShiftAxisFilter.call(this);
	}
	
	TiltShiftYFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
	TiltShiftYFilter.prototype.constructor = TiltShiftYFilter;
	module.exports = TiltShiftYFilter;
	
	/**
	 * Updates the filter delta values.
	 *
	 */
	TiltShiftYFilter.prototype.updateDelta = function ()
	{
	    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
	    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
	    var d = Math.sqrt(dx * dx + dy * dy);
	
	    this.uniforms.delta.value.x = -dy / d;
	    this.uniforms.delta.value.y = dx / d;
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	// @see https://github.com/substack/brfs/issues/25
	
	
	/**
	 * This filter applies a twist effect making display objects appear twisted in the given direction.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters
	 */
	function TwistFilter()
	{
	    core.AbstractFilter.call(this,
	        // vertex shader
	        null,
	        // fragment shader
	        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\n\nvoid main(void)\n{\n   vec2 coord = vTextureCoord - offset;\n   float dist = length(coord);\n\n   if (dist < radius)\n   {\n       float ratio = (radius - dist) / radius;\n       float angleMod = ratio * ratio * angle;\n       float s = sin(angleMod);\n       float c = cos(angleMod);\n       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n   }\n\n   gl_FragColor = texture2D(uSampler, coord+offset);\n}\n",
	        // custom uniforms
	        {
	            radius:     { type: '1f', value: 0.5 },
	            angle:      { type: '1f', value: 5 },
	            offset:     { type: 'v2', value: { x: 0.5, y: 0.5 } }
	        }
	    );
	}
	
	TwistFilter.prototype = Object.create(core.AbstractFilter.prototype);
	TwistFilter.prototype.constructor = TwistFilter;
	module.exports = TwistFilter;
	
	Object.defineProperties(TwistFilter.prototype, {
	    /**
	     * This point describes the the offset of the twist.
	     *
	     * @member {PIXI.Point}
	     * @memberof PIXI.filters.TwistFilter#
	     */
	    offset: {
	        get: function ()
	        {
	            return this.uniforms.offset.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.offset.value = value;
	        }
	    },
	
	    /**
	     * This radius of the twist.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TwistFilter#
	     */
	    radius: {
	        get: function ()
	        {
	            return this.uniforms.radius.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.radius.value = value;
	        }
	    },
	
	    /**
	     * This angle of the twist.
	     *
	     * @member {number}
	     * @memberof PIXI.filters.TwistFilter#
	     */
	    angle: {
	        get: function ()
	        {
	            return this.uniforms.angle.value;
	        },
	        set: function (value)
	        {
	            this.uniforms.angle.value = value;
	        }
	    }
	});


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file        Main export of the PIXI interactions library
	 * @author      Mat Groves <mat@goodboydigital.com>
	 * @copyright   2013-2015 GoodBoyDigital
	 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
	 */
	
	/**
	 * @namespace PIXI.interaction
	 */
	module.exports = {
	    InteractionData:    __webpack_require__(112),
	    InteractionManager: __webpack_require__(113),
	    interactiveTarget:  __webpack_require__(114)
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	/**
	 * Holds all information related to an Interaction event
	 *
	 * @class
	 * @memberof PIXI.interaction
	 */
	function InteractionData()
	{
	    /**
	     * This point stores the global coords of where the touch/mouse event happened
	     *
	     * @member {PIXI.Point}
	     */
	    this.global = new core.Point();
	
	    /**
	     * The target Sprite that was interacted with
	     *
	     * @member {PIXI.Sprite}
	     */
	    this.target = null;
	
	    /**
	     * When passed to an event handler, this will be the original DOM Event that was captured
	     *
	     * @member {Event}
	     */
	    this.originalEvent = null;
	}
	
	InteractionData.prototype.constructor = InteractionData;
	module.exports = InteractionData;
	
	/**
	 * This will return the local coordinates of the specified displayObject for this InteractionData
	 *
	 * @param displayObject {PIXI.DisplayObject} The DisplayObject that you would like the local coords off
	 * @param [point] {PIXI.Point} A Point object in which to store the value, optional (otherwise will create a new point)
	 * @param [globalPos] {PIXI.Point} A Point object containing your custom global coords, optional (otherwise will use the current global coords)
	 * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject
	 */
	InteractionData.prototype.getLocalPosition = function (displayObject, point, globalPos)
	{
	    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
	};


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    InteractionData = __webpack_require__(112);
	
	// Mix interactiveTarget into core.DisplayObject.prototype
	Object.assign(
	    core.DisplayObject.prototype,
	    __webpack_require__(114)
	);
	
	/**
	 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
	 * if its interactive parameter is set to true
	 * This manager also supports multitouch.
	 *
	 * @class
	 * @memberof PIXI.interaction
	 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer
	 * @param [options] {object}
	 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
	 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.
	 */
	function InteractionManager(renderer, options)
	{
	    options = options || {};
	
	    /**
	     * The renderer this interaction manager works for.
	     *
	     * @member {PIXI.SystemRenderer}
	     */
	    this.renderer = renderer;
	
	    /**
	     * Should default browser actions automatically be prevented.
	     *
	     * @member {boolean}
	     * @default true
	     */
	    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;
	
	    /**
	     * As this frequency increases the interaction events will be checked more often.
	     *
	     * @member {number}
	     * @default 10
	     */
	    this.interactionFrequency = options.interactionFrequency || 10;
	
	    /**
	     * The mouse data
	     *
	     * @member {PIXI.interaction.InteractionData}
	     */
	    this.mouse = new InteractionData();
	
	    /**
	     * An event data object to handle all the event tracking/dispatching
	     *
	     * @member {object}
	     */
	    this.eventData = {
	        stopped: false,
	        target: null,
	        type: null,
	        data: this.mouse,
	        stopPropagation:function(){
	            this.stopped = true;
	        }
	    };
	
	    /**
	     * Tiny little interactiveData pool !
	     *
	     * @member {PIXI.interaction.InteractionData[]}
	     */
	    this.interactiveDataPool = [];
	
	    /**
	     * The DOM element to bind to.
	     *
	     * @member {HTMLElement}
	     * @private
	     */
	    this.interactionDOMElement = null;
	
	    /**
	     * This property determins if mousemove and touchmove events are fired only when the cursror is over the object
	     * Setting to true will make things work more in line with how the DOM verison works.
	     * Setting to false can make things easier for things like dragging
	     * It is currently set to false as this is how pixi used to work. This will be set to true in future versions of pixi.
	     * @member {boolean}
	     * @private
	     */
	    this.moveWhenInside = false;
	    
	    /**
	     * Have events been attached to the dom element?
	     *
	     * @member {boolean}
	     * @private
	     */
	    this.eventsAdded = false;
	
	    //this will make it so that you don't have to call bind all the time
	
	    /**
	     * @member {Function}
	     */
	    this.onMouseUp = this.onMouseUp.bind(this);
	    this.processMouseUp = this.processMouseUp.bind( this );
	
	
	    /**
	     * @member {Function}
	     */
	    this.onMouseDown = this.onMouseDown.bind(this);
	    this.processMouseDown = this.processMouseDown.bind( this );
	
	    /**
	     * @member {Function}
	     */
	    this.onMouseMove = this.onMouseMove.bind( this );
	    this.processMouseMove = this.processMouseMove.bind( this );
	
	    /**
	     * @member {Function}
	     */
	    this.onMouseOut = this.onMouseOut.bind(this);
	    this.processMouseOverOut = this.processMouseOverOut.bind( this );
	
	
	    /**
	     * @member {Function}
	     */
	    this.onTouchStart = this.onTouchStart.bind(this);
	    this.processTouchStart = this.processTouchStart.bind(this);
	
	    /**
	     * @member {Function}
	     */
	    this.onTouchEnd = this.onTouchEnd.bind(this);
	    this.processTouchEnd = this.processTouchEnd.bind(this);
	
	    /**
	     * @member {Function}
	     */
	    this.onTouchMove = this.onTouchMove.bind(this);
	    this.processTouchMove = this.processTouchMove.bind(this);
	
	    /**
	     * @member {number}
	     */
	    this.last = 0;
	
	    /**
	     * The css style of the cursor that is being used
	     * @member {string}
	     */
	    this.currentCursorStyle = 'inherit';
	
	    /**
	     * Internal cached var
	     * @member {PIXI.Point}
	     * @private
	     */
	    this._tempPoint = new core.Point();
	    
	
	    /**
	     * The current resolution
	     * @member {number}
	     */
	    this.resolution = 1;
	
	    this.setTargetElement(this.renderer.view, this.renderer.resolution);
	}
	
	InteractionManager.prototype.constructor = InteractionManager;
	module.exports = InteractionManager;
	
	/**
	 * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
	 * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
	 * another DOM element to receive those events.
	 *
	 * @param element {HTMLElement} the DOM element which will receive mouse and touch events.
	 * @param [resolution=1] {number} THe resolution of the new element (relative to the canvas).
	 * @private
	 */
	InteractionManager.prototype.setTargetElement = function (element, resolution)
	{
	    this.removeEvents();
	
	    this.interactionDOMElement = element;
	
	    this.resolution = resolution || 1;
	
	    this.addEvents();
	};
	
	/**
	 * Registers all the DOM events
	 *
	 * @private
	 */
	InteractionManager.prototype.addEvents = function ()
	{
	    if (!this.interactionDOMElement)
	    {
	        return;
	    }
	
	    core.ticker.shared.add(this.update, this);
	
	    if (window.navigator.msPointerEnabled)
	    {
	        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
	        this.interactionDOMElement.style['-ms-touch-action'] = 'none';
	    }
	
	    window.document.addEventListener('mousemove',    this.onMouseMove, true);
	    this.interactionDOMElement.addEventListener('mousedown',    this.onMouseDown, true);
	    this.interactionDOMElement.addEventListener('mouseout',     this.onMouseOut, true);
	
	    this.interactionDOMElement.addEventListener('touchstart',   this.onTouchStart, true);
	    this.interactionDOMElement.addEventListener('touchend',     this.onTouchEnd, true);
	    this.interactionDOMElement.addEventListener('touchmove',    this.onTouchMove, true);
	
	    window.addEventListener('mouseup',  this.onMouseUp, true);
	
	    this.eventsAdded = true;
	};
	
	/**
	 * Removes all the DOM events that were previously registered
	 *
	 * @private
	 */
	InteractionManager.prototype.removeEvents = function ()
	{
	    if (!this.interactionDOMElement)
	    {
	        return;
	    }
	
	    core.ticker.shared.remove(this.update);
	
	    if (window.navigator.msPointerEnabled)
	    {
	        this.interactionDOMElement.style['-ms-content-zooming'] = '';
	        this.interactionDOMElement.style['-ms-touch-action'] = '';
	    }
	
	    window.document.removeEventListener('mousemove', this.onMouseMove, true);
	    this.interactionDOMElement.removeEventListener('mousedown', this.onMouseDown, true);
	    this.interactionDOMElement.removeEventListener('mouseout',  this.onMouseOut, true);
	
	    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
	    this.interactionDOMElement.removeEventListener('touchend',  this.onTouchEnd, true);
	    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);
	
	    this.interactionDOMElement = null;
	
	    window.removeEventListener('mouseup',  this.onMouseUp, true);
	
	    this.eventsAdded = false;
	};
	
	/**
	 * Updates the state of interactive objects.
	 * Invoked by a throttled ticker update from
	 * {@link PIXI.ticker.shared}.
	 *
	 * @param deltaTime {number}
	 */
	InteractionManager.prototype.update = function (deltaTime)
	{
	    this._deltaTime += deltaTime;
	
	    if (this._deltaTime < this.interactionFrequency)
	    {
	        return;
	    }
	
	    this._deltaTime = 0;
	
	    if (!this.interactionDOMElement)
	    {
	        return;
	    }
	
	    // if the user move the mouse this check has already been dfone using the mouse move!
	    if(this.didMove)
	    {
	        this.didMove = false;
	        return;
	    }
	
	    this.cursor = 'inherit';
	
	    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, true );
	
	    if (this.currentCursorStyle !== this.cursor)
	    {
	        this.currentCursorStyle = this.cursor;
	        this.interactionDOMElement.style.cursor = this.cursor;
	    }
	
	    //TODO
	};
	
	/**
	 * Dispatches an event on the display object that was interacted with
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the display object in question
	 * @param eventString {string} the name of the event (e.g, mousedown)
	 * @param eventData {object} the event data object
	 * @private
	 */
	InteractionManager.prototype.dispatchEvent = function ( displayObject, eventString, eventData )
	{
	    if(!eventData.stopped)
	    {
	        eventData.target = displayObject;
	        eventData.type = eventString;
	
	        displayObject.emit( eventString, eventData );
	
	        if( displayObject[eventString] )
	        {
	            displayObject[eventString]( eventData );
	        }
	    }
	};
	
	/**
	 * Maps x and y coords from a DOM object and maps them correctly to the pixi view. The resulting value is stored in the point.
	 * This takes into account the fact that the DOM element could be scaled and positioned anywhere on the screen.
	 *
	 * @param  {PIXI.Point} point the point that the result will be stored in
	 * @param  {number} x     the x coord of the position to map
	 * @param  {number} y     the y coord of the position to map
	 */
	InteractionManager.prototype.mapPositionToPoint = function ( point, x, y )
	{
	    var rect = this.interactionDOMElement.getBoundingClientRect();
	    point.x = ( ( x - rect.left ) * (this.interactionDOMElement.width  / rect.width  ) ) / this.resolution;
	    point.y = ( ( y - rect.top  ) * (this.interactionDOMElement.height / rect.height ) ) / this.resolution;
	};
	
	/**
	 * This function is provides a neat way of crawling through the scene graph and running a specified function on all interactive objects it finds.
	 * It will also take care of hit testing the interactive objects and passes the hit across in the function.
	 *
	 * @param  {PIXI.Point} point the point that is tested for collision
	 * @param  {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject the displayObject that will be hit test (recurcsivly crawls its children)
	 * @param  {Function} func the function that will be called on each interactive object. The displayObject and hit will be passed to the function
	 * @param  {boolean} hitTest this indicates if the objects inside should be hit test against the point
	 * @return {boolean} returns true if the displayObject hit the point
	 */
	InteractionManager.prototype.processInteractive = function (point, displayObject, func, hitTest, interactive)
	{
	    if(!displayObject || !displayObject.visible)
	    {
	        return false;
	    }
	
	    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
	    // 
	    // This function will now loop through all objects and then only hit test the objects it HAS to, not all of them. MUCH faster..
	    // An object will be hit test if the following is true:
	    // 
	    // 1: It is interactive.
	    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
	    // 
	    // As another little optimisation once an interactive object has been hit we can carry on through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
	    // A final optimisation is that an object is not hit test directly if a child has already been hit.
	    
	    var hit = false,
	        interactiveParent = interactive = displayObject.interactive || interactive;
	
	    // if the displayobject has a hitArea, then it does not need to hitTest children.
	    if(displayObject.hitArea)
	    {
	        interactiveParent = false;
	    }
	
	    // ** FREE TIP **! If an object is not interacttive or has no buttons in it (such as a game scene!) set interactiveChildren to false for that displayObject.
	    // This will allow pixi to completly ignore and bypass checking the displayObjects children.
	    if(displayObject.interactiveChildren)
	    {       
	        var children = displayObject.children;
	        
	        for (var i = children.length-1; i >= 0; i--)
	        {
	            var child = children[i];
	
	            // time to get recursive.. if this function will return if somthing is hit..
	            if(this.processInteractive(point, child, func, hitTest, interactiveParent))
	            {
	                // its a good idea to check if a child has lost its parent.
	                // this means it has been removed whilst looping so its best
	                if(!child.parent)
	                {
	                    continue;
	                }
	
	                hit = true;
	
	                // we no longer need to hit test any more objects in this container as we we now know the parent has been hit
	                interactiveParent = false;
	                
	                // If the child is interactive , that means that the object hit was actually interactive and not just the child of an interactive object. 
	                // This means we no longer need to hit test anything else. We still need to run through all objects, but we don't need to perform any hit tests.
	                //if(child.interactive)
	                //{
	                hitTest = false;
	                //}
	
	                // we can break now as we have hit an object.
	                //break;
	            }
	        }
	    }
	
	    // no point running this if the item is not interactive or does not have an interactive parent.
	    if(interactive)
	    {
	        // if we are hit testing (as in we have no hit any objects yet)
	        // We also don't need to worry about hit testing if once of the displayObjects children has already been hit!
	        if(hitTest && !hit)
	        {  
	            if(displayObject.hitArea)
	            {
	                displayObject.worldTransform.applyInverse(point,  this._tempPoint);
	                hit = displayObject.hitArea.contains( this._tempPoint.x, this._tempPoint.y );
	            }
	            else if(displayObject.containsPoint)
	            {
	                hit = displayObject.containsPoint(point);
	            }
	        }
	
	        if(displayObject.interactive)
	        {
	            func(displayObject, hit); 
	        }
	    }
	
	    return hit;
	  
	};
	
	
	/**
	 * Is called when the mouse button is pressed down on the renderer element
	 *
	 * @param event {Event} The DOM event of a mouse button being pressed down
	 * @private
	 */
	InteractionManager.prototype.onMouseDown = function (event)
	{
	    this.mouse.originalEvent = event;
	    this.eventData.data = this.mouse;
	    this.eventData.stopped = false;
	
	    // Update internal mouse reference
	    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);
	
	    if (this.autoPreventDefault)
	    {
	        this.mouse.originalEvent.preventDefault();
	    }
	
	    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, true );
	};
	
	/**
	 * Processes the result of the mouse down check and dispatches the event if need be
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
	 * @param hit {boolean} the result of the hit test on the dispay object
	 * @private
	 */
	InteractionManager.prototype.processMouseDown = function ( displayObject, hit )
	{
	    var e = this.mouse.originalEvent;
	    
	    var isRightButton = e.button === 2 || e.which === 3;
	
	    if(hit)
	    {
	        displayObject[ isRightButton ? '_isRightDown' : '_isLeftDown' ] = true;
	        this.dispatchEvent( displayObject, isRightButton ? 'rightdown' : 'mousedown', this.eventData );
	    }
	};
	
	
	
	/**
	 * Is called when the mouse button is released on the renderer element
	 *
	 * @param event {Event} The DOM event of a mouse button being released
	 * @private
	 */
	InteractionManager.prototype.onMouseUp = function (event)
	{
	    this.mouse.originalEvent = event;
	    this.eventData.data = this.mouse;
	    this.eventData.stopped = false;
	
	    // Update internal mouse reference
	    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);
	
	    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, true );
	};
	
	/**
	 * Processes the result of the mouse up check and dispatches the event if need be
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
	 * @param hit {boolean} the result of the hit test on the display object
	 * @private
	 */
	InteractionManager.prototype.processMouseUp = function ( displayObject, hit )
	{
	    var e = this.mouse.originalEvent;
	
	    var isRightButton = e.button === 2 || e.which === 3;
	    var isDown =  isRightButton ? '_isRightDown' : '_isLeftDown';
	
	    if(hit)
	    {
	        this.dispatchEvent( displayObject, isRightButton ? 'rightup' : 'mouseup', this.eventData );
	
	        if( displayObject[ isDown ] )
	        {
	            displayObject[ isDown ] = false;
	            this.dispatchEvent( displayObject, isRightButton ? 'rightclick' : 'click', this.eventData );
	        }
	    }
	    else
	    {
	        if( displayObject[ isDown ] )
	        {
	            displayObject[ isDown ] = false;
	            this.dispatchEvent( displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', this.eventData );
	        }
	    }
	};
	
	
	/**
	 * Is called when the mouse moves across the renderer element
	 *
	 * @param event {Event} The DOM event of the mouse moving
	 * @private
	 */
	InteractionManager.prototype.onMouseMove = function (event)
	{
	    this.mouse.originalEvent = event;
	    this.eventData.data = this.mouse;
	    this.eventData.stopped = false;
	
	    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);
	
	    this.didMove = true;
	
	    this.cursor = 'inherit';
	
	    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, true );
	
	    if (this.currentCursorStyle !== this.cursor)
	    {
	        this.currentCursorStyle = this.cursor;
	        this.interactionDOMElement.style.cursor = this.cursor;
	    }
	
	    //TODO BUG for parents ineractive object (border order issue)
	};
	
	/**
	 * Processes the result of the mouse move check and dispatches the event if need be
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
	 * @param hit {boolean} the result of the hit test on the display object
	 * @private
	 */
	InteractionManager.prototype.processMouseMove = function ( displayObject, hit )
	{
	    this.processMouseOverOut(displayObject, hit);
	    
	    // only display on mouse over
	    if(!this.moveWhenInside || hit)
	    {
	        this.dispatchEvent( displayObject, 'mousemove', this.eventData);
	    }
	};
	
	
	/**
	 * Is called when the mouse is moved out of the renderer element
	 *
	 * @param event {Event} The DOM event of a mouse being moved out
	 * @private
	 */
	InteractionManager.prototype.onMouseOut = function (event)
	{
	    this.mouse.originalEvent = event;
	    this.eventData.stopped = false;
	
	    // Update internal mouse reference
	    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);
	
	    this.interactionDOMElement.style.cursor = 'inherit';
	
	    // TODO optimize by not check EVERY TIME! maybe half as often? //
	    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY );
	
	    this.processInteractive( this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, false );
	};
	
	/**
	 * Processes the result of the mouse over/out check and dispatches the event if need be
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
	 * @param hit {boolean} the result of the hit test on the display object
	 * @private
	 */
	InteractionManager.prototype.processMouseOverOut = function ( displayObject, hit )
	{
	    if(hit)
	    {
	        if(!displayObject._over)
	        {
	            displayObject._over = true;
	            this.dispatchEvent( displayObject, 'mouseover', this.eventData );
	        }
	
	        if (displayObject.buttonMode)
	        {
	            this.cursor = displayObject.defaultCursor;
	        }
	    }
	    else
	    {
	        if(displayObject._over)
	        {
	            displayObject._over = false;
	            this.dispatchEvent( displayObject, 'mouseout', this.eventData);
	        }
	    }
	};
	
	
	/**
	 * Is called when a touch is started on the renderer element
	 *
	 * @param event {Event} The DOM event of a touch starting on the renderer view
	 * @private
	 */
	InteractionManager.prototype.onTouchStart = function (event)
	{
	    if (this.autoPreventDefault)
	    {
	        event.preventDefault();
	    }
	
	    var changedTouches = event.changedTouches;
	    var cLength = changedTouches.length;
	
	    for (var i=0; i < cLength; i++)
	    {
	        var touchEvent = changedTouches[i];
	        //TODO POOL
	        var touchData = this.getTouchData( touchEvent );
	
	        touchData.originalEvent = event;
	
	        this.eventData.data = touchData;
	        this.eventData.stopped = false;
	
	        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchStart, true );
	
	        this.returnTouchData( touchData );
	    }
	};
	
	/**
	 * Processes the result of a touch check and dispatches the event if need be
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
	 * @param hit {boolean} the result of the hit test on the display object
	 * @private
	 */
	InteractionManager.prototype.processTouchStart = function ( displayObject, hit )
	{
	    if(hit)
	    {
	        displayObject._touchDown = true;
	        this.dispatchEvent( displayObject, 'touchstart', this.eventData );
	    }
	};
	
	
	/**
	 * Is called when a touch ends on the renderer element
	 *
	 * @param event {Event} The DOM event of a touch ending on the renderer view
	 */
	InteractionManager.prototype.onTouchEnd = function (event)
	{
	    if (this.autoPreventDefault)
	    {
	        event.preventDefault();
	    }
	
	    var changedTouches = event.changedTouches;
	    var cLength = changedTouches.length;
	
	    for (var i=0; i < cLength; i++)
	    {
	        var touchEvent = changedTouches[i];
	
	        var touchData = this.getTouchData( touchEvent );
	
	        touchData.originalEvent = event;
	
	        //TODO this should be passed along.. no set
	        this.eventData.data = touchData;
	        this.eventData.stopped = false;
	
	
	        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchEnd, true );
	
	        this.returnTouchData( touchData );
	    }
	};
	
	/**
	 * Processes the result of the end of a touch and dispatches the event if need be
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
	 * @param hit {boolean} the result of the hit test on the display object
	 * @private
	 */
	InteractionManager.prototype.processTouchEnd = function ( displayObject, hit )
	{
	    if(hit)
	    {
	        this.dispatchEvent( displayObject, 'touchend', this.eventData );
	
	        if( displayObject._touchDown )
	        {
	            displayObject._touchDown = false;
	            this.dispatchEvent( displayObject, 'tap', this.eventData );
	        }
	    }
	    else
	    {
	        if( displayObject._touchDown )
	        {
	            displayObject._touchDown = false;
	            this.dispatchEvent( displayObject, 'touchendoutside', this.eventData );
	        }
	    }
	};
	
	/**
	 * Is called when a touch is moved across the renderer element
	 *
	 * @param event {Event} The DOM event of a touch moving across the renderer view
	 * @private
	 */
	InteractionManager.prototype.onTouchMove = function (event)
	{
	    if (this.autoPreventDefault)
	    {
	        event.preventDefault();
	    }
	
	    var changedTouches = event.changedTouches;
	    var cLength = changedTouches.length;
	
	    for (var i=0; i < cLength; i++)
	    {
	        var touchEvent = changedTouches[i];
	
	        var touchData = this.getTouchData( touchEvent );
	
	        touchData.originalEvent = event;
	
	        this.eventData.data = touchData;
	        this.eventData.stopped = false;
	
	        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchMove, this.moveWhenInside );
	
	        this.returnTouchData( touchData );
	    }
	};
	
	/**
	 * Processes the result of a touch move check and dispatches the event if need be
	 *
	 * @param displayObject {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} The display object that was tested
	 * @param hit {boolean} the result of the hit test on the display object
	 * @private
	 */
	InteractionManager.prototype.processTouchMove = function ( displayObject, hit )
	{
	    if(!this.moveWhenInside || hit)
	    {
	        this.dispatchEvent( displayObject, 'touchmove', this.eventData);
	    }
	};
	
	/**
	 * Grabs an interaction data object from the internal pool
	 *
	 * @param touchEvent {EventData} The touch event we need to pair with an interactionData object
	 *
	 * @private
	 */
	InteractionManager.prototype.getTouchData = function (touchEvent)
	{
	    var touchData = this.interactiveDataPool.pop();
	
	    if(!touchData)
	    {
	        touchData = new InteractionData();
	    }
	
	    touchData.identifier = touchEvent.identifier;
	    this.mapPositionToPoint( touchData.global, touchEvent.clientX, touchEvent.clientY );
	
	    if(navigator.isCocoonJS)
	    {
	        touchData.global.x = touchData.global.x / this.resolution;
	        touchData.global.y = touchData.global.y / this.resolution;
	    }
	
	    touchEvent.globalX = touchData.global.x;
	    touchEvent.globalY = touchData.global.y;
	
	    return touchData;
	};
	
	/**
	 * Returns an interaction data object to the internal pool
	 *
	 * @param touchData {PIXI.interaction.InteractionData} The touch data object we want to return to the pool
	 *
	 * @private
	 */
	InteractionManager.prototype.returnTouchData = function ( touchData )
	{
	    this.interactiveDataPool.push( touchData );
	};
	
	/**
	 * Destroys the interaction manager
	 *
	 */
	InteractionManager.prototype.destroy = function () {
	    this.removeEvents();
	
	    this.renderer = null;
	
	    this.mouse = null;
	
	    this.eventData = null;
	
	    this.interactiveDataPool = null;
	
	    this.interactionDOMElement = null;
	
	    this.onMouseUp = null;
	    this.processMouseUp = null;
	
	
	    this.onMouseDown = null;
	    this.processMouseDown = null;
	
	    this.onMouseMove = null;
	    this.processMouseMove = null;
	
	    this.onMouseOut = null;
	    this.processMouseOverOut = null;
	
	
	    this.onTouchStart = null;
	    this.processTouchStart = null;
	
	    this.onTouchEnd = null;
	    this.processTouchEnd = null;
	
	    this.onTouchMove = null;
	    this.processTouchMove = null;
	
	    this._tempPoint = null;
	};
	
	core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
	core.CanvasRenderer.registerPlugin('interaction', InteractionManager);


/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Default property values of interactive objects
	 * used by {@link PIXI.interaction.InteractionManager}.
	 *
	 * @mixin
	 * @memberof PIXI.interaction
	 * @example
	 *      function MyObject() {}
	 *
	 *      Object.assign(
	 *          MyObject.prototype,
	 *          PIXI.interaction.interactiveTarget
	 *      );
	 */
	var interactiveTarget = {
	    /**
	     * @todo Needs docs.
	     */
	    interactive: false,
	    /**
	     * @todo Needs docs.
	     */
	    buttonMode: false,
	    /**
	     * @todo Needs docs.
	     */
	    interactiveChildren: true,
	    /**
	     * @todo Needs docs.
	     */
	    defaultCursor: 'pointer',
	
	    // some internal checks..
	
	    /**
	     * @todo Needs docs.
	     * @private
	     */
	    _over: false,
	    /**
	     * @todo Needs docs.
	     * @private
	     */
	    _touchDown: false
	};
	
	module.exports = interactiveTarget;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file        Main export of the PIXI loaders library
	 * @author      Mat Groves <mat@goodboydigital.com>
	 * @copyright   2013-2015 GoodBoyDigital
	 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
	 */
	
	/**
	 * @namespace PIXI.loaders
	 */
	module.exports = {
	    Loader:             __webpack_require__(116),
	
	    // parsers
	    bitmapFontParser:   __webpack_require__(129),
	    spritesheetParser:  __webpack_require__(127),
	    textureParser:      __webpack_require__(126),
	    Resource:           __webpack_require__(117).Resource
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var ResourceLoader = __webpack_require__(117),
	    textureParser = __webpack_require__(126),
	    spritesheetParser = __webpack_require__(127),
	    bitmapFontParser = __webpack_require__(129);
	
	/**
	 *
	 * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader
	 *
	 * ```js
	 * var loader = PIXI.loader; // pixi exposes a premade instance for you to use.
	 * //or
	 * var loader = new PIXI.loaders.Loader(); // you can also create your own if you want
	 *
	 * loader.add('bunny',"data/bunny.png");
	 *
	 * loader.once('complete',onAssetsLoaded);
	 *
	 * loader.load();
	 * ```
	 *
	 * @class
	 * @extends PIXI.ResourceLoader
	 * @memberof PIXI.loaders
	 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
	 * @param [concurrency=10] {number} The number of resources to load concurrently.
	 */
	function Loader(baseUrl, concurrency)
	{
	    ResourceLoader.call(this, baseUrl, concurrency);
	
	    for (var i = 0; i < Loader._pixiMiddleware.length; ++i) {
	        this.use(Loader._pixiMiddleware[i]());
	    }
	}
	
	Loader.prototype = Object.create(ResourceLoader.prototype);
	Loader.prototype.constructor = Loader;
	
	module.exports = Loader;
	
	Loader._pixiMiddleware = [
	    // parse any blob into more usable objects (e.g. Image)
	    ResourceLoader.middleware.parsing.blob,
	    // parse any Image objects into textures
	    textureParser,
	    // parse any spritesheet data into multiple textures
	    spritesheetParser,
	    // parse any spritesheet data into multiple textures
	    bitmapFontParser
	];
	
	Loader.addPixiMiddleware = function (fn) {
	    Loader._pixiMiddleware.push(fn);
	};
	
	// Add custom extentions
	var Resource = ResourceLoader.Resource;
	
	Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint global-require: 0 */
	'use strict';
	
	module.exports = __webpack_require__(118);
	module.exports.Resource = __webpack_require__(121);
	module.exports.middleware = {
	    caching: {
	        memory: __webpack_require__(123)
	    },
	    parsing: {
	        blob: __webpack_require__(124)
	    }
	};
	
	module.exports.async = __webpack_require__(120);


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var parseUri        = __webpack_require__(119);
	var async           = __webpack_require__(120);
	var Resource        = __webpack_require__(121);
	var EventEmitter    = __webpack_require__(122);
	
	// some constants
	var DEFAULT_CONCURRENCY = 10;
	var MAX_PROGRESS = 100;
	
	/**
	 * Manages the state and loading of multiple resources to load.
	 *
	 * @class
	 * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
	 * @param {number} [concurrency=10] - The number of resources to load concurrently.
	 */
	function Loader(baseUrl, concurrency) {
	    EventEmitter.call(this);
	
	    concurrency = concurrency || DEFAULT_CONCURRENCY;
	
	    /**
	     * The base url for all resources loaded by this loader.
	     *
	     * @member {string}
	     */
	    this.baseUrl = baseUrl || '';
	
	    /**
	     * The progress percent of the loader going through the queue.
	     *
	     * @member {number}
	     */
	    this.progress = 0;
	
	    /**
	     * Loading state of the loader, true if it is currently loading resources.
	     *
	     * @member {boolean}
	     */
	    this.loading = false;
	
	    /**
	     * The percentage of total progress that a single resource represents.
	     *
	     * @member {number}
	     */
	    this._progressChunk = 0;
	
	    /**
	     * The middleware to run before loading each resource.
	     *
	     * @member {function[]}
	     */
	    this._beforeMiddleware = [];
	
	    /**
	     * The middleware to run after loading each resource.
	     *
	     * @member {function[]}
	     */
	    this._afterMiddleware = [];
	
	    /**
	     * The `_loadResource` function bound with this object context.
	     *
	     * @private
	     * @member {function}
	     */
	    this._boundLoadResource = this._loadResource.bind(this);
	
	    /**
	     * The resource buffer that fills until `load` is called to start loading resources.
	     *
	     * @private
	     * @member {Resource[]}
	     */
	    this._buffer = [];
	
	    /**
	     * Used to track load completion.
	     *
	     * @private
	     * @member {number}
	     */
	    this._numToLoad = 0;
	
	    /**
	     * The resources waiting to be loaded.
	     *
	     * @private
	     * @member {Resource[]}
	     */
	    this._queue = async.queue(this._boundLoadResource, concurrency);
	
	    /**
	     * All the resources for this loader keyed by name.
	     *
	     * @member {object<string, Resource>}
	     */
	    this.resources = {};
	
	    /**
	     * Emitted once per loaded or errored resource.
	     *
	     * @event progress
	     * @memberof Loader#
	     */
	
	    /**
	     * Emitted once per errored resource.
	     *
	     * @event error
	     * @memberof Loader#
	     */
	
	    /**
	     * Emitted once per loaded resource.
	     *
	     * @event load
	     * @memberof Loader#
	     */
	
	    /**
	     * Emitted when the loader begins to process the queue.
	     *
	     * @event start
	     * @memberof Loader#
	     */
	
	    /**
	     * Emitted when the queued resources all load.
	     *
	     * @event complete
	     * @memberof Loader#
	     */
	}
	
	Loader.prototype = Object.create(EventEmitter.prototype);
	Loader.prototype.constructor = Loader;
	module.exports = Loader;
	
	/**
	 * Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', function () {})
	 *     .add('http://...', function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ])
	 *
	 *     // and you can use both params and options
	 *     .add('key', 'http://...', { crossOrigin: true }, function () {})
	 *     .add('http://...', { crossOrigin: true }, function () {});
	 * ```
	 *
	 * @alias enqueue
	 * @param {string} [name] - The name of the resource to load, if not passed the url is used.
	 * @param {string} [url] - The url for this resource, relative to the baseUrl of this loader.
	 * @param {object} [options] - The options for the load.
	 * @param {boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.
	 * @param {Resource.XHR_LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?
	 * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param {function} [cb] - Function to call when this specific resource completes loading.
	 * @return {Loader} Returns itself.
	 */
	Loader.prototype.add = Loader.prototype.enqueue = function (name, url, options, cb) {
	    // special case of an array of objects or urls
	    if (Array.isArray(name)) {
	        for (var i = 0; i < name.length; ++i) {
	            this.add(name[i]);
	        }
	
	        return this;
	    }
	
	    // if an object is passed instead of params
	    if (typeof name === 'object') {
	        cb = url || name.callback || name.onComplete;
	        options = name;
	        url = name.url;
	        name = name.name || name.key || name.url;
	    }
	
	    // case where no name is passed shift all args over by one.
	    if (typeof url !== 'string') {
	        cb = options;
	        options = url;
	        url = name;
	    }
	
	    // now that we shifted make sure we have a proper url.
	    if (typeof url !== 'string') {
	        throw new Error('No url passed to add resource to loader.');
	    }
	
	    // options are optional so people might pass a function and no options
	    if (typeof options === 'function') {
	        cb = options;
	        options = null;
	    }
	
	    // check if resource already exists.
	    if (this.resources[name]) {
	        throw new Error('Resource with name "' + name + '" already exists.');
	    }
	
	    // add base url if this isn't an absolute url
	    url = this._prepareUrl(url);
	
	    // create the store the resource
	    this.resources[name] = new Resource(name, url, options);
	
	    if (typeof cb === 'function') {
	        this.resources[name].once('afterMiddleware', cb);
	    }
	
	    this._numToLoad++;
	
	    // if already loading add it to the worker queue
	    if (this._queue.started) {
	        this._queue.push(this.resources[name]);
	        this._progressChunk = (MAX_PROGRESS - this.progress) / (this._queue.length() + this._queue.running());
	    }
	    // otherwise buffer it to be added to the queue later
	    else {
	        this._buffer.push(this.resources[name]);
	        this._progressChunk = MAX_PROGRESS / this._buffer.length;
	    }
	
	    return this;
	};
	
	/**
	 * Sets up a middleware function that will run *before* the
	 * resource is loaded.
	 *
	 * @alias pre
	 * @method before
	 * @param {function} fn - The middleware function to register.
	 * @return {Loader} Returns itself.
	 */
	Loader.prototype.before = Loader.prototype.pre = function (fn) {
	    this._beforeMiddleware.push(fn);
	
	    return this;
	};
	
	/**
	 * Sets up a middleware function that will run *after* the
	 * resource is loaded.
	 *
	 * @alias use
	 * @method after
	 * @param {function} fn - The middleware function to register.
	 * @return {Loader} Returns itself.
	 */
	Loader.prototype.after = Loader.prototype.use = function (fn) {
	    this._afterMiddleware.push(fn);
	
	    return this;
	};
	
	/**
	 * Resets the queue of the loader to prepare for a new load.
	 *
	 * @return {Loader} Returns itself.
	 */
	Loader.prototype.reset = function () {
	    // this.baseUrl = baseUrl || '';
	
	    this.progress = 0;
	
	    this.loading = false;
	
	    this._progressChunk = 0;
	
	    // this._beforeMiddleware.length = 0;
	    // this._afterMiddleware.length = 0;
	
	    this._buffer.length = 0;
	
	    this._numToLoad = 0;
	
	    this._queue.kill();
	    this._queue.started = false;
	
	    // abort all resource loads
	    for (var k in this.resources) {
	        var res = this.resources[k];
	
	        res.off('complete', this._onLoad, this);
	
	        if (res.isLoading) {
	            res.abort();
	        }
	    }
	
	    this.resources = {};
	
	    return this;
	};
	
	/**
	 * Starts loading the queued resources.
	 *
	 * @fires start
	 * @param {function} [cb] - Optional callback that will be bound to the `complete` event.
	 * @return {Loader} Returns itself.
	 */
	Loader.prototype.load = function (cb) {
	    // register complete callback if they pass one
	    if (typeof cb === 'function') {
	        this.once('complete', cb);
	    }
	
	    // if the queue has already started we are done here
	    if (this._queue.started) {
	        return this;
	    }
	
	    // notify of start
	    this.emit('start', this);
	
	    // update loading state
	    this.loading = true;
	
	    // start the internal queue
	    for (var i = 0; i < this._buffer.length; ++i) {
	        this._queue.push(this._buffer[i]);
	    }
	
	    // empty the buffer
	    this._buffer.length = 0;
	
	    return this;
	};
	
	/**
	 * Prepares a url for usage based on the configuration of this object
	 *
	 * @private
	 * @param {string} url - The url to prepare.
	 * @return {string} The prepared url.
	 */
	Loader.prototype._prepareUrl = function (url) {
	    var parsedUrl = parseUri(url, { strictMode: true });
	
	    // absolute url, just use it as is.
	    if (parsedUrl.protocol || !parsedUrl.path || parsedUrl.path.indexOf('//') === 0) {
	        return url;
	    }
	
	    // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween
	    if (this.baseUrl.length
	        && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1
	        && url.charAt(0) !== '/'
	    ) {
	        return this.baseUrl + '/' + url;
	    }
	
	    return this.baseUrl + url;
	};
	
	/**
	 * Loads a single resource.
	 *
	 * @private
	 * @param {Resource} resource - The resource to load.
	 * @param {function} dequeue - The function to call when we need to dequeue this item.
	 */
	Loader.prototype._loadResource = function (resource, dequeue) {
	    var self = this;
	
	    resource._dequeue = dequeue;
	
	    // run before middleware
	    async.eachSeries(
	        this._beforeMiddleware,
	        function (fn, next) {
	            fn.call(self, resource, function () {
	                // if the before middleware marks the resource as complete,
	                // break and don't process any more before middleware
	                next(resource.isComplete ? {} : null);
	            });
	        },
	        function () {
	            // resource.on('progress', self.emit.bind(self, 'progress'));
	
	            if (resource.isComplete) {
	                self._onLoad(resource);
	            }
	            else {
	                resource.once('complete', self._onLoad, self);
	                resource.load();
	            }
	        }
	    );
	};
	
	/**
	 * Called once each resource has loaded.
	 *
	 * @fires complete
	 * @private
	 */
	Loader.prototype._onComplete = function () {
	    this.loading = false;
	
	    this.emit('complete', this, this.resources);
	};
	
	/**
	 * Called each time a resources is loaded.
	 *
	 * @fires progress
	 * @fires error
	 * @fires load
	 * @private
	 * @param {Resource} resource - The resource that was loaded
	 */
	Loader.prototype._onLoad = function (resource) {
	    var self = this;
	
	    // run middleware, this *must* happen before dequeue so sub-assets get added properly
	    async.eachSeries(
	        this._afterMiddleware,
	        function (fn, next) {
	            fn.call(self, resource, next);
	        },
	        function () {
	            resource.emit('afterMiddleware', resource);
	
	            self._numToLoad--;
	
	            self.progress += self._progressChunk;
	            self.emit('progress', self, resource);
	
	            if (resource.error) {
	                self.emit('error', resource.error, self, resource);
	            }
	            else {
	                self.emit('load', self, resource);
	            }
	
	            // do completion check
	            if (self._numToLoad === 0) {
	                self.progress = 100;
	                self._onComplete();
	            }
	        }
	    );
	
	    // remove this resource from the async queue
	    resource._dequeue();
	};
	
	Loader.LOAD_TYPE = Resource.LOAD_TYPE;
	Loader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;


/***/ },
/* 119 */
/***/ function(module, exports) {

	'use strict'
	
	module.exports = function parseURI (str, opts) {
	  opts = opts || {}
	
	  var o = {
	    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
	    q: {
	      name: 'queryKey',
	      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
	    },
	    parser: {
	      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
	      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
	    }
	  }
	
	  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)
	  var uri = {}
	  var i = 14
	
	  while (i--) uri[o.key[i]] = m[i] || ''
	
	  uri[o.q.name] = {}
	  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
	    if ($1) uri[o.q.name][$1] = $2
	  })
	
	  return uri
	}


/***/ },
/* 120 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Smaller version of the async library constructs.
	 *
	 */
	
	module.exports = {
	    eachSeries: asyncEachSeries,
	    queue: asyncQueue
	};
	
	function _noop() { /* empty */ }
	
	/**
	 * Iterates an array in series.
	 *
	 * @param {*[]} array - Array to iterate.
	 * @param {function} iterator - Function to call for each element.
	 * @param {function} callback - Function to call when done, or on error.
	 */
	function asyncEachSeries(array, iterator, callback) {
	    var i = 0;
	    var len = array.length;
	
	    (function next(err) {
	        if (err || i === len) {
	            if (callback) {
	                callback(err);
	            }
	
	            return;
	        }
	
	        iterator(array[i++], next);
	    })();
	}
	
	/**
	 * Ensures a function is only called once.
	 *
	 * @param {function} fn - The function to wrap.
	 * @return {function} The wrapping function.
	 */
	function onlyOnce(fn) {
	    return function onceWrapper() {
	        if (fn === null) {
	            throw new Error('Callback was already called.');
	        }
	
	        var callFn = fn;
	
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	
	/**
	 * Async queue implementation,
	 *
	 * @param {function} worker - The worker function to call for each task.
	 * @param {number} concurrency - How many workers to run in parrallel.
	 * @return {*} The async queue object.
	 */
	function asyncQueue(worker, concurrency) {
	    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq
	        concurrency = 1;
	    }
	    else if (concurrency === 0) {
	        throw new Error('Concurrency must not be zero');
	    }
	
	    var workers = 0;
	    var q = {
	        _tasks: [],
	        concurrency: concurrency,
	        saturated: _noop,
	        unsaturated: _noop,
	        buffer: concurrency / 4,
	        empty: _noop,
	        drain: _noop,
	        error: _noop,
	        started: false,
	        paused: false,
	        push: function (data, callback) {
	            _insert(data, false, callback);
	        },
	        kill: function () {
	            q.drain = _noop;
	            q._tasks = [];
	        },
	        unshift: function (data, callback) {
	            _insert(data, true, callback);
	        },
	        process: function () {
	            while (!q.paused && workers < q.concurrency && q._tasks.length) {
	                var task = q._tasks.shift();
	
	                if (q._tasks.length === 0) {
	                    q.empty();
	                }
	
	                workers += 1;
	
	                if (workers === q.concurrency) {
	                    q.saturated();
	                }
	
	                worker(task.data, onlyOnce(_next(task)));
	            }
	        },
	        length: function () {
	            return q._tasks.length;
	        },
	        running: function () {
	            return workers;
	        },
	        idle: function () {
	            return q._tasks.length + workers === 0;
	        },
	        pause: function () {
	            if (q.paused === true) {
	                return;
	            }
	
	            q.paused = true;
	        },
	        resume: function () {
	            if (q.paused === false) {
	                return;
	            }
	
	            q.paused = false;
	
	            // Need to call q.process once per concurrent
	            // worker to preserve full concurrency after pause
	            for (var w = 1; w <= q.concurrency; w++) {
	                q.process();
	            }
	        }
	    };
	
	    function _insert(data, insertAtFront, callback) {
	        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq
	            throw new Error('task callback must be a function');
	        }
	
	        q.started = true;
	
	        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq
	            // call drain immediately if there are no tasks
	            setTimeout(function () {
	                q.drain();
	            }, 1);
	
	            return;
	        }
	
	        var item = {
	            data: data,
	            callback: typeof callback === 'function' ? callback : _noop
	        };
	
	        if (insertAtFront) {
	            q._tasks.unshift(item);
	        }
	        else {
	            q._tasks.push(item);
	        }
	
	        setTimeout(function () {
	            q.process();
	        }, 1);
	    }
	
	    function _next(task) {
	        return function () {
	            workers -= 1;
	
	            task.callback.apply(task, arguments);
	
	            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq
	                q.error(arguments[0], task.data);
	            }
	
	            if (workers <= (q.concurrency - q.buffer)) {
	                q.unsaturated();
	            }
	
	            if (q.idle()) {
	                q.drain();
	            }
	
	            q.process();
	        };
	    }
	
	    return q;
	}


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter    = __webpack_require__(122);
	var parseUri        = __webpack_require__(119);
	
	// tests is CORS is supported in XHR, if not we need to use XDR
	var useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));
	var tempAnchor = null;
	
	// some status constants
	var STATUS_NONE = 0;
	var STATUS_OK = 200;
	var STATUS_EMPTY = 204;
	
	/**
	 * Manages the state and loading of a single resource represented by
	 * a single URL.
	 *
	 * @class
	 * @param {string} name - The name of the resource to load.
	 * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass an array of sources.
	 * @param {object} [options] - The options for the load.
	 * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.
	 * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?
	 * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param {object} [options.metadata] - Extra info for middleware.
	 */
	function Resource(name, url, options) {
	    EventEmitter.call(this);
	
	    options = options || {};
	
	    if (typeof name !== 'string' || typeof url !== 'string') {
	        throw new Error('Both name and url are required for constructing a resource.');
	    }
	
	    /**
	     * The name of this resource.
	     *
	     * @member {string}
	     * @readonly
	     */
	    this.name = name;
	
	    /**
	     * The url used to load this resource.
	     *
	     * @member {string}
	     * @readonly
	     */
	    this.url = url;
	
	    /**
	     * Stores whether or not this url is a data url.
	     *
	     * @member {boolean}
	     * @readonly
	     */
	    this.isDataUrl = this.url.indexOf('data:') === 0;
	
	    /**
	     * The data that was loaded by the resource.
	     *
	     * @member {any}
	     */
	    this.data = null;
	
	    /**
	     * Is this request cross-origin? If unset, determined automatically.
	     *
	     * @member {string}
	     */
	    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;
	
	    /**
	     * The method of loading to use for this resource.
	     *
	     * @member {Resource.LOAD_TYPE}
	     */
	    this.loadType = options.loadType || this._determineLoadType();
	
	    /**
	     * The type used to load the resource via XHR. If unset, determined automatically.
	     *
	     * @member {string}
	     */
	    this.xhrType = options.xhrType;
	
	    /**
	     * Extra info for middleware, and controlling specifics about how the resource loads.
	     *
	     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.
	     * Meaning it will modify it as it sees fit.
	     *
	     * @member {object}
	     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
	     *  element to use for loading, instead of creating one.
	     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
	     *  is useful if you want to pass in a `loadElement` that you already added load sources
	     *  to.
	     */
	    this.metadata = options.metadata || {};
	
	    /**
	     * The error that occurred while loading (if any).
	     *
	     * @member {Error}
	     * @readonly
	     */
	    this.error = null;
	
	    /**
	     * The XHR object that was used to load this resource. This is only set
	     * when `loadType` is `Resource.LOAD_TYPE.XHR`.
	     *
	     * @member {XMLHttpRequest}
	     */
	    this.xhr = null;
	
	    /**
	     * Describes if this resource was loaded as json. Only valid after the resource
	     * has completely loaded.
	     *
	     * @member {boolean}
	     */
	    this.isJson = false;
	
	    /**
	     * Describes if this resource was loaded as xml. Only valid after the resource
	     * has completely loaded.
	     *
	     * @member {boolean}
	     */
	    this.isXml = false;
	
	    /**
	     * Describes if this resource was loaded as an image tag. Only valid after the resource
	     * has completely loaded.
	     *
	     * @member {boolean}
	     */
	    this.isImage = false;
	
	    /**
	     * Describes if this resource was loaded as an audio tag. Only valid after the resource
	     * has completely loaded.
	     *
	     * @member {boolean}
	     */
	    this.isAudio = false;
	
	    /**
	     * Describes if this resource was loaded as a video tag. Only valid after the resource
	     * has completely loaded.
	     *
	     * @member {boolean}
	     */
	    this.isVideo = false;
	
	    /**
	     * Describes if this resource has finished loading. Is true when the resource has completely
	     * loaded.
	     *
	     * @member {boolean}
	     */
	    this.isComplete = false;
	
	    /**
	     * Describes if this resource is currently loading. Is true when the resource starts loading,
	     * and is false again when complete.
	     *
	     * @member {boolean}
	     */
	    this.isLoading = false;
	
	    /**
	     * The `dequeue` method that will be used a storage place for the async queue dequeue method
	     * used privately by the loader.
	     *
	     * @private
	     * @member {function}
	     */
	    this._dequeue = null;
	
	    /**
	     * The `complete` function bound to this resource's context.
	     *
	     * @private
	     * @member {function}
	     */
	    this._boundComplete = this.complete.bind(this);
	
	    /**
	     * The `_onError` function bound to this resource's context.
	     *
	     * @private
	     * @member {function}
	     */
	    this._boundOnError = this._onError.bind(this);
	
	    /**
	     * The `_onProgress` function bound to this resource's context.
	     *
	     * @private
	     * @member {function}
	     */
	    this._boundOnProgress = this._onProgress.bind(this);
	
	    // xhr callbacks
	    this._boundXhrOnError = this._xhrOnError.bind(this);
	    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
	    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
	    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);
	
	    /**
	     * Emitted when the resource beings to load.
	     *
	     * @event start
	     * @memberof Resource#
	     */
	
	    /**
	     * Emitted each time progress of this resource load updates.
	     * Not all resources types and loader systems can support this event
	     * so sometimes it may not be available. If the resource
	     * is being loaded on a modern browser, using XHR, and the remote server
	     * properly sets Content-Length headers, then this will be available.
	     *
	     * @event progress
	     * @memberof Resource#
	     */
	
	    /**
	     * Emitted once this resource has loaded, if there was an error it will
	     * be in the `error` property.
	     *
	     * @event complete
	     * @memberof Resource#
	     */
	}
	
	Resource.prototype = Object.create(EventEmitter.prototype);
	Resource.prototype.constructor = Resource;
	module.exports = Resource;
	
	/**
	 * Marks the resource as complete.
	 *
	 * @fires complete
	 */
	Resource.prototype.complete = function () {
	    // TODO: Clean this up in a wrapper or something...gross....
	    if (this.data && this.data.removeEventListener) {
	        this.data.removeEventListener('error', this._boundOnError, false);
	        this.data.removeEventListener('load', this._boundComplete, false);
	        this.data.removeEventListener('progress', this._boundOnProgress, false);
	        this.data.removeEventListener('canplaythrough', this._boundComplete, false);
	    }
	
	    if (this.xhr) {
	        if (this.xhr.removeEventListener) {
	            this.xhr.removeEventListener('error', this._boundXhrOnError, false);
	            this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
	            this.xhr.removeEventListener('progress', this._boundOnProgress, false);
	            this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
	        }
	        else {
	            this.xhr.onerror = null;
	            this.xhr.ontimeout = null;
	            this.xhr.onprogress = null;
	            this.xhr.onload = null;
	        }
	    }
	
	    if (this.isComplete) {
	        throw new Error('Complete called again for an already completed resource.');
	    }
	
	    this.isComplete = true;
	    this.isLoading = false;
	
	    this.emit('complete', this);
	};
	
	/**
	 * Aborts the loading of this resource, with an optional message.
	 *
	 * @param {string} message - The message to use for the error
	 */
	Resource.prototype.abort = function (message) {
	    // abort can be called multiple times, ignore subsequent calls.
	    if (this.error) {
	        return;
	    }
	
	    // store error
	    this.error = new Error(message);
	
	    // abort the actual loading
	    if (this.xhr) {
	        this.xhr.abort();
	    }
	    else if (this.xdr) {
	        this.xdr.abort();
	    }
	    else if (this.data) {
	        // single source
	        if (typeof this.data.src !== 'undefined') {
	            this.data.src = '';
	        }
	        // multi-source
	        else {
	            while (this.data.firstChild) {
	                this.data.removeChild(this.data.firstChild);
	            }
	        }
	    }
	
	    // done now.
	    this.complete();
	};
	
	/**
	 * Kicks off loading of this resource. This method is asynchronous.
	 *
	 * @fires start
	 * @param {function} [cb] - Optional callback to call once the resource is loaded.
	 */
	Resource.prototype.load = function (cb) {
	    if (this.isLoading) {
	        return;
	    }
	
	    if (this.isComplete) {
	        if (cb) {
	            var self = this;
	
	            setTimeout(function () {
	                cb(self);
	            }, 1);
	        }
	
	        return;
	    }
	    else if (cb) {
	        this.once('complete', cb);
	    }
	
	    this.isLoading = true;
	
	    this.emit('start', this);
	
	    // if unset, determine the value
	    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {
	        this.crossOrigin = this._determineCrossOrigin(this.url);
	    }
	
	    switch (this.loadType) {
	        case Resource.LOAD_TYPE.IMAGE:
	            this._loadElement('image');
	            break;
	
	        case Resource.LOAD_TYPE.AUDIO:
	            this._loadSourceElement('audio');
	            break;
	
	        case Resource.LOAD_TYPE.VIDEO:
	            this._loadSourceElement('video');
	            break;
	
	        case Resource.LOAD_TYPE.XHR:
	            /* falls through */
	        default:
	            if (useXdr && this.crossOrigin) {
	                this._loadXdr();
	            }
	            else {
	                this._loadXhr();
	            }
	            break;
	    }
	};
	
	/**
	 * Loads this resources using an element that has a single source,
	 * like an HTMLImageElement.
	 *
	 * @private
	 * @param {string} type - The type of element to use.
	 */
	Resource.prototype._loadElement = function (type) {
	    if (this.metadata.loadElement) {
	        this.data = this.metadata.loadElement;
	    }
	    else if (type === 'image' && typeof window.Image !== 'undefined') {
	        this.data = new Image();
	    }
	    else {
	        this.data = document.createElement(type);
	    }
	
	    if (this.crossOrigin) {
	        this.data.crossOrigin = this.crossOrigin;
	    }
	
	    if (!this.metadata.skipSource) {
	        this.data.src = this.url;
	    }
	
	    var typeName = 'is' + type[0].toUpperCase() + type.substring(1);
	
	    if (this[typeName] === false) {
	        this[typeName] = true;
	    }
	
	    this.data.addEventListener('error', this._boundOnError, false);
	    this.data.addEventListener('load', this._boundComplete, false);
	    this.data.addEventListener('progress', this._boundOnProgress, false);
	};
	
	/**
	 * Loads this resources using an element that has multiple sources,
	 * like an HTMLAudioElement or HTMLVideoElement.
	 *
	 * @private
	 * @param {string} type - The type of element to use.
	 */
	Resource.prototype._loadSourceElement = function (type) {
	    if (this.metadata.loadElement) {
	        this.data = this.metadata.loadElement;
	    }
	    else if (type === 'audio' && typeof window.Audio !== 'undefined') {
	        this.data = new Audio();
	    }
	    else {
	        this.data = document.createElement(type);
	    }
	
	    if (this.data === null) {
	        this.abort('Unsupported element ' + type);
	
	        return;
	    }
	
	    if (!this.metadata.skipSource) {
	        // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
	        if (navigator.isCocoonJS) {
	            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
	        }
	        else if (Array.isArray(this.url)) {
	            for (var i = 0; i < this.url.length; ++i) {
	                this.data.appendChild(this._createSource(type, this.url[i]));
	            }
	        }
	        else {
	            this.data.appendChild(this._createSource(type, this.url));
	        }
	    }
	
	    this['is' + type[0].toUpperCase() + type.substring(1)] = true;
	
	    this.data.addEventListener('error', this._boundOnError, false);
	    this.data.addEventListener('load', this._boundComplete, false);
	    this.data.addEventListener('progress', this._boundOnProgress, false);
	    this.data.addEventListener('canplaythrough', this._boundComplete, false);
	
	    this.data.load();
	};
	
	/**
	 * Loads this resources using an XMLHttpRequest.
	 *
	 * @private
	 */
	Resource.prototype._loadXhr = function () {
	    // if unset, determine the value
	    if (typeof this.xhrType !== 'string') {
	        this.xhrType = this._determineXhrType();
	    }
	
	    var xhr = this.xhr = new XMLHttpRequest();
	
	    // set the request type and url
	    xhr.open('GET', this.url, true);
	
	    // load json as text and parse it ourselves. We do this because some browsers
	    // *cough* safari *cough* can't deal with it.
	    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
	        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
	    }
	    else {
	        xhr.responseType = this.xhrType;
	    }
	
	    xhr.addEventListener('error', this._boundXhrOnError, false);
	    xhr.addEventListener('abort', this._boundXhrOnAbort, false);
	    xhr.addEventListener('progress', this._boundOnProgress, false);
	    xhr.addEventListener('load', this._boundXhrOnLoad, false);
	
	    xhr.send();
	};
	
	/**
	 * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
	 *
	 * @private
	 */
	Resource.prototype._loadXdr = function () {
	    // if unset, determine the value
	    if (typeof this.xhrType !== 'string') {
	        this.xhrType = this._determineXhrType();
	    }
	
	    var xdr = this.xhr = new XDomainRequest();
	
	    // XDomainRequest has a few quirks. Occasionally it will abort requests
	    // A way to avoid this is to make sure ALL callbacks are set even if not used
	    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
	    xdr.timeout = 5000;
	
	    xdr.onerror = this._boundXhrOnError;
	    xdr.ontimeout = this._boundXdrOnTimeout;
	    xdr.onprogress = this._boundOnProgress;
	    xdr.onload = this._boundXhrOnLoad;
	
	    xdr.open('GET', this.url, true);
	
	    // Note: The xdr.send() call is wrapped in a timeout to prevent an
	    // issue with the interface where some requests are lost if multiple
	    // XDomainRequests are being sent at the same time.
	    // Some info here: https://github.com/photonstorm/phaser/issues/1248
	    setTimeout(function () {
	        xdr.send();
	    }, 0);
	};
	
	/**
	 * Creates a source used in loading via an element.
	 *
	 * @private
	 * @param {string} type - The element type (video or audio).
	 * @param {string} url - The source URL to load from.
	 * @param {string} [mime] - The mime type of the video
	 * @return {HTMLSourceElement} The source element.
	 */
	Resource.prototype._createSource = function (type, url, mime) {
	    if (!mime) {
	        mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);
	    }
	
	    var source = document.createElement('source');
	
	    source.src = url;
	    source.type = mime;
	
	    return source;
	};
	
	/**
	 * Called if a load errors out.
	 *
	 * @param {Event} event - The error event from the element that emits it.
	 * @private
	 */
	Resource.prototype._onError = function (event) {
	    this.abort('Failed to load element using ' + event.target.nodeName);
	};
	
	/**
	 * Called if a load progress event fires for xhr/xdr.
	 *
	 * @fires progress
	 * @private
	 * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.
	 */
	Resource.prototype._onProgress = function (event) {
	    if (event && event.lengthComputable) {
	        this.emit('progress', this, event.loaded / event.total);
	    }
	};
	
	/**
	 * Called if an error event fires for xhr/xdr.
	 *
	 * @private
	 * @param {XMLHttpRequestErrorEvent|Event} event - Error event.
	 */
	Resource.prototype._xhrOnError = function () {
	    var xhr = this.xhr;
	
	    this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
	};
	
	/**
	 * Called if an abort event fires for xhr.
	 *
	 * @private
	 * @param {XMLHttpRequestAbortEvent} event - Abort Event
	 */
	Resource.prototype._xhrOnAbort = function () {
	    this.abort(reqType(this.xhr) + ' Request was aborted by the user.');
	};
	
	/**
	 * Called if a timeout event fires for xdr.
	 *
	 * @private
	 * @param {Event} event - Timeout event.
	 */
	Resource.prototype._xdrOnTimeout = function () {
	    this.abort(reqType(this.xhr) + ' Request timed out.');
	};
	
	/**
	 * Called when data successfully loads from an xhr/xdr request.
	 *
	 * @private
	 * @param {XMLHttpRequestLoadEvent|Event} event - Load event
	 */
	Resource.prototype._xhrOnLoad = function () {
	    var xhr = this.xhr;
	    var status = typeof xhr.status === 'undefined' ? xhr.status : STATUS_OK; // XDR has no `.status`, assume 200.
	
	    // status can be 0 when using the file:// protocol, also check if a response was found
	    if (status === STATUS_OK || status === STATUS_EMPTY || (status === STATUS_NONE && xhr.responseText.length > 0)) {
	        // if text, just return it
	        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
	            this.data = xhr.responseText;
	        }
	        // if json, parse into json object
	        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
	            try {
	                this.data = JSON.parse(xhr.responseText);
	                this.isJson = true;
	            }
	            catch (e) {
	                this.abort('Error trying to parse loaded json:', e);
	
	                return;
	            }
	        }
	        // if xml, parse into an xml document or div element
	        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
	            try {
	                if (window.DOMParser) {
	                    var domparser = new DOMParser();
	
	                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml');
	                }
	                else {
	                    var div = document.createElement('div');
	
	                    div.innerHTML = xhr.responseText;
	                    this.data = div;
	                }
	                this.isXml = true;
	            }
	            catch (e) {
	                this.abort('Error trying to parse loaded xml:', e);
	
	                return;
	            }
	        }
	        // other types just return the response
	        else {
	            this.data = xhr.response || xhr.responseText;
	        }
	    }
	    else {
	        this.abort('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);
	
	        return;
	    }
	
	    this.complete();
	};
	
	/**
	 * Sets the `crossOrigin` property for this resource based on if the url
	 * for this resource is cross-origin. If crossOrigin was manually set, this
	 * function does nothing.
	 *
	 * @private
	 * @param {string} url - The url to test.
	 * @param {object} [loc=window.location] - The location object to test against.
	 * @return {string} The crossOrigin value to use (or empty string for none).
	 */
	Resource.prototype._determineCrossOrigin = function (url, loc) {
	    // data: and javascript: urls are considered same-origin
	    if (url.indexOf('data:') === 0) {
	        return '';
	    }
	
	    // default is window.location
	    loc = loc || window.location;
	
	    if (!tempAnchor) {
	        tempAnchor = document.createElement('a');
	    }
	
	    // let the browser determine the full href for the url of this resource and then
	    // parse with the node url lib, we can't use the properties of the anchor element
	    // because they don't work in IE9 :(
	    tempAnchor.href = url;
	    url = parseUri(tempAnchor.href, { strictMode: true });
	
	    var samePort = (!url.port && loc.port === '') || (url.port === loc.port);
	    var protocol = url.protocol ? url.protocol + ':' : '';
	
	    // if cross origin
	    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
	        return 'anonymous';
	    }
	
	    return '';
	};
	
	/**
	 * Determines the responseType of an XHR request based on the extension of the
	 * resource being loaded.
	 *
	 * @private
	 * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
	 */
	Resource.prototype._determineXhrType = function () {
	    return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;
	};
	
	Resource.prototype._determineLoadType = function () {
	    return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;
	};
	
	Resource.prototype._getExtension = function () {
	    var url = this.url;
	    var ext = '';
	
	    if (this.isDataUrl) {
	        var slashIndex = url.indexOf('/');
	
	        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
	    }
	    else {
	        var queryStart = url.indexOf('?');
	
	        if (queryStart !== -1) {
	            url = url.substring(0, queryStart);
	        }
	
	        ext = url.substring(url.lastIndexOf('.') + 1);
	    }
	
	    return ext.toLowerCase();
	};
	
	/**
	 * Determines the mime type of an XHR request based on the responseType of
	 * resource being loaded.
	 *
	 * @private
	 * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
	 * @return {string} The mime type to use.
	 */
	Resource.prototype._getMimeFromXhrType = function (type) {
	    switch (type) {
	        case Resource.XHR_RESPONSE_TYPE.BUFFER:
	            return 'application/octet-binary';
	
	        case Resource.XHR_RESPONSE_TYPE.BLOB:
	            return 'application/blob';
	
	        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
	            return 'application/xml';
	
	        case Resource.XHR_RESPONSE_TYPE.JSON:
	            return 'application/json';
	
	        case Resource.XHR_RESPONSE_TYPE.DEFAULT:
	        case Resource.XHR_RESPONSE_TYPE.TEXT:
	            /* falls through */
	        default:
	            return 'text/plain';
	
	    }
	};
	
	/**
	 * Quick helper to get string xhr type.
	 *
	 * @ignore
	 * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
	 * @return {string} The type.
	 */
	function reqType(xhr) {
	    return xhr.toString().replace('object ', '');
	}
	
	/**
	 * The types of loading a resource can use.
	 *
	 * @static
	 * @readonly
	 * @enum {number}
	 */
	Resource.LOAD_TYPE = {
	    /** Uses XMLHttpRequest to load the resource. */
	    XHR:    1,
	    /** Uses an `Image` object to load the resource. */
	    IMAGE:  2,
	    /** Uses an `Audio` object to load the resource. */
	    AUDIO:  3,
	    /** Uses a `Video` object to load the resource. */
	    VIDEO:  4
	};
	
	/**
	 * The XHR ready states, used internally.
	 *
	 * @static
	 * @readonly
	 * @enum {string}
	 */
	Resource.XHR_RESPONSE_TYPE = {
	    /** defaults to text */
	    DEFAULT:    'text',
	    /** ArrayBuffer */
	    BUFFER:     'arraybuffer',
	    /** Blob */
	    BLOB:       'blob',
	    /** Document */
	    DOCUMENT:   'document',
	    /** Object */
	    JSON:       'json',
	    /** String */
	    TEXT:       'text'
	};
	
	Resource._loadTypeMap = {
	    gif:      Resource.LOAD_TYPE.IMAGE,
	    png:      Resource.LOAD_TYPE.IMAGE,
	    bmp:      Resource.LOAD_TYPE.IMAGE,
	    jpg:      Resource.LOAD_TYPE.IMAGE,
	    jpeg:     Resource.LOAD_TYPE.IMAGE,
	    tif:      Resource.LOAD_TYPE.IMAGE,
	    tiff:     Resource.LOAD_TYPE.IMAGE,
	    webp:     Resource.LOAD_TYPE.IMAGE,
	    tga:      Resource.LOAD_TYPE.IMAGE,
	    'svg+xml':  Resource.LOAD_TYPE.IMAGE
	};
	
	Resource._xhrTypeMap = {
	    // xml
	    xhtml:    Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    html:     Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    htm:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    xml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    tmx:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    tsx:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	    svg:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,
	
	    // images
	    gif:      Resource.XHR_RESPONSE_TYPE.BLOB,
	    png:      Resource.XHR_RESPONSE_TYPE.BLOB,
	    bmp:      Resource.XHR_RESPONSE_TYPE.BLOB,
	    jpg:      Resource.XHR_RESPONSE_TYPE.BLOB,
	    jpeg:     Resource.XHR_RESPONSE_TYPE.BLOB,
	    tif:      Resource.XHR_RESPONSE_TYPE.BLOB,
	    tiff:     Resource.XHR_RESPONSE_TYPE.BLOB,
	    webp:     Resource.XHR_RESPONSE_TYPE.BLOB,
	    tga:      Resource.XHR_RESPONSE_TYPE.BLOB,
	
	    // json
	    json:     Resource.XHR_RESPONSE_TYPE.JSON,
	
	    // text
	    text:     Resource.XHR_RESPONSE_TYPE.TEXT,
	    txt:      Resource.XHR_RESPONSE_TYPE.TEXT
	};
	
	/**
	 * Sets the load type to be used for a specific extension.
	 *
	 * @static
	 * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
	 * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.
	 */
	Resource.setExtensionLoadType = function (extname, loadType) {
	    setExtMap(Resource._loadTypeMap, extname, loadType);
	};
	
	/**
	 * Sets the load type to be used for a specific extension.
	 *
	 * @static
	 * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
	 * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.
	 */
	Resource.setExtensionXhrType = function (extname, xhrType) {
	    setExtMap(Resource._xhrTypeMap, extname, xhrType);
	};
	
	function setExtMap(map, extname, val) {
	    if (extname && extname.indexOf('.') === 0) {
	        extname = extname.substring(1);
	    }
	
	    if (!extname) {
	        return;
	    }
	
	    map[extname] = val;
	}


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var has = Object.prototype.hasOwnProperty
	  , prefix = '~';
	
	/**
	 * Constructor to create a storage for our `EE` objects.
	 * An `Events` instance is a plain object whose properties are event names.
	 *
	 * @constructor
	 * @api private
	 */
	function Events() {}
	
	//
	// We try to not inherit from `Object.prototype`. In some engines creating an
	// instance in this way is faster than calling `Object.create(null)` directly.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// character to make sure that the built-in object properties are not
	// overridden or used as an attack vector.
	//
	if (Object.create) {
	  Events.prototype = Object.create(null);
	
	  //
	  // This hack is needed because the `__proto__` property is still inherited in
	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	  //
	  if (!new Events().__proto__) prefix = false;
	}
	
	/**
	 * Representation of a single event listener.
	 *
	 * @param {Function} fn The listener function.
	 * @param {Mixed} context The context to invoke the listener with.
	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	 * @constructor
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}
	
	/**
	 * Minimal `EventEmitter` interface that is molded against the Node.js
	 * `EventEmitter` interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() {
	  this._events = new Events();
	  this._eventsCount = 0;
	}
	
	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var names = []
	    , events
	    , name;
	
	  if (this._eventsCount === 0) return names;
	
	  for (name in (events = this._events)) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }
	
	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }
	
	  return names;
	};
	
	/**
	 * Return the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Boolean} exists Only check if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events[evt];
	
	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];
	
	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }
	
	  return ee;
	};
	
	/**
	 * Calls each of the listeners registered for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @returns {Boolean} `true` if the event had listeners, else `false`.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events[evt]) return false;
	
	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;
	
	  if (listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	
	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }
	
	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }
	
	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;
	
	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	
	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }
	
	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Add a listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
	  else if (!this._events[evt].fn) this._events[evt].push(listener);
	  else this._events[evt] = [this._events[evt], listener];
	
	  return this;
	};
	
	/**
	 * Add a one-time listener for a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn The listener function.
	 * @param {Mixed} [context=this] The context to invoke the listener with.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
	  else if (!this._events[evt].fn) this._events[evt].push(listener);
	  else this._events[evt] = [this._events[evt], listener];
	
	  return this;
	};
	
	/**
	 * Remove the listeners of a given event.
	 *
	 * @param {String|Symbol} event The event name.
	 * @param {Function} fn Only remove the listeners that match this function.
	 * @param {Mixed} context Only remove the listeners that have this context.
	 * @param {Boolean} once Only remove one-time listeners.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events[evt]) return this;
	  if (!fn) {
	    if (--this._eventsCount === 0) this._events = new Events();
	    else delete this._events[evt];
	    return this;
	  }
	
	  var listeners = this._events[evt];
	
	  if (listeners.fn) {
	    if (
	         listeners.fn === fn
	      && (!once || listeners.once)
	      && (!context || listeners.context === context)
	    ) {
	      if (--this._eventsCount === 0) this._events = new Events();
	      else delete this._events[evt];
	    }
	  } else {
	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	      if (
	           listeners[i].fn !== fn
	        || (once && !listeners[i].once)
	        || (context && listeners[i].context !== context)
	      ) {
	        events.push(listeners[i]);
	      }
	    }
	
	    //
	    // Reset the array, or remove it completely if we have no more listeners.
	    //
	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
	    else if (--this._eventsCount === 0) this._events = new Events();
	    else delete this._events[evt];
	  }
	
	  return this;
	};
	
	/**
	 * Remove all listeners, or those of the specified event.
	 *
	 * @param {String|Symbol} [event] The event name.
	 * @returns {EventEmitter} `this`.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  var evt;
	
	  if (event) {
	    evt = prefix ? prefix + event : event;
	    if (this._events[evt]) {
	      if (--this._eventsCount === 0) this._events = new Events();
	      else delete this._events[evt];
	    }
	  } else {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }
	
	  return this;
	};
	
	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	
	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};
	
	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;
	
	//
	// Allow `EventEmitter` to be imported as module namespace.
	//
	EventEmitter.EventEmitter = EventEmitter;
	
	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 123 */
/***/ function(module, exports) {

	'use strict';
	
	// a simple in-memory cache for resources
	var cache = {};
	
	module.exports = function () {
	    return function (resource, next) {
	        // if cached, then set data and complete the resource
	        if (cache[resource.url]) {
	            resource.data = cache[resource.url];
	            resource.complete(); // marks resource load complete and stops processing before middlewares
	        }
	        // if not cached, wait for complete and store it in the cache.
	        else {
	            resource.once('complete', function () {
	                cache[this.url] = this.data;
	            });
	        }
	
	        next();
	    };
	};


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Resource = __webpack_require__(121);
	var b64 = __webpack_require__(125);
	
	var Url = window.URL || window.webkitURL;
	
	// a middleware for transforming XHR loaded Blobs into more useful objects
	
	module.exports = function () {
	    return function (resource, next) {
	        if (!resource.data) {
	            next();
	
	            return;
	        }
	
	        // if this was an XHR load of a blob
	        if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
	            // if there is no blob support we probably got a binary string back
	            if (!window.Blob || typeof resource.data === 'string') {
	                var type = resource.xhr.getResponseHeader('content-type');
	
	                // this is an image, convert the binary string into a data url
	                if (type && type.indexOf('image') === 0) {
	                    resource.data = new Image();
	                    resource.data.src = 'data:' + type + ';base64,' + b64.encodeBinary(resource.xhr.responseText);
	
	                    resource.isImage = true;
	
	                    // wait until the image loads and then callback
	                    resource.data.onload = function () {
	                        resource.data.onload = null;
	
	                        next();
	                    };
	
	                    // next will be called on load
	                    return;
	                }
	            }
	            // if content type says this is an image, then we should transform the blob into an Image object
	            else if (resource.data.type.indexOf('image') === 0) {
	                var src = Url.createObjectURL(resource.data);
	
	                resource.blob = resource.data;
	                resource.data = new Image();
	                resource.data.src = src;
	
	                resource.isImage = true;
	
	                // cleanup the no longer used blob after the image loads
	                resource.data.onload = function () {
	                    Url.revokeObjectURL(src);
	                    resource.data.onload = null;
	
	                    next();
	                };
	
	                // next will be called on load.
	                return;
	            }
	        }
	
	        next();
	    };
	};


/***/ },
/* 125 */
/***/ function(module, exports) {

	/* eslint no-magic-numbers: 0 */
	'use strict';
	
	module.exports = {
	    // private property
	    _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
	
	    encodeBinary: function (input) {
	        var output = '';
	        var bytebuffer;
	        var encodedCharIndexes = new Array(4);
	        var inx = 0;
	        var jnx = 0;
	        var paddingBytes = 0;
	
	        while (inx < input.length) {
	            // Fill byte buffer array
	            bytebuffer = new Array(3);
	
	            for (jnx = 0; jnx < bytebuffer.length; jnx++) {
	                if (inx < input.length) {
	                    // throw away high-order byte, as documented at:
	                    // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
	                    bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
	                }
	                else {
	                    bytebuffer[jnx] = 0;
	                }
	            }
	
	            // Get each encoded character, 6 bits at a time
	            // index 1: first 6 bits
	            encodedCharIndexes[0] = bytebuffer[0] >> 2;
	            // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
	            encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);
	            // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
	            encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);
	            // index 3: forth 6 bits (6 least significant bits from input byte 3)
	            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;
	
	            // Determine whether padding happened, and adjust accordingly
	            paddingBytes = inx - (input.length - 1);
	            switch (paddingBytes) {
	                case 2:
	                    // Set last 2 characters to padding char
	                    encodedCharIndexes[3] = 64;
	                    encodedCharIndexes[2] = 64;
	                    break;
	
	                case 1:
	                    // Set last character to padding char
	                    encodedCharIndexes[3] = 64;
	                    break;
	
	                default:
	                    break; // No padding - proceed
	            }
	
	            // Now we will grab each appropriate character out of our keystring
	            // based on our index array and append it to the output string
	            for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {
	                output += this._keyStr.charAt(encodedCharIndexes[jnx]);
	            }
	        }
	
	        return output;
	    }
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	module.exports = function ()
	{
	    return function (resource, next)
	    {
	        // create a new texture if the data is an Image object
	        if (resource.data && resource.isImage)
	        {
	            var baseTexture = new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url));
	            baseTexture.imageUrl = resource.url;
	            resource.texture = new core.Texture(baseTexture);
	            // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
	            core.utils.BaseTextureCache[resource.url] = baseTexture;
	            core.utils.TextureCache[resource.url] = resource.texture;
	        }
	
	        next();
	    };
	};


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var Resource = __webpack_require__(117).Resource,
	    path = __webpack_require__(128),
	    core = __webpack_require__(13),
	    async = __webpack_require__(27);
	
	var BATCH_SIZE = 1000;
	
	module.exports = function ()
	{
	    return function (resource, next)
	    {
	        var imageResourceName = resource.name + '_image';
	
	        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists
	        if (!resource.data || !resource.isJson || !resource.data.frames || this.resources[imageResourceName])
	        {
	            return next();
	        }
	
	        var loadOptions = {
	            crossOrigin: resource.crossOrigin,
	            loadType: Resource.LOAD_TYPE.IMAGE,
	            metadata: resource.metadata.imageMetadata
	        };
	
	        var route = path.dirname(resource.url.replace(this.baseUrl, ''));
	
	        // load the image for this sheet
	        this.add(imageResourceName, route + '/' + resource.data.meta.image, loadOptions, function (res)
	        {
	            resource.textures = {};
	
	            var frames = resource.data.frames;
	            var frameKeys = Object.keys(frames);
	            var resolution = core.utils.getResolutionOfUrl(resource.url);
	            var batchIndex = 0;
	
	            function processFrames(initialFrameIndex, maxFrames)
	            {
	                var frameIndex = initialFrameIndex;
	
	                while (frameIndex - initialFrameIndex < maxFrames && frameIndex < frameKeys.length)
	                {
	                    var frame = frames[frameKeys[frameIndex]];
	                    var rect = frame.frame;
	
	                    if (rect)
	                    {
	                        var size = null;
	                        var trim = null;
	
	                        if (frame.rotated)
	                        {
	                            size = new core.Rectangle(rect.x, rect.y, rect.h, rect.w);
	                        }
	                        else
	                        {
	                            size = new core.Rectangle(rect.x, rect.y, rect.w, rect.h);
	                        }
	
	                        //  Check to see if the sprite is trimmed
	                        if (frame.trimmed)
	                        {
	                            trim = new core.Rectangle(
	                                frame.spriteSourceSize.x / resolution,
	                                frame.spriteSourceSize.y / resolution,
	                                frame.sourceSize.w / resolution,
	                                frame.sourceSize.h / resolution
	                            );
	                        }
	
	                        // flip the width and height!
	                        if (frame.rotated)
	                        {
	                            var temp = size.width;
	                            size.width = size.height;
	                            size.height = temp;
	                        }
	
	                        size.x /= resolution;
	                        size.y /= resolution;
	                        size.width /= resolution;
	                        size.height /= resolution;
	
	                        resource.textures[frameKeys[frameIndex]] = new core.Texture(res.texture.baseTexture, size, size.clone(), trim, frame.rotated);
	
	                        // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
	                        core.utils.TextureCache[frameKeys[frameIndex]] = resource.textures[frameKeys[frameIndex]];
	                    }
	                    frameIndex++;
	                }
	            }
	
	            function shouldProcessNextBatch()
	            {
	                return batchIndex * BATCH_SIZE < frameKeys.length;
	            }
	
	            function processNextBatch(done)
	            {
	                processFrames(batchIndex * BATCH_SIZE, BATCH_SIZE);
	                batchIndex++;
	                setTimeout(done, 0);
	            }
	
	            if (frameKeys.length <= BATCH_SIZE)
	            {
	                processFrames(0, BATCH_SIZE);
	                next();
	            }
	            else
	            {
	                async.whilst(shouldProcessNextBatch, processNextBatch, next);
	            }
	        });
	    };
	};


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var Resource = __webpack_require__(117).Resource,
	    core = __webpack_require__(13),
	    extras = __webpack_require__(76),
	    path = __webpack_require__(128);
	
	
	function parse(resource, texture) {
	    var data = {};
	    var info = resource.data.getElementsByTagName('info')[0];
	    var common = resource.data.getElementsByTagName('common')[0];
	
	    data.font = info.getAttribute('face');
	    data.size = parseInt(info.getAttribute('size'), 10);
	    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
	    data.chars = {};
	
	    //parse letters
	    var letters = resource.data.getElementsByTagName('char');
	
	    for (var i = 0; i < letters.length; i++)
	    {
	        var charCode = parseInt(letters[i].getAttribute('id'), 10);
	
	        var textureRect = new core.Rectangle(
	            parseInt(letters[i].getAttribute('x'), 10) + texture.frame.x,
	            parseInt(letters[i].getAttribute('y'), 10) + texture.frame.y,
	            parseInt(letters[i].getAttribute('width'), 10),
	            parseInt(letters[i].getAttribute('height'), 10)
	        );
	
	        data.chars[charCode] = {
	            xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
	            yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
	            xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
	            kerning: {},
	            texture: new core.Texture(texture.baseTexture, textureRect)
	
	        };
	    }
	
	    //parse kernings
	    var kernings = resource.data.getElementsByTagName('kerning');
	    for (i = 0; i < kernings.length; i++)
	    {
	        var first = parseInt(kernings[i].getAttribute('first'), 10);
	        var second = parseInt(kernings[i].getAttribute('second'), 10);
	        var amount = parseInt(kernings[i].getAttribute('amount'), 10);
	
	        if(data.chars[second])
	        {
	            data.chars[second].kerning[first] = amount;
	        }
	    }
	
	    resource.bitmapFont = data;
	
	    // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3
	    // but it's very likely to change
	    extras.BitmapText.fonts[data.font] = data;
	}
	
	
	module.exports = function ()
	{
	    return function (resource, next)
	    {
	        // skip if no data or not xml data
	        if (!resource.data || !resource.isXml)
	        {
	            return next();
	        }
	
	        // skip if not bitmap font data, using some silly duck-typing
	        if (
	            resource.data.getElementsByTagName('page').length === 0 ||
	            resource.data.getElementsByTagName('info').length === 0 ||
	            resource.data.getElementsByTagName('info')[0].getAttribute('face') === null
	            )
	        {
	            return next();
	        }
	
	        var xmlUrl = path.dirname(resource.url);
	
	        if (xmlUrl === '.') {
	            xmlUrl = '';
	        }
	
	        if (this.baseUrl && xmlUrl) {
	            // if baseurl has a trailing slash then add one to xmlUrl so the replace works below
	            if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {
	                xmlUrl += '/';
	            }
	
	            // remove baseUrl from xmlUrl
	            xmlUrl = xmlUrl.replace(this.baseUrl, '');
	        }
	
	        // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.
	        if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {
	            xmlUrl += '/';
	        }
	        var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');
	        if (core.utils.TextureCache[textureUrl]) {
	            //reuse existing texture
	            parse(resource, core.utils.TextureCache[textureUrl]);
	            next();
	        }
	        else {
	            var loadOptions = {
	                crossOrigin: resource.crossOrigin,
	                loadType: Resource.LOAD_TYPE.IMAGE,
	                metadata: resource.metadata.imageMetadata
	            };
	            // load the texture for the font
	            this.add(resource.name + '_image', textureUrl, loadOptions, function (res) {
	                parse(resource, res.texture);
	                next();
	            });
	        }
	    };
	};


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file        Main export of the PIXI extras library
	 * @author      Mat Groves <mat@goodboydigital.com>
	 * @copyright   2013-2015 GoodBoyDigital
	 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
	 */
	
	/**
	 * @namespace PIXI.mesh
	 */
	module.exports = {
	    Mesh:           __webpack_require__(131),
	    Plane:           __webpack_require__(132),
	    Rope:           __webpack_require__(133),
	    MeshRenderer:   __webpack_require__(134),
	    MeshShader:     __webpack_require__(135)
	};


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    tempPoint = new core.Point(),
	    tempPolygon = new core.Polygon();
	
	/**
	 * Base mesh class
	 * @class
	 * @extends PIXI.Container
	 * @memberof PIXI.mesh
	 * @param texture {PIXI.Texture} The texture to use
	 * @param [vertices] {Float32Array} if you want to specify the vertices
	 * @param [uvs] {Float32Array} if you want to specify the uvs
	 * @param [indices] {Uint16Array} if you want to specify the indices
	 * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts
	 */
	function Mesh(texture, vertices, uvs, indices, drawMode)
	{
	    core.Container.call(this);
	
	    /**
	     * The texture of the Mesh
	     *
	     * @member {PIXI.Texture}
	     * @private
	     */
	    this._texture = null;
	
	    /**
	     * The Uvs of the Mesh
	     *
	     * @member {Float32Array}
	     */
	    this.uvs = uvs || new Float32Array([0, 0,
	        1, 0,
	        1, 1,
	        0, 1]);
	
	    /**
	     * An array of vertices
	     *
	     * @member {Float32Array}
	     */
	    this.vertices = vertices || new Float32Array([0, 0,
	        100, 0,
	        100, 100,
	        0, 100]);
	
	    /*
	     * @member {Uint16Array} An array containing the indices of the vertices
	     */
	    //  TODO auto generate this based on draw mode!
	    this.indices = indices || new Uint16Array([0, 1, 3, 2]);
	
	    /**
	     * Whether the Mesh is dirty or not
	     *
	     * @member {boolean}
	     */
	    this.dirty = true;
	
	    /**
	     * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove any blend mode.
	     *
	     * @member {number}
	     * @default PIXI.BLEND_MODES.NORMAL
	     * @see PIXI.BLEND_MODES
	     */
	    this.blendMode = core.BLEND_MODES.NORMAL;
	
	    /**
	     * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.
	     *
	     * @member {number}
	     */
	    this.canvasPadding = 0;
	
	    /**
	     * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts
	     *
	     * @member {number}
	     * @see PIXI.mesh.Mesh.DRAW_MODES
	     */
	    this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;
	
	    // run texture setter;
	    this.texture = texture;
	
	     /**
	     * The default shader that is used if a mesh doesn't have a more specific one.
	     *
	     * @member {PIXI.Shader}
	     */
	    this.shader = null;
	}
	
	// constructor
	Mesh.prototype = Object.create(core.Container.prototype);
	Mesh.prototype.constructor = Mesh;
	module.exports = Mesh;
	
	Object.defineProperties(Mesh.prototype, {
	    /**
	     * The texture that the sprite is using
	     *
	     * @member {PIXI.Texture}
	     * @memberof PIXI.mesh.Mesh#
	     */
	    texture: {
	        get: function ()
	        {
	            return  this._texture;
	        },
	        set: function (value)
	        {
	            if (this._texture === value)
	            {
	                return;
	            }
	
	            this._texture = value;
	
	            if (value)
	            {
	                // wait for the texture to load
	                if (value.baseTexture.hasLoaded)
	                {
	                    this._onTextureUpdate();
	                }
	                else
	                {
	                    value.once('update', this._onTextureUpdate, this);
	                }
	            }
	        }
	    }
	});
	
	/**
	 * Renders the object using the WebGL renderer
	 *
	 * @param renderer {PIXI.WebGLRenderer} a reference to the WebGL renderer
	 * @private
	 */
	Mesh.prototype._renderWebGL = function (renderer)
	{
	    renderer.setObjectRenderer(renderer.plugins.mesh);
	    renderer.plugins.mesh.render(this);
	};
	
	/**
	 * Renders the object using the Canvas renderer
	 *
	 * @param renderer {PIXI.CanvasRenderer}
	 * @private
	 */
	Mesh.prototype._renderCanvas = function (renderer)
	{
	    var context = renderer.context;
	
	    var transform = this.worldTransform;
	    var res = renderer.resolution;
	
	    if (renderer.roundPixels)
	    {
	        context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, (transform.tx * res) | 0, (transform.ty * res) | 0);
	    }
	    else
	    {
	        context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);
	    }
	
	    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)
	    {
	        this._renderCanvasTriangleMesh(context);
	    }
	    else
	    {
	        this._renderCanvasTriangles(context);
	    }
	};
	
	/**
	 * Draws the object in Triangle Mesh mode using canvas
	 *
	 * @param context {CanvasRenderingContext2D} the current drawing context
	 * @private
	 */
	Mesh.prototype._renderCanvasTriangleMesh = function (context)
	{
	    // draw triangles!!
	    var vertices = this.vertices;
	    var uvs = this.uvs;
	
	    var length = vertices.length / 2;
	    // this.count++;
	
	    for (var i = 0; i < length - 2; i++)
	    {
	        // draw some triangles!
	        var index = i * 2;
	        this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));
	    }
	};
	
	/**
	 * Draws the object in triangle mode using canvas
	 *
	 * @param context {CanvasRenderingContext2D} the current drawing context
	 * @private
	 */
	Mesh.prototype._renderCanvasTriangles = function (context)
	{
	    // draw triangles!!
	    var vertices = this.vertices;
	    var uvs = this.uvs;
	    var indices = this.indices;
	
	    var length = indices.length;
	    // this.count++;
	
	    for (var i = 0; i < length; i += 3)
	    {
	        // draw some triangles!
	        var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;
	        this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
	    }
	};
	
	/**
	 * Draws one of the triangles that form this Mesh
	 *
	 * @param context {CanvasRenderingContext2D} the current drawing context
	 * @param vertices {Float32Array} a reference to the vertices of the Mesh
	 * @param uvs {Float32Array} a reference to the uvs of the Mesh
	 * @param index0 {number} the index of the first vertex
	 * @param index1 {number} the index of the second vertex
	 * @param index2 {number} the index of the third vertex
	 * @private
	 */
	Mesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2)
	{
	    var base = this._texture.baseTexture;
	    var textureSource = base.source;
	    var textureWidth = base.width;
	    var textureHeight = base.height;
	
	    var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];
	    var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];
	
	    var u0 = uvs[index0] * base.width, u1 = uvs[index1] * base.width, u2 = uvs[index2] * base.width;
	    var v0 = uvs[index0 + 1] * base.height, v1 = uvs[index1 + 1] * base.height, v2 = uvs[index2 + 1] * base.height;
	
	    if (this.canvasPadding > 0)
	    {
	        var paddingX = this.canvasPadding / this.worldTransform.a;
	        var paddingY = this.canvasPadding / this.worldTransform.d;
	        var centerX = (x0 + x1 + x2) / 3;
	        var centerY = (y0 + y1 + y2) / 3;
	
	        var normX = x0 - centerX;
	        var normY = y0 - centerY;
	
	        var dist = Math.sqrt(normX * normX + normY * normY);
	        x0 = centerX + (normX / dist) * (dist + paddingX);
	        y0 = centerY + (normY / dist) * (dist + paddingY);
	
	        //
	
	        normX = x1 - centerX;
	        normY = y1 - centerY;
	
	        dist = Math.sqrt(normX * normX + normY * normY);
	        x1 = centerX + (normX / dist) * (dist + paddingX);
	        y1 = centerY + (normY / dist) * (dist + paddingY);
	
	        normX = x2 - centerX;
	        normY = y2 - centerY;
	
	        dist = Math.sqrt(normX * normX + normY * normY);
	        x2 = centerX + (normX / dist) * (dist + paddingX);
	        y2 = centerY + (normY / dist) * (dist + paddingY);
	    }
	
	    context.save();
	    context.beginPath();
	
	
	    context.moveTo(x0, y0);
	    context.lineTo(x1, y1);
	    context.lineTo(x2, y2);
	
	    context.closePath();
	
	    context.clip();
	
	    // Compute matrix transform
	    var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2);
	    var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2);
	    var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2);
	    var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
	    var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2);
	    var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2);
	    var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
	
	    context.transform(deltaA / delta, deltaD / delta,
	        deltaB / delta, deltaE / delta,
	        deltaC / delta, deltaF / delta);
	
	    context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);
	    context.restore();
	};
	
	
	
	/**
	 * Renders a flat Mesh
	 *
	 * @param Mesh {PIXI.mesh.Mesh} The Mesh to render
	 * @private
	 */
	Mesh.prototype.renderMeshFlat = function (Mesh)
	{
	    var context = this.context;
	    var vertices = Mesh.vertices;
	
	    var length = vertices.length/2;
	    // this.count++;
	
	    context.beginPath();
	    for (var i=1; i < length-2; i++)
	    {
	        // draw some triangles!
	        var index = i*2;
	
	        var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4];
	        var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5];
	
	        context.moveTo(x0, y0);
	        context.lineTo(x1, y1);
	        context.lineTo(x2, y2);
	    }
	
	    context.fillStyle = '#FF0000';
	    context.fill();
	    context.closePath();
	};
	
	/**
	 * When the texture is updated, this event will fire to update the scale and frame
	 *
	 * @param event
	 * @private
	 */
	Mesh.prototype._onTextureUpdate = function ()
	{
	    this.updateFrame = true;
	};
	
	/**
	 * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
	 *
	 * @param matrix {PIXI.Matrix} the transformation matrix of the sprite
	 * @return {PIXI.Rectangle} the framing rectangle
	 */
	Mesh.prototype.getBounds = function (matrix)
	{
	    if (!this._currentBounds) {
	        var worldTransform = matrix || this.worldTransform;
	
	        var a = worldTransform.a;
	        var b = worldTransform.b;
	        var c = worldTransform.c;
	        var d = worldTransform.d;
	        var tx = worldTransform.tx;
	        var ty = worldTransform.ty;
	
	        var maxX = -Infinity;
	        var maxY = -Infinity;
	
	        var minX = Infinity;
	        var minY = Infinity;
	
	        var vertices = this.vertices;
	        for (var i = 0, n = vertices.length; i < n; i += 2) {
	            var rawX = vertices[i], rawY = vertices[i + 1];
	            var x = (a * rawX) + (c * rawY) + tx;
	            var y = (d * rawY) + (b * rawX) + ty;
	
	            minX = x < minX ? x : minX;
	            minY = y < minY ? y : minY;
	
	            maxX = x > maxX ? x : maxX;
	            maxY = y > maxY ? y : maxY;
	        }
	
	        if (minX === -Infinity || maxY === Infinity) {
	            return core.Rectangle.EMPTY;
	        }
	
	        var bounds = this._bounds;
	
	        bounds.x = minX;
	        bounds.width = maxX - minX;
	
	        bounds.y = minY;
	        bounds.height = maxY - minY;
	
	        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
	        this._currentBounds = bounds;
	    }
	
	    return this._currentBounds;
	};
	
	/**
	 * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH
	 *
	 * @param point {PIXI.Point} the point to test
	 * @return {boolean} the result of the test
	 */
	Mesh.prototype.containsPoint = function( point ) {
	    if (!this.getBounds().contains(point.x, point.y)) {
	        return false;
	    }
	    this.worldTransform.applyInverse(point,  tempPoint);
	
	    var vertices = this.vertices;
	    var points = tempPolygon.points;
	    var i, len;
	
	    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {
	        var indices = this.indices;
	        len = this.indices.length;
	        //TODO: inline this.
	        for (i=0;i<len;i+=3) {
	            var ind0 = indices[i]*2, ind1 = indices[i+1]*2, ind2 = indices[i+2]*2;
	            points[0] = vertices[ind0];
	            points[1] = vertices[ind0+1];
	            points[2] = vertices[ind1];
	            points[3] = vertices[ind1+1];
	            points[4] = vertices[ind2];
	            points[5] = vertices[ind2+1];
	            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
	                return true;
	            }
	        }
	    } else {
	        len = vertices.length;
	        for (i=0;i<len;i+=6) {
	            points[0] = vertices[i];
	            points[1] = vertices[i+1];
	            points[2] = vertices[i+2];
	            points[3] = vertices[i+3];
	            points[4] = vertices[i+4];
	            points[5] = vertices[i+5];
	            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
	                return true;
	            }
	        }
	    }
	    return false;
	};
	
	/**
	 * Different drawing buffer modes supported
	 *
	 * @static
	 * @constant
	 * @property {object} DRAW_MODES
	 * @property {number} DRAW_MODES.TRIANGLE_MESH
	 * @property {number} DRAW_MODES.TRIANGLES
	 */
	Mesh.DRAW_MODES = {
	    TRIANGLE_MESH: 0,
	    TRIANGLES: 1
	};


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var Mesh = __webpack_require__(131);
	
	/**
	 * The Plane allows you to draw a texture across several points and them manipulate these points
	 *
	 *```js
	 * for (var i = 0; i < 20; i++) {
	 *     points.push(new PIXI.Point(i * 50, 0));
	 * };
	 * var Plane = new PIXI.Plane(PIXI.Texture.fromImage("snake.png"), points);
	 *  ```
	 *
	 * @class
	 * @extends PIXI.mesh.Mesh
	 * @memberof PIXI.mesh
	 * @param {PIXI.Texture} texture - The texture to use on the Plane.
	 * @param {int} segmentsX - The number ox x segments
	 * @param {int} segmentsY - The number of y segments
	 *
	 */
	function Plane(texture, segmentsX, segmentsY)
	{
	    Mesh.call(this, texture);
	
	    /**
	     * Tracker for if the Plane is ready to be drawn. Needed because Mesh ctor can
	     * call _onTextureUpdated which could call refresh too early.
	     *
	     * @member {boolean}
	     * @private
	     */
	    this._ready = true;
	
	    this.segmentsX =  segmentsX || 10;
	    this.segmentsY = segmentsY || 10;
	
	    this.drawMode = Mesh.DRAW_MODES.TRIANGLES;
	    this.refresh();
	
	}
	
	
	// constructor
	Plane.prototype = Object.create( Mesh.prototype );
	Plane.prototype.constructor = Plane;
	module.exports = Plane;
	
	/**
	 * Refreshes
	 *
	 */
	Plane.prototype.refresh = function()
	{
	    var total = this.segmentsX * this.segmentsY;
	    var verts = [];
	    var colors = [];
	    var uvs = [];
	    var indices = [];
	    var texture = this.texture;
	
	  //  texture.width = 800 texture.width || 800;
	 //   texture.height = 800//texture.height || 800;
	
	    var segmentsXSub = this.segmentsX - 1;
	    var segmentsYSub = this.segmentsY - 1;
	    var i = 0;
	
	    var sizeX = texture.width / segmentsXSub;
	    var sizeY = texture.height / segmentsYSub;
	
	    for (i = 0; i < total; i++) {
	
	        var x = (i % this.segmentsX);
	        var y = ( (i / this.segmentsX ) | 0 );
	
	
	        verts.push((x * sizeX),
	                   (y * sizeY));
	
	        // this works for rectangular textures. 
	        uvs.push(texture._uvs.x0 + (texture._uvs.x1 - texture._uvs.x0) * (x / (this.segmentsX-1)), texture._uvs.y0 + (texture._uvs.y3-texture._uvs.y0) * (y/ (this.segmentsY-1)));
	      }
	
	    //  cons
	
	    var totalSub = segmentsXSub * segmentsYSub;
	
	    for (i = 0; i < totalSub; i++) {
	
	        var xpos = i % segmentsXSub;
	        var ypos = (i / segmentsXSub ) | 0;
	
	
	        var  value = (ypos * this.segmentsX) + xpos;
	        var  value2 = (ypos * this.segmentsX) + xpos + 1;
	        var  value3 = ((ypos+1) * this.segmentsX) + xpos;
	        var  value4 = ((ypos+1) * this.segmentsX) + xpos + 1;
	
	        indices.push(value, value2, value3);
	        indices.push(value2, value4, value3);
	    }
	
	
	    //console.log(indices)
	    this.vertices = new Float32Array(verts);
	    this.uvs = new Float32Array(uvs);
	    this.colors = new Float32Array(colors);
	    this.indices = new Uint16Array(indices);
	};
	
	/**
	 * Clear texture UVs when new texture is set
	 *
	 * @private
	 */
	Plane.prototype._onTextureUpdate = function ()
	{
	    Mesh.prototype._onTextureUpdate.call(this);
	
	    // wait for the Plane ctor to finish before calling refresh
	    if (this._ready) {
	        this.refresh();
	    }
	};


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var Mesh = __webpack_require__(131);
	var core = __webpack_require__(13);
	
	/**
	 * The rope allows you to draw a texture across several points and them manipulate these points
	 *
	 *```js
	 * for (var i = 0; i < 20; i++) {
	 *     points.push(new PIXI.Point(i * 50, 0));
	 * };
	 * var rope = new PIXI.Rope(PIXI.Texture.fromImage("snake.png"), points);
	 *  ```
	 *
	 * @class
	 * @extends PIXI.mesh.Mesh
	 * @memberof PIXI.mesh
	 * @param {PIXI.Texture} texture - The texture to use on the rope.
	 * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.
	 *
	 */
	function Rope(texture, points)
	{
	    Mesh.call(this, texture);
	
	    /*
	     * @member {PIXI.Point[]} An array of points that determine the rope
	     */
	    this.points = points;
	
	    /*
	     * @member {Float32Array} An array of vertices used to construct this rope.
	     */
	    this.vertices = new Float32Array(points.length * 4);
	
	    /*
	     * @member {Float32Array} The WebGL Uvs of the rope.
	     */
	    this.uvs = new Float32Array(points.length * 4);
	
	    /*
	     * @member {Float32Array} An array containing the color components
	     */
	    this.colors = new Float32Array(points.length * 2);
	
	    /*
	     * @member {Uint16Array} An array containing the indices of the vertices
	     */
	    this.indices = new Uint16Array(points.length * 2);
	
	    /**
	     * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can
	     * call _onTextureUpdated which could call refresh too early.
	     *
	     * @member {boolean}
	     * @private
	     */
	     this._ready = true;
	
	     this.refresh();
	}
	
	
	// constructor
	Rope.prototype = Object.create(Mesh.prototype);
	Rope.prototype.constructor = Rope;
	module.exports = Rope;
	
	/**
	 * Refreshes
	 *
	 */
	Rope.prototype.refresh = function ()
	{
	    var points = this.points;
	
	    // if too little points, or texture hasn't got UVs set yet just move on.
	    if (points.length < 1 || !this._texture._uvs)
	    {
	        return;
	    }
	
	    var uvs = this.uvs;
	
	    var indices = this.indices;
	    var colors = this.colors;
	
	    var textureUvs = this._texture._uvs;
	    var offset = new core.Point(textureUvs.x0, textureUvs.y0);
	    var factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);
	
	    uvs[0] = 0 + offset.x;
	    uvs[1] = 0 + offset.y;
	    uvs[2] = 0 + offset.x;
	    uvs[3] = 1 * factor.y + offset.y;
	
	    colors[0] = 1;
	    colors[1] = 1;
	
	    indices[0] = 0;
	    indices[1] = 1;
	
	    var total = points.length,
	        point, index, amount;
	
	    for (var i = 1; i < total; i++)
	    {
	        point = points[i];
	        index = i * 4;
	        // time to do some smart drawing!
	        amount = i / (total-1);
	
	        uvs[index] = amount * factor.x + offset.x;
	        uvs[index+1] = 0 + offset.y;
	
	        uvs[index+2] = amount * factor.x + offset.x;
	        uvs[index+3] = 1 * factor.y + offset.y;
	
	        index = i * 2;
	        colors[index] = 1;
	        colors[index+1] = 1;
	
	        index = i * 2;
	        indices[index] = index;
	        indices[index + 1] = index + 1;
	    }
	
	    this.dirty = true;
	};
	
	/**
	 * Clear texture UVs when new texture is set
	 *
	 * @private
	 */
	Rope.prototype._onTextureUpdate = function ()
	{
	    Mesh.prototype._onTextureUpdate.call(this);
	
	    // wait for the Rope ctor to finish before calling refresh
	    if (this._ready) {
	        this.refresh();
	    }
	};
	
	/**
	 * Updates the object transform for rendering
	 *
	 * @private
	 */
	Rope.prototype.updateTransform = function ()
	{
	    var points = this.points;
	
	    if (points.length < 1)
	    {
	        return;
	    }
	
	    var lastPoint = points[0];
	    var nextPoint;
	    var perpX = 0;
	    var perpY = 0;
	
	    // this.count -= 0.2;
	
	    var vertices = this.vertices;
	    var total = points.length,
	        point, index, ratio, perpLength, num;
	
	    for (var i = 0; i < total; i++)
	    {
	        point = points[i];
	        index = i * 4;
	
	        if (i < points.length-1)
	        {
	            nextPoint = points[i+1];
	        }
	        else
	        {
	            nextPoint = point;
	        }
	
	        perpY = -(nextPoint.x - lastPoint.x);
	        perpX = nextPoint.y - lastPoint.y;
	
	        ratio = (1 - (i / (total-1))) * 10;
	
	        if (ratio > 1)
	        {
	            ratio = 1;
	        }
	
	        perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
	        num = this._texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
	        perpX /= perpLength;
	        perpY /= perpLength;
	
	        perpX *= num;
	        perpY *= num;
	
	        vertices[index] = point.x + perpX;
	        vertices[index+1] = point.y + perpY;
	        vertices[index+2] = point.x - perpX;
	        vertices[index+3] = point.y - perpY;
	
	        lastPoint = point;
	    }
	
	    this.containerUpdateTransform();
	};


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13),
	    Mesh = __webpack_require__(131);
	
	/**
	 * @author Mat Groves
	 *
	 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
	 * for creating the original pixi version!
	 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
	 *
	 * Heavily inspired by LibGDX's MeshRenderer:
	 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/MeshRenderer.java
	 */
	
	/**
	 *
	 * @class
	 * @private
	 * @memberof PIXI.mesh
	 * @extends PIXI.ObjectRenderer
	 * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.
	 */
	function MeshRenderer(renderer)
	{
	    core.ObjectRenderer.call(this, renderer);
	
	
	    /**
	     * Holds the indices
	     *
	     * @member {Uint16Array}
	     */
	    
	    this.indices = new Uint16Array(15000);
	
	    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers
	    for (var i=0, j=0; i < 15000; i += 6, j += 4)
	    {
	        this.indices[i + 0] = j + 0;
	        this.indices[i + 1] = j + 1;
	        this.indices[i + 2] = j + 2;
	        this.indices[i + 3] = j + 0;
	        this.indices[i + 4] = j + 2;
	        this.indices[i + 5] = j + 3;
	    }
	
	    this.currentShader = null;
	}
	
	MeshRenderer.prototype = Object.create(core.ObjectRenderer.prototype);
	MeshRenderer.prototype.constructor = MeshRenderer;
	module.exports = MeshRenderer;
	
	core.WebGLRenderer.registerPlugin('mesh', MeshRenderer);
	
	/**
	 * Sets up the renderer context and necessary buffers.
	 *
	 * @private
	 * @param gl {WebGLRenderingContext} the current WebGL drawing context
	 */
	MeshRenderer.prototype.onContextChange = function ()
	{
	
	};
	
	/**
	 * Renders the sprite object.
	 *
	 * @param mesh {PIXI.mesh.Mesh} the mesh to render
	 */
	MeshRenderer.prototype.render = function (mesh)
	{
	    if(!mesh._vertexBuffer)
	    {
	        this._initWebGL(mesh);
	    }
	
	    var renderer = this.renderer,
	        gl = renderer.gl,
	        texture = mesh._texture.baseTexture,
	        shader = mesh.shader;// || renderer.shaderManager.plugins.meshShader;
	
	    var drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;
	
	    renderer.blendModeManager.setBlendMode(mesh.blendMode);
	
	    //TODO cache custom state..
	    if (!shader)
	    {
	        shader = renderer.shaderManager.plugins.meshShader;
	    }
	    else
	    {
	        shader = shader.shaders[gl.id] || shader.getShader(renderer);// : shader;
	    }
	
	    this.renderer.shaderManager.setShader(shader);
	
	    shader.uniforms.translationMatrix.value = mesh.worldTransform.toArray(true);
	    shader.uniforms.projectionMatrix.value = renderer.currentRenderTarget.projectionMatrix.toArray(true);
	    shader.uniforms.alpha.value = mesh.worldAlpha;
	
	    shader.syncUniforms();
	
	    if (!mesh.dirty)
	    {
	
	        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
	        gl.bufferSubData(gl.ARRAY_BUFFER, 0, mesh.vertices);
	        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
	
	        // update the uvs
	        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
	        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
	
	
	        gl.activeTexture(gl.TEXTURE0);
	
	       if (!texture._glTextures[gl.id])
	        {
	            this.renderer.updateTexture(texture);
	        }
	        else
	        {
	            // bind the current texture
	            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
	        }
	
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
	        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, mesh.indices);
	    }
	    else
	    {
	
	        mesh.dirty = false;
	        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);
	        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
	
	        // update the uvs
	        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.STATIC_DRAW);
	        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
	
	         gl.activeTexture(gl.TEXTURE0);
	
	        if (!texture._glTextures[gl.id])
	        {
	            this.renderer.updateTexture(texture);
	        }
	        else
	        {
	            // bind the current texture
	            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
	        }
	
	        // dont need to upload!
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
	
	    }
	
	    gl.drawElements(drawMode, mesh.indices.length, gl.UNSIGNED_SHORT, 0);
	
	};
	
	/**
	 * Prepares all the buffers to render this mesh
	 * @param mesh {PIXI.mesh.Mesh} the mesh to render
	 */
	MeshRenderer.prototype._initWebGL = function (mesh)
	{
	    // build the strip!
	    var gl = this.renderer.gl;
	
	    mesh._vertexBuffer = gl.createBuffer();
	    mesh._indexBuffer = gl.createBuffer();
	    mesh._uvBuffer = gl.createBuffer();
	
	
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.DYNAMIC_DRAW);
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER,  mesh.uvs, gl.STATIC_DRAW);
	
	    if(mesh.colors){
	        mesh._colorBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._colorBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, mesh.colors, gl.STATIC_DRAW);
	    }
	
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
	};
	
	
	/**
	 * Empties the current batch.
	 *
	 */
	MeshRenderer.prototype.flush = function ()
	{
	
	};
	
	/**
	 * Starts a new mesh renderer.
	 *
	 */
	MeshRenderer.prototype.start = function ()
	{
	    
	
	    this.currentShader = null;
	};
	
	/**
	 * Destroys the Mesh renderer
	 *
	 */
	MeshRenderer.prototype.destroy = function ()
	{
	    core.ObjectRenderer.prototype.destroy.call(this);
	};


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	/**
	 * @class
	 * @extends PIXI.Shader
	 * @memberof PIXI.mesh
	 * @param shaderManager {PIXI.ShaderManager} The WebGL shader manager this shader works for.
	 */
	function MeshShader(shaderManager)
	{
	    core.Shader.call(this,
	        shaderManager,
	        // vertex shader
	        [
	            'precision lowp float;',
	            'attribute vec2 aVertexPosition;',
	            'attribute vec2 aTextureCoord;',
	
	            'uniform mat3 translationMatrix;',
	            'uniform mat3 projectionMatrix;',
	
	            'varying vec2 vTextureCoord;',
	
	            'void main(void){',
	            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
	            '   vTextureCoord = aTextureCoord;',
	            '}'
	        ].join('\n'),
	        [
	            'precision lowp float;',
	
	            'varying vec2 vTextureCoord;',
	            'uniform float alpha;',
	
	            'uniform sampler2D uSampler;',
	
	            'void main(void){',
	            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * alpha ;',
	            '}'
	        ].join('\n'),
	        // custom uniforms
	        {
	            alpha:  { type: '1f', value: 0 },
	            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
	            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
	        },
	        // custom attributes
	        {
	            aVertexPosition:0,
	            aTextureCoord:0
	        }
	    );
	}
	
	MeshShader.prototype = Object.create(core.Shader.prototype);
	MeshShader.prototype.constructor = MeshShader;
	module.exports = MeshShader;
	
	core.ShaderManager.registerPlugin('meshShader', MeshShader);


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @file        Main export of the PIXI accessibility library
	 * @author      Mat Groves <mat@goodboydigital.com>
	 * @copyright   2013-2015 GoodBoyDigital
	 * @license     {@link https://github.com/pixijs/pixi.js/blob/master/LICENSE|MIT License}
	 */
	
	/**
	 * @namespace PIXI.interaction
	 */
	module.exports = {
	    accessibleTarget:     __webpack_require__(137),
	    AccessibilityManager: __webpack_require__(138)
	};


/***/ },
/* 137 */
/***/ function(module, exports) {

	/**
	 * Default property values of accessible objects
	 * used by {@link PIXI.accessibility.AccessibilityManager}.
	 *
	 * @mixin
	 * @memberof PIXI
	 * @example
	 *      function MyObject() {}
	 *
	 *      Object.assign(
	 *          MyObject.prototype,
	 *          PIXI.accessibility.accessibleTarget
	 *      );
	 */
	var accessibleTarget = {
	    
	    /**
	     * @todo Needs docs.
	     */
	    accessible:false,
	
	    /**
	     * @todo Needs docs.
	     */
	    accessibleTitle:null,
	
	    /**
	     * @todo Needs docs.
	     */
	    tabIndex:0,
	
	    /**
	     * @todo Needs docs.
	     */
	    _accessibleActive:false,
	
	    /**
	     * @todo Needs docs.
	     */
	    _accessibleDiv:false
	
	};
	
	module.exports = accessibleTarget;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var core = __webpack_require__(13);
	
	// add some extra variables to the container..
	Object.assign(
	    core.DisplayObject.prototype,
	    __webpack_require__(137)
	);
	
	
	/**
	 * The Accessibility manager reacreates the ability to tab and and have content read by screen readers. This is very important as it can possibly help people with disabilities access pixi content.
	 * Much like interaction any DisplayObject can be made accessible. This manager will map the events as if the mouse was being used, minimizing the efferot required to implement.
	 *
	 * @class
	 * @memberof PIXI
	 * @param renderer {PIXI.CanvasRenderer|PIXI.WebGLRenderer} A reference to the current renderer
	 */
	function AccessibilityManager(renderer)
	{
		// first we create a div that will sit over the pixi element. This is where the div overlays will go.
	    var div = document.createElement('div');
	    
	    div.style.width = 100 + 'px';
	    div.style.height = 100 + 'px';
	    div.style.position = 'absolute';
	    div.style.top = 0;
	    div.style.left = 0;
	   //
	    div.style.zIndex = 2;
	   	
	   	/**
	   	 * This is the dom element that will sit over the pixi element. This is where the div overlays will go.
	   	 * 
	   	 * @type {HTMLElement}
	   	 * @private
	   	 */
	   	this.div = div;
	
	   	/**
	   	 * A simple pool for storing divs.
	   	 * 
	   	 * @type {Array}
	   	 * @private
	   	 */
	 	this.pool = [];
	
	 	/**
	 	 * This is a tick used to check if an object is no longer being rendered.
	 	 * 
	 	 * @type {Number}
	 	 * @private
	 	 */
	   	this.renderId = 0;
	
	   	/**
	   	 * Setting this to true will visually show the divs
	   	 * 
	   	 * @type {Boolean}
	   	 */
	   	this.debug = false;
	
	  	/**
	     * The renderer this accessibility manager works for.
	     *
	     * @member {PIXI.SystemRenderer}
	     */
	   	this.renderer = renderer;
	
	   	/**
	     * The array of currently active accessible items.
	     *
	     * @member {Array}
	     * @private
	     */
	   	this.children = [];
	   	
	   	/**
	     * pre bind the functions..
	     */
	   	this._onKeyDown = this._onKeyDown.bind(this);
	   	this._onMouseMove = this._onMouseMove.bind(this);
	   	
	   	/**
	     * stores the state of the manager. If there are no accessible objects or the mouse is moving the will be false.
	     *
	     * @member {Array}
	     * @private
	     */
	   	this.isActive = false;
	
	
	   	// let listen for tab.. once pressed we can fire up and show the accessibility layer
	   	window.addEventListener('keydown', this._onKeyDown, false);
	}
	
	
	AccessibilityManager.prototype.constructor = AccessibilityManager;
	module.exports = AccessibilityManager;
	
	/**
	 * Activating will cause the Accessibility layer to be shown. This is called when a user preses the tab key
	 * @private
	 */
	AccessibilityManager.prototype.activate = function()
	{
		if(this.isActive)
		{
			return;
		}
	
		this.isActive = true;
	
		window.document.addEventListener('mousemove', this._onMouseMove, true);
		window.removeEventListener('keydown', this._onKeyDown, false);
	
		this.renderer.on('postrender', this.update, this);
	
		this.renderer.view.parentNode.appendChild(this.div);	
	};
	
	/**
	 * Deactivating will cause the Accessibility layer to be hidden. This is called when a user moves the mouse
	 * @private
	 */
	AccessibilityManager.prototype.deactivate = function()
	{
		if(!this.isActive)
		{
			return;
		}
	
		this.isActive = false;
	
		window.document.removeEventListener('mousemove', this._onMouseMove);
		window.addEventListener('keydown', this._onKeyDown, false);
	
		this.renderer.off('postrender', this.update);
	
		this.div.parentNode.removeChild(this.div);
	
	};
	
	/**
	 * This recursive function will run throught he scene graph and add any new accessible objects to the DOM layer.
	 * @param element {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} the DisplayObject to check.
	 * @private
	 */
	AccessibilityManager.prototype.updateAccessibleObjects = function(displayObject)
	{
		if(!displayObject.visible)
		{
			return;
		}
	
		if(displayObject.accessible && displayObject.interactive)
		{
			if(!displayObject._accessibleActive)
			{
				this.addChild(displayObject);
			}
		   	
		   	displayObject.renderId = this.renderId;
		}
	
	
		if(displayObject.interactiveChildren)
		{
	
			var children = displayObject.children;
	
			for (var i = children.length - 1; i >= 0; i--) {
			
				this.updateAccessibleObjects(children[i]);
			}
		}
	};
	
	
	/**
	 * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects
	 * @private
	 */
	AccessibilityManager.prototype.update = function()
	{
	
		// update children...
		this.updateAccessibleObjects(this.renderer._lastObjectRendered);
	
		var rect = this.renderer.view.getBoundingClientRect();
		var sx = rect.width  / this.renderer.width;
		var sy = rect.height / this.renderer.height;
	
		var div = this.div;
	
		div.style.left = rect.left + 'px';
		div.style.top = rect.top + 'px';
		div.style.width = this.renderer.width + 'px';
		div.style.height = this.renderer.height + 'px';
	
		for (var i = 0; i < this.children.length; i++)
		{
	
			var child = this.children[i];
	
			if(child.renderId !== this.renderId)
			{
				child._accessibleActive = false;
	
	            core.utils.removeItems(this.children, i, 1);
				this.div.removeChild( child._accessibleDiv );
				this.pool.push(child._accessibleDiv);
				child._accessibleDiv = null;
	
				i--;
	
				if(this.children.length === 0)
				{
					this.deactivate();
				}
			}
			else
			{
				// map div to display..
				div = child._accessibleDiv;
				var hitArea = child.hitArea;
				var wt = child.worldTransform;
	
				if(child.hitArea)
				{
					div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + 'px';
					div.style.top =  ((wt.ty + (hitArea.y * wt.d)) * sy) +  'px';
	
					div.style.width = (hitArea.width * wt.a * sx) + 'px';
					div.style.height = (hitArea.height * wt.d * sy) + 'px';
				
				}
				else
				{
					hitArea = child.getBounds();
	
					this.capHitArea(hitArea);
	
					div.style.left = (hitArea.x * sx) + 'px';
					div.style.top =  (hitArea.y * sy) +  'px';
	
					div.style.width = (hitArea.width * sx) + 'px';
					div.style.height = (hitArea.height * sy) + 'px';
				}		
			}
		}
	
		// increment the render id..
		this.renderId++;
	};
	
	AccessibilityManager.prototype.capHitArea = function (hitArea)
	{
	    if (hitArea.x < 0)
	    {
	        hitArea.width += hitArea.x;
	        hitArea.x = 0;
	    }
	
	    if (hitArea.y < 0)
	    {
	        hitArea.height += hitArea.y;
	        hitArea.y = 0;
	    }
	
	    if ( hitArea.x + hitArea.width > this.renderer.width )
	    {
	        hitArea.width = this.renderer.width - hitArea.x;
	    }
	
	    if ( hitArea.y + hitArea.height > this.renderer.height )
	    {
	        hitArea.height = this.renderer.height - hitArea.y;
	    }
	};
	
	
	/**
	 * Adds a DisplayObject to the accessibility manager
	 * @private
	 */
	AccessibilityManager.prototype.addChild = function(displayObject)
	{
	//	this.activate();
		
		var div = this.pool.pop();
	
		if(!div)
		{
			div = document.createElement('button'); 
	
		    div.style.width = 100 + 'px';
		    div.style.height = 100 + 'px';
		    div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
		    div.style.position = 'absolute';
		    div.style.zIndex = 2;
		    div.style.borderStyle = 'none';
	
		    
		    div.addEventListener('click', this._onClick.bind(this));
		    div.addEventListener('focus', this._onFocus.bind(this));
		    div.addEventListener('focusout', this._onFocusOut.bind(this));
		}
		   	
	
	
	
		div.title = displayObject.accessibleTitle || 'displayObject ' + this.tabIndex;
	
		//
		
		displayObject._accessibleActive = true;
		displayObject._accessibleDiv = div;
		div.displayObject = displayObject;
	
	
		this.children.push(displayObject);
		this.div.appendChild( displayObject._accessibleDiv );
		displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
	};
	
	
	/**
	 * Maps the div button press to pixi's InteractionManager (click)
	 * @private
	 */
	AccessibilityManager.prototype._onClick = function(e)
	{
		var interactionManager = this.renderer.plugins.interaction;
		interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
	};
	
	/**
	 * Maps the div focus events to pixis InteractionManager (mouseover)
	 * @private
	 */
	AccessibilityManager.prototype._onFocus = function(e)
	{
		var interactionManager = this.renderer.plugins.interaction;
		interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
	};
	
	/**
	 * Maps the div focus events to pixis InteractionManager (mouseout)
	 * @private
	 */
	AccessibilityManager.prototype._onFocusOut = function(e)
	{
		var interactionManager = this.renderer.plugins.interaction;
		interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
	};
	
	/**
	 * Is called when a key is pressed
	 *
	 * @private
	 */
	AccessibilityManager.prototype._onKeyDown = function(e)
	{
		if(e.keyCode !== 9)
		{
			return;
		}
	
		this.activate();
	};
	
	/**
	 * Is called when the mouse moves across the renderer element
	 *
	 * @private
	 */
	AccessibilityManager.prototype._onMouseMove = function()
	{
		this.deactivate();
	};
	
	
	/**
	 * Destroys the accessibility manager
	 *
	 */
	AccessibilityManager.prototype.destroy = function () 
	{
		this.div = null;
	
		for (var i = 0; i < this.children.length; i++)
		{
			this.children[i].div = null;
		}
	
		
		window.document.removeEventListener('mousemove', this._onMouseMove);
		window.removeEventListener('keydown', this._onKeyDown);
			
		this.pool = null;
		this.children = null;
		this.renderer = null;
	
	};
	
	core.WebGLRenderer.registerPlugin('accessibility', AccessibilityManager);
	core.CanvasRenderer.registerPlugin('accessibility', AccessibilityManager);
	


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/*global console */
	var core = __webpack_require__(13),
	    mesh = __webpack_require__(130),
	    extras = __webpack_require__(76),
	    filters = __webpack_require__(83);
	
	/**
	 * @class
	 * @private
	 * @name SpriteBatch
	 * @memberof PIXI
	 * @see PIXI.ParticleContainer
	 * @throws {ReferenceError} SpriteBatch does not exist any more, please use the new ParticleContainer instead.
	 * @deprecated since version 3.0.0
	 */
	core.SpriteBatch = function()
	{
	    throw new ReferenceError('SpriteBatch does not exist any more, please use the new ParticleContainer instead.');
	};
	
	/**
	 * @class
	 * @private
	 * @name AssetLoader
	 * @memberof PIXI
	 * @see PIXI.loaders.Loader
	 * @throws {ReferenceError} The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.
	 * @deprecated since version 3.0.0
	 */
	core.AssetLoader = function()
	{
	    throw new ReferenceError('The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.');
	};
	
	Object.defineProperties(core, {
	
	    /**
	     * @class
	     * @private
	     * @name Stage
	     * @memberof PIXI
	     * @see PIXI.Container
	     * @deprecated since version 3.0.0
	     */
	    Stage: {
	        get: function()
	        {
	            console.warn('You do not need to use a PIXI Stage any more, you can simply render any container.');
	            return core.Container;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name DisplayObjectContainer
	     * @memberof PIXI
	     * @see PIXI.Container
	     * @deprecated since version 3.0.0
	     */
	    DisplayObjectContainer: {
	        get: function()
	        {
	            console.warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.');
	            return core.Container;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name Strip
	     * @memberof PIXI
	     * @see PIXI.mesh.Mesh
	     * @deprecated since version 3.0.0
	     */
	    Strip: {
	        get: function()
	        {
	            console.warn('The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.');
	            return mesh.Mesh;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name Rope
	     * @memberof PIXI
	     * @see PIXI.mesh.Rope
	     * @deprecated since version 3.0.0
	     */
	    Rope: {
	        get: function()
	        {
	            console.warn('The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.');
	            return mesh.Rope;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name MovieClip
	     * @memberof PIXI
	     * @see PIXI.extras.MovieClip
	     * @deprecated since version 3.0.0
	     */
	    MovieClip: {
	        get: function()
	        {
	            console.warn('The MovieClip class has been moved to extras.MovieClip, please use extras.MovieClip from now on.');
	            return extras.MovieClip;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name TilingSprite
	     * @memberof PIXI
	     * @see PIXI.extras.TilingSprite
	     * @deprecated since version 3.0.0
	     */
	    TilingSprite: {
	        get: function()
	        {
	            console.warn('The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on.');
	            return extras.TilingSprite;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name BitmapText
	     * @memberof PIXI
	     * @see PIXI.extras.BitmapText
	     * @deprecated since version 3.0.0
	     */
	    BitmapText: {
	        get: function()
	        {
	            console.warn('The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on.');
	            return extras.BitmapText;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name blendModes
	     * @memberof PIXI
	     * @see PIXI.BLEND_MODES
	     * @deprecated since version 3.0.0
	     */
	    blendModes: {
	        get: function()
	        {
	            console.warn('The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.');
	            return core.BLEND_MODES;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name scaleModes
	     * @memberof PIXI
	     * @see PIXI.SCALE_MODES
	     * @deprecated since version 3.0.0
	     */
	    scaleModes: {
	        get: function()
	        {
	            console.warn('The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.');
	            return core.SCALE_MODES;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name BaseTextureCache
	     * @memberof PIXI
	     * @see PIXI.utils.BaseTextureCache
	     * @deprecated since version 3.0.0
	     */
	    BaseTextureCache: {
	        get: function ()
	        {
	            console.warn('The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on.');
	            return core.utils.BaseTextureCache;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name TextureCache
	     * @memberof PIXI
	     * @see PIXI.utils.TextureCache
	     * @deprecated since version 3.0.0
	     */
	    TextureCache: {
	        get: function ()
	        {
	            console.warn('The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on.');
	            return core.utils.TextureCache;
	        }
	    },
	
	    /**
	     * @namespace
	     * @private
	     * @name math
	     * @memberof PIXI
	     * @see PIXI
	     * @deprecated since version 3.0.6
	     */
	    math: {
	        get: function ()
	        {
	            console.warn('The math namespace is deprecated, please access members already accessible on PIXI.');
	            return core;
	        }
	    }
	});
	
	/**
	 * @method
	 * @private
	 * @name PIXI.Sprite#setTexture
	 * @see PIXI.Sprite#texture
	 * @deprecated since version 3.0.0
	 */
	core.Sprite.prototype.setTexture = function(texture)
	{
	    this.texture = texture;
	    console.warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;');
	};
	
	/**
	 * @method
	 * @name PIXI.extras.BitmapText#setText
	 * @see PIXI.extras.BitmapText#text
	 * @deprecated since version 3.0.0
	 */
	extras.BitmapText.prototype.setText = function(text)
	{
	    this.text = text;
	    console.warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \'my text\';');
	};
	
	/**
	 * @method
	 * @name PIXI.Text#setText
	 * @see PIXI.Text#text
	 * @deprecated since version 3.0.0
	 */
	core.Text.prototype.setText = function(text)
	{
	    this.text = text;
	    console.warn('setText is now deprecated, please use the text property, e.g : myText.text = \'my text\';');
	};
	
	/**
	 * @method
	 * @name PIXI.Text#setStyle
	 * @see PIXI.Text#style
	 * @deprecated since version 3.0.0
	 */
	core.Text.prototype.setStyle = function(style)
	{
	    this.style = style;
	    console.warn('setStyle is now deprecated, please use the style property, e.g : myText.style = style;');
	};
	
	/**
	 * @method
	 * @name PIXI.Texture#setFrame
	 * @see PIXI.Texture#setFrame
	 * @deprecated since version 3.0.0
	 */
	core.Texture.prototype.setFrame = function(frame)
	{
	    this.frame = frame;
	    console.warn('setFrame is now deprecated, please use the frame property, e.g : myTexture.frame = frame;');
	};
	
	Object.defineProperties(filters, {
	
	    /**
	     * @class
	     * @private
	     * @name PIXI.filters.AbstractFilter
	     * @see PIXI.AbstractFilter
	     * @deprecated since version 3.0.6
	     */
	    AbstractFilter: {
	        get: function()
	        {
	            console.warn('filters.AbstractFilter is an undocumented alias, please use AbstractFilter from now on.');
	            return core.AbstractFilter;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name PIXI.filters.FXAAFilter
	     * @see PIXI.FXAAFilter
	     * @deprecated since version 3.0.6
	     */
	    FXAAFilter: {
	        get: function()
	        {
	            console.warn('filters.FXAAFilter is an undocumented alias, please use FXAAFilter from now on.');
	            return core.FXAAFilter;
	        }
	    },
	
	    /**
	     * @class
	     * @private
	     * @name PIXI.filters.SpriteMaskFilter
	     * @see PIXI.SpriteMaskFilter
	     * @deprecated since version 3.0.6
	     */
	    SpriteMaskFilter: {
	        get: function()
	        {
	            console.warn('filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.');
	            return core.SpriteMaskFilter;
	        }
	    }
	});
	
	/**
	 * @method
	 * @name PIXI.utils.uuid
	 * @see PIXI.utils.uid
	 * @deprecated since version 3.0.6
	 */
	core.utils.uuid = function ()
	{
	    console.warn('utils.uuid() is deprecated, please use utils.uid() from now on.');
	    return core.utils.uid();
	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _events = __webpack_require__(141);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _GameConstants = __webpack_require__(142);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var RendererStore = function (_EventEmitter) {
	  _inherits(RendererStore, _EventEmitter);
	
	  function RendererStore() {
	    var _ref;
	
	    _classCallCheck(this, RendererStore);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = _possibleConstructorReturn(this, (_ref = RendererStore.__proto__ || Object.getPrototypeOf(RendererStore)).call.apply(_ref, [this].concat(args)));
	
	    _this.data = {
	      width: 0,
	      height: 0,
	      stageWidth: 0,
	      stageHeight: 0,
	      stageCenter: {
	        x: 0,
	        y: 0
	      },
	      resolution: 1
	    };
	    return _this;
	  }
	
	  _createClass(RendererStore, [{
	    key: 'get',
	    value: function get(key) {
	      return this.data[key];
	    }
	  }, {
	    key: 'set',
	    value: function set(key, value) {
	      return this.data[key] = value;
	    }
	  }, {
	    key: 'emitChange',
	    value: function emitChange() {
	      this.emit(_GameConstants.RESIZE, this.data);
	    }
	  }, {
	    key: 'addChangeListener',
	    value: function addChangeListener(callback) {
	      this.on(_GameConstants.RESIZE, callback, this.data);
	    }
	  }]);
	
	  return RendererStore;
	}(_events2.default);
	
	exports.default = new RendererStore();

/***/ },
/* 141 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 142 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var constants = exports.constants = {
	  RESIZE: 'APP_RESIZE',
	  ANIMATE: 'APP_ANIMATE',
	  BET_MADE: 'BET_MADE'
	};

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ScaledContainer2 = __webpack_require__(144);
	
	var _ScaledContainer3 = _interopRequireDefault(_ScaledContainer2);
	
	var _Background = __webpack_require__(145);
	
	var _Background2 = _interopRequireDefault(_Background);
	
	var _Game = __webpack_require__(148);
	
	var _Game2 = _interopRequireDefault(_Game);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var App = function (_ScaledContainer) {
	  _inherits(App, _ScaledContainer);
	
	  function App() {
	    var _ref;
	
	    _classCallCheck(this, App);
	
	    var bg = new _Background2.default();
	    var game = new _Game2.default();
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = _possibleConstructorReturn(this, (_ref = App.__proto__ || Object.getPrototypeOf(App)).call.apply(_ref, [this].concat(args)));
	
	    _this.addChild(bg);
	    _this.addChild(game);
	    return _this;
	  }
	
	  return App;
	}(_ScaledContainer3.default);
	
	exports.default = App;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _pixi = __webpack_require__(7);
	
	var _pixi2 = _interopRequireDefault(_pixi);
	
	var _RendererStore = __webpack_require__(140);
	
	var _RendererStore2 = _interopRequireDefault(_RendererStore);
	
	var _GameConstants = __webpack_require__(142);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var tw = 1920;
	var th = 1080;
	
	var ScaledContainer = function (_PIXI$Container) {
	  _inherits(ScaledContainer, _PIXI$Container);
	
	  function ScaledContainer(target_w, target_h) {
	    _classCallCheck(this, ScaledContainer);
	
	    var _this = _possibleConstructorReturn(this, (ScaledContainer.__proto__ || Object.getPrototypeOf(ScaledContainer)).call(this));
	
	    tw = target_w || _RendererStore2.default.get('target_width');
	    th = target_h || _RendererStore2.default.get('target_height');
	
	    _RendererStore2.default.addChangeListener(_this.resizeHandler.bind(_this));
	
	    _this.resizeHandler();
	    return _this;
	  }
	
	  _createClass(ScaledContainer, [{
	    key: 'resizeHandler',
	    value: function resizeHandler() {
	      var rw = _RendererStore2.default.get('width');
	      var rh = _RendererStore2.default.get('height');
	      var Xratio = rw / tw;
	      var Yratio = rh / th;
	      var scaleRatio = rw > rh ? Xratio : Yratio;
	      var scale = new _pixi2.default.Point(scaleRatio, scaleRatio);
	      var offsetX = rw / 2 - tw * scaleRatio / 2;
	      var offsetY = rh / 2 - th * scaleRatio / 2;
	
	      if (th * scaleRatio < rh) {
	        scaleRatio = Yratio;
	        scale = new _pixi2.default.Point(scaleRatio, scaleRatio);
	        offsetX = rw / 2 - tw * scaleRatio / 2;
	        offsetY = rh / 2 - th * scaleRatio / 2;
	      }
	
	      this.position.x = offsetX;
	      this.position.y = offsetY;
	      this.scale = scale;
	    }
	  }]);
	
	  return ScaledContainer;
	}(_pixi2.default.Container);
	
	exports.default = ScaledContainer;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _pixi = __webpack_require__(7);
	
	var _pixi2 = _interopRequireDefault(_pixi);
	
	var _package = __webpack_require__(3);
	
	var _kitchen = __webpack_require__(146);
	
	var _kitchen2 = _interopRequireDefault(_kitchen);
	
	var _table = __webpack_require__(147);
	
	var _table2 = _interopRequireDefault(_table);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Background = function (_PIXI$Container) {
	  _inherits(Background, _PIXI$Container);
	
	  function Background() {
	    _classCallCheck(this, Background);
	
	    var _this = _possibleConstructorReturn(this, (Background.__proto__ || Object.getPrototypeOf(Background)).call(this));
	
	    var positionX = _package.config.stageWidth / 3.5;
	    var positionY = _package.config.stageHeight / 5;
	
	    var bg = _pixi2.default.Sprite.fromImage(_kitchen2.default);
	    var table = _pixi2.default.Sprite.fromImage(_table2.default);
	
	    bg.anchor.x = 0;
	    bg.anchor.y = 0;
	    bg.alpha = .7;
	    bg.position.x = -120;
	    bg.position.y = 50;
	
	    table.x = positionX + 230;
	    table.y = positionY + 420;
	    table.scale.x = 1.5;
	    table.scale.y = 1.5;
	
	    var blurFilter = new _pixi2.default.filters.BlurFilter();
	    blurFilter.blur = 3;
	    bg.filters = [blurFilter];
	
	    _this.addChild(bg, table);
	    return _this;
	  }
	
	  return Background;
	}(_pixi2.default.Container);
	
	exports.default = Background;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/kitchen.png";

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/table.png";

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _pixi = __webpack_require__(7);
	
	var _pixi2 = _interopRequireDefault(_pixi);
	
	var _package = __webpack_require__(3);
	
	var _Banner = __webpack_require__(149);
	
	var _Banner2 = _interopRequireDefault(_Banner);
	
	var _Button = __webpack_require__(150);
	
	var _Button2 = _interopRequireDefault(_Button);
	
	var _GameStore = __webpack_require__(151);
	
	var _GameStore2 = _interopRequireDefault(_GameStore);
	
	var _Win = __webpack_require__(152);
	
	var _Win2 = _interopRequireDefault(_Win);
	
	var _Lose = __webpack_require__(153);
	
	var _Lose2 = _interopRequireDefault(_Lose);
	
	var _cake = __webpack_require__(154);
	
	var _cake2 = _interopRequireDefault(_cake);
	
	var _cake3 = __webpack_require__(155);
	
	var _cake4 = _interopRequireDefault(_cake3);
	
	var _cake5 = __webpack_require__(156);
	
	var _cake6 = _interopRequireDefault(_cake5);
	
	var _cake7 = __webpack_require__(157);
	
	var _cake8 = _interopRequireDefault(_cake7);
	
	var _cake9 = __webpack_require__(158);
	
	var _cake10 = _interopRequireDefault(_cake9);
	
	var _leftLady = __webpack_require__(159);
	
	var _leftLady2 = _interopRequireDefault(_leftLady);
	
	var _rightLady = __webpack_require__(160);
	
	var _rightLady2 = _interopRequireDefault(_rightLady);
	
	var _leftLadyOver = __webpack_require__(161);
	
	var _leftLadyOver2 = _interopRequireDefault(_leftLadyOver);
	
	var _rightLadyOver = __webpack_require__(162);
	
	var _rightLadyOver2 = _interopRequireDefault(_rightLadyOver);
	
	var _leftLady3 = __webpack_require__(163);
	
	var _leftLady4 = _interopRequireDefault(_leftLady3);
	
	var _leftLady5 = __webpack_require__(164);
	
	var _leftLady6 = _interopRequireDefault(_leftLady5);
	
	var _leftLady7 = __webpack_require__(165);
	
	var _leftLady8 = _interopRequireDefault(_leftLady7);
	
	var _leftLady9 = __webpack_require__(166);
	
	var _leftLady10 = _interopRequireDefault(_leftLady9);
	
	var _rightLady3 = __webpack_require__(167);
	
	var _rightLady4 = _interopRequireDefault(_rightLady3);
	
	var _rightLady5 = __webpack_require__(168);
	
	var _rightLady6 = _interopRequireDefault(_rightLady5);
	
	var _rightLady7 = __webpack_require__(169);
	
	var _rightLady8 = _interopRequireDefault(_rightLady7);
	
	var _rightLady9 = __webpack_require__(170);
	
	var _rightLady10 = _interopRequireDefault(_rightLady9);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var leftButtonTexture = _pixi2.default.Texture.fromImage(_leftLady2.default);
	var rightButtonTexture = _pixi2.default.Texture.fromImage(_rightLady2.default);
	
	var Bet = function (_PIXI$Sprite) {
	  _inherits(Bet, _PIXI$Sprite);
	
	  function Bet() {
	    _classCallCheck(this, Bet);
	
	    var _this = _possibleConstructorReturn(this, (Bet.__proto__ || Object.getPrototypeOf(Bet)).call(this));
	
	    var positionX = _package.config.stageWidth / 3.5;
	    var positionY = _package.config.stageHeight / 5;
	
	    var cakeTexture = _pixi2.default.Texture.fromImage(_cake2.default);
	    var leftButtonTextureOver = _pixi2.default.Texture.fromImage(_leftLadyOver2.default);
	    var rightButtonTextureOver = _pixi2.default.Texture.fromImage(_rightLadyOver2.default);
	
	    var banner = new _Banner2.default();
	    var cake = new _pixi2.default.Sprite(cakeTexture);
	    var leftButton = new _Button2.default(leftButtonTexture);
	    var rightButton = new _Button2.default(rightButtonTexture);
	    var gameWin = new _Win2.default();
	    var gameLoss = new _Lose2.default();
	    var getReadyText = new _pixi2.default.Text('', {
	      fontWeight: 'bold',
	      fontSize: 60,
	      fontFamily: 'Helvetica',
	      fill: '#cc00ff',
	      align: 'center',
	      stroke: '#000',
	      strokeThickness: 3
	    });
	
	    cake.position.x = positionX - -320;
	    cake.position.y = positionY + 185;
	    cake.scale.x = .4;
	    cake.scale.y = .4;
	
	    getReadyText.position.x = positionX - -350;
	    getReadyText.position.y = positionY - -20;
	    getReadyText.scale.x = 2;
	    getReadyText.scale.y = 2;
	
	    gameWin.visible = false;
	    gameLoss.visible = false;
	    getReadyText.visible = false;
	
	    leftButton.set('texture', leftButtonTextureOver);
	    leftButton.anchor.set(.5);
	    leftButton.x = positionX + 230;
	    leftButton.y = positionY + 325;
	    leftButton.anchor.x = .5;
	    leftButton.anchor.y = .33;
	    leftButton.scale.x = 1.5;
	    leftButton.scale.y = 1.5;
	    leftButton.addInteractivityToButtons();
	    leftButton.addButtonEvents();
	    leftButton.on('click', function () {
	      _this.buttonUpdates(leftButton, rightButton);
	      _GameStore2.default.set('gamePrediction', true);
	      banner.visible = false;
	      getReadyText.visible = true;
	      _this.countdown(getReadyText);
	      setTimeout(function () {
	        _this.eatCake(cake, leftButton, rightButton);
	      }, 6000);
	      setTimeout(function () {
	        _this.gameOutcome(gameWin, gameLoss);
	      }, 12000);
	    });
	
	    rightButton.set('texture', rightButtonTextureOver);
	    rightButton.anchor.set(.5);
	    rightButton.x = positionX + 650;
	    rightButton.y = positionY + 325;
	    rightButton.anchor.x = .5;
	    rightButton.anchor.y = .33;
	    rightButton.scale.x = 1.5;
	    rightButton.scale.y = 1.5;
	    rightButton.addInteractivityToButtons();
	    rightButton.addButtonEvents();
	    rightButton.on('click', function () {
	      _this.buttonUpdates(leftButton, rightButton);
	      _GameStore2.default.set('gamePrediction', false);
	      banner.visible = false;
	      getReadyText.visible = true;
	      _this.countdown(getReadyText);
	      setTimeout(function () {
	        _this.eatCake(cake, leftButton, rightButton);
	      }, 6000);
	      setTimeout(function () {
	        _this.gameOutcome(gameWin, gameLoss);
	      }, 12000);
	    });
	
	    _this.addChild(banner, cake, leftButton, rightButton, getReadyText, gameWin, gameLoss);
	    return _this;
	  }
	
	  _createClass(Bet, [{
	    key: 'buttonUpdates',
	    value: function buttonUpdates(buttonX, buttonY) {
	      buttonX.texture = leftButtonTexture;
	      buttonY.texture = rightButtonTexture;
	      buttonX.removeInteractivityToButtons();
	      buttonY.removeInteractivityToButtons();
	    }
	  }, {
	    key: 'countdown',
	    value: function countdown(countdownText) {
	      var counter = 3;
	      var ticker = _pixi2.default.ticker.shared;
	      ticker.add(function () {
	        counter -= 0.01;
	
	        if (counter > 2) {
	          countdownText.text = 'Ready\n';
	        } else if (counter > 1) {
	          countdownText.text = 'Ready\nSet\n';
	        } else if (counter > 0) {
	          countdownText.text = 'Ready\nSet\nGO!';
	        } else {
	          countdownText.visible = false;
	        }
	      });
	    }
	  }, {
	    key: 'eatCake',
	    value: function eatCake(cakeTexture, leftButtonTexture, rightButtonTexture) {
	      var cakeTexture1 = _pixi2.default.Texture.fromImage(_cake4.default);
	      var cakeTexture3 = _pixi2.default.Texture.fromImage(_cake6.default);
	      var cakeTexture4 = _pixi2.default.Texture.fromImage(_cake8.default);
	      var cakeTexture5 = _pixi2.default.Texture.fromImage(_cake10.default);
	      var rightLadyFat1 = _pixi2.default.Texture.fromImage(_rightLady4.default);
	      var rightLadyFat2 = _pixi2.default.Texture.fromImage(_rightLady6.default);
	      var rightLadyFat3 = _pixi2.default.Texture.fromImage(_rightLady8.default);
	      var rightLadyFat4 = _pixi2.default.Texture.fromImage(_rightLady10.default);
	      var leftLadyFat1 = _pixi2.default.Texture.fromImage(_leftLady4.default);
	      var leftLadyFat2 = _pixi2.default.Texture.fromImage(_leftLady6.default);
	      var leftLadyFat3 = _pixi2.default.Texture.fromImage(_leftLady8.default);
	      var leftLadyFat4 = _pixi2.default.Texture.fromImage(_leftLady10.default);
	
	      var counter = 3;
	      var ticker = _pixi2.default.ticker.shared;
	      ticker.add(function () {
	        counter -= 0.01;
	
	        if (counter > 2) {
	          cakeTexture.texture = cakeTexture1;
	          if (_GameStore2.default.get('gameOutcome') === true) {
	            leftButtonTexture.texture = leftLadyFat1;
	          } else {
	            rightButtonTexture.texture = rightLadyFat1;
	          }
	        } else if (counter > 1) {
	          cakeTexture.texture = cakeTexture3;
	          if (_GameStore2.default.get('gameOutcome') === true) {
	            leftButtonTexture.texture = leftLadyFat2;
	          } else {
	            rightButtonTexture.texture = rightLadyFat2;
	          }
	        } else if (counter > 0) {
	          cakeTexture.texture = cakeTexture4;
	          if (_GameStore2.default.get('gameOutcome') === true) {
	            leftButtonTexture.texture = leftLadyFat3;
	          } else {
	            rightButtonTexture.texture = rightLadyFat3;
	          }
	        } else {
	          cakeTexture.texture = cakeTexture5;
	          if (_GameStore2.default.get('gameOutcome') === true) {
	            leftButtonTexture.texture = leftLadyFat4;
	          } else {
	            rightButtonTexture.texture = rightLadyFat4;
	          }
	        }
	      });
	    }
	  }, {
	    key: 'gameOutcome',
	    value: function gameOutcome(win, loss) {
	      if (_GameStore2.default.isWinner() === true) {
	        win.visible = true;
	      } else {
	        loss.visible = true;
	      }
	    }
	  }]);
	
	  return Bet;
	}(_pixi2.default.Sprite);
	
	exports.default = Bet;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _pixi = __webpack_require__(7);
	
	var _package = __webpack_require__(3);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Banner = function (_PIXI$Sprite) {
	  _inherits(Banner, _PIXI$Sprite);
	
	  function Banner() {
	    _classCallCheck(this, Banner);
	
	    var _this = _possibleConstructorReturn(this, (Banner.__proto__ || Object.getPrototypeOf(Banner)).call(this));
	
	    var positionX = _package.config.stageWidth / 3.5;
	    var positionY = _package.config.stageHeight / 5;
	
	    var textContainer = new PIXI.Graphics();
	
	    var text = new _pixi.Text('Who\'s going to eat all the cake?\nPick your winner', {
	      fontFamily: 'Hevetica',
	      fontSize: 96,
	      fill: '#cc00ff',
	      align: 'center',
	      stroke: '#FFFFFF'
	    });
	
	    textContainer.beginFill(0x000000);
	    textContainer.lineStyle(2, 0xFFFFFF);
	    textContainer.drawRect(positionX + 110, positionY, 635, 115);
	    textContainer.alpha = .5;
	
	    text.position.x = positionX - -127;
	    text.position.y = positionY - -10;
	    text.scale.x = 1.5;
	    text.scale.y = 1.5;
	
	    _this.addChild(textContainer, text);
	    return _this;
	  }
	
	  return Banner;
	}(PIXI.Sprite);
	
	exports.default = Banner;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _pixi = __webpack_require__(7);
	
	var _pixi2 = _interopRequireDefault(_pixi);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Button = function (_PIXI$Sprite) {
	  _inherits(Button, _PIXI$Sprite);
	
	  function Button() {
	    var _ref;
	
	    _classCallCheck(this, Button);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = _possibleConstructorReturn(this, (_ref = Button.__proto__ || Object.getPrototypeOf(Button)).call.apply(_ref, [this].concat(args)));
	
	    _this.data = {
	      texture: 0,
	      textureNormal: 0
	    };
	
	    new _pixi2.default.Sprite(_this.data.textureNormal);
	    return _this;
	  }
	
	  _createClass(Button, [{
	    key: 'get',
	    value: function get(key) {
	      return this.data[key];
	    }
	  }, {
	    key: 'set',
	    value: function set(key, value) {
	      return this.data[key] = value;
	    }
	  }, {
	    key: 'setTexture',
	    value: function setTexture(texture) {
	      this.set('textureNormal', texture);
	    }
	  }, {
	    key: 'addInteractivityToButtons',
	    value: function addInteractivityToButtons() {
	      this.buttonMode = true;
	      this.interactive = true;
	    }
	  }, {
	    key: 'removeInteractivityToButtons',
	    value: function removeInteractivityToButtons() {
	      this.buttonMode = false;
	      this.interactive = false;
	    }
	  }, {
	    key: 'addButtonEvents',
	    value: function addButtonEvents() {
	      this.on('touchstart', this.onButtonDown).on('touchend', this.onButtonUp).on('touchendoutside', this.onButtonUp).on('mousedown', this.onButtonDown).on('mouseup', this.onButtonUp).on('mouseupoutside', this.onButtonUp).on('mouseover', this.onButtonOver).on('mouseout', this.onButtonOut);
	    }
	  }, {
	    key: 'onButtonDown',
	    value: function onButtonDown() {
	      this.isdown = true;
	      this.texture = this.data.texture;
	      this.alpha = 1;
	    }
	  }, {
	    key: 'onButtonUp',
	    value: function onButtonUp() {
	      this.isdown = false;
	      if (this.isOver) {
	        if (this.leftButton) {
	          this.texture = this.data.texture;
	        } else {
	          this.texture = this.data.texture;
	        }
	      } else {
	        this.texture = this.data.textureNormal;
	      }
	    }
	  }, {
	    key: 'onButtonOver',
	    value: function onButtonOver() {
	      this.isOver = true;
	      if (this.isdown) {
	        return;
	      }
	      this.texture = this.data.texture;
	    }
	  }, {
	    key: 'onButtonOut',
	    value: function onButtonOut() {
	      this.isOver = false;
	      if (this.isdown) {
	        return;
	      }
	      this.texture = this.data.texture;
	    }
	  }]);
	
	  return Button;
	}(_pixi2.default.Sprite);
	
	exports.default = Button;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _events = __webpack_require__(141);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _GameConstants = __webpack_require__(142);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var GameStore = function (_EventEmitter) {
	  _inherits(GameStore, _EventEmitter);
	
	  function GameStore() {
	    var _ref;
	
	    _classCallCheck(this, GameStore);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = _possibleConstructorReturn(this, (_ref = GameStore.__proto__ || Object.getPrototypeOf(GameStore)).call.apply(_ref, [this].concat(args)));
	
	    _this.data = {
	      gameOutcome: true,
	      gamePrediction: true,
	      winAmount: 0
	    };
	    return _this;
	  }
	
	  _createClass(GameStore, [{
	    key: 'get',
	    value: function get(key) {
	      return this.data[key];
	    }
	  }, {
	    key: 'set',
	    value: function set(key, value) {
	      return this.data[key] = value;
	    }
	  }, {
	    key: 'setGameOutcome',
	    value: function setGameOutcome() {
	      return this.data.gameOutcome = Math.random() >= 0.5;
	    }
	  }, {
	    key: 'emitChange',
	    value: function emitChange() {
	      this.emit(_GameConstants.BET_MADE, this.data);
	    }
	  }, {
	    key: 'addChangeListener',
	    value: function addChangeListener(callback) {
	      this.on(_GameConstants.BET_MADE, callback, this.data);
	    }
	  }, {
	    key: 'isWinner',
	    value: function isWinner() {
	      var winner = false;
	      if (this.data.gameOutcome === this.data.gamePrediction) {
	        winner = true;
	      }
	      return winner;
	    }
	  }]);
	
	  return GameStore;
	}(_events2.default);
	
	exports.default = new GameStore();

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _pixi = __webpack_require__(7);
	
	var _pixi2 = _interopRequireDefault(_pixi);
	
	var _package = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var WinningOutcome = function (_PIXI$Sprite) {
	  _inherits(WinningOutcome, _PIXI$Sprite);
	
	  function WinningOutcome() {
	    _classCallCheck(this, WinningOutcome);
	
	    var _this = _possibleConstructorReturn(this, (WinningOutcome.__proto__ || Object.getPrototypeOf(WinningOutcome)).call(this));
	
	    var positionX = _package.config.stageWidth / 3.5;
	    var positionY = _package.config.stageHeight / 5;
	
	    var text = new _pixi2.default.Text('Congratulations\n YOU\'VE\n WON', {
	      fontFamily: 'Hevetica',
	      fontSize: 96,
	      fill: '#cc00ff',
	      align: 'center',
	      stroke: '#000',
	      strokeThickness: 3
	    });
	
	    text.position.x = positionX - -270;
	    text.position.y = positionY - -20;
	    text.scale.x = 1.5;
	    text.scale.y = 1.5;
	
	    _this.addChild(text);
	
	    return _this;
	  }
	
	  return WinningOutcome;
	}(_pixi2.default.Sprite);
	
	exports.default = WinningOutcome;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _pixi = __webpack_require__(7);
	
	var _package = __webpack_require__(3);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LosingOutcome = function (_PIXI$Sprite) {
	  _inherits(LosingOutcome, _PIXI$Sprite);
	
	  function LosingOutcome() {
	    _classCallCheck(this, LosingOutcome);
	
	    var _this = _possibleConstructorReturn(this, (LosingOutcome.__proto__ || Object.getPrototypeOf(LosingOutcome)).call(this));
	
	    var positionX = _package.config.stageWidth / 3.5;
	    var positionY = _package.config.stageHeight / 5;
	
	    var text = new _pixi.Text('Sorry\n Dude...\n You\'ve lost', {
	      fontFamily: 'Helvetica',
	      fontSize: 96,
	      fill: '#cc00ff',
	      align: 'center',
	      stroke: '#000',
	      strokeThickness: 3
	    });
	
	    text.position.x = positionX - -300;
	    text.position.y = positionY - -20;
	    text.scale.x = 1.5;
	    text.scale.y = 1.5;
	
	    _this.addChild(text);
	    return _this;
	  }
	
	  return LosingOutcome;
	}(PIXI.Sprite);
	
	exports.default = LosingOutcome;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/cake.png";

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/cake1.png";

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/cake3.png";

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/cake4.png";

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/cake6.png";

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/leftLady.png";

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/rightLady.png";

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/leftLadyOver.png";

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/rightLadyOver.png";

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/leftLady1.png";

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/leftLady2.png";

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/leftLady3.png";

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/leftLady4.png";

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/rightLady1.png";

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/rightLady2.png";

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/rightLady3.png";

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "displayobjects/images/rightLady4.png";

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMTA0M2I0ZTQyMzM3NzFkZmY2NGUiLCJ3ZWJwYWNrOi8vLy4vYXBwLmpzIiwid2VicGFjazovLy8uL2luZGV4Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4uL3BhY2thZ2UuanNvbiIsIndlYnBhY2s6Ly8vLi91dGlscy9mcHMvZnJhbWVzQ291bnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdGF0cy1qcy9idWlsZC9zdGF0cy5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vUmVuZGVyZXIvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvcG9seWZpbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvcG9seWZpbGwvT2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL3BvbHlmaWxsL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9wb2x5ZmlsbC9NYXRoLnNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL2NvbnN0LmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9tYXRoL01hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvR3JvdXBEOC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL0VsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9tYXRoL3NoYXBlcy9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvbWF0aC9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS91dGlscy9wbHVnaW5UYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYXN5bmMvbGliL2FzeW5jLmpzIiwid2VicGFjazovLy8uLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS90aWNrZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS90aWNrZXIvVGlja2VyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvZGlzcGxheS9EaXNwbGF5T2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvdGV4dHVyZXMvUmVuZGVyVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3RleHR1cmVzL0Jhc2VUZXh0dXJlLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3RleHR1cmVzL1ZpZGVvQmFzZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS90ZXh0dXJlcy9UZXh0dXJlVXZzLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9TdGVuY2lsTWFza1N0YWNrLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL0ZpbHRlck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvV2ViR0xNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL2Rpc3BsYXkvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvc3ByaXRlcy9TcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc1RpbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy9QYXJ0aWNsZUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy9TeXN0ZW1SZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9TaGFkZXJNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvVGV4dHVyZVNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9zaGFkZXJzL1NoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9zaGFkZXJzL0NvbXBsZXhQcmltaXRpdmVTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9QcmltaXRpdmVTaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvTWFza01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9TcHJpdGVNYXNrRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvQWJzdHJhY3RGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvU3RlbmNpbE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvQmxlbmRNb2RlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0ZYQUFGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9wYXJ0aWNsZXMvd2ViZ2wvUGFydGljbGVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZVNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3RleHQvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNHcmFwaGljcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9ncmFwaGljcy93ZWJnbC9XZWJHTEdyYXBoaWNzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc01hc2tNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2V4dHJhcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9leHRyYXMvY2FjaGVBc0JpdG1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9leHRyYXMvZ2V0Q2hpbGRCeU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZXh0cmFzL2dldEdsb2JhbFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2V4dHJhcy9Nb3ZpZUNsaXAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZXh0cmFzL1RpbGluZ1Nwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9leHRyYXMvQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvYXNjaWkvQXNjaWlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9ibG9vbS9CbG9vbUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2JsdXIvQmx1clhGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9ibHVyL0JsdXJZRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvYmx1ci9CbHVyRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvYmx1ci9CbHVyRGlyRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvY29sb3IvQ29sb3JNYXRyaXhGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9jb2xvci9Db2xvclN0ZXBGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9jb252b2x1dGlvbi9Db252b2x1dGlvbkZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2Nyb3NzaGF0Y2gvQ3Jvc3NIYXRjaEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2Rpc3BsYWNlbWVudC9EaXNwbGFjZW1lbnRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9kb3QvRG90U2NyZWVuRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvZ3JheS9HcmF5RmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvZHJvcHNoYWRvdy9Ecm9wU2hhZG93RmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvZHJvcHNoYWRvdy9CbHVyWVRpbnRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9pbnZlcnQvSW52ZXJ0RmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvbm9pc2UvTm9pc2VGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9waXhlbGF0ZS9QaXhlbGF0ZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL3JnYi9SR0JTcGxpdEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL3Nob2Nrd2F2ZS9TaG9ja3dhdmVGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9zZXBpYS9TZXBpYUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2JsdXIvU21hcnRCbHVyRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvdGlsdHNoaWZ0L1RpbHRTaGlmdEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL3RpbHRzaGlmdC9UaWx0U2hpZnRYRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvdGlsdHNoaWZ0L1RpbHRTaGlmdEF4aXNGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy90aWx0c2hpZnQvVGlsdFNoaWZ0WUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL3R3aXN0L1R3aXN0RmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ludGVyYWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvaW50ZXJhY3Rpb24vaW50ZXJhY3RpdmVUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvbG9hZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9sb2FkZXJzL2xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZXNvdXJjZS1sb2FkZXIvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3Jlc291cmNlLWxvYWRlci9zcmMvTG9hZGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BhcnNlLXVyaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZXNvdXJjZS1sb2FkZXIvc3JjL2FzeW5jLmpzIiwid2VicGFjazovLy8uLi9+L3Jlc291cmNlLWxvYWRlci9zcmMvUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVzb3VyY2UtbG9hZGVyL34vZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZXNvdXJjZS1sb2FkZXIvc3JjL21pZGRsZXdhcmVzL2NhY2hpbmcvbWVtb3J5LmpzIiwid2VicGFjazovLy8uLi9+L3Jlc291cmNlLWxvYWRlci9zcmMvbWlkZGxld2FyZXMvcGFyc2luZy9ibG9iLmpzIiwid2VicGFjazovLy8uLi9+L3Jlc291cmNlLWxvYWRlci9zcmMvYjY0LmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2xvYWRlcnMvdGV4dHVyZVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9sb2FkZXJzL3Nwcml0ZXNoZWV0UGFyc2VyLmpzIiwid2VicGFjazovLy8uLi9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9sb2FkZXJzL2JpdG1hcEZvbnRQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvbWVzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9tZXNoL01lc2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvbWVzaC9QbGFuZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9waXhpLmpzL3NyYy9tZXNoL1JvcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvbWVzaC93ZWJnbC9NZXNoUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvbWVzaC93ZWJnbC9NZXNoU2hhZGVyLmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2FjY2Vzc2liaWxpdHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvYWNjZXNzaWJpbGl0eS9hY2Nlc3NpYmxlVGFyZ2V0LmpzIiwid2VicGFjazovLy8uLi9+L3BpeGkuanMvc3JjL2FjY2Vzc2liaWxpdHkvQWNjZXNzaWJpbGl0eU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGl4aS5qcy9zcmMvZGVwcmVjYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3RvcmVzL1JlbmRlcmVyU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9jb25zdGFudHMvR2FtZUNvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9kaXNwbGF5b2JqZWN0cy9BcHAvQXBwLmpzIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL1NjYWxlZENvbnRhaW5lci9TY2FsZWRDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvQmFja2dyb3VuZC9CYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9raXRjaGVuLnBuZyIsIndlYnBhY2s6Ly8vLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvdGFibGUucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL0dhbWUvR2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9kaXNwbGF5b2JqZWN0cy9HYW1lL0Jhbm5lci5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9idXR0b24vQnV0dG9uLmpzIiwid2VicGFjazovLy8uL3N0b3Jlcy9HYW1lU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvT3V0Y29tZS9XaW4uanMiLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvT3V0Y29tZS9Mb3NlLmpzIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9jYWtlLnBuZyIsIndlYnBhY2s6Ly8vLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvY2FrZTEucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9jYWtlMy5wbmciLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL2Nha2U0LnBuZyIsIndlYnBhY2s6Ly8vLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvY2FrZTYucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeS5wbmciLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL3JpZ2h0TGFkeS5wbmciLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL2xlZnRMYWR5T3Zlci5wbmciLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL3JpZ2h0TGFkeU92ZXIucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTEucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTIucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTMucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTQucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9yaWdodExhZHkxLnBuZyIsIndlYnBhY2s6Ly8vLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvcmlnaHRMYWR5Mi5wbmciLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL3JpZ2h0TGFkeTMucG5nIiwid2VicGFjazovLy8uL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9yaWdodExhZHk0LnBuZyJdLCJuYW1lcyI6WyJyZW5kZXJlciIsInN0YWdlV2lkdGgiLCJzdGFnZUhlaWdodCIsImFwcCIsImRvY3VtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwidmlldyIsInNldCIsInNldEdhbWVPdXRjb21lIiwiYWRkUmVuZGVyYWJsZSIsInN0YXJ0IiwiZnJhbWVzQ291bnRlciIsInN0YXRzIiwic2V0TW9kZSIsImRvbUVsZW1lbnQiLCJzdHlsZSIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsInNldEludGVydmFsIiwiYmVnaW4iLCJlbmQiLCJyZW5kZXJhYmxlcyIsIlNldCIsIlJlbmRlcmVyIiwiYXJncyIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNpemVIYW5kbGVyIiwiYmluZCIsInJlc29sdXRpb24iLCJQb2ludCIsInNldFN0b3JlIiwiZ2V0V2luZG93U2l6ZSIsInJlc2l6ZSIsImVtaXRDaGFuZ2UiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsImFjdGl2ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGUiLCJyZW5kZXJSZW5kZXJhYmxlcyIsInJlbmRlcmFibGUiLCJhZGQiLCJoYXNSZW5kZXJhYmxlIiwiaGFzIiwiZGVsZXRlIiwiZW50cnkiLCJyZW5kZXIiLCJXZWJHTFJlbmRlcmVyIiwiUmVuZGVyZXJTdG9yZSIsImRhdGEiLCJzdGFnZUNlbnRlciIsIngiLCJ5Iiwia2V5IiwidmFsdWUiLCJlbWl0IiwiY2FsbGJhY2siLCJvbiIsImNvbnN0YW50cyIsIlJFU0laRSIsIkFOSU1BVEUiLCJCRVRfTUFERSIsIkFwcCIsImJnIiwiZ2FtZSIsImFkZENoaWxkIiwidHciLCJ0aCIsIlNjYWxlZENvbnRhaW5lciIsInRhcmdldF93IiwidGFyZ2V0X2giLCJnZXQiLCJhZGRDaGFuZ2VMaXN0ZW5lciIsInJ3IiwicmgiLCJYcmF0aW8iLCJZcmF0aW8iLCJzY2FsZVJhdGlvIiwic2NhbGUiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIkNvbnRhaW5lciIsIkJhY2tncm91bmQiLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJTcHJpdGUiLCJmcm9tSW1hZ2UiLCJ0YWJsZSIsImFuY2hvciIsImFscGhhIiwiYmx1ckZpbHRlciIsImZpbHRlcnMiLCJCbHVyRmlsdGVyIiwiYmx1ciIsImxlZnRCdXR0b25UZXh0dXJlIiwiVGV4dHVyZSIsInJpZ2h0QnV0dG9uVGV4dHVyZSIsIkJldCIsImNha2VUZXh0dXJlIiwibGVmdEJ1dHRvblRleHR1cmVPdmVyIiwicmlnaHRCdXR0b25UZXh0dXJlT3ZlciIsImJhbm5lciIsImNha2UiLCJsZWZ0QnV0dG9uIiwicmlnaHRCdXR0b24iLCJnYW1lV2luIiwiZ2FtZUxvc3MiLCJnZXRSZWFkeVRleHQiLCJUZXh0IiwiZm9udFdlaWdodCIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImZpbGwiLCJhbGlnbiIsInN0cm9rZSIsInN0cm9rZVRoaWNrbmVzcyIsInZpc2libGUiLCJhZGRJbnRlcmFjdGl2aXR5VG9CdXR0b25zIiwiYWRkQnV0dG9uRXZlbnRzIiwiYnV0dG9uVXBkYXRlcyIsImNvdW50ZG93biIsInNldFRpbWVvdXQiLCJlYXRDYWtlIiwiZ2FtZU91dGNvbWUiLCJidXR0b25YIiwiYnV0dG9uWSIsInRleHR1cmUiLCJyZW1vdmVJbnRlcmFjdGl2aXR5VG9CdXR0b25zIiwiY291bnRkb3duVGV4dCIsImNvdW50ZXIiLCJ0aWNrZXIiLCJzaGFyZWQiLCJ0ZXh0IiwiY2FrZVRleHR1cmUxIiwiY2FrZVRleHR1cmUzIiwiY2FrZVRleHR1cmU0IiwiY2FrZVRleHR1cmU1IiwicmlnaHRMYWR5RmF0MSIsInJpZ2h0TGFkeUZhdDIiLCJyaWdodExhZHlGYXQzIiwicmlnaHRMYWR5RmF0NCIsImxlZnRMYWR5RmF0MSIsImxlZnRMYWR5RmF0MiIsImxlZnRMYWR5RmF0MyIsImxlZnRMYWR5RmF0NCIsIndpbiIsImxvc3MiLCJpc1dpbm5lciIsIkJhbm5lciIsInRleHRDb250YWluZXIiLCJQSVhJIiwiR3JhcGhpY3MiLCJiZWdpbkZpbGwiLCJsaW5lU3R5bGUiLCJkcmF3UmVjdCIsIkJ1dHRvbiIsInRleHR1cmVOb3JtYWwiLCJidXR0b25Nb2RlIiwiaW50ZXJhY3RpdmUiLCJvbkJ1dHRvbkRvd24iLCJvbkJ1dHRvblVwIiwib25CdXR0b25PdmVyIiwib25CdXR0b25PdXQiLCJpc2Rvd24iLCJpc092ZXIiLCJHYW1lU3RvcmUiLCJnYW1lUHJlZGljdGlvbiIsIndpbkFtb3VudCIsIk1hdGgiLCJyYW5kb20iLCJ3aW5uZXIiLCJXaW5uaW5nT3V0Y29tZSIsIkxvc2luZ091dGNvbWUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdENBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxLQUFNQSxXQUFXLHVCQUFhLGdCQUFPQyxVQUFwQixFQUFnQyxnQkFBT0MsV0FBdkMsQ0FBakI7QUFDQSxLQUFNQyxNQUFNLGtCQUFRLGdCQUFPRixVQUFmLEVBQTJCLGdCQUFPQyxXQUFsQyxDQUFaOztBQUVBRSxVQUFTQyxJQUFULENBQWNDLFdBQWQsQ0FBMEJOLFNBQVNPLElBQW5DOztBQUVBLHFCQUFVQyxHQUFWLENBQWMsYUFBZCxFQUE2QixvQkFBVUMsY0FBVixFQUE3Qjs7QUFFQVQsVUFBU1UsYUFBVCxDQUF1QlAsR0FBdkI7QUFDQUgsVUFBU1csS0FBVDtBQUNBLGdDOzs7Ozs7QUNoQkEsdUQ7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7Ozs7OzttQkM1Q3dCQyxhOztBQUZ4Qjs7Ozs7O0FBRWUsVUFBU0EsYUFBVCxHQUF5QjtBQUN0QyxPQUFNQyxRQUFRLHVCQUFkO0FBQ0FBLFNBQU1DLE9BQU4sQ0FBYyxDQUFkOztBQUVBRCxTQUFNRSxVQUFOLENBQWlCQyxLQUFqQixDQUF1QkMsUUFBdkIsR0FBa0MsVUFBbEM7QUFDQUosU0FBTUUsVUFBTixDQUFpQkMsS0FBakIsQ0FBdUJFLElBQXZCLEdBQThCLEtBQTlCO0FBQ0FMLFNBQU1FLFVBQU4sQ0FBaUJDLEtBQWpCLENBQXVCRyxHQUF2QixHQUE2QixLQUE3Qjs7QUFFQWYsWUFBU0MsSUFBVCxDQUFjQyxXQUFkLENBQTJCTyxNQUFNRSxVQUFqQzs7QUFFQUssZUFBYSxZQUFNO0FBQ2ZQLFdBQU1RLEtBQU47QUFDQVIsV0FBTVMsR0FBTjtBQUVILElBSkQsRUFJRyxPQUFPLEVBSlY7QUFLRCxFOzs7Ozs7QUNqQkQ7QUFDQSxzQkFBcUIsbUdBQW1HLGFBQWEsMkNBQTJDLG1CQUFtQixTQUFTLEtBQUssNEJBQTRCLFlBQVksZ0JBQWdCLG9DQUFvQyxXQUFXLHFDQUFxQyxnQkFBZ0IsdUJBQXVCLGlCQUFpQixvQ0FBb0MsZUFBZSw0QkFBNEIsdUNBQXVDLGNBQWMsaUJBQWlCO0FBQzFpQixtQkFBa0IsaUJBQWlCLG9DQUFvQyxnQkFBZ0IsbUNBQW1DLFdBQVcsWUFBWSx1QkFBdUIscUJBQXFCLHFCQUFxQixFQUFFLHFDQUFxQywyQkFBMkIsWUFBWSxXQUFXLHVCQUF1QixpQkFBaUIsb0NBQW9DLFVBQVUscUNBQXFDLGdCQUFnQixzQkFBc0IsY0FBYyxpQkFBaUI7QUFDM2UsZUFBYyw0QkFBNEIsdUNBQXVDLGNBQWMsaUJBQWlCLGtCQUFrQixpQkFBaUIsaUJBQWlCLG9DQUFvQyxlQUFlLG1DQUFtQyxXQUFXLFlBQVksdUJBQXVCLHFCQUFxQixxQkFBcUIsNkRBQTZELFlBQVksV0FBVyx3Q0FBd0Msa0JBQWtCLElBQUksVUFBVTtBQUM5ZSxTQUFRLHVCQUF1QixNQUFNLHdEQUF3RCxPQUFPLG9EQUFvRCxhQUFhLGdCQUFnQixpQkFBaUIsTUFBTSxnQkFBZ0IsZ0JBQWdCLG9DQUFvQyxpQ0FBaUMsZ0RBQWdELElBQUk7QUFDclcsaUJBQWdCLFNBQVMsbUJBQW1CLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7O0FDTDVEOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUEsS0FBSUMsY0FBYyxJQUFJQyxHQUFKLEVBQWxCOztLQUVxQkMsUTs7O0FBRW5CLHVCQUFxQjtBQUFBOztBQUFBOztBQUFBLHVDQUFOQyxJQUFNO0FBQU5BLFdBQU07QUFBQTs7QUFBQSxnSkFFVkEsSUFGVTs7QUFJbkJDLFlBQU9DLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLE1BQUtDLGFBQUwsQ0FBbUJDLElBQW5CLE9BQWxDOztBQUVBLDZCQUFjdEIsR0FBZCxDQUFrQixZQUFsQixFQUFnQyxNQUFLdUIsVUFBckM7QUFDQSw2QkFBY3ZCLEdBQWQsQ0FBa0IsWUFBbEIsRUFBZ0NrQixLQUFLLENBQUwsQ0FBaEM7QUFDQSw2QkFBY2xCLEdBQWQsQ0FBa0IsYUFBbEIsRUFBaUNrQixLQUFLLENBQUwsQ0FBakM7QUFDQSw2QkFBY2xCLEdBQWQsQ0FBa0IsYUFBbEIsRUFBaUMsSUFBSSxlQUFLd0IsS0FBVCxDQUFlTixLQUFLLENBQUwsSUFBVSxDQUF6QixFQUE0QkEsS0FBSyxDQUFMLElBQVUsQ0FBdEMsQ0FBakM7O0FBRUEsV0FBS08sUUFBTDs7QUFFQSxXQUFLSixhQUFMO0FBYm1CO0FBY3BCOzs7O2dDQUVVO0FBQ1QsK0JBQWNyQixHQUFkLENBQWtCLE9BQWxCLEVBQTJCLEtBQUswQixhQUFMLEdBQXFCLENBQXJCLENBQTNCO0FBQ0EsK0JBQWMxQixHQUFkLENBQWtCLFFBQWxCLEVBQTRCLEtBQUswQixhQUFMLEdBQXFCLENBQXJCLENBQTVCO0FBQ0Q7OztxQ0FFZTtBQUNkLFlBQUtDLE1BQUwsZ0NBQWUsS0FBS0QsYUFBTCxFQUFmO0FBQ0EsWUFBS0QsUUFBTDtBQUNBLCtCQUFjRyxVQUFkO0FBQ0Q7OztxQ0FFZTtBQUNkLFdBQUlDLFFBQVFWLE9BQU9XLFVBQW5CO0FBQ0EsV0FBSUMsU0FBU1osT0FBT2EsV0FBcEI7O0FBRUEsY0FBTyxDQUFDSCxLQUFELEVBQVFFLE1BQVIsQ0FBUDtBQUNEOzs7NkJBRU87QUFDTixZQUFLRSxNQUFMLEdBQWMsSUFBZDtBQUNBZCxjQUFPZSxxQkFBUCxDQUE2QixLQUFLQyxPQUFMLENBQWFiLElBQWIsQ0FBa0IsSUFBbEIsQ0FBN0I7QUFDRDs7OzRCQUVNO0FBQ0wsWUFBS1csTUFBTCxHQUFjLEtBQWQ7QUFDRDs7OytCQUVTO0FBQ1IsWUFBS0csaUJBQUw7O0FBRUEsV0FBRyxLQUFLSCxNQUFSLEVBQWdCO0FBQ2RkLGdCQUFPZSxxQkFBUCxDQUE2QixLQUFLQyxPQUFMLENBQWFiLElBQWIsQ0FBa0IsSUFBbEIsQ0FBN0I7QUFDRDtBQUNGOzs7bUNBRWFlLFUsRUFBWTtBQUN4QixjQUFPdEIsWUFBWXVCLEdBQVosQ0FBZ0JELFVBQWhCLENBQVA7QUFDRDs7O3NDQUVnQkEsVSxFQUFZO0FBQzNCLFdBQUlFLGdCQUFnQnhCLFlBQVl5QixHQUFaLENBQWdCSCxVQUFoQixDQUFwQjs7QUFFQSxXQUFHRSxhQUFILEVBQWtCO0FBQ2hCeEIscUJBQVkwQixNQUFaLENBQW1CSixVQUFuQjtBQUNEOztBQUVELGNBQU9FLGFBQVA7QUFDRDs7O3lDQUVtQjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNsQiw4QkFBa0J4QixXQUFsQiw4SEFBK0I7QUFBQSxlQUF0QjJCLEtBQXNCOztBQUM3QixnQkFBS0MsTUFBTCxDQUFZRCxLQUFaO0FBQ0Q7QUFIaUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUluQjs7OztHQXZFbUMsZUFBS0UsYTs7bUJBQXRCM0IsUTs7Ozs7O0FDTHJCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsbUNBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0Isc0JBQXNCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWMscURBQXFEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsT0FBTztBQUNoQywyQkFBMEIsT0FBTztBQUNqQywwQkFBeUIsT0FBTztBQUNoQywrQkFBOEIsa0JBQWtCO0FBQ2hELDRDQUEyQyxRQUFRO0FBQ25ELDBDQUF5QyxRQUFRO0FBQ2pELHNEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0MsZ0NBQStCLFFBQVE7QUFDdkM7QUFDQSxpQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUM3RkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLHVCQUF1QjtBQUN6RDtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLDZCQUE2QjtBQUNqRTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUE4RCx5QkFBeUI7QUFDdkYsc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSwwQ0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7Ozs7OztBQ2h2Q0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7O0FDekxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVB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QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixXQUFXO0FBQy9CLGFBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LHVCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSx3QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixpQ0FBZ0MsUUFBUTtBQUN4QyxpREFBZ0QsT0FBTyxNQUFNLHVCQUF1QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixzQkFBcUIsT0FBTyxNQUFNLHVCQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixpQkFBaUI7QUFDeEMsb0JBQW1CLGVBQWU7QUFDbEMsbUJBQWtCLGVBQWU7QUFDakMsbUJBQWtCLGVBQWU7QUFDakMscUJBQW9CLE9BQU8sK0RBQStEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsK0JBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLG1CQUFtQjtBQUMvQjtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0Isd0JBQXVCLFFBQVE7QUFDL0Isc0JBQXFCLE9BQU8sTUFBTSx1QkFBdUI7QUFDekQsYUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsYUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixzQkFBcUIsT0FBTyxNQUFNLHVCQUF1QjtBQUN6RCxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixzQkFBcUIsT0FBTyxNQUFNLHVCQUF1QjtBQUN6RCxhQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLHNCQUFxQixPQUFPLE1BQU0sdUJBQXVCO0FBQ3pELGFBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGFBQWE7QUFDaEMsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsYUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pjQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELDBEQUEwRDtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVEseUNBQXlDO0FBQ2pELFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCLHdCQUF1QixPQUFPLE1BQU0sdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsc0JBQXFCLE9BQU8sTUFBTSx1QkFBdUI7QUFDekQsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLGdDQUFnQztBQUNwRCwyQkFBMEIsT0FBTztBQUNqQyw0QkFBMkIsT0FBTztBQUNsQztBQUNBLHNCQUFxQixPQUFPLE1BQU0sdUJBQXVCO0FBQ3pELGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsc0JBQXFCO0FBQ3JCLG1CQUFrQixPQUFPLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLHNCQUFzQjtBQUNwQyxrQkFBaUIsT0FBTztBQUN4QixtQkFBa0IsT0FBTztBQUN6QixzQkFBcUIsT0FBTyxNQUFNLHVCQUF1QjtBQUN6RCx1QkFBc0IsT0FBTztBQUM3QixpQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEIsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7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b0JBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFlBQVk7QUFDOUIsYUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLFdBQVc7QUFDM0IsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEs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O0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFHQUFvRzs7QUFFcEc7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMEMsUUFBUTtB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QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBLHdCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBd0IsY0FBYztBQUN0QztBQUNBLHdCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsWUFBWTtBQUM5QixhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7OztBQ3RyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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RUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsY0FBYztBQUN0QyxzQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQSxrQ0FBaUMsK0JBQStCOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbURBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUEsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RB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Q0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDOUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxrQ0FBa0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDZFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsbUJBQW1COztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsMkJBQTJCO0FBQ3RDLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsOEJBQThCO0FBQ3pDLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0VEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDckJBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRDs7QUFFM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbEVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsMEJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbkVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7Ozs7Ozs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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LHNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLG9EQUFvRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBLG9DQUFtQyxRQUFROztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQiwwQkFBMEI7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFnSDtBQUNoSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBaUg7QUFDakg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTJHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF3RztBQUN4Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBMkc7QUFDM0c7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM1VkE7Ozs7QUFDQTs7Ozs7Ozs7OztLQUVNNEIsYTs7O0FBRUosNEJBQXFCO0FBQUE7O0FBQUE7O0FBQUEsdUNBQU4zQixJQUFNO0FBQU5BLFdBQU07QUFBQTs7QUFBQSwwSkFDVkEsSUFEVTs7QUFHbkIsV0FBSzRCLElBQUwsR0FBWTtBQUNWakIsY0FBTyxDQURHO0FBRVZFLGVBQVEsQ0FGRTtBQUdWdEMsbUJBQVksQ0FIRjtBQUlWQyxvQkFBYSxDQUpIO0FBS1ZxRCxvQkFBYTtBQUNYQyxZQUFHLENBRFE7QUFFWEMsWUFBRztBQUZRLFFBTEg7QUFTVjFCLG1CQUFZO0FBVEYsTUFBWjtBQUhtQjtBQWNwQjs7Ozt5QkFFRzJCLEcsRUFBSztBQUNQLGNBQU8sS0FBS0osSUFBTCxDQUFVSSxHQUFWLENBQVA7QUFDRDs7O3lCQUVHQSxHLEVBQUtDLEssRUFBTztBQUNkLGNBQU8sS0FBS0wsSUFBTCxDQUFVSSxHQUFWLElBQWlCQyxLQUF4QjtBQUNEOzs7a0NBRVk7QUFDWCxZQUFLQyxJQUFMLHdCQUFrQixLQUFLTixJQUF2QjtBQUNEOzs7dUNBRWlCTyxRLEVBQVU7QUFDMUIsWUFBS0MsRUFBTCx3QkFBZ0JELFFBQWhCLEVBQTBCLEtBQUtQLElBQS9CO0FBQ0Q7Ozs7OzttQkFHWSxJQUFJRCxhQUFKLEU7Ozs7OztBQ3RDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFH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Z0Y7Ozs7OztBQ0FBLGlGOzs7Ozs7QUNBQSxpRjs7Ozs7O0FDQUEsaUY7Ozs7OztBQ0FBLGlGIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAxMDQzYjRlNDIzMzc3MWRmZjY0ZSIsImltcG9ydCAnLi9pbmRleC5odG1sJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgZnJhbWVzQ291bnRlciBmcm9tICcuL3V0aWxzL2Zwcy9mcmFtZXNDb3VudGVyJztcbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL1JlbmRlcmVyL1JlbmRlcmVyJztcbmltcG9ydCBBcHAgZnJvbSAnLi9kaXNwbGF5b2JqZWN0cy9BcHAvQXBwJztcbmltcG9ydCBHYW1lU3RvcmUgZnJvbSAnLi9zdG9yZXMvR2FtZVN0b3JlJztcblxuY29uc3QgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoY29uZmlnLnN0YWdlV2lkdGgsIGNvbmZpZy5zdGFnZUhlaWdodCk7XG5jb25zdCBhcHAgPSBuZXcgQXBwKGNvbmZpZy5zdGFnZVdpZHRoLCBjb25maWcuc3RhZ2VIZWlnaHQpO1xuXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlbmRlcmVyLnZpZXcpO1xuXG5HYW1lU3RvcmUuc2V0KCdnYW1lT3V0Y29tZScsIEdhbWVTdG9yZS5zZXRHYW1lT3V0Y29tZSgpKTtcblxucmVuZGVyZXIuYWRkUmVuZGVyYWJsZShhcHApO1xucmVuZGVyZXIuc3RhcnQoKTtcbmZyYW1lc0NvdW50ZXIoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC5qcyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImluZGV4Lmh0bWxcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2luZGV4Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwibmFtZVwiOiBcImZlZWQtbWVcIixcblx0XCJ2ZXJzaW9uXCI6IFwiMS4wLjBcIixcblx0XCJyZXBvc2l0b3J5XCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RhbnlhcG93ZWxsL2ZlZWQtbWVcIixcblx0XCJkZXNjcmlwdGlvblwiOiBcIkdhbWUgYnVpbHQgd2l0aCBQaXhpLmpzLCB3ZWJwYWNrIGFuZCBFUzZcIixcblx0XCJjb25maWdcIjoge1xuXHRcdFwiYnVpbGREaXJcIjogXCIuL2J1aWxkXCIsXG5cdFx0XCJzdGFnZVdpZHRoXCI6IDE5MjAsXG5cdFx0XCJzdGFnZUhlaWdodFwiOiAxMDgwXG5cdH0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJkZXBsb3lcIjogXCJnaC1wYWdlcyAtZCBidWlsZFwiLFxuXHRcdFwicHJlc3RhcnRcIjogXCJucG0gaW5zdGFsbFwiLFxuXHRcdFwic3RhcnRcIjogXCJOT0RFX0VOVj1kZXZlbG9wbWVudCB3ZWJwYWNrLWRldi1zZXJ2ZXIgLS1jb250ZW50LWJhc2UgLi9idWlsZC8gLS1ob3QgLS1pbmxpbmUgLS1ob3N0IDAuMC4wLjBcIixcblx0XHRcIndlYnBhY2tcIjogXCJ3ZWJwYWNrIC1wIC0tY29uZmlnIC4vd2VicGFjay5jb25maWcuanNcIixcblx0XHRcImJ1aWxkXCI6IFwiTk9ERV9FTlY9cHJvZHVjdGlvbiBucG0gcnVuIHdlYnBhY2tcIixcblx0XHRcInByZXdlYnBhY2tcIjogXCJucG0gcnVuIGNsZWFuXCIsXG5cdFx0XCJjbGVhblwiOiBcInJpbXJhZiAkbnBtX3BhY2thZ2VfY29uZmlnX2J1aWxkRGlyICYmIG1rZGlyICRucG1fcGFja2FnZV9jb25maWdfYnVpbGREaXJcIixcblx0XHRcImxpbnRcIjogXCJlc2xpbnQgLi9hcHAvKiovKi5qc1wiLFxuXHRcdFwicmVhY3RtYW5cIjogXCJyZWFjdG1hbiAtLWNvbmZpZyAuL3RlbXBsYXRlcy9yZWFjdG1hbi5jb25maWcuanNcIlxuXHR9LFxuXHRcImRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJwaXhpLmpzXCI6IFwiXjMuMC43XCIsXG5cdFx0XCJzdGF0cy1qc1wiOiBcIl4xLjAuMC1hbHBoYTFcIlxuXHR9LFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJiYWJlbC1jb3JlXCI6IFwiXjYuNy4yXCIsXG5cdFx0XCJiYWJlbC1lc2xpbnRcIjogXCJeNS4wLjBcIixcblx0XHRcImJhYmVsLWxvYWRlclwiOiBcIl42LjIuNFwiLFxuXHRcdFwiYmFiZWwtcHJlc2V0LWVzMjAxNVwiOiBcIl42LjYuMFwiLFxuXHRcdFwiYmFiZWwtcnVudGltZVwiOiBcIl42LjYuMVwiLFxuXHRcdFwiYnJmc1wiOiBcIl4xLjQuM1wiLFxuXHRcdFwiZXNsaW50XCI6IFwiXjIuNC4wXCIsXG5cdFx0XCJmaWxlLWxvYWRlclwiOiBcIl4wLjguNFwiLFxuXHRcdFwiZ2gtcGFnZXNcIjogXCJeMC4xMi4wXCIsXG5cdFx0XCJodG1sLWxvYWRlclwiOiBcIl4wLjQuM1wiLFxuXHRcdFwianNvbi1sb2FkZXJcIjogXCJeMC41LjNcIixcblx0XHRcInJlYWN0bWFuXCI6IFwiXjMuMi4wXCIsXG5cdFx0XCJyaW1yYWZcIjogXCJeMi40LjNcIixcblx0XHRcInRyYW5zZm9ybS1sb2FkZXJcIjogXCJeMC4yLjNcIixcblx0XHRcIndlYnBhY2tcIjogXCJeMS4xMi4yXCIsXG5cdFx0XCJ3ZWJwYWNrLWRldi1zZXJ2ZXJcIjogXCJeMS4xMS4wXCJcblx0fSxcblx0XCJlbmdpbmVzXCI6IHtcblx0XHRcIm5vZGVcIjogXCI+PTUuMC4wXCJcblx0fVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFN0YXRzIGZyb20gJ3N0YXRzLWpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnJhbWVzQ291bnRlcigpIHtcbiAgY29uc3Qgc3RhdHMgPSBuZXcgU3RhdHMoKTtcbiAgc3RhdHMuc2V0TW9kZSgwKTtcblxuICBzdGF0cy5kb21FbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgc3RhdHMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gIHN0YXRzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggc3RhdHMuZG9tRWxlbWVudCApO1xuXG4gIHNldEludGVydmFsKCAoKSA9PiB7XG4gICAgICBzdGF0cy5iZWdpbigpO1xuICAgICAgc3RhdHMuZW5kKCk7XG5cbiAgfSwgMTAwMCAvIDYwICk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi91dGlscy9mcHMvZnJhbWVzQ291bnRlci5qcyIsIi8vIHN0YXRzLmpzIC0gaHR0cDovL2dpdGh1Yi5jb20vbXJkb29iL3N0YXRzLmpzXG52YXIgU3RhdHM9ZnVuY3Rpb24oKXt2YXIgbD1EYXRlLm5vdygpLG09bCxnPTAsbj1JbmZpbml0eSxvPTAsaD0wLHA9SW5maW5pdHkscT0wLHI9MCxzPTAsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2YuaWQ9XCJzdGF0c1wiO2YuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGIpe2IucHJldmVudERlZmF1bHQoKTt0KCsrcyUyKX0sITEpO2Yuc3R5bGUuY3NzVGV4dD1cIndpZHRoOjgwcHg7b3BhY2l0eTowLjk7Y3Vyc29yOnBvaW50ZXJcIjt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2EuaWQ9XCJmcHNcIjthLnN0eWxlLmNzc1RleHQ9XCJwYWRkaW5nOjAgMCAzcHggM3B4O3RleHQtYWxpZ246bGVmdDtiYWNrZ3JvdW5kLWNvbG9yOiMwMDJcIjtmLmFwcGVuZENoaWxkKGEpO3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5pZD1cImZwc1RleHRcIjtpLnN0eWxlLmNzc1RleHQ9XCJjb2xvcjojMGZmO2ZvbnQtZmFtaWx5OkhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZTo5cHg7Zm9udC13ZWlnaHQ6Ym9sZDtsaW5lLWhlaWdodDoxNXB4XCI7XG5pLmlubmVySFRNTD1cIkZQU1wiO2EuYXBwZW5kQ2hpbGQoaSk7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtjLmlkPVwiZnBzR3JhcGhcIjtjLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDo3NHB4O2hlaWdodDozMHB4O2JhY2tncm91bmQtY29sb3I6IzBmZlwiO2ZvcihhLmFwcGVuZENoaWxkKGMpOzc0PmMuY2hpbGRyZW4ubGVuZ3RoOyl7dmFyIGo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7ai5zdHlsZS5jc3NUZXh0PVwid2lkdGg6MXB4O2hlaWdodDozMHB4O2Zsb2F0OmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojMTEzXCI7Yy5hcHBlbmRDaGlsZChqKX12YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2QuaWQ9XCJtc1wiO2Quc3R5bGUuY3NzVGV4dD1cInBhZGRpbmc6MCAwIDNweCAzcHg7dGV4dC1hbGlnbjpsZWZ0O2JhY2tncm91bmQtY29sb3I6IzAyMDtkaXNwbGF5Om5vbmVcIjtmLmFwcGVuZENoaWxkKGQpO3ZhciBrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5rLmlkPVwibXNUZXh0XCI7ay5zdHlsZS5jc3NUZXh0PVwiY29sb3I6IzBmMDtmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6OXB4O2ZvbnQtd2VpZ2h0OmJvbGQ7bGluZS1oZWlnaHQ6MTVweFwiO2suaW5uZXJIVE1MPVwiTVNcIjtkLmFwcGVuZENoaWxkKGspO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5pZD1cIm1zR3JhcGhcIjtlLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDo3NHB4O2hlaWdodDozMHB4O2JhY2tncm91bmQtY29sb3I6IzBmMFwiO2ZvcihkLmFwcGVuZENoaWxkKGUpOzc0PmUuY2hpbGRyZW4ubGVuZ3RoOylqPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLGouc3R5bGUuY3NzVGV4dD1cIndpZHRoOjFweDtoZWlnaHQ6MzBweDtmbG9hdDpsZWZ0O2JhY2tncm91bmQtY29sb3I6IzEzMVwiLGUuYXBwZW5kQ2hpbGQoaik7dmFyIHQ9ZnVuY3Rpb24oYil7cz1iO3N3aXRjaChzKXtjYXNlIDA6YS5zdHlsZS5kaXNwbGF5PVxuXCJibG9ja1wiO2Quc3R5bGUuZGlzcGxheT1cIm5vbmVcIjticmVhaztjYXNlIDE6YS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCJ9fTtyZXR1cm57UkVWSVNJT046MTIsZG9tRWxlbWVudDpmLHNldE1vZGU6dCxiZWdpbjpmdW5jdGlvbigpe2w9RGF0ZS5ub3coKX0sZW5kOmZ1bmN0aW9uKCl7dmFyIGI9RGF0ZS5ub3coKTtnPWItbDtuPU1hdGgubWluKG4sZyk7bz1NYXRoLm1heChvLGcpO2sudGV4dENvbnRlbnQ9ZytcIiBNUyAoXCIrbitcIi1cIitvK1wiKVwiO3ZhciBhPU1hdGgubWluKDMwLDMwLTMwKihnLzIwMCkpO2UuYXBwZW5kQ2hpbGQoZS5maXJzdENoaWxkKS5zdHlsZS5oZWlnaHQ9YStcInB4XCI7cisrO2I+bSsxRTMmJihoPU1hdGgucm91bmQoMUUzKnIvKGItbSkpLHA9TWF0aC5taW4ocCxoKSxxPU1hdGgubWF4KHEsaCksaS50ZXh0Q29udGVudD1oK1wiIEZQUyAoXCIrcCtcIi1cIitxK1wiKVwiLGE9TWF0aC5taW4oMzAsMzAtMzAqKGgvMTAwKSksYy5hcHBlbmRDaGlsZChjLmZpcnN0Q2hpbGQpLnN0eWxlLmhlaWdodD1cbmErXCJweFwiLG09YixyPTApO3JldHVybiBifSx1cGRhdGU6ZnVuY3Rpb24oKXtsPXRoaXMuZW5kKCl9fX07XCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGUmJihtb2R1bGUuZXhwb3J0cz1TdGF0cyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3N0YXRzLWpzL2J1aWxkL3N0YXRzLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUElYSSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCBSZW5kZXJlclN0b3JlIGZyb20gJy4uL3N0b3Jlcy9SZW5kZXJlclN0b3JlJztcblxubGV0IHJlbmRlcmFibGVzID0gbmV3IFNldCgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlciBleHRlbmRzIFBJWEkuV2ViR0xSZW5kZXJlciB7XG5cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuXG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVIYW5kbGVyLmJpbmQodGhpcykpO1xuXG4gICAgUmVuZGVyZXJTdG9yZS5zZXQoJ3Jlc29sdXRpb24nLCB0aGlzLnJlc29sdXRpb24pO1xuICAgIFJlbmRlcmVyU3RvcmUuc2V0KCdzdGFnZVdpZHRoJywgYXJnc1swXSk7XG4gICAgUmVuZGVyZXJTdG9yZS5zZXQoJ3N0YWdlSGVpZ2h0JywgYXJnc1sxXSk7XG4gICAgUmVuZGVyZXJTdG9yZS5zZXQoJ3N0YWdlQ2VudGVyJywgbmV3IFBJWEkuUG9pbnQoYXJnc1swXSAvIDIsIGFyZ3NbMV0gLyAyKSk7XG5cbiAgICB0aGlzLnNldFN0b3JlKCk7XG5cbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXIoKTtcbiAgfVxuXG4gIHNldFN0b3JlKCkge1xuICAgIFJlbmRlcmVyU3RvcmUuc2V0KCd3aWR0aCcsIHRoaXMuZ2V0V2luZG93U2l6ZSgpWzBdKTtcbiAgICBSZW5kZXJlclN0b3JlLnNldCgnaGVpZ2h0JywgdGhpcy5nZXRXaW5kb3dTaXplKClbMV0pO1xuICB9XG5cbiAgcmVzaXplSGFuZGxlcigpIHtcbiAgICB0aGlzLnJlc2l6ZSguLi50aGlzLmdldFdpbmRvd1NpemUoKSk7XG4gICAgdGhpcy5zZXRTdG9yZSgpO1xuICAgIFJlbmRlcmVyU3RvcmUuZW1pdENoYW5nZSgpO1xuICB9XG5cbiAgZ2V0V2luZG93U2l6ZSgpIHtcbiAgICBsZXQgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGFuaW1hdGUoKSB7XG4gICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlcygpO1xuXG4gICAgaWYodGhpcy5hY3RpdmUpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIGFkZFJlbmRlcmFibGUocmVuZGVyYWJsZSkge1xuICAgIHJldHVybiByZW5kZXJhYmxlcy5hZGQocmVuZGVyYWJsZSk7XG4gIH1cblxuICByZW1vdmVSZW5kZXJhYmxlKHJlbmRlcmFibGUpIHtcbiAgICBsZXQgaGFzUmVuZGVyYWJsZSA9IHJlbmRlcmFibGVzLmhhcyhyZW5kZXJhYmxlKTtcblxuICAgIGlmKGhhc1JlbmRlcmFibGUpIHtcbiAgICAgIHJlbmRlcmFibGVzLmRlbGV0ZShyZW5kZXJhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzUmVuZGVyYWJsZTtcbiAgfVxuXG4gIHJlbmRlclJlbmRlcmFibGVzKCkge1xuICAgIGZvciAobGV0IGVudHJ5IG9mIHJlbmRlcmFibGVzKSB7XG4gICAgICB0aGlzLnJlbmRlcihlbnRyeSk7XG4gICAgfVxuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1JlbmRlcmVyL1JlbmRlcmVyLmpzIiwiLy8gcnVuIHRoZSBwb2x5ZmlsbHNcbnJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vLyBhZGQgY29yZSBwbHVnaW5zLlxuY29yZS5leHRyYXMgICAgICAgICA9IHJlcXVpcmUoJy4vZXh0cmFzJyk7XG5jb3JlLmZpbHRlcnMgICAgICAgID0gcmVxdWlyZSgnLi9maWx0ZXJzJyk7XG5jb3JlLmludGVyYWN0aW9uICAgID0gcmVxdWlyZSgnLi9pbnRlcmFjdGlvbicpO1xuY29yZS5sb2FkZXJzICAgICAgICA9IHJlcXVpcmUoJy4vbG9hZGVycycpO1xuY29yZS5tZXNoICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWVzaCcpO1xuY29yZS5hY2Nlc3NpYmlsaXR5ICA9IHJlcXVpcmUoJy4vYWNjZXNzaWJpbGl0eScpO1xuXG4vLyBleHBvcnQgYSBwcmVtYWRlIGxvYWRlciBpbnN0YW5jZVxuLyoqXG4gKiBBIHByZW1hZGUgaW5zdGFuY2Ugb2YgdGhlIGxvYWRlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWRlciByZXNvdXJjZXMuXG4gKlxuICogQG5hbWUgbG9hZGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHByb3BlcnR5IHtQSVhJLmxvYWRlcnMuTG9hZGVyfVxuICovXG5jb3JlLmxvYWRlciA9IG5ldyBjb3JlLmxvYWRlcnMuTG9hZGVyKCk7XG5cbi8vIG1peGluIHRoZSBkZXByZWNhdGlvbiBmZWF0dXJlcy5cbk9iamVjdC5hc3NpZ24oY29yZSwgcmVxdWlyZSgnLi9kZXByZWNhdGlvbicpKTtcblxuLy8gQWx3YXlzIGV4cG9ydCBwaXhpIGdsb2JhbGx5LlxuZ2xvYmFsLlBJWEkgPSBjb3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG5yZXF1aXJlKCcuL01hdGguc2lnbicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9wb2x5ZmlsbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBSZWZlcmVuY2VzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9vYmplY3QtYXNzaWduXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG5cbmlmICghT2JqZWN0LmFzc2lnbilcbntcbiAgICBPYmplY3QuYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9wb2x5ZmlsbC9PYmplY3QuYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFJlZmVyZW5jZXM6XG4vLyBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTU3OTY3MVxuLy8gaHR0cDovL3VwZGF0ZXMuaHRtbDVyb2Nrcy5jb20vMjAxMi8wNS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtQVBJLW5vdy13aXRoLXN1Yi1taWxsaXNlY29uZC1wcmVjaXNpb25cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3RpbWhhbGwvNDA3ODYxNFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL3RyZWUvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblxuLy8gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIEJyb3dzZXJmaXlcbi8vIEJyb3dzZXJpZnkgYXV0b21hdGljYWxseSBkZXRlY3RzIHRoZSB1c2Ugb2YgYGdsb2JhbGAgYW5kIHBhc3NlcyB0aGVcbi8vIGNvcnJlY3QgcmVmZXJlbmNlIG9mIGBnbG9iYWxgLCBgc2VsZmAsIGFuZCBmaW5hbGx5IGB3aW5kb3dgXG5cbi8vIERhdGUubm93XG5pZiAoIShEYXRlLm5vdyAmJiBEYXRlLnByb3RvdHlwZS5nZXRUaW1lKSkge1xuICAgIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cblxuLy8gcGVyZm9ybWFuY2Uubm93XG5pZiAoIShnbG9iYWwucGVyZm9ybWFuY2UgJiYgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdykpIHtcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIWdsb2JhbC5wZXJmb3JtYW5jZSkge1xuICAgICAgICBnbG9iYWwucGVyZm9ybWFuY2UgPSB7fTtcbiAgICB9XG4gICAgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgfTtcbn1cblxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG52YXIgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xudmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuXG5mb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XG4gICAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xufVxuXG5pZiAoIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCksXG4gICAgICAgICAgICBkZWxheSA9IDE2ICsgbGFzdFRpbWUgLSBjdXJyZW50VGltZTtcblxuICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG59XG5cbmlmICghZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9wb2x5ZmlsbC9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFJlZmVyZW5jZXM6XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ25cblxuaWYgKCFNYXRoLnNpZ24pXG57XG4gICAgTWF0aC5zaWduID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeCA9ICt4O1xuICAgICAgICBpZiAoeCA9PT0gMCB8fCBpc05hTih4KSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL3BvbHlmaWxsL01hdGguc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgY29yZSBsaWJyYXJ5XG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWElcbiAqL1xuLy8gZXhwb3J0IGNvcmUgYW5kIGNvbnN0LiBXZSBhc3NpZ24gY29yZSB0byBjb25zdCBzbyB0aGF0IHRoZSBub24tcmVmZXJlbmNlIHR5cGVzIGluIGNvbnN0IHJlbWFpbiBpbi10YWN0XG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbihyZXF1aXJlKCcuL2NvbnN0JyksIHJlcXVpcmUoJy4vbWF0aCcpLCB7XG4gICAgLy8gdXRpbHNcbiAgICB1dGlsczogcmVxdWlyZSgnLi91dGlscycpLFxuICAgIHRpY2tlcjogcmVxdWlyZSgnLi90aWNrZXInKSxcblxuICAgIC8vIGRpc3BsYXlcbiAgICBEaXNwbGF5T2JqZWN0OiAgICAgICAgICByZXF1aXJlKCcuL2Rpc3BsYXkvRGlzcGxheU9iamVjdCcpLFxuICAgIENvbnRhaW5lcjogICAgICAgICAgICAgIHJlcXVpcmUoJy4vZGlzcGxheS9Db250YWluZXInKSxcblxuICAgIC8vIHNwcml0ZXNcbiAgICBTcHJpdGU6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3Nwcml0ZXMvU3ByaXRlJyksXG4gICAgUGFydGljbGVDb250YWluZXI6ICAgICAgcmVxdWlyZSgnLi9wYXJ0aWNsZXMvUGFydGljbGVDb250YWluZXInKSxcbiAgICBTcHJpdGVSZW5kZXJlcjogICAgICAgICByZXF1aXJlKCcuL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXInKSxcbiAgICBQYXJ0aWNsZVJlbmRlcmVyOiAgICAgICByZXF1aXJlKCcuL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZVJlbmRlcmVyJyksXG5cbiAgICAvLyB0ZXh0XG4gICAgVGV4dDogICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0L1RleHQnKSxcblxuICAgIC8vIHByaW1pdGl2ZXNcbiAgICBHcmFwaGljczogICAgICAgICAgICAgICByZXF1aXJlKCcuL2dyYXBoaWNzL0dyYXBoaWNzJyksXG4gICAgR3JhcGhpY3NEYXRhOiAgICAgICAgICAgcmVxdWlyZSgnLi9ncmFwaGljcy9HcmFwaGljc0RhdGEnKSxcbiAgICBHcmFwaGljc1JlbmRlcmVyOiAgICAgICByZXF1aXJlKCcuL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXInKSxcblxuICAgIC8vIHRleHR1cmVzXG4gICAgVGV4dHVyZTogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlJyksXG4gICAgQmFzZVRleHR1cmU6ICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0dXJlcy9CYXNlVGV4dHVyZScpLFxuICAgIFJlbmRlclRleHR1cmU6ICAgICAgICAgIHJlcXVpcmUoJy4vdGV4dHVyZXMvUmVuZGVyVGV4dHVyZScpLFxuICAgIFZpZGVvQmFzZVRleHR1cmU6ICAgICAgIHJlcXVpcmUoJy4vdGV4dHVyZXMvVmlkZW9CYXNlVGV4dHVyZScpLFxuICAgIFRleHR1cmVVdnM6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vdGV4dHVyZXMvVGV4dHVyZVV2cycpLFxuXG4gICAgLy8gcmVuZGVyZXJzIC0gY2FudmFzXG4gICAgQ2FudmFzUmVuZGVyZXI6ICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyksXG4gICAgQ2FudmFzR3JhcGhpY3M6ICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0dyYXBoaWNzJyksXG4gICAgQ2FudmFzQnVmZmVyOiAgICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0J1ZmZlcicpLFxuXG4gICAgLy8gcmVuZGVyZXJzIC0gd2ViZ2xcbiAgICBXZWJHTFJlbmRlcmVyOiAgICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyksXG4gICAgV2ViR0xNYW5hZ2VyOiAgICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvV2ViR0xNYW5hZ2VyJyksXG4gICAgU2hhZGVyTWFuYWdlcjogICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvU2hhZGVyTWFuYWdlcicpLFxuICAgIFNoYWRlcjogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvU2hhZGVyJyksXG4gICAgVGV4dHVyZVNoYWRlcjogICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9UZXh0dXJlU2hhZGVyJyksXG4gICAgUHJpbWl0aXZlU2hhZGVyOiAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9QcmltaXRpdmVTaGFkZXInKSxcbiAgICBDb21wbGV4UHJpbWl0aXZlU2hhZGVyOiByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC9zaGFkZXJzL0NvbXBsZXhQcmltaXRpdmVTaGFkZXInKSxcbiAgICBPYmplY3RSZW5kZXJlcjogICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpLFxuICAgIFJlbmRlclRhcmdldDogICAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldCcpLFxuXG4gICAgLy8gZmlsdGVycyAtIHdlYmdsXG4gICAgQWJzdHJhY3RGaWx0ZXI6ICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9BYnN0cmFjdEZpbHRlcicpLFxuICAgIEZYQUFGaWx0ZXI6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvRlhBQUZpbHRlcicpLFxuICAgIFNwcml0ZU1hc2tGaWx0ZXI6ICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvU3ByaXRlTWFza0ZpbHRlcicpLFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCB3aGljaCByZW5kZXJlciB5b3Ugc2hvdWxkIGJlIHVzaW5nLlxuICAgICAqIFdlYkdMIGlzIHRoZSBwcmVmZXJyZWQgcmVuZGVyZXIgYXMgaXQgaXMgYSBsb3QgZmFzdGVyLiBJZiB3ZWJHTCBpcyBub3Qgc3VwcG9ydGVkIGJ5XG4gICAgICogdGhlIGJyb3dzZXIgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgY2FudmFzIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSVxuICAgICAqIEBwYXJhbSB3aWR0aD04MDAge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSByZW5kZXJlcnMgdmlld1xuICAgICAqIEBwYXJhbSBoZWlnaHQ9NjAwIHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlcmVycyB2aWV3XG4gICAgICogQHBhcmFtIFtvcHRpb25zXSB7b2JqZWN0fSBUaGUgb3B0aW9uYWwgcmVuZGVyZXIgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBbb3B0aW9ucy52aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMuYW50aWFsaWFzPWZhbHNlXSB7Ym9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlXSB7Ym9vbGVhbn0gZW5hYmxlcyBkcmF3aW5nIGJ1ZmZlciBwcmVzZXJ2YXRpb24sIGVuYWJsZSB0aGlzIGlmIHlvdVxuICAgICAqICAgICAgbmVlZCB0byBjYWxsIHRvRGF0YVVybCBvbiB0aGUgd2ViZ2wgY29udGV4dFxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIHtudW1iZXJ9IHRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciwgcmV0aW5hIHdvdWxkIGJlIDJcbiAgICAgKiBAcGFyYW0gW25vV2ViR0w9ZmFsc2VdIHtib29sZWFufSBwcmV2ZW50cyBzZWxlY3Rpb24gb2YgV2ViR0wgcmVuZGVyZXIsIGV2ZW4gaWYgc3VjaCBpcyBwcmVzZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmVyfENhbnZhc1JlbmRlcmVyfSBSZXR1cm5zIFdlYkdMIHJlbmRlcmVyIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIENhbnZhc1JlbmRlcmVyXG4gICAgICovXG4gICAgYXV0b0RldGVjdFJlbmRlcmVyOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgb3B0aW9ucywgbm9XZWJHTClcbiAgICB7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgODAwO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgNjAwO1xuXG4gICAgICAgIGlmICghbm9XZWJHTCAmJiBjb3JlLnV0aWxzLmlzV2ViR0xTdXBwb3J0ZWQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLldlYkdMUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IGNvcmUuQ2FudmFzUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29uc3RhbnQgdmFsdWVzIHVzZWQgaW4gcGl4aVxuICpcbiAqIEBsZW5kcyBQSVhJXG4gKi9cbnZhciBDT05TVCA9IHtcbiAgICAvKipcbiAgICAgKiBTdHJpbmcgb2YgdGhlIGN1cnJlbnQgUElYSSB2ZXJzaW9uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFZFUlNJT05cbiAgICAgKi9cbiAgICBWRVJTSU9OOiAnX19WRVJTSU9OX18nLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFBJXzIgLSBUd28gUGlcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgUElfMjogTWF0aC5QSSAqIDIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUkFEX1RPX0RFRyAtIENvbnN0YW50IGNvbnZlcnNpb24gZmFjdG9yIGZvciBjb252ZXJ0aW5nIHJhZGlhbnMgdG8gZGVncmVlc1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IERFR19UT19SQUQgLSBDb25zdGFudCBjb252ZXJzaW9uIGZhY3RvciBmb3IgY29udmVydGluZyBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcblxuICAgIC8qKlxuICAgICAqIFRhcmdldCBmcmFtZXMgcGVyIG1pbGxpc2Vjb25kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUQVJHRVRfRlBNUz0wLjA2XG4gICAgICovXG4gICAgVEFSR0VUX0ZQTVM6IDAuMDYsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCB0byBpZGVudGlmeSB0aGUgUmVuZGVyZXIgVHlwZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gUkVOREVSRVJfVFlQRVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRU5ERVJFUl9UWVBFLlVOS05PV05cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUkVOREVSRVJfVFlQRS5XRUJHTFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRU5ERVJFUl9UWVBFLkNBTlZBU1xuICAgICAqL1xuICAgIFJFTkRFUkVSX1RZUEU6IHtcbiAgICAgICAgVU5LTk9XTjogICAgMCxcbiAgICAgICAgV0VCR0w6ICAgICAgMSxcbiAgICAgICAgQ0FOVkFTOiAgICAgMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWYXJpb3VzIGJsZW5kIG1vZGVzIHN1cHBvcnRlZCBieSBQSVhJLiBJTVBPUlRBTlQgLSBUaGUgV2ViR0wgcmVuZGVyZXIgb25seSBzdXBwb3J0c1xuICAgICAqIHRoZSBOT1JNQUwsIEFERCwgTVVMVElQTFkgYW5kIFNDUkVFTiBibGVuZCBtb2Rlcy4gQW55dGhpbmcgZWxzZSB3aWxsIHNpbGVudGx5IGFjdCBsaWtlXG4gICAgICogTk9STUFMLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBCTEVORF9NT0RFU1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuQUREXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLk1VTFRJUExZXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLlNDUkVFTlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5PVkVSTEFZXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkRBUktFTlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5MSUdIVEVOXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkNPTE9SX0RPREdFXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkNPTE9SX0JVUk5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuSEFSRF9MSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5TT0ZUX0xJR0hUXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkRJRkZFUkVOQ0VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuRVhDTFVTSU9OXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkhVRVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5TQVRVUkFUSU9OXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkNPTE9SXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkxVTUlOT1NJVFlcbiAgICAgKi9cbiAgICBCTEVORF9NT0RFUzoge1xuICAgICAgICBOT1JNQUw6ICAgICAgICAgMCxcbiAgICAgICAgQUREOiAgICAgICAgICAgIDEsXG4gICAgICAgIE1VTFRJUExZOiAgICAgICAyLFxuICAgICAgICBTQ1JFRU46ICAgICAgICAgMyxcbiAgICAgICAgT1ZFUkxBWTogICAgICAgIDQsXG4gICAgICAgIERBUktFTjogICAgICAgICA1LFxuICAgICAgICBMSUdIVEVOOiAgICAgICAgNixcbiAgICAgICAgQ09MT1JfRE9ER0U6ICAgIDcsXG4gICAgICAgIENPTE9SX0JVUk46ICAgICA4LFxuICAgICAgICBIQVJEX0xJR0hUOiAgICAgOSxcbiAgICAgICAgU09GVF9MSUdIVDogICAgIDEwLFxuICAgICAgICBESUZGRVJFTkNFOiAgICAgMTEsXG4gICAgICAgIEVYQ0xVU0lPTjogICAgICAxMixcbiAgICAgICAgSFVFOiAgICAgICAgICAgIDEzLFxuICAgICAgICBTQVRVUkFUSU9OOiAgICAgMTQsXG4gICAgICAgIENPTE9SOiAgICAgICAgICAxNSxcbiAgICAgICAgTFVNSU5PU0lUWTogICAgIDE2XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFZhcmlvdXMgd2ViZ2wgZHJhdyBtb2Rlcy4gVGhlc2UgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB3aGljaCBHTCBkcmF3TW9kZSB0byB1c2VcbiAgICAgKiB1bmRlciBjZXJ0YWluIHNpdHVhdGlvbnMgYW5kIHJlbmRlcmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gRFJBV19NT0RFU1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlBPSU5UU1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLkxJTkVTXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERSQVdfTU9ERVMuTElORV9MT09QXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERSQVdfTU9ERVMuTElORV9TVFJJUFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFU1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFX1NUUklQXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERSQVdfTU9ERVMuVFJJQU5HTEVfRkFOXG4gICAgICovXG4gICAgRFJBV19NT0RFUzoge1xuICAgICAgICBQT0lOVFM6ICAgICAgICAgMCxcbiAgICAgICAgTElORVM6ICAgICAgICAgIDEsXG4gICAgICAgIExJTkVfTE9PUDogICAgICAyLFxuICAgICAgICBMSU5FX1NUUklQOiAgICAgMyxcbiAgICAgICAgVFJJQU5HTEVTOiAgICAgIDQsXG4gICAgICAgIFRSSUFOR0xFX1NUUklQOiA1LFxuICAgICAgICBUUklBTkdMRV9GQU46ICAgNlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXG4gICAgICpcbiAgICAgKiBUaGUgREVGQVVMVCBzY2FsZSBtb2RlIGFmZmVjdHMgdGhlIGRlZmF1bHQgc2NhbGluZyBtb2RlIG9mIGZ1dHVyZSBvcGVyYXRpb25zLlxuICAgICAqIEl0IGNhbiBiZSByZS1hc3NpZ25lZCB0byBlaXRoZXIgTElORUFSIG9yIE5FQVJFU1QsIGRlcGVuZGluZyB1cG9uIHN1aXRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTQ0FMRV9NT0RFU1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ0FMRV9NT0RFUy5ERUZBVUxUPUxJTkVBUlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ0FMRV9NT0RFUy5MSU5FQVIgU21vb3RoIHNjYWxpbmdcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU0NBTEVfTU9ERVMuTkVBUkVTVCBQaXhlbGF0aW5nIHNjYWxpbmdcbiAgICAgKi9cbiAgICBTQ0FMRV9NT0RFUzoge1xuICAgICAgICBERUZBVUxUOiAgICAwLFxuICAgICAgICBMSU5FQVI6ICAgICAwLFxuICAgICAgICBORUFSRVNUOiAgICAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmaXggdGhhdCBkZW5vdGVzIGEgVVJMIGlzIGZvciBhIHJldGluYSBhc3NldFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSRVRJTkFfUFJFRklYXG4gICAgICovXG4gICAgLy9leGFtcGxlOiAnQDJ4JyxcbiAgICBSRVRJTkFfUFJFRklYOiAvQCguKyl4LyxcblxuICAgIFJFU09MVVRJT046MSxcblxuICAgIEZJTFRFUl9SRVNPTFVUSU9OOjEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCByZW5kZXIgb3B0aW9ucyBpZiBub25lIGFyZSBzdXBwbGllZCB0byB7QGxpbmsgUElYSS5XZWJHTFJlbmRlcmVyfVxuICAgICAqIG9yIHtAbGluayBQSVhJLkNhbnZhc1JlbmRlcmVyfS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gREVGQVVMVF9SRU5ERVJfT1BUSU9OU1xuICAgICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IERFRkFVTFRfUkVOREVSX09QVElPTlMudmlldz1udWxsXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLnRyYW5zcGFyZW50PWZhbHNlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLmFudGlhbGlhcz1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gREVGQVVMVF9SRU5ERVJfT1BUSU9OUy5mb3JjZUZYQUE9ZmFsc2VcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IERFRkFVTFRfUkVOREVSX09QVElPTlMucHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERFRkFVTFRfUkVOREVSX09QVElPTlMucmVzb2x1dGlvbj0xXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERFRkFVTFRfUkVOREVSX09QVElPTlMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IERFRkFVTFRfUkVOREVSX09QVElPTlMuYXV0b1Jlc2l6ZT1mYWxzZVxuICAgICAqL1xuICAgIERFRkFVTFRfUkVOREVSX09QVElPTlM6IHtcbiAgICAgICAgdmlldzogbnVsbCxcbiAgICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgZm9yY2VGWEFBOiBmYWxzZSxcbiAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2UsXG4gICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAweDAwMDAwMCxcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgIHJvdW5kUGl4ZWxzOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudHMgdGhhdCBpZGVudGlmeSBzaGFwZXMsIG1haW5seSB0byBwcmV2ZW50IGBpbnN0YW5jZW9mYCBjYWxscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0hBUEVTXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFNIQVBFUy5QT0xZPTBcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0hBUEVTLlJFQ1Q9MVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTSEFQRVMuQ0lSQz0yXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFNIQVBFUy5FTElQPTNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0hBUEVTLlJSRUM9NFxuICAgICAqL1xuICAgIFNIQVBFUzoge1xuICAgICAgICBQT0xZOiAwLFxuICAgICAgICBSRUNUOiAxLFxuICAgICAgICBDSVJDOiAyLFxuICAgICAgICBFTElQOiAzLFxuICAgICAgICBSUkVDOiA0XG4gICAgfSxcblxuICAgIC8vIFRPRE86IG1heWJlIGNoYW5nZSB0byBTUFJJVEUuQkFUQ0hfU0laRTogMjAwMFxuICAgIC8vIFRPRE86IG1heWJlIGFkZCBQQVJUSUNMRS5CQVRDSF9TSVpFOiAxNTAwMFxuICAgIFNQUklURV9CQVRDSF9TSVpFOiAyMDAwIC8vbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIGFuZCBkZXNrdG9wIG1hY2hpbmVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENPTlNUO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL2NvbnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1hdGggY2xhc3NlcyBhbmQgdXRpbGl0aWVzIG1peGVkIGludG8gUElYSSBuYW1lc3BhY2UuXG4gKlxuICogQGxlbmRzIFBJWElcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gVGhlc2Ugd2lsbCBiZSBtaXhlZCB0byBiZSBtYWRlIHB1YmxpY2x5IGF2YWlsYWJsZSxcbiAgICAvLyB3aGlsZSB0aGlzIG1vZHVsZSBpcyB1c2VkIGludGVybmFsbHkgaW4gY29yZVxuICAgIC8vIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgY3V0IGRvd24gb25cbiAgICAvLyBpbnRlcm5hbCBtb2R1bGUgcmVxdWlyZXMuXG5cbiAgICBQb2ludDogICAgICByZXF1aXJlKCcuL1BvaW50JyksXG4gICAgTWF0cml4OiAgICAgcmVxdWlyZSgnLi9NYXRyaXgnKSxcbiAgICBHcm91cEQ4OiAgICByZXF1aXJlKCcuL0dyb3VwRDgnKSxcblxuICAgIENpcmNsZTogICAgIHJlcXVpcmUoJy4vc2hhcGVzL0NpcmNsZScpLFxuICAgIEVsbGlwc2U6ICAgIHJlcXVpcmUoJy4vc2hhcGVzL0VsbGlwc2UnKSxcbiAgICBQb2x5Z29uOiAgICByZXF1aXJlKCcuL3NoYXBlcy9Qb2x5Z29uJyksXG4gICAgUmVjdGFuZ2xlOiAgcmVxdWlyZSgnLi9zaGFwZXMvUmVjdGFuZ2xlJyksXG4gICAgUm91bmRlZFJlY3RhbmdsZTogcmVxdWlyZSgnLi9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZScpXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIFBvaW50IG9iamVjdCByZXByZXNlbnRzIGEgbG9jYXRpb24gaW4gYSB0d28tZGltZW5zaW9uYWwgY29vcmRpbmF0ZSBzeXN0ZW0sIHdoZXJlIHggcmVwcmVzZW50c1xuICogdGhlIGhvcml6b250YWwgYXhpcyBhbmQgeSByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBheGlzLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBbeD0wXSB7bnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICogQHBhcmFtIFt5PTBdIHtudW1iZXJ9IHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gKi9cbmZ1bmN0aW9uIFBvaW50KHgsIHkpXG57XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcbn1cblxuUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50XG4gKlxuICogQHJldHVybiB7UElYSS5Qb2ludH0gYSBjb3B5IG9mIHRoZSBwb2ludFxuICovXG5Qb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgeCBhbmQgeSBmcm9tIHRoZSBnaXZlbiBwb2ludFxuICpcbiAqIEBwYXJhbSBwIHtQSVhJLlBvaW50fVxuICovXG5Qb2ludC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdGhpcy5zZXQocC54LCBwLnkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGVxdWFsIHRvIHRoaXMgcG9pbnRcbiAqXG4gKiBAcGFyYW0gcCB7UElYSS5Qb2ludH1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gKHAueCA9PT0gdGhpcy54KSAmJiAocC55ID09PSB0aGlzLnkpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyB4IGFuZCB5IHBvc2l0aW9uLlxuICogSWYgeSBpcyBvbWl0dGVkLCBib3RoIHggYW5kIHkgd2lsbCBiZSBzZXQgdG8geC5cbiAqXG4gKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICovXG5Qb2ludC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgdGhpcy54ID0geCB8fCAwO1xuICAgIHRoaXMueSA9IHkgfHwgKCAoeSAhPT0gMCkgPyB0aGlzLnggOiAwICkgO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9tYXRoL1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAdG9kbyAtIGlnbm9yZSB0aGUgdG9vIG1hbnkgcGFyYW1ldGVycyB3YXJuaW5nIGZvciBub3dcbi8vIHNob3VsZCBlaXRoZXIgZml4IGl0IG9yIGNoYW5nZSB0aGUganNoaW50IGNvbmZpZ1xuLy8ganNoaW50IC1XMDcyXG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxuLyoqXG4gKiBUaGUgcGl4aSBNYXRyaXggY2xhc3MgYXMgYW4gb2JqZWN0LCB3aGljaCBtYWtlcyBpdCBhIGxvdCBmYXN0ZXIsXG4gKiBoZXJlIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaXQgOlxuICogfCBhIHwgYiB8IHR4fFxuICogfCBjIHwgZCB8IHR5fFxuICogfCAwIHwgMCB8IDEgfFxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuZnVuY3Rpb24gTWF0cml4KClcbntcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuYiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuYyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuZCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMudHggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnR5ID0gMDtcbn1cblxuTWF0cml4LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hdHJpeDtcbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBNYXRyaXggb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheS4gVGhlIEVsZW1lbnQgdG8gTWF0cml4IG1hcHBpbmcgb3JkZXIgaXMgYXMgZm9sbG93czpcbiAqXG4gKiBhID0gYXJyYXlbMF1cbiAqIGIgPSBhcnJheVsxXVxuICogYyA9IGFycmF5WzNdXG4gKiBkID0gYXJyYXlbNF1cbiAqIHR4ID0gYXJyYXlbMl1cbiAqIHR5ID0gYXJyYXlbNV1cbiAqXG4gKiBAcGFyYW0gYXJyYXkge251bWJlcltdfSBUaGUgYXJyYXkgdGhhdCB0aGUgbWF0cml4IHdpbGwgYmUgcG9wdWxhdGVkIGZyb20uXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KVxue1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG59O1xuXG5cbi8qKlxuICogc2V0cyB0aGUgbWF0cml4IHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjXG4gKiBAcGFyYW0ge251bWJlcn0gZFxuICogQHBhcmFtIHtudW1iZXJ9IHR4XG4gKiBAcGFyYW0ge251bWJlcn0gdHlcbiAqXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgdHgsIHR5KVxue1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy50eCA9IHR4O1xuICAgIHRoaXMudHkgPSB0eTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgZnJvbSB0aGUgY3VycmVudCBNYXRyaXggb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0cmFuc3Bvc2Uge2Jvb2xlYW59IFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAqIEBwYXJhbSBbb3V0XSB7QXJyYXl9IElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGJlIGFzc2lnbmVkIHRvIG91dFxuICogQHJldHVybiB7bnVtYmVyW119IHRoZSBuZXdseSBjcmVhdGVkIGFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBtYXRyaXhcbiAqL1xuTWF0cml4LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKHRyYW5zcG9zZSwgb3V0KVxue1xuICAgIGlmICghdGhpcy5hcnJheSlcbiAgICB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICAgIH1cblxuICAgIHZhciBhcnJheSA9IG91dCB8fCB0aGlzLmFycmF5O1xuXG4gICAgaWYgKHRyYW5zcG9zZSlcbiAgICB7XG4gICAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgICAgYXJyYXlbMl0gPSAwO1xuICAgICAgICBhcnJheVszXSA9IHRoaXMuYztcbiAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgIGFycmF5WzVdID0gMDtcbiAgICAgICAgYXJyYXlbNl0gPSB0aGlzLnR4O1xuICAgICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICAgIGFycmF5WzhdID0gMTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgIGFycmF5WzFdID0gdGhpcy5jO1xuICAgICAgICBhcnJheVsyXSA9IHRoaXMudHg7XG4gICAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xuICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgICAgYXJyYXlbNV0gPSB0aGlzLnR5O1xuICAgICAgICBhcnJheVs2XSA9IDA7XG4gICAgICAgIGFycmF5WzddID0gMDtcbiAgICAgICAgYXJyYXlbOF0gPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cbiAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIHJlbmRlcmluZylcbiAqXG4gKiBAcGFyYW0gcG9zIHtQSVhJLlBvaW50fSBUaGUgb3JpZ2luXG4gKiBAcGFyYW0gW25ld1Bvc10ge1BJWEkuUG9pbnR9IFRoZSBwb2ludCB0aGF0IHRoZSBuZXcgcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gKGFsbG93ZWQgdG8gYmUgc2FtZSBhcyBpbnB1dClcbiAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIHRyYW5zZm9ybWVkIHRocm91Z2ggdGhpcyBtYXRyaXhcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChwb3MsIG5ld1BvcylcbntcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG5cbiAgICB2YXIgeCA9IHBvcy54O1xuICAgIHZhciB5ID0gcG9zLnk7XG5cbiAgICBuZXdQb3MueCA9IHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy50eDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eTtcblxuICAgIHJldHVybiBuZXdQb3M7XG59O1xuXG4vKipcbiAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBpbnZlcnNlIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlIHRvIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiBpbnB1dClcbiAqXG4gKiBAcGFyYW0gcG9zIHtQSVhJLlBvaW50fSBUaGUgb3JpZ2luXG4gKiBAcGFyYW0gW25ld1Bvc10ge1BJWEkuUG9pbnR9IFRoZSBwb2ludCB0aGF0IHRoZSBuZXcgcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gKGFsbG93ZWQgdG8gYmUgc2FtZSBhcyBpbnB1dClcbiAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIGludmVyc2UtdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICovXG5NYXRyaXgucHJvdG90eXBlLmFwcGx5SW52ZXJzZSA9IGZ1bmN0aW9uIChwb3MsIG5ld1BvcylcbntcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG5cbiAgICB2YXIgaWQgPSAxIC8gKHRoaXMuYSAqIHRoaXMuZCArIHRoaXMuYyAqIC10aGlzLmIpO1xuXG4gICAgdmFyIHggPSBwb3MueDtcbiAgICB2YXIgeSA9IHBvcy55O1xuXG4gICAgbmV3UG9zLnggPSB0aGlzLmQgKiBpZCAqIHggKyAtdGhpcy5jICogaWQgKiB5ICsgKHRoaXMudHkgKiB0aGlzLmMgLSB0aGlzLnR4ICogdGhpcy5kKSAqIGlkO1xuICAgIG5ld1Bvcy55ID0gdGhpcy5hICogaWQgKiB5ICsgLXRoaXMuYiAqIGlkICogeCArICgtdGhpcy50eSAqIHRoaXMuYSArIHRoaXMudHggKiB0aGlzLmIpICogaWQ7XG5cbiAgICByZXR1cm4gbmV3UG9zO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAqL1xuTWF0cml4LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICB0aGlzLnR4ICs9IHg7XG4gICAgdGhpcy50eSArPSB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBhbW91bnQgdG8gc2NhbGUgaG9yaXpvbnRhbGx5XG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHlcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgdGhpcy5hICo9IHg7XG4gICAgdGhpcy5kICo9IHk7XG4gICAgdGhpcy5jICo9IHg7XG4gICAgdGhpcy5iICo9IHk7XG4gICAgdGhpcy50eCAqPSB4O1xuICAgIHRoaXMudHkgKj0geTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEFwcGxpZXMgYSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKVxue1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cbiAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgdmFyIGMxID0gdGhpcy5jO1xuICAgIHZhciB0eDEgPSB0aGlzLnR4O1xuXG4gICAgdGhpcy5hID0gYTEgKiBjb3MtdGhpcy5iICogc2luO1xuICAgIHRoaXMuYiA9IGExICogc2luK3RoaXMuYiAqIGNvcztcbiAgICB0aGlzLmMgPSBjMSAqIGNvcy10aGlzLmQgKiBzaW47XG4gICAgdGhpcy5kID0gYzEgKiBzaW4rdGhpcy5kICogY29zO1xuICAgIHRoaXMudHggPSB0eDEgKiBjb3MgLSB0aGlzLnR5ICogc2luO1xuICAgIHRoaXMudHkgPSB0eDEgKiBzaW4gKyB0aGlzLnR5ICogY29zO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXhcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChtYXRyaXgpXG57XG4gICAgdmFyIGExID0gdGhpcy5hO1xuICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICB2YXIgYzEgPSB0aGlzLmM7XG4gICAgdmFyIGQxID0gdGhpcy5kO1xuXG4gICAgdGhpcy5hICA9IG1hdHJpeC5hICogYTEgKyBtYXRyaXguYiAqIGMxO1xuICAgIHRoaXMuYiAgPSBtYXRyaXguYSAqIGIxICsgbWF0cml4LmIgKiBkMTtcbiAgICB0aGlzLmMgID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzE7XG4gICAgdGhpcy5kICA9IG1hdHJpeC5jICogYjEgKyBtYXRyaXguZCAqIGQxO1xuXG4gICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXRyaXggYmFzZWQgb24gYWxsIHRoZSBhdmFpbGFibGUgcHJvcGVydGllc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WFxuICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WVxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWFxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWVxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gc2tld1hcbiAqIEBwYXJhbSB7bnVtYmVyfSBza2V3WVxuICpcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4LCB5LCBwaXZvdFgsIHBpdm90WSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1kpXG57XG4gICAgdmFyIGEsIGIsIGMsIGQsIHNyLCBjciwgY3ksIHN5LCBuc3gsIGN4O1xuXG4gICAgc3IgID0gTWF0aC5zaW4ocm90YXRpb24pO1xuICAgIGNyICA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICBjeSAgPSBNYXRoLmNvcyhza2V3WSk7XG4gICAgc3kgID0gTWF0aC5zaW4oc2tld1kpO1xuICAgIG5zeCA9IC1NYXRoLnNpbihza2V3WCk7XG4gICAgY3ggID0gIE1hdGguY29zKHNrZXdYKTtcblxuICAgIGEgID0gIGNyICogc2NhbGVYO1xuICAgIGIgID0gIHNyICogc2NhbGVYO1xuICAgIGMgID0gLXNyICogc2NhbGVZO1xuICAgIGQgID0gIGNyICogc2NhbGVZO1xuXG4gICAgdGhpcy5hICA9IGN5ICogYSArIHN5ICogYztcbiAgICB0aGlzLmIgID0gY3kgKiBiICsgc3kgKiBkO1xuICAgIHRoaXMuYyAgPSBuc3ggKiBhICsgY3ggKiBjO1xuICAgIHRoaXMuZCAgPSBuc3ggKiBiICsgY3ggKiBkO1xuXG4gICAgdGhpcy50eCA9IHggKyAoIHBpdm90WCAqIGEgKyBwaXZvdFkgKiBjICk7XG4gICAgdGhpcy50eSA9IHkgKyAoIHBpdm90WCAqIGIgKyBwaXZvdFkgKiBkICk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHJlcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXhcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihtYXRyaXgpXG57XG4gICAgdmFyIHR4MSA9IHRoaXMudHg7XG5cbiAgICBpZiAobWF0cml4LmEgIT09IDEgfHwgbWF0cml4LmIgIT09IDAgfHwgbWF0cml4LmMgIT09IDAgfHwgbWF0cml4LmQgIT09IDEpXG4gICAge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICAgICAgdGhpcy5hICA9IGExKm1hdHJpeC5hK3RoaXMuYiptYXRyaXguYztcbiAgICAgICAgdGhpcy5iICA9IGExKm1hdHJpeC5iK3RoaXMuYiptYXRyaXguZDtcbiAgICAgICAgdGhpcy5jICA9IGMxKm1hdHJpeC5hK3RoaXMuZCptYXRyaXguYztcbiAgICAgICAgdGhpcy5kICA9IGMxKm1hdHJpeC5iK3RoaXMuZCptYXRyaXguZDtcbiAgICB9XG5cbiAgICB0aGlzLnR4ID0gdHgxKm1hdHJpeC5hK3RoaXMudHkqbWF0cml4LmMrbWF0cml4LnR4O1xuICAgIHRoaXMudHkgPSB0eDEqbWF0cml4LmIrdGhpcy50eSptYXRyaXguZCttYXRyaXgudHk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW52ZXJ0cyB0aGlzIG1hdHJpeFxuICpcbiAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgdmFyIGIxID0gdGhpcy5iO1xuICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICB2YXIgZDEgPSB0aGlzLmQ7XG4gICAgdmFyIHR4MSA9IHRoaXMudHg7XG4gICAgdmFyIG4gPSBhMSpkMS1iMSpjMTtcblxuICAgIHRoaXMuYSA9IGQxL247XG4gICAgdGhpcy5iID0gLWIxL247XG4gICAgdGhpcy5jID0gLWMxL247XG4gICAgdGhpcy5kID0gYTEvbjtcbiAgICB0aGlzLnR4ID0gKGMxKnRoaXMudHktZDEqdHgxKS9uO1xuICAgIHRoaXMudHkgPSAtKGExKnRoaXMudHktYjEqdHgxKS9uO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogUmVzZXRzIHRoaXMgTWF0aXggdG8gYW4gaWRlbnRpdHkgKGRlZmF1bHQpIG1hdHJpeC5cbiAqXG4gKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5hID0gMTtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuYyA9IDA7XG4gICAgdGhpcy5kID0gMTtcbiAgICB0aGlzLnR4ID0gMDtcbiAgICB0aGlzLnR5ID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB7UElYSS5NYXRyaXh9IEEgY29weSBvZiB0aGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcblxuICAgIHJldHVybiBtYXRyaXg7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBvbmVzIGluIHRoaXMgbWF0cml4XG4gKlxuICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoZSBtYXRyaXggZ2l2ZW4gaW4gcGFyYW1ldGVyIHdpdGggaXRzIHZhbHVlcyB1cGRhdGVkLlxuICovXG5NYXRyaXgucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAobWF0cml4KVxue1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcblxuICAgIHJldHVybiBtYXRyaXg7XG59O1xuXG4vKipcbiAqIEEgZGVmYXVsdCAoaWRlbnRpdHkpIG1hdHJpeFxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICovXG5NYXRyaXguSURFTlRJVFkgPSBuZXcgTWF0cml4KCk7XG5cbi8qKlxuICogQSB0ZW1wIG1hdHJpeFxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICovXG5NYXRyaXguVEVNUF9NQVRSSVggPSBuZXcgTWF0cml4KCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvbWF0aC9NYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFlvdXIgZnJpZW5kbHkgbmVpZ2hib3VyIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RpaGVkcmFsX2dyb3VwIG9mIG9yZGVyIDE2XG5cbnZhciB1eCA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxXTtcbnZhciB1eSA9IFswLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbnZhciB2eCA9IFswLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbnZhciB2eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXTtcbnZhciB0ZW1wTWF0cmljZXMgPSBbXTtcbnZhciBNYXRyaXggPSByZXF1aXJlKCcuL01hdHJpeCcpO1xuXG52YXIgbXVsID0gW107XG5cbmZ1bmN0aW9uIHNpZ251bSh4KSB7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPiAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgICBtdWwucHVzaChyb3cpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgIHZhciBfdXggPSBzaWdudW0odXhbaV0gKiB1eFtqXSArIHZ4W2ldICogdXlbal0pO1xuICAgICAgICAgICAgdmFyIF91eSA9IHNpZ251bSh1eVtpXSAqIHV4W2pdICsgdnlbaV0gKiB1eVtqXSk7XG4gICAgICAgICAgICB2YXIgX3Z4ID0gc2lnbnVtKHV4W2ldICogdnhbal0gKyB2eFtpXSAqIHZ5W2pdKTtcbiAgICAgICAgICAgIHZhciBfdnkgPSBzaWdudW0odXlbaV0gKiB2eFtqXSArIHZ5W2ldICogdnlbal0pO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAxNjsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV4W2tdID09PSBfdXggJiYgdXlba10gPT09IF91eSAmJiB2eFtrXSA9PT0gX3Z4ICYmIHZ5W2tdID09PSBfdnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaT0wO2k8MTY7aSsrKSB7XG4gICAgICAgIHZhciBtYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIG1hdC5zZXQodXhbaV0sIHV5W2ldLCB2eFtpXSwgdnlbaV0sIDAsIDApO1xuICAgICAgICB0ZW1wTWF0cmljZXMucHVzaChtYXQpO1xuICAgIH1cbn1cblxuaW5pdCgpO1xuXG4vKipcbiAqIEltcGxlbWVudHMgRGloZWRyYWwgR3JvdXAgRF84LCBzZWUgW2dyb3VwIEQ0XXtAbGluayBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0RpaGVkcmFsR3JvdXBENC5odG1sfSwgRDggaXMgdGhlIHNhbWUgYnV0IHdpdGggZGlhZ29uYWxzXG4gKiBVc2VkIGZvciB0ZXh0dXJlIHJvdGF0aW9uc1xuICogVmVjdG9yIHhYKGkpLCB4WShpKSBpcyBVLWF4aXMgb2Ygc3ByaXRlIHdpdGggcm90YXRpb24gaVxuICogVmVjdG9yIHlZKGkpLCB5WShpKSBpcyBWLWF4aXMgb2Ygc3ByaXRlIHdpdGggcm90YXRpb24gaVxuICogUm90YXRpb25zOiAwIGdyYWQgKDApLCA5MCBncmFkICgyKSwgMTgwIGdyYWQgKDQpLCAyNzAgZ3JhZCAoNilcbiAqIE1pcnJvcnM6IHZlcnRpY2FsICg4KSwgbWFpbiBkaWFnb25hbCAoMTApLCBob3Jpem9udGFsICgxMiksIHJldmVyc2UgZGlhZ29uYWwgKDE0KVxuICogVGhpcyBpcyB0aGUgc21hbGwgcGFydCBvZiBnYW1lb2Zib21icy5jb20gcG9ydGFsIHN5c3RlbS4gSXQgd29ya3MuXG4gKiBAYXV0aG9yIEl2YW4gQGl2YW5wb3BlbHlzaGV2XG4gKlxuICogQG5hbWVzcGFjZSBQSVhJLkdyb3VwRDhcbiAqL1xudmFyIEdyb3VwRDggPSB7XG4gICAgRTogMCxcbiAgICBTRTogMSxcbiAgICBTOiAyLFxuICAgIFNXOiAzLFxuICAgIFc6IDQsXG4gICAgTlc6IDUsXG4gICAgTjogNixcbiAgICBORTogNyxcbiAgICBNSVJST1JfVkVSVElDQUw6IDgsXG4gICAgTUlSUk9SX0hPUklaT05UQUw6IDEyLFxuICAgIHVYOiBmdW5jdGlvbiAoaW5kKSB7XG4gICAgICAgIHJldHVybiB1eFtpbmRdO1xuICAgIH0sXG4gICAgdVk6IGZ1bmN0aW9uIChpbmQpIHtcbiAgICAgICAgcmV0dXJuIHV5W2luZF07XG4gICAgfSxcbiAgICB2WDogZnVuY3Rpb24gKGluZCkge1xuICAgICAgICByZXR1cm4gdnhbaW5kXTtcbiAgICB9LFxuICAgIHZZOiBmdW5jdGlvbiAoaW5kKSB7XG4gICAgICAgIHJldHVybiB2eVtpbmRdO1xuICAgIH0sXG4gICAgaW52OiBmdW5jdGlvbiAocm90YXRpb24pIHtcbiAgICAgICAgaWYgKHJvdGF0aW9uICYgOCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0aW9uICYgMTU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgtcm90YXRpb24pICYgNztcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSB7XG4gICAgICAgIHJldHVybiBtdWxbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdO1xuICAgIH0sXG4gICAgc3ViOiBmdW5jdGlvbiAocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIG11bFtyb3RhdGlvblNlY29uZF1bR3JvdXBEOC5pbnYocm90YXRpb25GaXJzdCldO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkcyAxODAgZGVncmVlcyB0byByb3RhdGlvbi4gQ29tbXV0YXRpdmUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHJvdGF0aW9uXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICByb3RhdGUxODA6IGZ1bmN0aW9uIChyb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gcm90YXRpb24gXiA0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSSBkb250IGtub3cgd2h5IHNvbWV0aW1lcyB3aWR0aCBhbmQgaGVpZ2h0cyBuZWVkcyB0byBiZSBzd2FwcGVkLiBXZSdsbCBmaXggaXQgbGF0ZXIuXG4gICAgICogQHBhcmFtIHJvdGF0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTd2FwV2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAocm90YXRpb24gJiAzKSA9PT0gMjtcbiAgICB9LFxuICAgIGJ5RGlyZWN0aW9uOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkeCkgKiAyIDw9IE1hdGguYWJzKGR5KSkge1xuICAgICAgICAgICAgaWYgKGR5ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5TO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkeSkgKiAyIDw9IE1hdGguYWJzKGR4KSkge1xuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5XO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguU0U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5TVztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5ORTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Lk5XO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBIZWxwcyBzcHJpdGUgdG8gY29tcGVuc2F0ZSB0ZXh0dXJlIHBhY2tlciByb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0gbWF0cml4IHtQSVhJLk1hdHJpeH0gc3ByaXRlIHdvcmxkIG1hdHJpeFxuICAgICAqIEBwYXJhbSByb3RhdGlvbiB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB0eCB7bnVtYmVyfCp9IHNwcml0ZSBhbmNob3JpbmdcbiAgICAgKiBAcGFyYW0gdHkge251bWJlcnwqfSBzcHJpdGUgYW5jaG9yaW5nXG4gICAgICovXG4gICAgbWF0cml4QXBwZW5kUm90YXRpb25JbnY6IGZ1bmN0aW9uIChtYXRyaXgsIHJvdGF0aW9uLCB0eCwgdHkpIHtcbiAgICAgICAgLy9QYWNrZXIgdXNlZCBcInJvdGF0aW9uXCIsIHdlIHVzZSBcImludihyb3RhdGlvbilcIlxuICAgICAgICB2YXIgbWF0ID0gdGVtcE1hdHJpY2VzW0dyb3VwRDguaW52KHJvdGF0aW9uKV07XG4gICAgICAgIHR4ID0gdHggfHwgMDtcbiAgICAgICAgdHkgPSB0eSB8fCAwO1xuICAgICAgICBtYXQudHggPSB0eDtcbiAgICAgICAgbWF0LnR5ID0gdHk7XG4gICAgICAgIG1hdHJpeC5hcHBlbmQobWF0KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwRDg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvbWF0aC9Hcm91cEQ4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9SZWN0YW5nbGUnKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogVGhlIENpcmNsZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gKiBAcGFyYW0gcmFkaXVzIHtudW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICovXG5mdW5jdGlvbiBDaXJjbGUoeCwgeSwgcmFkaXVzKVxue1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLkNJUkM7XG59XG5cbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBDaXJjbGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtQSVhJLkNpcmNsZX0gYSBjb3B5IG9mIHRoZSBDaXJjbGVcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGVcbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIENpcmNsZVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgaWYgKHRoaXMucmFkaXVzIDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGR4ID0gKHRoaXMueCAtIHgpLFxuICAgICAgICBkeSA9ICh0aGlzLnkgLSB5KSxcbiAgICAgICAgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuXG4gICAgZHggKj0gZHg7XG4gICAgZHkgKj0gZHk7XG5cbiAgICByZXR1cm4gKGR4ICsgZHkgPD0gcjIpO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBjaXJjbGUgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4qXG4qIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiovXG5DaXJjbGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gdGhpcy5yYWRpdXMsIHRoaXMueSAtIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxuLyoqXG4gKiB0aGUgUmVjdGFuZ2xlIG9iamVjdCBpcyBhbiBhcmVhIGRlZmluZWQgYnkgaXRzIHBvc2l0aW9uLCBhcyBpbmRpY2F0ZWQgYnkgaXRzIHRvcC1sZWZ0IGNvcm5lciBwb2ludCAoeCwgeSkgYW5kIGJ5IGl0cyB3aWR0aCBhbmQgaXRzIGhlaWdodC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcmVjdGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IENPTlNULlNIQVBFUy5SRUNUO1xufVxuXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdGFuZ2xlO1xubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XG5cbi8qKlxuICogQSBjb25zdGFudCBlbXB0eSByZWN0YW5nbGUuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKi9cblJlY3RhbmdsZS5FTVBUWSA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgMCwgMCk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGVcbiAqXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gYSBjb3B5IG9mIHRoZSByZWN0YW5nbGVcbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICovXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDwgdGhpcy54ICsgdGhpcy53aWR0aClcbiAgICB7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9tYXRoL3NoYXBlcy9SZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1JlY3RhbmdsZScpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxuLyoqXG4gKiBUaGUgRWxsaXBzZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gVGhlIGhhbGYgd2lkdGggb2YgdGhpcyBlbGxpcHNlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IFRoZSBoYWxmIGhlaWdodCBvZiB0aGlzIGVsbGlwc2VcbiAqL1xuZnVuY3Rpb24gRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IENPTlNULlNIQVBFUy5FTElQO1xufVxuXG5FbGxpcHNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsbGlwc2U7XG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgRWxsaXBzZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge1BJWEkuRWxsaXBzZX0gYSBjb3B5IG9mIHRoZSBlbGxpcHNlXG4gKi9cbkVsbGlwc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gbmV3IEVsbGlwc2UodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gKlxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICovXG5FbGxpcHNlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5KVxue1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL25vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwXG4gICAgdmFyIG5vcm14ID0gKCh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGgpLFxuICAgICAgICBub3JteSA9ICgoeSAtIHRoaXMueSkgLyB0aGlzLmhlaWdodCk7XG5cbiAgICBub3JteCAqPSBub3JteDtcbiAgICBub3JteSAqPSBub3JteTtcblxuICAgIHJldHVybiAobm9ybXggKyBub3JteSA8PSAxKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGVsbGlwc2UgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gKlxuICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICovXG5FbGxpcHNlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMud2lkdGgsIHRoaXMueSAtIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL1BvaW50JyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBwb2ludHMge1BJWEkuUG9pbnRbXXxudW1iZXJbXXwuLi5QSVhJLlBvaW50fC4uLm51bWJlcn0gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb2YgUG9pbnRzIHRoYXQgZm9ybSB0aGUgcG9seWdvbixcbiAqICAgICAgYSBmbGF0IGFycmF5IG9mIG51bWJlcnMgdGhhdCB3aWxsIGJlIGludGVycHJldGVkIGFzIFt4LHksIHgseSwgLi4uXSwgb3IgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlXG4gKiAgICAgIGFsbCB0aGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIGUuZy4gYG5ldyBQSVhJLlBvbHlnb24obmV3IFBJWEkuUG9pbnQoKSwgbmV3IFBJWEkuUG9pbnQoKSwgLi4uKWAsIG9yIHRoZVxuICogICAgICBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBmbGF0IHgseSB2YWx1ZXMgZS5nLiBgbmV3IFBvbHlnb24oeCx5LCB4LHksIHgseSwgLi4uKWAgd2hlcmUgYHhgIGFuZCBgeWAgYXJlXG4gKiAgICAgIE51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIFBvbHlnb24ocG9pbnRzXylcbntcbiAgICAvLyBwcmV2ZW50cyBhbiBhcmd1bWVudCBhc3NpZ25tZW50IGRlb3B0XG4gICAgLy8gc2VlIHNlY3Rpb24gMy4xOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcbiAgICB2YXIgcG9pbnRzID0gcG9pbnRzXztcblxuICAgIC8vaWYgcG9pbnRzIGlzbid0IGFuIGFycmF5LCB1c2UgYXJndW1lbnRzIGFzIHRoZSBhcnJheVxuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgbGVhayBkZW9wdFxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjI6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgICAgICBwb2ludHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBwb2ludHMubGVuZ3RoOyArK2EpIHtcbiAgICAgICAgICAgIHBvaW50c1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaXMgYW4gYXJyYXkgb2YgcG9pbnRzLCBjb252ZXJ0IGl0IHRvIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzXG4gICAgaWYgKHBvaW50c1swXSBpbnN0YW5jZW9mIFBvaW50KVxuICAgIHtcbiAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAucHVzaChwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnRzID0gcDtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB0aGUgcG9pbnRzIG9mIHRoaXMgcG9seWdvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICovXG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLlBPTFk7XG59XG5cblBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2x5Z29uXG4gKlxuICogQHJldHVybiB7UElYSS5Qb2x5Z29ufSBhIGNvcHkgb2YgdGhlIHBvbHlnb25cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLnBvaW50cy5zbGljZSgpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gKlxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuXG4gICAgLy8gdXNlIHNvbWUgcmF5Y2FzdGluZyB0byB0ZXN0IGhpdHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHhpID0gdGhpcy5wb2ludHNbaSAqIDJdLCB5aSA9IHRoaXMucG9pbnRzW2kgKiAyICsgMV0sXG4gICAgICAgICAgICB4aiA9IHRoaXMucG9pbnRzW2ogKiAyXSwgeWogPSB0aGlzLnBvaW50c1tqICogMiArIDFdLFxuICAgICAgICAgICAgaW50ZXJzZWN0ID0gKCh5aSA+IHkpICE9PSAoeWogPiB5KSkgJiYgKHggPCAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcblxuICAgICAgICBpZiAoaW50ZXJzZWN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc2lkZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvbWF0aC9zaGFwZXMvUG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxuLyoqXG4gKiBUaGUgUm91bmRlZCBSZWN0YW5nbGUgb2JqZWN0IGlzIGFuIGFyZWEgdGhhdCBoYXMgbmljZSByb3VuZGVkIGNvcm5lcnMsIGFzIGluZGljYXRlZCBieSBpdHMgdG9wLWxlZnQgY29ybmVyIHBvaW50ICh4LCB5KSBhbmQgYnkgaXRzIHdpZHRoIGFuZCBpdHMgaGVpZ2h0IGFuZCBpdHMgcmFkaXVzLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByb3VuZGVkIHJlY3RhbmdsZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhpcyByb3VuZGVkIHJlY3RhbmdsZVxuICogQHBhcmFtIHJhZGl1cyB7bnVtYmVyfSBDb250cm9scyB0aGUgcmFkaXVzIG9mIHRoZSByb3VuZGVkIGNvcm5lcnNcbiAqL1xuZnVuY3Rpb24gUm91bmRlZFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpXG57XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMjBcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAyMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBDT05TVC5TSEFQRVMuUlJFQztcbn1cblxuUm91bmRlZFJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3VuZGVkUmVjdGFuZ2xlO1xubW9kdWxlLmV4cG9ydHMgPSBSb3VuZGVkUmVjdGFuZ2xlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gKlxuICogQHJldHVybiB7UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gKi9cblJvdW5kZWRSZWN0YW5nbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gbmV3IFJvdW5kZWRSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gKi9cblJvdW5kZWRSZWN0YW5nbGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpXG4gICAge1xuICAgICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLnV0aWxzXG4gKi9cbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIF91aWQ6IDAsXG4gICAgX3NhaWRIZWxsbzogZmFsc2UsXG5cbiAgICBFdmVudEVtaXR0ZXI6ICAgcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpLFxuICAgIHBsdWdpblRhcmdldDogICByZXF1aXJlKCcuL3BsdWdpblRhcmdldCcpLFxuICAgIGFzeW5jOiAgICAgICAgICByZXF1aXJlKCdhc3luYycpLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCB1bmlxdWUgaWRlbnRpZmllciB0byB1c2UuXG4gICAgICovXG4gICAgdWlkOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICsrdXRpbHMuX3VpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGFuIFtSLCBHLCBCXSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIGhleCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSAge251bWJlcltdfSBbb3V0PVtdXVxuICAgICAqIEByZXR1cm4ge251bWJlcltdfSBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIFtSLCBHLCBCXSBvZiB0aGUgY29sb3IuXG4gICAgICovXG4gICAgaGV4MnJnYjogZnVuY3Rpb24gKGhleCwgb3V0KVxuICAgIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IFtdO1xuXG4gICAgICAgIG91dFswXSA9IChoZXggPj4gMTYgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgb3V0WzFdID0gKGhleCA+PiA4ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIG91dFsyXSA9IChoZXggJiAweEZGKSAvIDI1NTtcblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGhleCBjb2xvciBudW1iZXIgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGV4IHtudW1iZXJ9XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIGNvbG9yLlxuICAgICAqL1xuICAgIGhleDJzdHJpbmc6IGZ1bmN0aW9uIChoZXgpXG4gICAge1xuICAgICAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggPSAnMDAwMDAwJy5zdWJzdHIoMCwgNiAtIGhleC5sZW5ndGgpICsgaGV4O1xuXG4gICAgICAgIHJldHVybiAnIycgKyBoZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5IHRvIGEgaGV4IG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHJnYiB7bnVtYmVyW119XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29sb3IgbnVtYmVyXG4gICAgICovXG4gICAgcmdiMmhleDogZnVuY3Rpb24gKHJnYilcbiAgICB7XG4gICAgICAgIHJldHVybiAoKHJnYlswXSoyNTUgPDwgMTYpICsgKHJnYlsxXSoyNTUgPDwgOCkgKyByZ2JbMl0qMjU1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIENhbnZhcyBCbGVuZE1vZGVzIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3NlclxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGV5IGFyZSBzdXBwb3J0ZWRcbiAgICAgKi9cbiAgICBjYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbmdIZWFkID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVFBQUFBQkFRTUFBQUREOHAyT0FBQUFBMUJNVkVYLyc7XG4gICAgICAgIHZhciBwbmdFbmQgPSAnQUFBQUNrbEVRVlFJMTJOZ0FBQUFBZ0FCNGlHOE13QUFBQUJKUlU1RXJrSmdnZz09JztcblxuICAgICAgICB2YXIgbWFnZW50YSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBtYWdlbnRhLnNyYyA9IHBuZ0hlYWQgKyAnQVA4MDRPYTYnICsgcG5nRW5kO1xuXG4gICAgICAgIHZhciB5ZWxsb3cgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgeWVsbG93LnNyYyA9IHBuZ0hlYWQgKyAnL3dDS3h2UkYnICsgcG5nRW5kO1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gNjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShtYWdlbnRhLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoeWVsbG93LCAyLCAwKTtcblxuICAgICAgICB2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDIsMCwxLDEpLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIChkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMCAmJiBkYXRhWzJdID09PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBudW1iZXIsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY2xvc2VzdCBudW1iZXIgdGhhdCBpcyBhIHBvd2VyIG9mIHR3b1xuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgdGFrZW4gZnJvbSBTdGFybGluZyBGcmFtZXdvcmsgYXMgaXRzIHByZXR0eSBuZWF0IDspXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY2xvc2VzdCBudW1iZXIgdGhhdCBpcyBhIHBvd2VyIG9mIHR3b1xuICAgICAqL1xuICAgIGdldE5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAobnVtYmVyKVxuICAgIHtcbiAgICAgICAgLy8gc2VlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Bvd2VyX29mX3R3byNGYXN0X2FsZ29yaXRobV90b19jaGVja19pZl9hX3Bvc2l0aXZlX251bWJlcl9pc19hX3Bvd2VyX29mX3R3b1xuICAgICAgICBpZiAobnVtYmVyID4gMCAmJiAobnVtYmVyICYgKG51bWJlciAtIDEpKSA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAxO1xuXG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0IDwgbnVtYmVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA8PD0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgdGhlIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHQgbWFrZSBhIHBvd2VyIG9mIHR3byByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSBoZWlnaHQge251bWJlcn1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICByZXR1cm4gKHdpZHRoID4gMCAmJiAod2lkdGggJiAod2lkdGggLSAxKSkgPT09IDAgJiYgaGVpZ2h0ID4gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PT0gMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcmVzb2x1dGlvbiBvZiBhbiBhc3NldCBieSBsb29raW5nIGZvciB0aGUgcHJlZml4XG4gICAgICogdXNlZCBieSBzcHJpdGVzaGVldHMgYW5kIGltYWdlIHVybHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ30gdGhlIGltYWdlIHBhdGhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmVzb2x1dGlvbk9mVXJsOiBmdW5jdGlvbiAodXJsKVxuICAgIHtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBDT05TVC5SRVRJTkFfUFJFRklYLmV4ZWModXJsKTtcblxuICAgICAgICBpZiAocmVzb2x1dGlvbilcbiAgICAgICAge1xuICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChyZXNvbHV0aW9uWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIG91dCB0aGUgdmVyc2lvbiBhbmQgcmVuZGVyZXIgaW5mb3JtYXRpb24gZm9yIHRoaXMgcnVubmluZyBpbnN0YW5jZSBvZiBQSVhJLlxuICAgICAqIElmIHlvdSBkb24ndCB3YW50IHRvIHNlZSB0aGlzIG1lc3NhZ2UgeW91IGNhbiBzZXQgYFBJWEkudXRpbHMuX3NhaWRIZWxsbyA9IHRydWU7YFxuICAgICAqIHNvIHRoZSBsaWJyYXJ5IHRoaW5rcyBpdCBhbHJlYWR5IHNhaWQgaXQuIEtlZXAgaW4gbWluZCB0aGF0IGRvaW5nIHRoYXQgd2lsbCBmb3JldmVyXG4gICAgICogbWFrZXMgeW91IGEgamVyayBmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgc3RyaW5nIHJlbmRlcmVyIHR5cGUgdG8gbG9nLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzYXlIZWxsbzogZnVuY3Rpb24gKHR5cGUpXG4gICAge1xuICAgICAgICBpZiAodXRpbHMuX3NhaWRIZWxsbylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtcbiAgICAgICAgICAgICAgICAnXFxuICVjICVjICVjIFBpeGkuanMgJyArIENPTlNULlZFUlNJT04gKyAnIC0g4pywICcgKyB0eXBlICsgJyDinLAgICVjICcgKyAnICVjICcgKyAnIGh0dHA6Ly93d3cucGl4aWpzLmNvbS8gICVjICVjIOKZpSVj4pmlJWPimaUgXFxuXFxuJyxcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZmY2NmE1OyBiYWNrZ3JvdW5kOiAjMDMwMzA3OyBwYWRkaW5nOjVweCAwOycsXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmQ6ICNmZjY2YTU7IHBhZGRpbmc6NXB4IDA7JyxcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmYzNkYzsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmOyBwYWRkaW5nOjVweCAwOycsXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmOyBwYWRkaW5nOjVweCAwOycsXG4gICAgICAgICAgICAgICAgJ2NvbG9yOiAjZmYyNDI0OyBiYWNrZ3JvdW5kOiAjZmZmOyBwYWRkaW5nOjVweCAwOydcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTsgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aW5kb3cuY29uc29sZSlcbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKCdQaXhpLmpzICcgKyBDT05TVC5WRVJTSU9OICsgJyAtICcgKyB0eXBlICsgJyAtIGh0dHA6Ly93d3cucGl4aWpzLmNvbS8nKTsgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLl9zYWlkSGVsbG8gPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIGNoZWNraW5nIGZvciB3ZWJnbCBzdXBwb3J0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzV2ViR0xTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgY29udGV4dE9wdGlvbnMgPSB7IHN0ZW5jaWw6IHRydWUgfTtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGNvbnRleHRPcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gISEoZ2wgJiYgZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5zdGVuY2lsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2lnbiBvZiBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuIHtudW1iZXJ9XG4gICAgICogQHJldHVybnMge251bWJlcn0gMCBpZiBuIGlzIDAsIC0xIGlmIG4gaXMgbmVnYXRpdmUsIDEgaWYgbiBpIHBvc2l0aXZlXG4gICAgICovXG4gICAgc2lnbjogZnVuY3Rpb24gKG4pXG4gICAge1xuICAgICAgICByZXR1cm4gbiA/IChuIDwgMCA/IC0xIDogMSkgOiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmVJdGVtc1xuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyIFRoZSB0YXJnZXQgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJZHggVGhlIGluZGV4IHRvIGJlZ2luIHJlbW92aW5nIGZyb20gKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlQ291bnQgSG93IG1hbnkgaXRlbXMgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbXM6IGZ1bmN0aW9uIChhcnIsIHN0YXJ0SWR4LCByZW1vdmVDb3VudClcbiAgICB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIGlmIChzdGFydElkeCA+PSBsZW5ndGggfHwgcmVtb3ZlQ291bnQgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZUNvdW50ID0gKHN0YXJ0SWR4K3JlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoLXN0YXJ0SWR4IDogcmVtb3ZlQ291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJZHgsIGxlbiA9IGxlbmd0aC1yZW1vdmVDb3VudDsgaSA8IGxlbjsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyci5sZW5ndGggPSBsZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0b2RvIERlc2NyaWJlIHByb3BlcnR5IHVzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUZXh0dXJlQ2FjaGU6IHt9LFxuXG4gICAgLyoqXG4gICAgICogQHRvZG8gRGVzY3JpYmUgcHJvcGVydHkgdXNhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEJhc2VUZXh0dXJlQ2FjaGU6IHt9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3V0aWxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vL1xuLy8gV2Ugc3RvcmUgb3VyIEVFIG9iamVjdHMgaW4gYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gYH5gIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IG92ZXJyaWRkZW4gb3Jcbi8vIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vIFdlIGFsc28gYXNzdW1lIHRoYXQgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIGF2YWlsYWJsZSB3aGVuIHRoZSBldmVudCBuYW1lXG4vLyBpcyBhbiBFUzYgU3ltYm9sLlxuLy9cbnZhciBwcmVmaXggPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJyA/ICd+JyA6IGZhbHNlO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIEV2ZW50RW1pdHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyIHRvIGJlIGNhbGxlZC5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgQ29udGV4dCBmb3IgZnVuY3Rpb24gZXhlY3V0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gT25seSBlbWl0IG9uY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogTWluaW1hbCBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7IC8qIE5vdGhpbmcgdG8gc2V0ICovIH1cblxuLyoqXG4gKiBIb2xkIHRoZSBhc3NpZ25lZCBFdmVudEVtaXR0ZXJzIGJ5IG5hbWUuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNcbiAgICAsIG5hbWVzID0gW11cbiAgICAsIG5hbWU7XG5cbiAgaWYgKCFldmVudHMpIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGxpc3Qgb2YgYXNzaWduZWQgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIGxpc3RlZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhpc3RzIFdlIG9ubHkgbmVlZCB0byBrbm93IGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7QXJyYXl8Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50LCBleGlzdHMpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGF2YWlsYWJsZSA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoZXhpc3RzKSByZXR1cm4gISFhdmFpbGFibGU7XG4gIGlmICghYXZhaWxhYmxlKSByZXR1cm4gW107XG4gIGlmIChhdmFpbGFibGUuZm4pIHJldHVybiBbYXZhaWxhYmxlLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGF2YWlsYWJsZS5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBhdmFpbGFibGVbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIEVtaXQgYW4gZXZlbnQgdG8gYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGlvbiBpZiB3ZSd2ZSBlbWl0dGVkIGFuIGV2ZW50LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBFdmVudExpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0gcHJlZml4ID8ge30gOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyO1xuICBlbHNlIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdLmZuKSB0aGlzLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW1xuICAgICAgdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gRXZlbnRMaXN0ZW5lciB0aGF0J3Mgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzLCB0cnVlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0gcHJlZml4ID8ge30gOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyO1xuICBlbHNlIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdLmZuKSB0aGlzLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW1xuICAgICAgdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgd2Ugd2FudCB0byByZW1vdmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgdGhhdCB3ZSBuZWVkIHRvIGZpbmQuXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IE9ubHkgcmVtb3ZlIGxpc3RlbmVycyBtYXRjaGluZyB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25jZSBsaXN0ZW5lcnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBldmVudHMgPSBbXTtcblxuICBpZiAoZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgICBpZiAoXG4gICAgICAgICAgIGxpc3RlbmVycy5mbiAhPT0gZm5cbiAgICAgICAgfHwgKG9uY2UgJiYgIWxpc3RlbmVycy5vbmNlKVxuICAgICAgICB8fCAoY29udGV4dCAmJiBsaXN0ZW5lcnMuY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuXG4gICAgICAgICAgfHwgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKVxuICAgICAgICAgIHx8IChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgICApIHtcbiAgICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAvL1xuICBpZiAoZXZlbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb3Igb25seSB0aGUgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgd2FudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKGV2ZW50KSBkZWxldGUgdGhpcy5fZXZlbnRzW3ByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRdO1xuICBlbHNlIHRoaXMuX2V2ZW50cyA9IHByZWZpeCA/IHt9IDogT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFwcGx5IGFueW1vcmUuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZXZlbnRlbWl0dGVyMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBNaXhpbnMgZnVuY3Rpb25hbGl0eSB0byBtYWtlIGFuIG9iamVjdCBoYXZlIFwicGx1Z2luc1wiLlxuICpcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAqIEBwYXJhbSBvYmoge29iamVjdH0gVGhlIG9iamVjdCB0byBtaXggaW50by5cbiAqIEBleGFtcGxlXG4gKiAgICAgIGZ1bmN0aW9uIE15T2JqZWN0KCkge31cbiAqXG4gKiAgICAgIHBsdWdpblRhcmdldC5taXhpbihNeU9iamVjdCk7XG4gKi9cbmZ1bmN0aW9uIHBsdWdpblRhcmdldChvYmopXG57XG4gICAgb2JqLl9fcGx1Z2lucyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBsdWdpbiB0byBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbHVnaW5OYW1lIHtzdHJpbmd9IFRoZSBldmVudHMgdGhhdCBzaG91bGQgYmUgbGlzdGVkLlxuICAgICAqIEBwYXJhbSBjdG9yIHtGdW5jdGlvbn0gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgcGx1Z2luLlxuICAgICAqL1xuICAgIG9iai5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW5OYW1lLCBjdG9yKVxuICAgIHtcbiAgICAgICAgb2JqLl9fcGx1Z2luc1twbHVnaW5OYW1lXSA9IGN0b3I7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbGwgdGhlIHBsdWdpbnMgb2YgdGhpcyBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIG9iai5wcm90b3R5cGUuaW5pdFBsdWdpbnMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zIHx8IHt9O1xuXG4gICAgICAgIGZvciAodmFyIG8gaW4gb2JqLl9fcGx1Z2lucylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dID0gbmV3IChvYmouX19wbHVnaW5zW29dKSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgcGx1Z2lucyBvZiB0aGlzIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgb2JqLnByb3RvdHlwZS5kZXN0cm95UGx1Z2lucyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBvIGluIHRoaXMucGx1Z2lucylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tvXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsdWdpbnMgPSBudWxsO1xuICAgIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogTWl4ZXMgaW4gdGhlIHByb3BlcnRpZXMgb2YgdGhlIHBsdWdpblRhcmdldCBpbnRvIGFub3RoZXIgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0IHtvYmplY3R9IFRoZSBvYmogdG8gbWl4IGludG9cbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24gbWl4aW4ob2JqKVxuICAgIHtcbiAgICAgICAgcGx1Z2luVGFyZ2V0KG9iaik7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS91dGlscy9wbHVnaW5UYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogYXN5bmNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDE0IENhb2xhbiBNY01haG9uXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhc3luYyA9IHt9O1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHYpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQm9vbCh2KSB7XG4gICAgICAgIHJldHVybiAhIXY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdElkKHYpIHtcbiAgICAgICAgcmV0dXJuICF2O1xuICAgIH1cblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcHJldmlvdXNfYXN5bmM7XG5cbiAgICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3NlciwgYGdsb2JhbGBcbiAgICAvLyBvbiB0aGUgc2VydmVyLCBvciBgdGhpc2AgaW4gc29tZSB2aXJ0dWFsIG1hY2hpbmVzLiBXZSB1c2UgYHNlbGZgXG4gICAgLy8gaW5zdGVhZCBvZiBgd2luZG93YCBmb3IgYFdlYldvcmtlcmAgc3VwcG9ydC5cbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fFxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCB8fFxuICAgICAgICAgICAgdGhpcztcblxuICAgIGlmIChyb290ICE9IG51bGwpIHtcbiAgICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb25jZShmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZm4gPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIC8vIFBvcnRlZCBmcm9tIHVuZGVyc2NvcmUuanMgaXNPYmplY3RcbiAgICB2YXIgX2lzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9pc0FycmF5TGlrZShhcnIpIHtcbiAgICAgICAgcmV0dXJuIF9pc0FycmF5KGFycikgfHwgKFxuICAgICAgICAgICAgLy8gaGFzIGEgcG9zaXRpdmUgaW50ZWdlciBsZW5ndGggcHJvcGVydHlcbiAgICAgICAgICAgIHR5cGVvZiBhcnIubGVuZ3RoID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBhcnIubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgIGFyci5sZW5ndGggJSAxID09PSAwXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FycmF5RWFjaChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2luZGV4XSwgaW5kZXgsIGFycik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfbWFwKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdG9yKGFycltpbmRleF0sIGluZGV4LCBhcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JhbmdlKGNvdW50KSB7XG4gICAgICAgIHJldHVybiBfbWFwKEFycmF5KGNvdW50KSwgZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWR1Y2UoYXJyLCBpdGVyYXRvciwgbWVtbykge1xuICAgICAgICBfYXJyYXlFYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mb3JFYWNoT2Yob2JqZWN0LCBpdGVyYXRvcikge1xuICAgICAgICBfYXJyYXlFYWNoKF9rZXlzKG9iamVjdCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrZXldLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5kZXhPZihhcnIsIGl0ZW0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgX2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfa2V5SXRlcmF0b3IoY29sbCkge1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIga2V5cztcbiAgICAgICAgaWYgKF9pc0FycmF5TGlrZShjb2xsKSkge1xuICAgICAgICAgICAgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBpIDogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlzID0gX2tleXMoY29sbCk7XG4gICAgICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGxlbiA/IGtleXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNpbWlsYXIgdG8gRVM2J3MgcmVzdCBwYXJhbSAoaHR0cDovL2FyaXlhLm9maWxhYnMuY29tLzIwMTMvMDMvZXM2LWFuZC1yZXN0LXBhcmFtZXRlci5odG1sKVxuICAgIC8vIFRoaXMgYWNjdW11bGF0ZXMgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byBhbiBhcnJheSwgYWZ0ZXIgYSBnaXZlbiBpbmRleC5cbiAgICAvLyBGcm9tIHVuZGVyc2NvcmUuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzIxNDApLlxuICAgIGZ1bmN0aW9uIF9yZXN0UGFyYW0oZnVuYywgc3RhcnRJbmRleCkge1xuICAgICAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChhcmd1bWVudHMubGVuZ3RoIC0gc3RhcnRJbmRleCwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCByZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSB1bnVzZWQgYnV0IGhhbmRsZSBjYXNlcyBvdXRzaWRlIG9mIHRoZSBzd2l0Y2ggc3RhdGVtZW50OlxuICAgICAgICAgICAgLy8gdmFyIGFyZ3MgPSBBcnJheShzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAvLyBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzdGFydEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gYXJnc1tzdGFydEluZGV4XSA9IHJlc3Q7XG4gICAgICAgICAgICAvLyByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cblxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xuXG4gICAgLy8gY2FwdHVyZSB0aGUgZ2xvYmFsIHJlZmVyZW5jZSB0byBndWFyZCBhZ2FpbnN0IGZha2VUaW1lciBtb2Nrc1xuICAgIHZhciBfc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7XG5cbiAgICB2YXIgX2RlbGF5ID0gX3NldEltbWVkaWF0ZSA/IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgIF9zZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0gOiBmdW5jdGlvbihmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBfZGVsYXk7XG4gICAgfVxuICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IF9zZXRJbW1lZGlhdGUgPyBfZGVsYXkgOiBhc3luYy5uZXh0VGljaztcblxuXG4gICAgYXN5bmMuZm9yRWFjaCA9XG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMuZWFjaE9mKGFyciwgX3dpdGhvdXRJbmRleChpdGVyYXRvciksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9XG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMuZWFjaE9mU2VyaWVzKGFyciwgX3dpdGhvdXRJbmRleChpdGVyYXRvciksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG5cbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPVxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9lYWNoT2ZMaW1pdChsaW1pdCkoYXJyLCBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5mb3JFYWNoT2YgPVxuICAgIGFzeW5jLmVhY2hPZiA9IGZ1bmN0aW9uIChvYmplY3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICBvYmplY3QgPSBvYmplY3QgfHwgW107XG5cbiAgICAgICAgdmFyIGl0ZXIgPSBfa2V5SXRlcmF0b3Iob2JqZWN0KTtcbiAgICAgICAgdmFyIGtleSwgY29tcGxldGVkID0gMDtcblxuICAgICAgICB3aGlsZSAoKGtleSA9IGl0ZXIoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICBpdGVyYXRvcihvYmplY3Rba2V5XSwga2V5LCBvbmx5X29uY2UoZG9uZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gMCkgY2FsbGJhY2sobnVsbCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlZC0tO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBrZXkgaXMgbnVsbCBpbiBjYXNlIGl0ZXJhdG9yIGlzbid0IGV4aGF1c3RlZFxuICAgICAgICAgICAgLy8gYW5kIGRvbmUgcmVzb2x2ZWQgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gbnVsbCAmJiBjb21wbGV0ZWQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmZvckVhY2hPZlNlcmllcyA9XG4gICAgYXN5bmMuZWFjaE9mU2VyaWVzID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIG9iaiA9IG9iaiB8fCBbXTtcbiAgICAgICAgdmFyIG5leHRLZXkgPSBfa2V5SXRlcmF0b3Iob2JqKTtcbiAgICAgICAgdmFyIGtleSA9IG5leHRLZXkoKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcihvYmpba2V5XSwga2V5LCBvbmx5X29uY2UoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5leHRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoaXRlcmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcblxuXG5cbiAgICBhc3luYy5mb3JFYWNoT2ZMaW1pdCA9XG4gICAgYXN5bmMuZWFjaE9mTGltaXQgPSBmdW5jdGlvbiAob2JqLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG5leHRLZXkgPSBfa2V5SXRlcmF0b3Iob2JqKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChkb25lICYmIHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiAhZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gbmV4dEtleSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG9ialtrZXldLCBrZXksIG9ubHlfb25jZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGRvUGFyYWxsZWwoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGFzeW5jLmVhY2hPZiwgb2JqLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb1BhcmFsbGVsTGltaXQoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmbihfZWFjaE9mTGltaXQobGltaXQpLCBvYmosIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvU2VyaWVzKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmbihhc3luYy5lYWNoT2ZTZXJpZXMsIG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXN5bmNNYXAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICBhcnIgPSBhcnIgfHwgW107XG4gICAgICAgIHZhciByZXN1bHRzID0gX2lzQXJyYXlMaWtlKGFycikgPyBbXSA6IHt9O1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IodmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfYXN5bmNNYXApO1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLmluamVjdCA9XG4gICAgYXN5bmMuZm9sZGwgPVxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoT2ZTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgaSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5mb2xkciA9XG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGlkZW50aXR5KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudHJhbnNmb3JtID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdG9yO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBtZW1vO1xuICAgICAgICAgICAgbWVtbyA9IF9pc0FycmF5KGFycikgPyBbXSA6IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMuZWFjaE9mKGFyciwgZnVuY3Rpb24odiwgaywgY2IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHYsIGssIGNiKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2ZpbHRlcihlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtpbmRleDogaW5kZXgsIHZhbHVlOiB4fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMuc2VsZWN0ID1cbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xuXG4gICAgYXN5bmMuc2VsZWN0TGltaXQgPVxuICAgIGFzeW5jLmZpbHRlckxpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9maWx0ZXIpO1xuXG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID1cbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcblxuICAgIGZ1bmN0aW9uIF9yZWplY3QoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBfZmlsdGVyKGVhY2hmbiwgYXJyLCBmdW5jdGlvbih2YWx1ZSwgY2IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgY2IoIXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVUZXN0ZXIoZWFjaGZuLCBjaGVjaywgZ2V0UmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2IpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiKSBjYihnZXRSZXN1bHQoZmFsc2UsIHZvaWQgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZWUoeCwgXywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNiKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2IgJiYgY2hlY2sodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGdldFJlc3VsdCh0cnVlLCB4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYiA9IGl0ZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIGVhY2hmbihhcnIsIGxpbWl0LCBpdGVyYXRlZSwgZG9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiID0gaXRlcmF0b3I7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICBlYWNoZm4oYXJyLCBpdGVyYXRlZSwgZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMuYW55ID1cbiAgICBhc3luYy5zb21lID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2YsIHRvQm9vbCwgaWRlbnRpdHkpO1xuXG4gICAgYXN5bmMuc29tZUxpbWl0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZMaW1pdCwgdG9Cb29sLCBpZGVudGl0eSk7XG5cbiAgICBhc3luYy5hbGwgPVxuICAgIGFzeW5jLmV2ZXJ5ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2YsIG5vdElkLCBub3RJZCk7XG5cbiAgICBhc3luYy5ldmVyeUxpbWl0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZMaW1pdCwgbm90SWQsIG5vdElkKTtcblxuICAgIGZ1bmN0aW9uIF9maW5kR2V0UmVzdWx0KHYsIHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGFzeW5jLmRldGVjdCA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mLCBpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mU2VyaWVzLCBpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpO1xuICAgIGFzeW5jLmRldGVjdExpbWl0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZMaW1pdCwgaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoY29tcGFyYXRvciksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBjb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjb25jdXJyZW5jeSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy5cbiAgICAgICAgICAgIGNhbGxiYWNrID0gY29uY3VycmVuY3k7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cyh0YXNrcyk7XG4gICAgICAgIHZhciByZW1haW5pbmdUYXNrcyA9IGtleXMubGVuZ3RoO1xuICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSByZW1haW5pbmdUYXNrcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgIHZhciBydW5uaW5nVGFza3MgPSAwO1xuXG4gICAgICAgIHZhciBoYXNFcnJvciA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZm4pIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihmbikge1xuICAgICAgICAgICAgdmFyIGlkeCA9IF9pbmRleE9mKGxpc3RlbmVycywgZm4pO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSBsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmVtYWluaW5nVGFza3MtLTtcbiAgICAgICAgICAgIF9hcnJheUVhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hcnJheUVhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRhc2sgPSBfaXNBcnJheSh0YXNrc1trXSkgPyB0YXNrc1trXTogW3Rhc2tzW2tdXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdUYXNrcy0tO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZm9yRWFjaE9mKHJlc3VsdHMsIGZ1bmN0aW9uKHZhbCwgcmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgdGFzay5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZGVhZC1sb2Nrc1xuICAgICAgICAgICAgdmFyIGxlbiA9IHJlcXVpcmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkZXA7XG4gICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShkZXAgPSB0YXNrc1tyZXF1aXJlc1tsZW5dXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXMgbm9uZXhpc3RlbnQgZGVwZW5kZW5jeSBpbiAnICsgcmVxdWlyZXMuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheShkZXApICYmIF9pbmRleE9mKGRlcCwgaykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhcyBjeWNsaWMgZGVwZW5kZW5jaWVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5ICYmIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1Rhc2tzKys7XG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGFza3MrKztcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4gICAgYXN5bmMucmV0cnkgPSBmdW5jdGlvbih0aW1lcywgdGFzaywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgICAgICB2YXIgREVGQVVMVF9JTlRFUlZBTCA9IDA7XG5cbiAgICAgICAgdmFyIGF0dGVtcHRzID0gW107XG5cbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICB0aW1lczogREVGQVVMVF9USU1FUyxcbiAgICAgICAgICAgIGludGVydmFsOiBERUZBVUxUX0lOVEVSVkFMXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VUaW1lcyhhY2MsIHQpe1xuICAgICAgICAgICAgaWYodHlwZW9mIHQgPT09ICdudW1iZXInKXtcbiAgICAgICAgICAgICAgICBhY2MudGltZXMgPSBwYXJzZUludCh0LCAxMCkgfHwgREVGQVVMVF9USU1FUztcbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YgdCA9PT0gJ29iamVjdCcpe1xuICAgICAgICAgICAgICAgIGFjYy50aW1lcyA9IHBhcnNlSW50KHQudGltZXMsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICAgICAgICAgIGFjYy5pbnRlcnZhbCA9IHBhcnNlSW50KHQuaW50ZXJ2YWwsIDEwKSB8fCBERUZBVUxUX0lOVEVSVkFMO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFyZ3VtZW50IHR5cGUgZm9yIFxcJ3RpbWVzXFwnOiAnICsgdHlwZW9mIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAxIHx8IGxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgLSBtdXN0IGJlIGVpdGhlciAodGFzayksICh0YXNrLCBjYWxsYmFjayksICh0aW1lcywgdGFzaykgb3IgKHRpbWVzLCB0YXNrLCBjYWxsYmFjayknKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPD0gMiAmJiB0eXBlb2YgdGltZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFzaztcbiAgICAgICAgICAgIHRhc2sgPSB0aW1lcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpbWVzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwYXJzZVRpbWVzKG9wdHMsIHRpbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIG9wdHMudGFzayA9IHRhc2s7XG5cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlZFRhc2sod3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkUmVzdWx0cykge1xuICAgICAgICAgICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KHRhc2ssIGZpbmFsQXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKCFlcnIgfHwgZmluYWxBdHRlbXB0LCB7ZXJyOiBlcnIsIHJlc3VsdDogcmVzdWx0fSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdyYXBwZWRSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZXRyeUludGVydmFsKGludGVydmFsKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VyaWVzQ2FsbGJhY2spe1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChvcHRzLnRpbWVzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmluYWxBdHRlbXB0ID0gIShvcHRzLnRpbWVzLT0xKTtcbiAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5QXR0ZW1wdChvcHRzLnRhc2ssIGZpbmFsQXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIGlmKCFmaW5hbEF0dGVtcHQgJiYgb3B0cy5pbnRlcnZhbCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5SW50ZXJ2YWwob3B0cy5pbnRlcnZhbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXN5bmMuc2VyaWVzKGF0dGVtcHRzLCBmdW5jdGlvbihkb25lLCBkYXRhKXtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICh3cmFwcGVkQ2FsbGJhY2sgfHwgb3B0cy5jYWxsYmFjaykoZGF0YS5lcnIsIGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHJ1biB0aGlzIGFzIGEgY29udHJvbGwgZmxvd1xuICAgICAgICByZXR1cm4gb3B0cy5jYWxsYmFjayA/IHdyYXBwZWRUYXNrKCkgOiB3cmFwcGVkVGFzaztcbiAgICB9O1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICBpZiAoIV9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcEl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbZXJyXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlQXN5bmMoaXRlcmF0b3IpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBJdGVyYXRvcihhc3luYy5pdGVyYXRvcih0YXNrcykpKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9wYXJhbGxlbChlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIHZhciByZXN1bHRzID0gX2lzQXJyYXlMaWtlKHRhc2tzKSA/IFtdIDoge307XG5cbiAgICAgICAgZWFjaGZuKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGFzayhfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gYXJncztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKGFzeW5jLmVhY2hPZiwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKF9lYWNoT2ZMaW1pdChsaW1pdCksIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoYXN5bmMuZWFjaE9mU2VyaWVzLCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICBmdW5jdGlvbiBtYWtlQ2FsbGJhY2soaW5kZXgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZuKCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IF9yZXN0UGFyYW0oZnVuY3Rpb24gKGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChjYWxsQXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KGNhbGxBcmdzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBfY29uY2F0KGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgaW5kZXgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jLmNvbmNhdCA9IGRvUGFyYWxsZWwoX2NvbmNhdCk7XG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XG5cbiAgICBhc3luYy53aGlsc3QgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlc3QuYXBwbHkodGhpcywgYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IobmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdGVyYXRvcihuZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2FsbHMgPSAwO1xuICAgICAgICByZXR1cm4gYXN5bmMud2hpbHN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICsrY2FsbHMgPD0gMSB8fCB0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMud2hpbHN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5kdXJpbmcgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblxuICAgICAgICB2YXIgbmV4dCA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGNoZWNrKTtcbiAgICAgICAgICAgICAgICB0ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbihlcnIsIHRydXRoKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJ1dGgpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGVzdChjaGVjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmRvRHVyaW5nID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2FsbHMgPSAwO1xuICAgICAgICBhc3luYy5kdXJpbmcoZnVuY3Rpb24obmV4dCkge1xuICAgICAgICAgICAgaWYgKGNhbGxzKysgPCAxKSB7XG4gICAgICAgICAgICAgICAgbmV4dChudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfcXVldWUod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY29uY3VycmVuY3kgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXJyYXlFYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrIHx8IG5vb3BcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX25leHQocSwgdGFza3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcblxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgX2FycmF5RWFjaCh0YXNrcywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgX2FycmF5RWFjaCh3b3JrZXJzTGlzdCwgZnVuY3Rpb24gKHdvcmtlciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrZXIgPT09IHRhc2sgJiYgIXJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgICAgIHZhciB3b3JrZXJzTGlzdCA9IFtdO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG5vb3AsXG4gICAgICAgICAgICBlbXB0eTogbm9vcCxcbiAgICAgICAgICAgIGRyYWluOiBub29wLFxuICAgICAgICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICAgICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBxLmRyYWluID0gbm9vcDtcbiAgICAgICAgICAgICAgICBxLnRhc2tzID0gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdoaWxlKCFxLnBhdXNlZCAmJiB3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2tzID0gcS5wYXlsb2FkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKDAsIHEucGF5bG9hZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoMCwgcS50YXNrcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX21hcCh0YXNrcywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3QucHVzaCh0YXNrc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShfbmV4dChxLCB0YXNrcykpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIoZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdvcmtlcnNMaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnNMaXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bWVDb3VudCA9IE1hdGgubWluKHEuY29uY3VycmVuY3ksIHEudGFza3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNhbGwgcS5wcm9jZXNzIG9uY2UgcGVyIGNvbmN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyB3b3JrZXIgdG8gcHJlc2VydmUgZnVsbCBjb25jdXJyZW5jeSBhZnRlciBwYXVzZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAxOyB3IDw9IHJlc3VtZUNvdW50OyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG5cbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIHZhciBxID0gX3F1ZXVlKGZ1bmN0aW9uIChpdGVtcywgY2IpIHtcbiAgICAgICAgICAgIHdvcmtlcihpdGVtc1swXSwgY2IpO1xuICAgICAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLnByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuXG4gICAgICAgIGZ1bmN0aW9uIF9jb21wYXJlVGFza3MoYSwgYil7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfYmluYXJ5U2VhcmNoKHNlcXVlbmNlLCBpdGVtLCBjb21wYXJlKSB7XG4gICAgICAgICAgICB2YXIgYmVnID0gLTEsXG4gICAgICAgICAgICAgICAgZW5kID0gc2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChiZWcgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlkID0gYmVnICsgKChlbmQgLSBiZWcgKyAxKSA+Pj4gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgc2VxdWVuY2VbbWlkXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBiZWcgPSBtaWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVnO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FycmF5RWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbm9vcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZShfYmluYXJ5U2VhcmNoKHEudGFza3MsIGl0ZW0sIF9jb21wYXJlVGFza3MpICsgMSwgMCwgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBub3JtYWwgcXVldWVcbiAgICAgICAgdmFyIHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgICAgICAvLyBPdmVycmlkZSBwdXNoIHRvIGFjY2VwdCBzZWNvbmQgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBwcmlvcml0eVxuICAgICAgICBxLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuc2hpZnQgZnVuY3Rpb25cbiAgICAgICAgZGVsZXRlIHEudW5zaGlmdDtcblxuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfcXVldWUod29ya2VyLCAxLCBwYXlsb2FkKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NvbnNvbGVfZm4obmFtZSkge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hcnJheUVhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KV0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jLmxvZyA9IF9jb25zb2xlX2ZuKCdsb2cnKTtcbiAgICBhc3luYy5kaXIgPSBfY29uc29sZV9mbignZGlyJyk7XG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcbiAgICBhc3luYy53YXJuID0gX2NvbnNvbGVfZm4oJ3dhcm4nKTtcbiAgICBhc3luYy5lcnJvciA9IF9jb25zb2xlX2ZuKCdlcnJvcicpOyovXG5cbiAgICBhc3luYy5tZW1vaXplID0gZnVuY3Rpb24gKGZuLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xuICAgICAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGlkZW50aXR5O1xuICAgICAgICB2YXIgbWVtb2l6ZWQgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uIG1lbW9pemVkKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG1lbW8sIGtleSkpIHsgICBcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzLmNhbGwocXVldWVzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW19yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfTtcblxuICAgIGFzeW5jLnVubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdGltZXMobWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgbWFwcGVyKF9yYW5nZShjb3VudCksIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMudGltZXMgPSBfdGltZXMoYXN5bmMubWFwKTtcbiAgICBhc3luYy50aW1lc1NlcmllcyA9IF90aW1lcyhhc3luYy5tYXBTZXJpZXMpO1xuICAgIGFzeW5jLnRpbWVzTGltaXQgPSBmdW5jdGlvbiAoY291bnQsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcExpbWl0KF9yYW5nZShjb3VudCksIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXEgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIG5leHRhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICByZXR1cm4gYXN5bmMuc2VxLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gX2FwcGx5RWFjaChlYWNoZm4pIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24oZm5zLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZ28gPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBfLCBjYikge1xuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMuYXBwbHlFYWNoID0gX2FwcGx5RWFjaChhc3luYy5lYWNoT2YpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IF9hcHBseUVhY2goYXN5bmMuZWFjaE9mU2VyaWVzKTtcblxuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRvbmUgPSBvbmx5X29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIHZhciB0YXNrID0gZW5zdXJlQXN5bmMoZm4pO1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZW5zdXJlQXN5bmMoZm4pIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMuZW5zdXJlQXN5bmMgPSBlbnN1cmVBc3luYztcblxuICAgIGFzeW5jLmNvbnN0YW50ID0gX3Jlc3RQYXJhbShmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbbnVsbF0uY29uY2F0KHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGFzeW5jLndyYXBTeW5jID1cbiAgICBhc3luYy5hc3luY2lmeSA9IGZ1bmN0aW9uIGFzeW5jaWZ5KGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICAgICAgaWYgKF9pc09iamVjdChyZXN1bHQpICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyci5tZXNzYWdlID8gZXJyIDogbmV3IEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gTm9kZS5qc1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuICAgIH1cbiAgICAvLyBBTUQgLyBSZXF1aXJlSlNcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2FzeW5jL2xpYi9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGlja2VyID0gcmVxdWlyZSgnLi9UaWNrZXInKTtcblxuLyoqXG4gKiBUaGUgc2hhcmVkIHRpY2tlciBpbnN0YW5jZSB1c2VkIGJ5IHtAbGluayBQSVhJLmV4dHJhcy5Nb3ZpZUNsaXB9LlxuICogYW5kIGJ5IHtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn0uXG4gKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNhdXRvU3RhcnR9IGlzIHNldCB0byBgdHJ1ZWBcbiAqIGZvciB0aGlzIGluc3RhbmNlLiBQbGVhc2UgZm9sbG93IHRoZSBleGFtcGxlcyBmb3IgdXNhZ2UsIGluY2x1ZGluZ1xuICogaG93IHRvIG9wdC1vdXQgb2YgYXV0by1zdGFydGluZyB0aGUgc2hhcmVkIHRpY2tlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHRpY2tlciA9IFBJWEkudGlja2VyLnNoYXJlZDtcbiAqIC8vIFNldCB0aGlzIHRvIHByZXZlbnQgc3RhcnRpbmcgdGhpcyB0aWNrZXIgd2hlbiBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICogLy8gQnkgZGVmYXVsdCB0aGlzIGlzIHRydWUgb25seSBmb3IgdGhlIFBJWEkudGlja2VyLnNoYXJlZCBpbnN0YW5jZS5cbiAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAqIC8vIEZZSSwgY2FsbCB0aGlzIHRvIGVuc3VyZSB0aGUgdGlja2VyIGlzIHN0b3BwZWQuIEl0IHNob3VsZCBiZSBzdG9wcGVkXG4gKiAvLyBpZiB5b3UgaGF2ZSBub3QgYXR0ZW1wdGVkIHRvIHJlbmRlciBhbnl0aGluZyB5ZXQuXG4gKiB0aWNrZXIuc3RvcCgpO1xuICogLy8gQ2FsbCB0aGlzIHdoZW4geW91IGFyZSByZWFkeSBmb3IgYSBydW5uaW5nIHNoYXJlZCB0aWNrZXIuXG4gKiB0aWNrZXIuc3RhcnQoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gWW91IG1heSB1c2UgdGhlIHNoYXJlZCB0aWNrZXIgdG8gcmVuZGVyLi4uXG4gKiB2YXIgcmVuZGVyZXIgPSBQSVhJLmF1dG9EZXRlY3RSZW5kZXJlcig4MDAsIDYwMCk7XG4gKiB2YXIgc3RhZ2UgPSBuZXcgUElYSS5Db250YWluZXIoKTtcbiAqIHZhciBpbnRlcmFjdGlvbk1hbmFnZXIgPSBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcihyZW5kZXJlcik7XG4gKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlbmRlcmVyLnZpZXcpO1xuICogdGlja2VyLmFkZChmdW5jdGlvbiAodGltZSkge1xuICogICAgIHJlbmRlcmVyLnJlbmRlcihzdGFnZSk7XG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gT3IgeW91IGNhbiBqdXN0IHVwZGF0ZSBpdCBtYW51YWxseS5cbiAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAqIHRpY2tlci5zdG9wKCk7XG4gKiBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcbiAqICAgICB0aWNrZXIudXBkYXRlKHRpbWUpO1xuICogICAgIHJlbmRlcmVyLnJlbmRlcihzdGFnZSk7XG4gKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICogfVxuICogYW5pbWF0ZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gKlxuICogQHR5cGUge1BJWEkudGlja2VyLlRpY2tlcn1cbiAqIEBtZW1iZXJvZiBQSVhJLnRpY2tlclxuICovXG52YXIgc2hhcmVkID0gbmV3IFRpY2tlcigpO1xuc2hhcmVkLmF1dG9TdGFydCA9IHRydWU7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLnRpY2tlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaGFyZWQ6IHNoYXJlZCxcbiAgICBUaWNrZXI6IFRpY2tlclxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS90aWNrZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpLFxuICAgIC8vIEludGVybmFsIGV2ZW50IHVzZWQgYnkgY29tcG9zZWQgZW1pdHRlclxuICAgIFRJQ0sgPSAndGljayc7XG5cbi8qKlxuICogQSBUaWNrZXIgY2xhc3MgdGhhdCBydW5zIGFuIHVwZGF0ZSBsb29wIHRoYXQgb3RoZXIgb2JqZWN0cyBsaXN0ZW4gdG8uXG4gKiBUaGlzIGNsYXNzIGlzIGNvbXBvc2VkIGFyb3VuZCBhbiBFdmVudEVtaXR0ZXIgb2JqZWN0IHRvIGFkZCBsaXN0ZW5lcnNcbiAqIG1lYW50IGZvciBleGVjdXRpb24gb24gdGhlIG5leHQgcmVxdWVzdGVkIGFuaW1hdGlvbiBmcmFtZS5cbiAqIEFuaW1hdGlvbiBmcmFtZXMgYXJlIHJlcXVlc3RlZCBvbmx5IHdoZW4gbmVjZXNzYXJ5LFxuICogZS5nLiBXaGVuIHRoZSB0aWNrZXIgaXMgc3RhcnRlZCBhbmQgdGhlIGVtaXR0ZXIgaGFzIGxpc3RlbmVycy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLnRpY2tlclxuICovXG5mdW5jdGlvbiBUaWNrZXIoKVxue1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB0aWNrIG1ldGhvZCBib3VuZCB0byB0aWNrZXIgaW5zdGFuY2UuXG4gICAgICogVGhpcyBpcyBiZWNhdXNlIGluIGVhcmx5IDIwMTUsIEZ1bmN0aW9uLmJpbmRcbiAgICAgKiBpcyBzdGlsbCA2MCUgc2xvd2VyIGluIGhpZ2ggcGVyZm9ybWFuY2Ugc2NlbmFyaW9zLlxuICAgICAqIEFsc28gc2VwYXJhdGluZyBmcmFtZSByZXF1ZXN0cyBmcm9tIHVwZGF0ZSBtZXRob2RcbiAgICAgKiBzbyBsaXN0ZW5lcnMgbWF5IGJlIGNhbGxlZCBhdCBhbnkgdGltZSBhbmQgd2l0aFxuICAgICAqIGFueSBhbmltYXRpb24gQVBJLCBqdXN0IGludm9rZSB0aWNrZXIudXBkYXRlKHRpbWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90aWNrID0gZnVuY3Rpb24gX3RpY2sodGltZSkge1xuXG4gICAgICAgIF90aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuXG4gICAgICAgIGlmIChfdGhpcy5zdGFydGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBJbnZva2UgbGlzdGVuZXJzIG5vd1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlKHRpbWUpO1xuICAgICAgICAgICAgLy8gTGlzdGVuZXIgc2lkZSBlZmZlY3RzIG1heSBoYXZlIG1vZGlmaWVkIHRpY2tlciBzdGF0ZS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydGVkICYmIF90aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgX3RoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKFRJQ0ssIHRydWUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMuX3RpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGVtaXR0ZXIgdXNlZCB0byBmaXJlICd0aWNrJyBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGN1cnJlbnQgZnJhbWUgcmVxdWVzdCBJRFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVxdWVzdElkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHZhbHVlIG1hbmFnZWQgYnkgbWluRlBTIHByb3BlcnR5IHNldHRlciBhbmQgZ2V0dGVyLlxuICAgICAqIFRoaXMgaXMgdGhlIG1heGltdW0gYWxsb3dlZCBtaWxsaXNlY29uZHMgYmV0d2VlbiB1cGRhdGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMTAwO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXG4gICAgICoge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNzdGFydH0gYXV0b21hdGljYWxseVxuICAgICAqIHdoZW4gYSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2NhbGFyIHRpbWUgdmFsdWUgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBjYXBwZWQgYnkgc2V0dGluZyB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI21pbkZQU31cbiAgICAgKiBhbmQgaXMgc2NhbGVkIHdpdGgge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNzcGVlZH0uXG4gICAgICogKipOb3RlOioqIFRoZSBjYXAgbWF5IGJlIGV4Y2VlZGVkIGJ5IHNjYWxpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHMgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICogT3Bwb3NlZCB0byB3aGF0IHRoZSBzY2FsYXIge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNkZWx0YVRpbWV9XG4gICAgICogaXMgYmFzZWQsIHRoaXMgdmFsdWUgaXMgbmVpdGhlciBjYXBwZWQgbm9yIHNjYWxlZC5cbiAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcbiAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0RPTUhpZ2hSZXNUaW1lU3RhbXB8bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEgLyBUQVJHRVRfRlBNU1xuICAgICAqL1xuICAgIHRoaXMuZWxhcHNlZE1TID0gMSAvIENPTlNULlRBUkdFVF9GUE1TOyAvLyBkZWZhdWx0IHRvIHRhcmdldCBmcmFtZSB0aW1lXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCB0aW1lIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjdXBkYXRlfSB3YXMgaW52b2tlZC5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIGFsc28gcmVzZXQgaW50ZXJuYWxseSBvdXRzaWRlIG9mIGludm9raW5nXG4gICAgICogdXBkYXRlLCBidXQgb25seSB3aGVuIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXG4gICAgICogdGhpcyB2YWx1ZSB3aWxsIGhhdmUgYSBwcmVjaXNpb24gb2YgMSDCtXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtET01IaWdoUmVzVGltZVN0YW1wfG51bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5sYXN0VGltZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBGYWN0b3Igb2YgY3VycmVudCB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI2RlbHRhVGltZX0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTY2FsZXMgdGlja2VyLmRlbHRhVGltZSB0byB3aGF0IHdvdWxkIGJlXG4gICAgICogLy8gdGhlIGVxdWl2YWxlbnQgb2YgYXBwcm94aW1hdGVseSAxMjAgRlBTXG4gICAgICogdGlja2VyLnNwZWVkID0gMjtcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5zcGVlZCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxuICAgICAqIGB0cnVlYCBpZiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3N0YXJ0fSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICogYGZhbHNlYCBpZiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI3N0b3B9IGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBXaGlsZSBgZmFsc2VgLCB0aGlzIHZhbHVlIG1heSBjaGFuZ2UgdG8gYHRydWVgIGluIHRoZVxuICAgICAqIGV2ZW50IG9mIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjYXV0b1N0YXJ0fSBiZWluZyBgdHJ1ZWBcbiAgICAgKiBhbmQgYSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGlja2VyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZXMgcGVyIHNlY29uZCBhdCB3aGljaCB0aGlzIHRpY2tlciBpcyBydW5uaW5nLlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGFwcHJveGltYXRlbHkgNjAgaW4gbW9zdCBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICogKipOb3RlOioqIFRoaXMgZG9lcyBub3QgZmFjdG9yIGluIHRoZSB2YWx1ZSBvZlxuICAgICAqIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjc3BlZWR9LCB3aGljaCBpcyBzcGVjaWZpY1xuICAgICAqIHRvIHNjYWxpbmcge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNkZWx0YVRpbWV9LlxuICAgICAqXG4gICAgICogQG1lbWJlclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLnRpY2tlci5UaWNrZXIjXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgRlBTOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuZWxhcHNlZE1TO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgdGhlIG1heGltdW0gYW1vdW50IG9mIG1pbGxpc2Vjb25kcyBhbGxvd2VkIHRvXG4gICAgICogZWxhcHNlIGJldHdlZW4gaW52b2tpbmcge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciN1cGRhdGV9LlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdXNlZCB0byBjYXAge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgICAqIGJ1dCBkb2VzIG5vdCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjRlBTfS5cbiAgICAgKiBXaGVuIHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBpdCBpcyBjbGFtcGVkIHRvIGEgdmFsdWUgYmV0d2VlblxuICAgICAqIGAwYCBhbmQgYFBJWEkuVEFSR0VUX0ZQTVMgKiAxMDAwYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS50aWNrZXIuVGlja2VyI1xuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgbWluRlBTOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmcHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENsYW1wOiAwIHRvIFRBUkdFVF9GUE1TXG4gICAgICAgICAgICB2YXIgbWluRlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGZwcykgLyAxMDAwLCBDT05TVC5UQVJHRVRfRlBNUyk7XG4gICAgICAgICAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxIC8gbWluRlBNUztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENvbmRpdGlvbmFsbHkgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lLlxuICogSWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWxcbiAqIGVtaXR0ZXIgaGFzIGxpc3RlbmVycywgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRpY2tlci5wcm90b3R5cGUuX3JlcXVlc3RJZk5lZWRlZCA9IGZ1bmN0aW9uIF9yZXF1ZXN0SWZOZWVkZWQoKVxue1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoVElDSywgdHJ1ZSkpXG4gICAge1xuICAgICAgICAvLyBlbnN1cmUgY2FsbGJhY2tzIGdldCBjb3JyZWN0IGRlbHRhXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29uZGl0aW9uYWxseSBjYW5jZWxzIGEgcGVuZGluZyBhbmltYXRpb24gZnJhbWUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGlja2VyLnByb3RvdHlwZS5fY2FuY2VsSWZOZWVkZWQgPSBmdW5jdGlvbiBfY2FuY2VsSWZOZWVkZWQoKVxue1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgIT09IG51bGwpXG4gICAge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gKiBJZiB0aGUgdGlja2VyIGhhcyBiZWVuIHN0YXJ0ZWQgaXQgY2hlY2tzIGlmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5XG4gKiBiZWVuIHJlcXVlc3RlZCwgYW5kIGlmIHRoZSBpbnRlcm5hbCBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMuIElmIHRoZXNlXG4gKiBjb25kaXRpb25zIGFyZSBtZXQsIGEgbmV3IGZyYW1lIGlzIHJlcXVlc3RlZC4gSWYgdGhlIHRpY2tlciBoYXMgbm90XG4gKiBiZWVuIHN0YXJ0ZWQsIGJ1dCBhdXRvU3RhcnQgaXMgYHRydWVgLCB0aGVuIHRoZSB0aWNrZXIgc3RhcnRzIG5vdyxcbiAqIGFuZCBjb250aW51ZXMgd2l0aCB0aGUgcHJldmlvdXMgY29uZGl0aW9ucyB0byByZXF1ZXN0IGEgbmV3IGZyYW1lLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRpY2tlci5wcm90b3R5cGUuX3N0YXJ0SWZQb3NzaWJsZSA9IGZ1bmN0aW9uIF9zdGFydElmUG9zc2libGUoKVxue1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5hdXRvU3RhcnQpXG4gICAge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxscyB7QGxpbmsgbW9kdWxlOmV2ZW50ZW1pdHRlcjMuRXZlbnRFbWl0dGVyI29ufSBpbnRlcm5hbGx5IGZvciB0aGVcbiAqIGludGVybmFsICd0aWNrJyBldmVudC4gSXQgY2hlY2tzIGlmIHRoZSBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMsXG4gKiBhbmQgaWYgc28gaXQgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGF0IHRoaXMgcG9pbnQuXG4gKlxuICogQHBhcmFtIGZuIHtGdW5jdGlvbn0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciB1cGRhdGVzXG4gKiBAcGFyYW0gW2NvbnRleHRdIHtGdW5jdGlvbn0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAqIEByZXR1cm5zIHtQSVhJLnRpY2tlci5UaWNrZXJ9IHRoaXNcbiAqL1xuVGlja2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoZm4sIGNvbnRleHQpXG57XG4gICAgdGhpcy5fZW1pdHRlci5vbihUSUNLLCBmbiwgY29udGV4dCk7XG5cbiAgICB0aGlzLl9zdGFydElmUG9zc2libGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxscyB7QGxpbmsgbW9kdWxlOmV2ZW50ZW1pdHRlcjMuRXZlbnRFbWl0dGVyI29uY2V9IGludGVybmFsbHkgZm9yIHRoZVxuICogaW50ZXJuYWwgJ3RpY2snIGV2ZW50LiBJdCBjaGVja3MgaWYgdGhlIGVtaXR0ZXIgaGFzIGxpc3RlbmVycyxcbiAqIGFuZCBpZiBzbyBpdCByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUgYXQgdGhpcyBwb2ludC5cbiAqXG4gKiBAcGFyYW0gZm4ge0Z1bmN0aW9ufSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAqIEBwYXJhbSBbY29udGV4dF0ge0Z1bmN0aW9ufSBUaGUgbGlzdGVuZXIgY29udGV4dFxuICogQHJldHVybnMge1BJWEkudGlja2VyLlRpY2tlcn0gdGhpc1xuICovXG5UaWNrZXIucHJvdG90eXBlLmFkZE9uY2UgPSBmdW5jdGlvbiBhZGRPbmNlKGZuLCBjb250ZXh0KVxue1xuICAgIHRoaXMuX2VtaXR0ZXIub25jZShUSUNLLCBmbiwgY29udGV4dCk7XG5cbiAgICB0aGlzLl9zdGFydElmUG9zc2libGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxscyB7QGxpbmsgbW9kdWxlOmV2ZW50ZW1pdHRlcjMuRXZlbnRFbWl0dGVyI29mZn0gaW50ZXJuYWxseSBmb3IgJ3RpY2snIGV2ZW50LlxuICogSXQgY2hlY2tzIGlmIHRoZSBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMgZm9yICd0aWNrJyBldmVudC5cbiAqIElmIGl0IGRvZXMsIHRoZW4gaXQgY2FuY2VscyB0aGUgYW5pbWF0aW9uIGZyYW1lLlxuICpcbiAqIEBwYXJhbSBbZm5dIHtGdW5jdGlvbn0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcbiAqIEBwYXJhbSBbY29udGV4dF0ge0Z1bmN0aW9ufSBUaGUgbGlzdGVuZXIgY29udGV4dCB0byBiZSByZW1vdmVkXG4gKiBAcmV0dXJucyB7UElYSS50aWNrZXIuVGlja2VyfSB0aGlzXG4gKi9cblRpY2tlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGZuLCBjb250ZXh0KVxue1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKFRJQ0ssIGZuLCBjb250ZXh0KTtcblxuICAgIGlmICghdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoVElDSywgdHJ1ZSkpXG4gICAge1xuICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdGhlIHRpY2tlci4gSWYgdGhlIHRpY2tlciBoYXMgbGlzdGVuZXJzXG4gKiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkIGF0IHRoaXMgcG9pbnQuXG4gKi9cblRpY2tlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpXG57XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpXG4gICAge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFN0b3BzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIHJlcXVlc3RlZFxuICogYW4gYW5pbWF0aW9uIGZyYW1lIGl0IGlzIGNhbmNlbGVkIGF0IHRoaXMgcG9pbnQuXG4gKi9cblRpY2tlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKVxue1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcbiAqIGN1cnJlbnQge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNlbGFwc2VkTVN9LFxuICogdGhlIGN1cnJlbnQge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNkZWx0YVRpbWV9LFxuICogaW52b2tpbmcgYWxsIGxpc3RlbmVycyB3aXRoIGN1cnJlbnQgZGVsdGFUaW1lLFxuICogYW5kIHRoZW4gZmluYWxseSBzZXR0aW5nIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjbGFzdFRpbWV9XG4gKiB3aXRoIHRoZSB2YWx1ZSBvZiBjdXJyZW50VGltZSB0aGF0IHdhcyBwcm92aWRlZC5cbiAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gKiBmcmFtZSBjYWxsYmFja3MgaWYgdGhlIHRpY2tlciBpbnN0YW5jZSBoYXMgYmVlbiBzdGFydGVkXG4gKiBhbmQgbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAqXG4gKiBAcGFyYW0gW2N1cnJlbnRUaW1lPXBlcmZvcm1hbmNlLm5vdygpXSB7RE9NSGlnaFJlc1RpbWVTdGFtcHxudW1iZXJ9IHRoZSBjdXJyZW50IHRpbWUgb2YgZXhlY3V0aW9uXG4gKi9cblRpY2tlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGN1cnJlbnRUaW1lKVxue1xuICAgIHZhciBlbGFwc2VkTVM7XG5cbiAgICAvLyBBbGxvdyBjYWxsaW5nIHVwZGF0ZSBkaXJlY3RseSB3aXRoIGRlZmF1bHQgY3VycmVudFRpbWUuXG4gICAgY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSB8fCBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBTYXZlIHVuY2FwcGVkIGVsYXBzZWRNUyBmb3IgbWVhc3VyZW1lbnRcbiAgICBlbGFwc2VkTVMgPSB0aGlzLmVsYXBzZWRNUyA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcblxuICAgIC8vIGNhcCB0aGUgbWlsbGlzZWNvbmRzIGVsYXBzZWQgdXNlZCBmb3IgZGVsdGFUaW1lXG4gICAgaWYgKGVsYXBzZWRNUyA+IHRoaXMuX21heEVsYXBzZWRNUylcbiAgICB7XG4gICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICB9XG5cbiAgICB0aGlzLmRlbHRhVGltZSA9IGVsYXBzZWRNUyAqIENPTlNULlRBUkdFVF9GUE1TICogdGhpcy5zcGVlZDtcblxuICAgIC8vIEludm9rZSBsaXN0ZW5lcnMgYWRkZWQgdG8gaW50ZXJuYWwgZW1pdHRlclxuICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChUSUNLLCB0aGlzLmRlbHRhVGltZSk7XG5cbiAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpY2tlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS90aWNrZXIvVGlja2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcbiAgICBSZW5kZXJUZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvUmVuZGVyVGV4dHVyZScpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgX3RlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKSxcbiAgICBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSB7d29ybGRUcmFuc2Zvcm06bmV3IG1hdGguTWF0cml4KCksIHdvcmxkQWxwaGE6MSwgY2hpbGRyZW46W119O1xuXG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIG9uIHRoZSBzY3JlZW4uXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgb24gaXRzIG93biByYXRoZXIgaXQgc2hvdWxkIGJlIGV4dGVuZGVkLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5mdW5jdGlvbiBEaXNwbGF5T2JqZWN0KClcbntcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgbWF0aC5Qb2ludCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlID0gbmV3IG1hdGguUG9pbnQoMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl2b3QgcG9pbnQgb2YgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCBpdCByb3RhdGVzIGFyb3VuZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLnBpdm90ID0gbmV3IG1hdGguUG9pbnQoMCwgMCk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBza2V3IGZhY3RvciBmb3IgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLnNrZXcgPSBuZXcgbWF0aC5Qb2ludCgwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYWxwaGEgPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZpc2liaWxpdHkgb2YgdGhlIG9iamVjdC4gSWYgZmFsc2UgdGhlIG9iamVjdCB3aWxsIG5vdCBiZSBkcmF3biwgYW5kXG4gICAgICogdGhlIHVwZGF0ZVRyYW5zZm9ybSBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBDYW4gdGhpcyBvYmplY3QgYmUgcmVuZGVyZWQsIGlmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24gYnV0IHRoZSB1cGRhdGVUcmFuc2Zvcm1cbiAgICAgKiBtZXRob2RzIHdpbGwgc3RpbGwgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkNvbnRhaW5lcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGlwbGllZCBhbHBoYSBvZiB0aGUgZGlzcGxheU9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgbWF0aC5NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pc2F0aW9uXG4gICAgICogcmF0aGVyIHRoYW4gZmlndXJpbmcgb3V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGVhY2ggZnJhbWUgeW91IGNhbiBzZXQgdGhpcyByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBjYWNoZWQgc2luIHJvdGF0aW9uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBjYWNoZWQgY29zIHJvdGF0aW9uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jciA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwsIGNhY2hlZCBib3VuZHMgb2YgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgbWF0aC5SZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCB1cC10by1kYXRlIGJvdW5kcyBvZiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsLCBjYWNoZWQgbWFzayBvZiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21hc2sgPSBudWxsO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXNwbGF5T2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5T2JqZWN0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICovXG4gICAgeDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHkgYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAqL1xuICAgIHk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBzcHJpdGUgaXMgZ2xvYmFsbHkgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB3b3JsZFZpc2libGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXM7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0udmlzaWJsZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgICAgICAgICB9IHdoaWxlIChpdGVtKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC5cbiAgICAgKiBJbiBQSVhJIGEgcmVndWxhciBtYXNrIG11c3QgYmUgYSBQSVhJLkdyYXBoaWNzIG9yIGEgUElYSS5TcHJpdGUgb2JqZWN0LiBUaGlzIGFsbG93cyBmb3IgbXVjaCBmYXN0ZXIgbWFza2luZyBpbiBjYW52YXMgYXMgaXQgdXRpbGlzZXMgc2hhcGUgY2xpcHBpbmcuXG4gICAgICogVG8gcmVtb3ZlIGEgbWFzaywgc2V0IHRoaXMgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgKlxuICAgICAqIEB0b2RvIEZvciB0aGUgbW9tZW50LCBQSVhJLkNhbnZhc1JlbmRlcmVyIGRvZXNuJ3Qgc3VwcG9ydCBQSVhJLlNwcml0ZSBhcyBtYXNrLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAqL1xuICAgIG1hc2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXNrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hc2sucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX21hc2sgPSB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX21hc2spXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZmlsdGVycyBmb3IgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAgICogKiBJTVBPUlRBTlQ6IFRoaXMgaXMgYSB3ZWJHTCBvbmx5IGZlYXR1cmUgYW5kIHdpbGwgYmUgaWdub3JlZCBieSB0aGUgY2FudmFzIHJlbmRlcmVyLlxuICAgICAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnbnVsbCdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuQWJzdHJhY3RGaWx0ZXJbXX1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAqL1xuICAgIGZpbHRlcnM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVycyAmJiB0aGlzLl9maWx0ZXJzLnNsaWNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJzID0gdmFsdWUgJiYgdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBUT0RPIC0gT3B0aW1pemF0aW9uIHBhc3MhXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gY3JlYXRlIHNvbWUgbWF0cml4IHJlZnMgZm9yIGVhc3kgYWNjZXNzXG4gICAgdmFyIHB0ID0gdGhpcy5wYXJlbnQud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIC8vIHRlbXBvcmFyeSBtYXRyaXggdmFyaWFibGVzXG4gICAgdmFyIGEsIGIsIGMsIGQsIHR4LCB0eTtcblxuICAgIC8vIGxvb2tzIGxpa2Ugd2UgYXJlIHNrZXdpbmdcbiAgICBpZih0aGlzLnNrZXcueCB8fCB0aGlzLnNrZXcueSlcbiAgICB7XG4gICAgICAgIC8vIEknbSBhc3N1bWluZyB0aGF0IHNrZXdpbmcgaXMgbm90IGdvaW5nIHRvIGJlIHZlcnkgY29tbW9uXG4gICAgICAgIC8vIFdpdGggdGhhdCBpbiBtaW5kLCB3ZSBjYW4gZG8gYSBmdWxsIHNldFRyYW5zZm9ybSB1c2luZyB0aGUgdGVtcCBtYXRyaXhcbiAgICAgICAgX3RlbXBNYXRyaXguc2V0VHJhbnNmb3JtKFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54LFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55LFxuICAgICAgICAgICAgdGhpcy5waXZvdC54LFxuICAgICAgICAgICAgdGhpcy5waXZvdC55LFxuICAgICAgICAgICAgdGhpcy5zY2FsZS54LFxuICAgICAgICAgICAgdGhpcy5zY2FsZS55LFxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbixcbiAgICAgICAgICAgIHRoaXMuc2tldy54LFxuICAgICAgICAgICAgdGhpcy5za2V3LnlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBub3cgY29uY2F0IHRoZSBtYXRyaXggKGlubGluZWQgc28gdGhhdCB3ZSBjYW4gYXZvaWQgdXNpbmcgY29weSlcbiAgICAgICAgd3QuYSAgPSBfdGVtcE1hdHJpeC5hICAqIHB0LmEgKyBfdGVtcE1hdHJpeC5iICAqIHB0LmM7XG4gICAgICAgIHd0LmIgID0gX3RlbXBNYXRyaXguYSAgKiBwdC5iICsgX3RlbXBNYXRyaXguYiAgKiBwdC5kO1xuICAgICAgICB3dC5jICA9IF90ZW1wTWF0cml4LmMgICogcHQuYSArIF90ZW1wTWF0cml4LmQgICogcHQuYztcbiAgICAgICAgd3QuZCAgPSBfdGVtcE1hdHJpeC5jICAqIHB0LmIgKyBfdGVtcE1hdHJpeC5kICAqIHB0LmQ7XG4gICAgICAgIHd0LnR4ID0gX3RlbXBNYXRyaXgudHggKiBwdC5hICsgX3RlbXBNYXRyaXgudHkgKiBwdC5jICsgcHQudHg7XG4gICAgICAgIHd0LnR5ID0gX3RlbXBNYXRyaXgudHggKiBwdC5iICsgX3RlbXBNYXRyaXgudHkgKiBwdC5kICsgcHQudHk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIHNvIGlmIHJvdGF0aW9uIGlzIGJldHdlZW4gMCB0aGVuIHdlIGNhbiBzaW1wbGlmeSB0aGUgbXVsdGlwbGljYXRpb24gcHJvY2Vzcy4uLlxuICAgICAgICBpZiAodGhpcy5yb3RhdGlvbiAlIENPTlNULlBJXzIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcm90YXRpb24gaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJlbmRlci4gVGhpcyBtZWFucyB3ZSBvbmx5IG5lZWQgdG8gdXNlIHNpbiBhbmQgY29zIHdoZW4gcm90YXRpb24gYWN0dWFsbHkgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpb24gIT09IHRoaXMucm90YXRpb25DYWNoZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uQ2FjaGUgPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NyID0gTWF0aC5zaW4odGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3IgPSBNYXRoLmNvcyh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYXRyaXggdmFsdWVzIG9mIHRoZSBkaXNwbGF5b2JqZWN0IGJhc2VkIG9uIGl0cyB0cmFuc2Zvcm0gcHJvcGVydGllcy4uXG4gICAgICAgICAgICBhICA9ICB0aGlzLl9jciAqIHRoaXMuc2NhbGUueDtcbiAgICAgICAgICAgIGIgID0gIHRoaXMuX3NyICogdGhpcy5zY2FsZS54O1xuICAgICAgICAgICAgYyAgPSAtdGhpcy5fc3IgKiB0aGlzLnNjYWxlLnk7XG4gICAgICAgICAgICBkICA9ICB0aGlzLl9jciAqIHRoaXMuc2NhbGUueTtcbiAgICAgICAgICAgIHR4ID0gIHRoaXMucG9zaXRpb24ueDtcbiAgICAgICAgICAgIHR5ID0gIHRoaXMucG9zaXRpb24ueTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHBpdm90Li4gbm90IG9mdGVuIHVzZWQgc28gZ2VhcmVkIHRvd2FyZHMgdGhhdCBmYWN0IVxuICAgICAgICAgICAgaWYgKHRoaXMucGl2b3QueCB8fCB0aGlzLnBpdm90LnkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHggLT0gdGhpcy5waXZvdC54ICogYSArIHRoaXMucGl2b3QueSAqIGM7XG4gICAgICAgICAgICAgICAgdHkgLT0gdGhpcy5waXZvdC54ICogYiArIHRoaXMucGl2b3QueSAqIGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbmNhdCB0aGUgcGFyZW50IG1hdHJpeCB3aXRoIHRoZSBvYmplY3RzIHRyYW5zZm9ybS5cbiAgICAgICAgICAgIHd0LmEgID0gYSAgKiBwdC5hICsgYiAgKiBwdC5jO1xuICAgICAgICAgICAgd3QuYiAgPSBhICAqIHB0LmIgKyBiICAqIHB0LmQ7XG4gICAgICAgICAgICB3dC5jICA9IGMgICogcHQuYSArIGQgICogcHQuYztcbiAgICAgICAgICAgIHd0LmQgID0gYyAgKiBwdC5iICsgZCAgKiBwdC5kO1xuICAgICAgICAgICAgd3QudHggPSB0eCAqIHB0LmEgKyB0eSAqIHB0LmMgKyBwdC50eDtcbiAgICAgICAgICAgIHd0LnR5ID0gdHggKiBwdC5iICsgdHkgKiBwdC5kICsgcHQudHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBsZXRzIGRvIHRoZSBmYXN0IHZlcnNpb24gYXMgd2Uga25vdyB0aGVyZSBpcyBubyByb3RhdGlvbi4uXG4gICAgICAgICAgICBhICA9IHRoaXMuc2NhbGUueDtcbiAgICAgICAgICAgIGQgID0gdGhpcy5zY2FsZS55O1xuXG4gICAgICAgICAgICB0eCA9IHRoaXMucG9zaXRpb24ueCAtIHRoaXMucGl2b3QueCAqIGE7XG4gICAgICAgICAgICB0eSA9IHRoaXMucG9zaXRpb24ueSAtIHRoaXMucGl2b3QueSAqIGQ7XG5cbiAgICAgICAgICAgIHd0LmEgID0gYSAgKiBwdC5hO1xuICAgICAgICAgICAgd3QuYiAgPSBhICAqIHB0LmI7XG4gICAgICAgICAgICB3dC5jICA9IGQgICogcHQuYztcbiAgICAgICAgICAgIHd0LmQgID0gZCAgKiBwdC5kO1xuICAgICAgICAgICAgd3QudHggPSB0eCAqIHB0LmEgKyB0eSAqIHB0LmMgKyBwdC50eDtcbiAgICAgICAgICAgIHd0LnR5ID0gdHggKiBwdC5iICsgdHkgKiBwdC5kICsgcHQudHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtdWx0aXBseSB0aGUgYWxwaGFzLi5cbiAgICB0aGlzLndvcmxkQWxwaGEgPSB0aGlzLmFscGhhICogdGhpcy5wYXJlbnQud29ybGRBbHBoYTtcblxuICAgIC8vIHJlc2V0IHRoZSBib3VuZHMgZWFjaCB0aW1lIHRoaXMgaXMgY2FsbGVkIVxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xufTtcblxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSA9IERpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcblxuLyoqXG4gKlxuICpcbiAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICpcbiAqIEBwYXJhbSBtYXRyaXgge1BJWEkuTWF0cml4fVxuICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChtYXRyaXgpIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbntcbiAgICByZXR1cm4gbWF0aC5SZWN0YW5nbGUuRU1QVFk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICpcbiAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKG1hdGguTWF0cml4LklERU5USVRZKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxuICpcbiAqIEBwYXJhbSBwb3NpdGlvbiB7UElYSS5Qb2ludH0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbVxuICogQHJldHVybiB7UElYSS5Qb2ludH0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdFxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS50b0dsb2JhbCA9IGZ1bmN0aW9uIChwb3NpdGlvbilcbntcbiAgICAvLyB0aGlzIHBhcmVudCBjaGVjayBpcyBmb3IganVzdCBpbiBjYXNlIHRoZSBpdGVtIGlzIGEgcm9vdCBvYmplY3QuXG4gICAgLy8gSWYgaXQgaXMgd2UgbmVlZCB0byBnaXZlIGl0IGEgdGVtcG9yYXJ5IHBhcmVudCBzbyB0aGF0IGRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gd29ya3MgY29ycmVjdGx5XG4gICAgLy8gdGhpcyBpcyBtYWlubHkgdG8gYXZvaWQgYSBwYXJlbnQgY2hlY2sgaW4gdGhlIG1haW4gbG9vcC4gRXZlcnkgbGl0dGxlIGhlbHBzIGZvciBwZXJmb3JtYW5jZSA6KVxuICAgIGlmKCF0aGlzLnBhcmVudClcbiAgICB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgbG90XG4gICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHkocG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QgcmVsYXRpdmUgdG8gYW5vdGhlciBwb2ludFxuICpcbiAqIEBwYXJhbSBwb3NpdGlvbiB7UElYSS5Qb2ludH0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbVxuICogQHBhcmFtIFtmcm9tXSB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byBjYWxjdWxhdGUgdGhlIGdsb2JhbCBwb3NpdGlvbiBmcm9tXG4gKiBAcGFyYW0gW3BvaW50XSB7UElYSS5Qb2ludH0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbCAob3RoZXJ3aXNlIHdpbGwgY3JlYXRlIGEgbmV3IFBvaW50KVxuICogQHJldHVybiB7UElYSS5Qb2ludH0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdFxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS50b0xvY2FsID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBmcm9tLCBwb2ludClcbntcbiAgICBpZiAoZnJvbSlcbiAgICB7XG4gICAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxuICAgIC8vIElmIGl0IGlzIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBwYXJlbnQgc28gdGhhdCBkaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtIHdvcmtzIGNvcnJlY3RseVxuICAgIC8vIHRoaXMgaXMgbWFpbmx5IHRvIGF2b2lkIGEgcGFyZW50IGNoZWNrIGluIHRoZSBtYWluIGxvb3AuIEV2ZXJ5IGxpdHRsZSBoZWxwcyBmb3IgcGVyZm9ybWFuY2UgOilcbiAgICBpZighdGhpcy5wYXJlbnQpXG4gICAge1xuICAgICAgICB0aGlzLnBhcmVudCA9IF90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgLy8gc2ltcGx5IGFwcGx5IHRoZSBtYXRyaXguLlxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlclxuICogQHByaXZhdGVcbiAqL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbntcbiAgICAvLyBPVkVSV1JJVEU7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSBUaGUgcmVuZGVyZXJcbiAqIEBwcml2YXRlXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnJlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcikgLy8ganNoaW50IHVudXNlZDpmYWxzZVxue1xuICAgIC8vIE9WRVJXUklURTtcbn07XG4vKipcbiAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcbiAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGRpc3BsYXlPYmplY3QgaXMgc3RhdGljIC8gY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcGFyYW0gcmVzb2x1dGlvbiB7bnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZSBiZWluZyBnZW5lcmF0ZWRcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZW5lcmF0ZVRleHR1cmUgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbilcbntcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgUmVuZGVyVGV4dHVyZShyZW5kZXJlciwgYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDAsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbik7XG5cbiAgICBfdGVtcE1hdHJpeC50eCA9IC1ib3VuZHMueDtcbiAgICBfdGVtcE1hdHJpeC50eSA9IC1ib3VuZHMueTtcblxuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIF90ZW1wTWF0cml4KTtcblxuICAgIHJldHVybiByZW5kZXJUZXh0dXJlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhcmVudCBDb250YWluZXIgb2YgdGhpcyBEaXNwbGF5T2JqZWN0XG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciB7Q29udGFpbmVyfSBUaGUgQ29udGFpbmVyIHRvIGFkZCB0aGlzIERpc3BsYXlPYmplY3QgdG9cbiAqIEByZXR1cm4ge0NvbnRhaW5lcn0gVGhlIENvbnRhaW5lciB0aGF0IHRoaXMgRGlzcGxheU9iamVjdCB3YXMgYWRkZWQgdG9cbiAqL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKGNvbnRhaW5lcilcbntcbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLmFkZENoaWxkKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXInKTtcbiAgICB9XG5cbiAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcyk7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2V0IHRoZSBwb3N0aW9uLCBzY2FsZSwgc2tldyBhbmQgcGl2b3QgYXQgb25jZS5cbiAqXG4gKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gVGhlIFggcG9zaXRpb25cbiAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBUaGUgWSBwb3NpdGlvblxuICogQHBhcmFtIFtzY2FsZVg9MV0ge251bWJlcn0gVGhlIFggc2NhbGUgdmFsdWVcbiAqIEBwYXJhbSBbc2NhbGVZPTFdIHtudW1iZXJ9IFRoZSBZIHNjYWxlIHZhbHVlXG4gKiBAcGFyYW0gW3JvdGF0aW9uPTBdIHtudW1iZXJ9IFRoZSByb3RhdGlvblxuICogQHBhcmFtIFtza2V3WD0wXSB7bnVtYmVyfSBUaGUgWCBza2V3IHZhbHVlXG4gKiBAcGFyYW0gW3NrZXdZPTBdIHtudW1iZXJ9IFRoZSBZIHNrZXcgdmFsdWVcbiAqIEBwYXJhbSBbcGl2b3RYPTBdIHtudW1iZXJ9IFRoZSBYIHBpdm90IHZhbHVlXG4gKiBAcGFyYW0gW3Bpdm90WT0wXSB7bnVtYmVyfSBUaGUgWSBwaXZvdCB2YWx1ZVxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fVxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcGl2b3RYLCBwaXZvdFkpIC8vanNoaW50IGlnbm9yZTpsaW5lXG57XG4gICAgdGhpcy5wb3NpdGlvbi54ID0geCB8fCAwO1xuICAgIHRoaXMucG9zaXRpb24ueSA9IHkgfHwgMDtcbiAgICB0aGlzLnNjYWxlLnggPSAhc2NhbGVYID8gMSA6IHNjYWxlWDtcbiAgICB0aGlzLnNjYWxlLnkgPSAhc2NhbGVZID8gMSA6IHNjYWxlWTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24gfHwgMDtcbiAgICB0aGlzLnNrZXcueCA9IHNrZXdYIHx8IDA7XG4gICAgdGhpcy5za2V3LnkgPSBza2V3WSB8fCAwO1xuICAgIHRoaXMucGl2b3QueCA9IHBpdm90WCB8fCAwO1xuICAgIHRoaXMucGl2b3QueSA9IHBpdm90WSB8fCAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBCYXNlIGRlc3Ryb3kgbWV0aG9kIGZvciBnZW5lcmljIGRpc3BsYXkgb2JqZWN0c1xuICpcbiAqL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG5cbiAgICB0aGlzLnBvc2l0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNjYWxlID0gbnVsbDtcbiAgICB0aGlzLnBpdm90ID0gbnVsbDtcbiAgICB0aGlzLnNrZXcgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcbiAgICB0aGlzLl9tYXNrID0gbnVsbDtcblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL2Rpc3BsYXkvRGlzcGxheU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpLFxuICAgIFRleHR1cmUgPSByZXF1aXJlKCcuL1RleHR1cmUnKSxcbiAgICBSZW5kZXJUYXJnZXQgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvUmVuZGVyVGFyZ2V0JyksXG4gICAgRmlsdGVyTWFuYWdlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9GaWx0ZXJNYW5hZ2VyJyksXG4gICAgQ2FudmFzQnVmZmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNCdWZmZXInKSxcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICB0ZW1wTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCk7XG5cbi8qKlxuICogQSBSZW5kZXJUZXh0dXJlIGlzIGEgc3BlY2lhbCB0ZXh0dXJlIHRoYXQgYWxsb3dzIGFueSBQaXhpIGRpc3BsYXkgb2JqZWN0IHRvIGJlIHJlbmRlcmVkIHRvIGl0LlxuICpcbiAqIF9fSGludF9fOiBBbGwgRGlzcGxheU9iamVjdHMgKGkuZS4gU3ByaXRlcykgdGhhdCByZW5kZXIgdG8gYSBSZW5kZXJUZXh0dXJlIHNob3VsZCBiZSBwcmVsb2FkZWRcbiAqIG90aGVyd2lzZSBibGFjayByZWN0YW5nbGVzIHdpbGwgYmUgZHJhd24gaW5zdGVhZC5cbiAqXG4gKiBBIFJlbmRlclRleHR1cmUgdGFrZXMgYSBzbmFwc2hvdCBvZiBhbnkgRGlzcGxheSBPYmplY3QgZ2l2ZW4gdG8gaXRzIHJlbmRlciBtZXRob2QuIFRoZSBwb3NpdGlvblxuICogYW5kIHJvdGF0aW9uIG9mIHRoZSBnaXZlbiBEaXNwbGF5IE9iamVjdHMgaXMgaWdub3JlZC4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZW5kZXJlciA9IFBJWEkuYXV0b0RldGVjdFJlbmRlcmVyKDEwMjQsIDEwMjQsIHsgdmlldzogY2FudmFzLCByYXRpbzogMSB9KTtcbiAqIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFBJWEkuUmVuZGVyVGV4dHVyZShyZW5kZXJlciwgODAwLCA2MDApO1xuICogdmFyIHNwcml0ZSA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcInNwaW5PYmpfMDEucG5nXCIpO1xuICpcbiAqIHNwcml0ZS5wb3NpdGlvbi54ID0gODAwLzI7XG4gKiBzcHJpdGUucG9zaXRpb24ueSA9IDYwMC8yO1xuICogc3ByaXRlLmFuY2hvci54ID0gMC41O1xuICogc3ByaXRlLmFuY2hvci55ID0gMC41O1xuICpcbiAqIHJlbmRlclRleHR1cmUucmVuZGVyKHNwcml0ZSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgU3ByaXRlIGluIHRoaXMgY2FzZSB3aWxsIGJlIHJlbmRlcmVkIHRvIGEgcG9zaXRpb24gb2YgMCwwLiBUbyByZW5kZXIgdGhpcyBzcHJpdGUgYXQgaXRzIGFjdHVhbFxuICogcG9zaXRpb24gYSBDb250YWluZXIgc2hvdWxkIGJlIHVzZWQ6XG4gKlxuICogYGBganNcbiAqIHZhciBkb2MgPSBuZXcgUElYSS5Db250YWluZXIoKTtcbiAqXG4gKiBkb2MuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqXG4gKiByZW5kZXJUZXh0dXJlLnJlbmRlcihkb2MpOyAgLy8gUmVuZGVycyB0byBjZW50ZXIgb2YgcmVuZGVyVGV4dHVyZVxuICogYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLlRleHR1cmVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdXNlZCBmb3IgdGhpcyBSZW5kZXJUZXh0dXJlXG4gKiBAcGFyYW0gW3dpZHRoPTEwMF0ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICogQHBhcmFtIFtoZWlnaHQ9MTAwXSB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICogQHBhcmFtIFtzY2FsZU1vZGVdIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICogQHBhcmFtIFtyZXNvbHV0aW9uPTFdIHtudW1iZXJ9IFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZFxuICovXG5mdW5jdGlvbiBSZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pXG57XG4gICAgaWYgKCFyZW5kZXJlcilcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSBSZW5kZXJUZXh0dXJlLCB5b3UgbXVzdCBwYXNzIGEgcmVuZGVyZXIgaW50byB0aGUgY29uc3RydWN0b3IuJyk7XG4gICAgfVxuXG4gICAgd2lkdGggPSB3aWR0aCB8fCAxMDA7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDEwMDtcbiAgICByZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBDT05TVC5SRVNPTFVUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgdGV4dHVyZSBvYmplY3QgdGhhdCB0aGlzIHRleHR1cmUgdXNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7QmFzZVRleHR1cmV9XG4gICAgICovXG4gICAgdmFyIGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKCk7XG4gICAgYmFzZVRleHR1cmUud2lkdGggPSB3aWR0aDtcbiAgICBiYXNlVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgYmFzZVRleHR1cmUucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgYmFzZVRleHR1cmUuc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IENPTlNULlNDQUxFX01PREVTLkRFRkFVTFQ7XG4gICAgYmFzZVRleHR1cmUuaGFzTG9hZGVkID0gdHJ1ZTtcblxuXG4gICAgVGV4dHVyZS5jYWxsKHRoaXMsXG4gICAgICAgIGJhc2VUZXh0dXJlLFxuICAgICAgICBuZXcgbWF0aC5SZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICApO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2l0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIFJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIERyYXcvcmVuZGVyIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0IG9udG8gdGhlIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBUaGUgZGlzcGxheU9iamVjdCBhbmQgZGVzY2VuZGVudHMgYXJlIHRyYW5zZm9ybWVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBJZiBgdXBkYXRlVHJhbnNmb3JtYCBpcyB0cnVlIHRoZW4gdGhlIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIHJlc3RvcmVkIGJlZm9yZSB0aGVcbiAgICAgKiBtZXRob2QgcmV0dXJucy4gT3RoZXJ3aXNlIGl0IGlzIHVwIHRvIHRoZSBjYWxsaW5nIGNvZGUgdG8gY29ycmVjdGx5IHVzZSBvciByZXNldFxuICAgICAqIHRoZSB0cmFuc2Zvcm1lZCBkaXNwbGF5IG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBUaGUgZGlzcGxheSBvYmplY3QgaXMgYWx3YXlzIHJlbmRlcmVkIHdpdGggYSB3b3JsZEFscGhhIHZhbHVlIG9mIDEuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlciB0aGlzIHRleHR1cmUgb25cbiAgICAgKiBAcGFyYW0gW21hdHJpeF0ge1BJWEkuTWF0cml4fSBPcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IGJlZm9yZSByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIFtjbGVhcj1mYWxzZV0ge2Jvb2xlYW59IElmIHRydWUgdGhlIHRleHR1cmUgd2lsbCBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgZGlzcGxheU9iamVjdCBpcyBkcmF3blxuICAgICAqIEBwYXJhbSBbdXBkYXRlVHJhbnNmb3JtPXRydWVdIHtib29sZWFufSBJZiB0cnVlIHRoZSBkaXNwbGF5T2JqZWN0J3Mgd29ybGRUcmFuc2Zvcm0vd29ybGRBbHBoYSBhbmQgYWxsIGNoaWxkcmVuXG4gICAgICogIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIHJlc3RvcmVkLiBOb3QgcmVzdG9yaW5nIHRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhIGxpdHRsZSBmYXN0ZXIuXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlcmVyIHRoaXMgUmVuZGVyVGV4dHVyZSB1c2VzLiBBIFJlbmRlclRleHR1cmUgY2FuIG9ubHkgYmVsb25nIHRvIG9uZSByZW5kZXJlciBhdCB0aGUgbW9tZW50IGlmIGl0cyB3ZWJHTC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgIGlmICh0aGlzLnJlbmRlcmVyLnR5cGUgPT09IENPTlNULlJFTkRFUkVSX1RZUEUuV0VCR0wpXG4gICAge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgICAgIHRoaXMudGV4dHVyZUJ1ZmZlciA9IG5ldyBSZW5kZXJUYXJnZXQoZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBiYXNlVGV4dHVyZS5zY2FsZU1vZGUsIHRoaXMucmVzb2x1dGlvbik7Ly8sIHRoaXMuYmFzZVRleHR1cmUuc2NhbGVNb2RlKTtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gPSB0aGlzLnRleHR1cmVCdWZmZXIudGV4dHVyZTtcblxuICAgICAgICAvL1RPRE8gcmVmYWN0b3IgZmlsdGVyIG1hbmFnZXIuLiBhcyByZWFsbHkgaXRzIG5vIGxvbmdlciBhIG1hbmFnZXIgaWYgd2UgdXNlIGl0IGhlcmUuLlxuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBuZXcgRmlsdGVyTWFuYWdlcih0aGlzLnJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5maWx0ZXJNYW5hZ2VyLm9uQ29udGV4dENoYW5nZSgpO1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyV2ViR0w7XG5cbiAgICAgICAgLy8gdGhlIGNyZWF0aW9uIG9mIGEgZmlsdGVyIG1hbmFnZXIgdW5iaW5kcyB0aGUgYnVmZmVycy4uXG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXJDYW52YXM7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1ZmZlciA9IG5ldyBDYW52YXNCdWZmZXIodGhpcy53aWR0aCogdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCogdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgPSB0aGlzLnRleHR1cmVCdWZmZXIuY2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52YWxpZCA9IHRydWU7XG5cbiAgICB0aGlzLl91cGRhdGVVdnMoKTtcbn1cblxuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRleHR1cmUucHJvdG90eXBlKTtcblJlbmRlclRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVuZGVyVGV4dHVyZTtcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyVGV4dHVyZTtcblxuLyoqXG4gKiBSZXNpemVzIHRoZSBSZW5kZXJUZXh0dXJlLlxuICpcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggdG8gcmVzaXplIHRvLlxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IHRvIHJlc2l6ZSB0by5cbiAqIEBwYXJhbSB1cGRhdGVCYXNlIHtib29sZWFufSBTaG91bGQgdGhlIGJhc2VUZXh0dXJlLndpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIGJlIHJlc2l6ZWQgYXMgd2VsbD9cbiAqL1xuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZUJhc2UpXG57XG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZCA9ICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCk7XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5fZnJhbWUud2lkdGggPSB0aGlzLmNyb3Aud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9ICB0aGlzLl9mcmFtZS5oZWlnaHQgPSB0aGlzLmNyb3AuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKHVwZGF0ZUJhc2UpXG4gICAge1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmFsaWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICBpZih0aGlzLmZpbHRlck1hbmFnZXIpXG4gICAge1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgUmVuZGVyVGV4dHVyZS5cbiAqXG4gKi9cblJlbmRlclRleHR1cmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMudmFsaWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyZXIudHlwZSA9PT0gQ09OU1QuUkVOREVSRVJfVFlQRS5XRUJHTClcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMucmVuZGVyZXIuZ2wuRlJBTUVCVUZGRVIsIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCBhc3NpZ25lZCB0byB0aGUgYHJlbmRlcmAgcHJvcGVydHkgaWYgdXNpbmcgYSBDYW52YXNSZW5kZXJlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlciB0aGlzIHRleHR1cmUgb25cbiAqIEBwYXJhbSBbbWF0cml4XSB7UElYSS5NYXRyaXh9IE9wdGlvbmFsIG1hdHJpeCB0byBhcHBseSB0byB0aGUgZGlzcGxheSBvYmplY3QgYmVmb3JlIHJlbmRlcmluZy5cbiAqIEBwYXJhbSBbY2xlYXI9ZmFsc2VdIHtib29sZWFufSBJZiB0cnVlIHRoZSB0ZXh0dXJlIHdpbGwgYmUgY2xlYXJlZCBiZWZvcmUgdGhlIGRpc3BsYXlPYmplY3QgaXMgZHJhd25cbiAqIEBwYXJhbSBbdXBkYXRlVHJhbnNmb3JtPXRydWVdIHtib29sZWFufSBJZiB0cnVlIHRoZSBkaXNwbGF5T2JqZWN0J3Mgd29ybGRUcmFuc2Zvcm0vd29ybGRBbHBoYSBhbmQgYWxsIGNoaWxkcmVuXG4gKiAgdHJhbnNmb3JtYXRpb25zIHdpbGwgYmUgcmVzdG9yZWQuIE5vdCByZXN0b3JpbmcgdGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIGEgbGl0dGxlIGZhc3Rlci5cbiAqL1xuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAoZGlzcGxheU9iamVjdCwgbWF0cml4LCBjbGVhciwgdXBkYXRlVHJhbnNmb3JtKVxue1xuICAgIGlmICghdGhpcy52YWxpZClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIHVwZGF0ZVRyYW5zZm9ybSA9ICh1cGRhdGVUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkgPyB1cGRhdGVUcmFuc2Zvcm0gOiB0cnVlOy8vIXVwZGF0ZVRyYW5zZm9ybTtcblxuICAgIHRoaXMudGV4dHVyZUJ1ZmZlci50cmFuc2Zvcm0gPSBtYXRyaXg7XG5cbiAgICAvL1RPRE8gbm90IGEgZmFuIHRoYXQgdGhpcyBpcyBoZXJlLi4uIGl0IHdpbGwgbW92ZSFcbiAgICB0aGlzLnRleHR1cmVCdWZmZXIuYWN0aXZhdGUoKTtcblxuICAgIC8vIHNldFdvcmxkIEFscGhhIHRvIGVuc3VyZSB0aGF0IHRoZSBvYmplY3QgaXMgcmVuZGVyZXIgYXQgZnVsbCBvcGFjaXR5XG4gICAgZGlzcGxheU9iamVjdC53b3JsZEFscGhhID0gMTtcblxuICAgIGlmICh1cGRhdGVUcmFuc2Zvcm0pXG4gICAge1xuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBtYXRyaXggb2YgdGhlIGRpc3BsYXR5T2JqZWN0Li5cbiAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuXG4gICAgICAgIGRpc3BsYXlPYmplY3QuY3VycmVudEJvdW5kcyA9IG51bGw7XG5cbiAgICAgICAgLy8gVGltZSB0byB1cGRhdGUgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzcGxheU9iamVjdCB3aXRoIHRoZSBuZXcgbWF0cml4Li5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGksIGo7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1RPRE8gcmVuYW1lIHRleHR1cmVCdWZmZXIgdG8gcmVuZGVyVGFyZ2V0Li5cbiAgICB2YXIgdGVtcCA9ICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXI7XG5cbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIgPSB0aGlzLmZpbHRlck1hbmFnZXI7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJEaXNwbGF5T2JqZWN0KGRpc3BsYXlPYmplY3QsIHRoaXMudGV4dHVyZUJ1ZmZlciwgY2xlYXIpO1xuXG4gICAgdGhpcy5yZW5kZXJlci5maWx0ZXJNYW5hZ2VyID0gdGVtcDtcbn07XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBtZXRob2QgYXNzaWduZWQgdG8gdGhlIGByZW5kZXJgIHByb3BlcnR5IGlmIHVzaW5nIGEgQ2FudmFzUmVuZGVyZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXG4gKiBAcGFyYW0gW21hdHJpeF0ge1BJWEkuTWF0cml4fSBPcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IGJlZm9yZSByZW5kZXJpbmcuXG4gKiBAcGFyYW0gW2NsZWFyXSB7Ym9vbGVhbn0gSWYgdHJ1ZSB0aGUgdGV4dHVyZSB3aWxsIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGRyYXduXG4gKi9cblJlbmRlclRleHR1cmUucHJvdG90eXBlLnJlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCBtYXRyaXgsIGNsZWFyLCB1cGRhdGVUcmFuc2Zvcm0pXG57XG4gICAgaWYgKCF0aGlzLnZhbGlkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZVRyYW5zZm9ybSA9ICEhdXBkYXRlVHJhbnNmb3JtO1xuXG4gICAgdmFyIHd0ID0gdGVtcE1hdHJpeDtcblxuICAgIHd0LmlkZW50aXR5KCk7XG5cbiAgICBpZiAobWF0cml4KVxuICAgIHtcbiAgICAgICAgd3QuYXBwZW5kKG1hdHJpeCk7XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZFd0ID0gZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybTtcbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID0gd3Q7XG5cbiAgICAvLyBzZXRXb3JsZCBBbHBoYSB0byBlbnN1cmUgdGhhdCB0aGUgb2JqZWN0IGlzIHJlbmRlcmVyIGF0IGZ1bGwgb3BhY2l0eVxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRBbHBoYSA9IDE7XG5cbiAgICAvLyBUaW1lIHRvIHVwZGF0ZSBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXNwbGF5T2JqZWN0IHdpdGggdGhlIG5ldyBtYXRyaXguLlxuICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG4gICAgdmFyIGksIGo7XG5cbiAgICBmb3IgKGkgPSAwLCBqID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxuICAgIHtcbiAgICAgICAgY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgaWYgKGNsZWFyKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnVmZmVyLmNsZWFyKCk7XG4gICAgfVxuXG5cbi8vICAgIHRoaXMudGV4dHVyZUJ1ZmZlci5cbiAgICB2YXIgY29udGV4dCA9IHRoaXMudGV4dHVyZUJ1ZmZlci5jb250ZXh0O1xuXG4gICAgdmFyIHJlYWxSZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJEaXNwbGF5T2JqZWN0KGRpc3BsYXlPYmplY3QsIGNvbnRleHQpO1xuXG4gICAgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uID0gcmVhbFJlc29sdXRpb247XG5cbiAgICBpZihkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID09PSB3dClcbiAgICB7XG4gICAgICAgIC8vIGZpeGVzIGNhY2hlQXNCaXRtYXAgSGFwcGVuaW5nIGR1cmluZyB0aGUgYWJvdmUuLlxuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtID0gY2FjaGVkV3Q7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICpcbiAqIEBwYXJhbSBkZXN0cm95QmFzZSB7Ym9vbGVhbn0gV2hldGhlciB0byBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgYXMgd2VsbFxuICovXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICBUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgdHJ1ZSk7XG5cbiAgICB0aGlzLnRleHR1cmVCdWZmZXIuZGVzdHJveSgpO1xuXG4gICAgLy8gZGVzdHJveSB0aGUgZmlsdGVybWFuYWdlci4uXG4gICAgaWYodGhpcy5maWx0ZXJNYW5hZ2VyKVxuICAgIHtcbiAgICAgICAgdGhpcy5maWx0ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBIVE1MIEltYWdlIG9mIHRoZSB0ZXh0dXJlXG4gKlxuICogQHJldHVybiB7SW1hZ2V9XG4gKi9cblJlbmRlclRleHR1cmUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSB0aGlzLmdldEJhc2U2NCgpO1xuICAgIHJldHVybiBpbWFnZTtcbn07XG5cbi8qKlxuICogV2lsbCByZXR1cm4gYSBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiB0aGlzIHRleHR1cmUuIEl0IHdvcmtzIGJ5IGNhbGxpbmcgUmVuZGVyVGV4dHVyZS5nZXRDYW52YXMgYW5kIHRoZW4gcnVubmluZyB0b0RhdGFVUkwgb24gdGhhdC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIHRoZSB0ZXh0dXJlLlxuICovXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5nZXRCYXNlNjQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLmdldENhbnZhcygpLnRvRGF0YVVSTCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQsIHJlbmRlcnMgdGhpcyBSZW5kZXJUZXh0dXJlIHRvIGl0IGFuZCB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEEgQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgdGV4dHVyZSByZW5kZXJlZCBvbi5cbiAqL1xuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuZ2V0Q2FudmFzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0dXJlQnVmZmVyLnNpemUud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnRleHR1cmVCdWZmZXIuc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHdlYkdMUGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHdpZHRoICogaGVpZ2h0KTtcblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViR0xQaXhlbHMpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgICAgIHZhciB0ZW1wQ2FudmFzID0gbmV3IENhbnZhc0J1ZmZlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0ZW1wQ2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjYW52YXNEYXRhLmRhdGEuc2V0KHdlYkdMUGl4ZWxzKTtcblxuICAgICAgICB0ZW1wQ2FudmFzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuXG4gICAgICAgIHJldHVybiB0ZW1wQ2FudmFzLmNhbnZhcztcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUJ1ZmZlci5jYW52YXM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXaWxsIHJldHVybiBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZSBpbiBSR0JBIG9yZGVyLCB3aXRoIGludGVnZXIgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjU1IChpbmNsdWRlZCkuXG4gKlxuICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl9XG4gKi9cblJlbmRlclRleHR1cmUucHJvdG90eXBlLmdldFBpeGVscyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgd2lkdGggPSB0aGlzLnRleHR1cmVCdWZmZXIuc2l6ZS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy50ZXh0dXJlQnVmZmVyLnNpemUuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB3ZWJHTFBpeGVscyA9IG5ldyBVaW50OEFycmF5KDQgKiB3aWR0aCAqIGhlaWdodCk7XG5cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLnRleHR1cmVCdWZmZXIuZnJhbWVCdWZmZXIpO1xuICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHdlYkdMUGl4ZWxzKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICByZXR1cm4gd2ViR0xQaXhlbHM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHdpZHRoID0gdGhpcy50ZXh0dXJlQnVmZmVyLmNhbnZhcy53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy50ZXh0dXJlQnVmZmVyLmNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUJ1ZmZlci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgb25lLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgb2YgYSBwaXhlbCB3aXRoaW4gdGhlIHRleHR1cmUgaW4gUkdCQSBvcmRlciwgd2l0aCBpbnRlZ2VyIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDI1NSAoaW5jbHVkZWQpLlxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBpeGVsIHRvIHJldHJpZXZlLlxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgcGl4ZWwgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheX1cbiAqL1xuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuZ2V0UGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICB2YXIgd2ViR0xQaXhlbHMgPSBuZXcgVWludDhBcnJheSg0KTtcblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViR0xQaXhlbHMpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgICAgIHJldHVybiB3ZWJHTFBpeGVscztcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUJ1ZmZlci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoeCwgeSwgMSwgMSkuZGF0YTtcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3RleHR1cmVzL1JlbmRlclRleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxuLyoqXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2UuIEFsbCB0ZXh0dXJlcyBoYXZlIGEgYmFzZSB0ZXh0dXJlLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBzb3VyY2Uge0ltYWdlfENhbnZhc30gdGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIHRleHR1cmUuXG4gKiBAcGFyYW0gW3NjYWxlTW9kZT1QSVhJLlNDQUxFX01PREVTLkRFRkFVTFRdIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gdGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgZm9yIGRldmljZXMgd2l0aCBkaWZmZXJlbnQgcGl4ZWwgcmF0aW9zXG4gKi9cbmZ1bmN0aW9uIEJhc2VUZXh0dXJlKHNvdXJjZSwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKVxue1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy51aWQgPSB1dGlscy51aWQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBSZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMTAwO1xuXG4gICAgLy8gVE9ETyBkb2NzXG4gICAgLy8gdXNlZCB0byBzdG9yZSB0aGUgYWN0dWFsIGRpbWVuc2lvbnMgb2YgdGhlIHNvdXJjZVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3RvcmUgdGhlIGFjdHVhbCB3aWR0aCBvZiB0aGUgc291cmNlIG9mIHRoaXMgdGV4dHVyZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMucmVhbFdpZHRoID0gMTAwO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3RvcmUgdGhlIGFjdHVhbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnJlYWxIZWlnaHQgPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS5TQ0FMRV9NT0RFUy5MSU5FQVJcbiAgICAgKiBAc2VlIFBJWEkuU0NBTEVfTU9ERVNcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSB8fCBDT05TVC5TQ0FMRV9NT0RFUy5ERUZBVUxUO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgb25jZSB0aGUgYmFzZSB0ZXh0dXJlIGhhcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBuZXZlciB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBmYWlscyB0byBsb2FkIG9yIGhhcyBubyB0ZXh0dXJlIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuaGFzTG9hZGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB0aGUgc291cmNlIGlzIGN1cnJlbnRseSBsb2FkaW5nLlxuICAgICAqXG4gICAgICogSWYgYW4gSW1hZ2Ugc291cmNlIGlzIGxvYWRpbmcgdGhlICdsb2FkZWQnIG9yICdlcnJvcicgZXZlbnQgd2lsbCBiZVxuICAgICAqIGRpc3BhdGNoZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGVuZHMuIEFuIHVuZGVyeWxpbmcgc291cmNlIHRoYXQgaXNcbiAgICAgKiBpbW1lZGlhdGVseS1hdmFpbGFibGUgYnlwYXNzZXMgbG9hZGluZyBlbnRpcmVseS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBzb3VyY2UgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIFRPRE86IE1ha2UgdGhpcyBhIHNldHRlciB0aGF0IGNhbGxzIGxvYWRTb3VyY2UoKTtcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0ltYWdlfENhbnZhc31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7IC8vIHNldCBpbiBsb2FkU291cmNlLCBpZiBhdCBhbGxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIGlmIFJHQiBjaGFubmVscyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgYnkgQWxwaGEgIChXZWJHTCBvbmx5KVxuICAgICAqIEFsbCBibGVuZCBtb2RlcywgYW5kIHNoYWRlcnMgd3JpdHRlbiBmb3IgZGVmYXVsdCB2YWx1ZS4gQ2hhbmdlIGl0IG9uIHlvdXIgb3duIHJpc2suXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVVybCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXZXRoZXIgb3Igbm90IHRoZSB0ZXh0dXJlIGlzIGEgcG93ZXIgb2YgdHdvLCB0cnkgdG8gdXNlIHBvd2VyIG9mIHR3byB0ZXh0dXJlcyBhcyBtdWNoIGFzIHlvdSBjYW5cbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSBmYWxzZTtcblxuICAgIC8vIHVzZWQgZm9yIHdlYkdMXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgYSBtaXBtYXAgb2YgdGhpcyB0ZXh0dXJlIG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4gVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIHRoZSB0ZXh0dXJlIGlzIHVzZWRcbiAgICAgKiBBbHNvIHRoZSB0ZXh0dXJlIG11c3QgYmUgYSBwb3dlciBvZiB0d28gc2l6ZSB0byB3b3JrXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgdGV4dHVyZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIFdlYkdMVGV4dHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9nbFRleHR1cmVzID0ge307XG5cbiAgICAvLyBpZiBubyBzb3VyY2UgcGFzc2VkIGRvbid0IHRyeSB0byBsb2FkXG4gICAgaWYgKHNvdXJjZSlcbiAgICB7XG4gICAgICAgIHRoaXMubG9hZFNvdXJjZShzb3VyY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBub3QtaW1tZWRpYXRlbHktYXZhaWxhYmxlIHNvdXJjZSBmaW5pc2hlcyBsb2FkaW5nLlxuICAgICAqXG4gICAgICogQGV2ZW50IGxvYWRlZFxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkJhc2VUZXh0dXJlI1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBub3QtaW1tZWRpYXRlbHktYXZhaWxhYmxlIHNvdXJjZSBmYWlscyB0byBsb2FkLlxuICAgICAqXG4gICAgICogQGV2ZW50IGVycm9yXG4gICAgICogQG1lbWJlcm9mIFBJWEkuQmFzZVRleHR1cmUjXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xufVxuXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQmFzZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZVRleHR1cmU7XG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VUZXh0dXJlO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHRleHR1cmUgb24gYWxsIHRoZSB3ZWJnbCByZW5kZXJlcnMsIHRoaXMgYWxzbyBhc3N1bWVzIHRoZSBzcmMgaGFzIGNoYW5nZWQuXG4gKlxuICogQGZpcmVzIHVwZGF0ZVxuICovXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnJlYWxXaWR0aCA9IHRoaXMuc291cmNlLm5hdHVyYWxXaWR0aCB8fCB0aGlzLnNvdXJjZS53aWR0aDtcbiAgICB0aGlzLnJlYWxIZWlnaHQgPSB0aGlzLnNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHRoaXMuc291cmNlLmhlaWdodDtcblxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJlYWxXaWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMucmVhbEhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcblxuICAgIHRoaXMuaXNQb3dlck9mVHdvID0gdXRpbHMuaXNQb3dlck9mVHdvKHRoaXMucmVhbFdpZHRoLCB0aGlzLnJlYWxIZWlnaHQpO1xuXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcbn07XG5cbi8qKlxuICogTG9hZCBhIHNvdXJjZS5cbiAqXG4gKiBJZiB0aGUgc291cmNlIGlzIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUsIHN1Y2ggYXMgYW4gaW1hZ2UgdGhhdCBuZWVkcyB0byBiZVxuICogZG93bmxvYWRlZCwgdGhlbiB0aGUgJ2xvYWRlZCcgb3IgJ2Vycm9yJyBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgaW4gdGhlIGZ1dHVyZVxuICogYW5kIGBoYXNMb2FkZWRgIHdpbGwgcmVtYWluIGZhbHNlIGFmdGVyIHRoaXMgY2FsbC5cbiAqXG4gKiBUaGUgbG9naWMgc3RhdGUgYWZ0ZXIgY2FsbGluZyBgbG9hZFNvdXJjZWAgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSAoZWcuIGBmcm9tSW1hZ2VgLCBgbmV3IEJhc2VUZXh0dXJlYCkgaXM6XG4gKlxuICogICAgIGlmICh0ZXh0dXJlLmhhc0xvYWRlZClcbiB7XG4gKiAgICAgICAgLy8gdGV4dHVyZSByZWFkeSBmb3IgdXNlXG4gKiAgICAgfSBlbHNlIGlmICh0ZXh0dXJlLmlzTG9hZGluZylcbiB7XG4gKiAgICAgICAgLy8gbGlzdGVuIHRvICdsb2FkZWQnIGFuZC9vciAnZXJyb3InIGV2ZW50cyBvbiB0ZXh0dXJlXG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAvLyBub3QgbG9hZGluZywgbm90IGdvaW5nIHRvIGxvYWQgVU5MRVNTIHRoZSBzb3VyY2UgaXMgcmVsb2FkZWRcbiAqICAgICAgICAvLyAoaXQgbWF5IHN0aWxsIG1ha2Ugc2Vuc2UgdG8gbGlzdGVuIHRvIHRoZSBldmVudHMpXG4gKiAgICAgfVxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSBzb3VyY2Uge0ltYWdlfENhbnZhc30gdGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIHRleHR1cmUuXG4gKi9cbkJhc2VUZXh0dXJlLnByb3RvdHlwZS5sb2FkU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSlcbntcbiAgICB2YXIgd2FzTG9hZGluZyA9IHRoaXMuaXNMb2FkaW5nO1xuICAgIHRoaXMuaGFzTG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgIGlmICh3YXNMb2FkaW5nICYmIHRoaXMuc291cmNlKVxuICAgIHtcbiAgICAgICAgdGhpcy5zb3VyY2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2Uub25lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAvLyBBcHBseSBzb3VyY2UgaWYgbG9hZGVkLiBPdGhlcndpc2Ugc2V0dXAgYXBwcm9wcmlhdGUgbG9hZGluZyBtb25pdG9ycy5cbiAgICBpZiAoKHRoaXMuc291cmNlLmNvbXBsZXRlIHx8IHRoaXMuc291cmNlLmdldENvbnRleHQpICYmIHRoaXMuc291cmNlLndpZHRoICYmIHRoaXMuc291cmNlLmhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMuX3NvdXJjZUxvYWRlZCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc291cmNlLmdldENvbnRleHQpXG4gICAge1xuXG4gICAgICAgIC8vIEltYWdlIGZhaWwgLyBub3QgcmVhZHlcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgc291cmNlLm9ubG9hZCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIXNjb3BlLmlzTG9hZGluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc2NvcGUuX3NvdXJjZUxvYWRlZCgpO1xuXG4gICAgICAgICAgICBzY29wZS5lbWl0KCdsb2FkZWQnLCBzY29wZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc291cmNlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFzY29wZS5pc0xvYWRpbmcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY29wZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjb3BlLmVtaXQoJ2Vycm9yJywgc2NvcGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBlciBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCN0aGUtaW1nLWVsZW1lbnRcbiAgICAgICAgLy8gICBcIlRoZSB2YWx1ZSBvZiBgY29tcGxldGVgIGNhbiB0aHVzIGNoYW5nZSB3aGlsZSBhIHNjcmlwdCBpcyBleGVjdXRpbmcuXCJcbiAgICAgICAgLy8gU28gY29tcGxldGUgbmVlZHMgdG8gYmUgcmUtY2hlY2tlZCBhZnRlciB0aGUgY2FsbGJhY2tzIGhhdmUgYmVlbiBhZGRlZC4uXG4gICAgICAgIC8vIE5PVEU6IGNvbXBsZXRlIHdpbGwgYmUgdHJ1ZSBpZiB0aGUgaW1hZ2UgaGFzIG5vIHNyYyBzbyBiZXN0IHRvIGNoZWNrIGlmIHRoZSBzcmMgaXMgc2V0LlxuICAgICAgICBpZiAoc291cmNlLmNvbXBsZXRlICYmIHNvdXJjZS5zcmMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIC4uYW5kIGlmIHdlJ3JlIGNvbXBsZXRlIG5vdywgbm8gbmVlZCBmb3IgY2FsbGJhY2tzXG4gICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZUxvYWRlZCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IHByZXZpb3VzIHN1YnNjcmliZXJzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgaWYgKHdhc0xvYWRpbmcpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgcHJldmlvdXMgc3Vic2NyaWJlcnMgcG9zc2libGVcbiAgICAgICAgICAgICAgICBpZiAod2FzTG9hZGluZylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFVzZWQgaW50ZXJuYWxseSB0byB1cGRhdGUgdGhlIHdpZHRoLCBoZWlnaHQsIGFuZCBzb21lIG90aGVyIHRyYWNraW5nIHZhcnMgb25jZVxuICogYSBzb3VyY2UgaGFzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQmFzZVRleHR1cmUucHJvdG90eXBlLl9zb3VyY2VMb2FkZWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIGJhc2UgdGV4dHVyZVxuICpcbiAqL1xuQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLmltYWdlVXJsKVxuICAgIHtcbiAgICAgICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbdGhpcy5pbWFnZVVybF07XG4gICAgICAgIGRlbGV0ZSB1dGlscy5UZXh0dXJlQ2FjaGVbdGhpcy5pbWFnZVVybF07XG5cbiAgICAgICAgdGhpcy5pbWFnZVVybCA9IG51bGw7XG5cbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IuaXNDb2Nvb25KUylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3JjID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2UuX3BpeGlJZClcbiAgICB7XG4gICAgICAgIGRlbGV0ZSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW3RoaXMuc291cmNlLl9waXhpSWRdO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlID0gbnVsbDtcblxuICAgIHRoaXMuZGlzcG9zZSgpO1xufTtcblxuLyoqXG4gKiBGcmVlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMIG1lbW9yeSB3aXRob3V0IGRlc3Ryb3lpbmcgdGhpcyB0ZXh0dXJlIG9iamVjdC5cbiAqIFRoaXMgbWVhbnMgeW91IGNhbiBzdGlsbCB1c2UgdGhlIHRleHR1cmUgbGF0ZXIgd2hpY2ggd2lsbCB1cGxvYWQgaXQgdG8gR1BVXG4gKiBtZW1vcnkgYWdhaW4uXG4gKlxuICovXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5lbWl0KCdkaXNwb3NlJywgdGhpcyk7XG5cbiAgICAvLyB0aGlzIHNob3VsZCBubyBsb25nZXIgYmUgbmVlZGVkLCB0aGUgcmVuZGVyZXJzIHNob3VsZCBjbGVhbnVwIGFsbCB0aGUgZ2wgdGV4dHVyZXMuXG4gICAgLy8gdGhpcy5fZ2xUZXh0dXJlcyA9IHt9O1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBzb3VyY2UgaW1hZ2Ugb2YgdGhlIHRleHR1cmUuXG4gKiBUaGUgb3JpZ2luYWwgc291cmNlIG11c3QgYmUgYW4gSW1hZ2UgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gbmV3U3JjIHtzdHJpbmd9IHRoZSBwYXRoIG9mIHRoZSBpbWFnZVxuICovXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlU291cmNlSW1hZ2UgPSBmdW5jdGlvbiAobmV3U3JjKVxue1xuICAgIHRoaXMuc291cmNlLnNyYyA9IG5ld1NyYztcblxuICAgIHRoaXMubG9hZFNvdXJjZSh0aGlzLnNvdXJjZSk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBiYXNlIHRleHR1cmUgZnJvbSB0aGUgZ2l2ZW4gaW1hZ2UgdXJsLlxuICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBpbWFnZVVybCB7c3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gW2Nyb3Nzb3JpZ2luPShhdXRvKV0ge2Jvb2xlYW59IFNob3VsZCB1c2UgYW5vbnltb3VzIENPUlM/IERlZmF1bHRzIHRvIHRydWUgaWYgdGhlIFVSTCBpcyBub3QgYSBkYXRhLVVSSS5cbiAqIEBwYXJhbSBbc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuREVGQVVMVF0ge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIFBJWEkuQmFzZVRleHR1cmVcbiAqL1xuQmFzZVRleHR1cmUuZnJvbUltYWdlID0gZnVuY3Rpb24gKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxue1xuICAgIHZhciBiYXNlVGV4dHVyZSA9IHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuXG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQgJiYgaW1hZ2VVcmwuaW5kZXhPZignZGF0YTonKSAhPT0gMClcbiAgICB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2VUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgLy8gbmV3IEltYWdlKCkgYnJlYWtzIHRleCBsb2FkaW5nIGluIHNvbWUgdmVyc2lvbnMgb2YgQ2hyb21lLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIzODA3MVxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsvL2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShpbWFnZSwgc2NhbGVNb2RlKTtcbiAgICAgICAgYmFzZVRleHR1cmUuaW1hZ2VVcmwgPSBpbWFnZVVybDtcblxuICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVVybDtcblxuICAgICAgICB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXSA9IGJhc2VUZXh0dXJlO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIEAyeCBhdCB0aGUgZW5kIG9mIHRoZSB1cmwgd2UgYXJlIGdvaW5nIHRvIGFzc3VtZSBpdHMgYSBoaWdocmVzIGltYWdlXG4gICAgICAgIGJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwoaW1hZ2VVcmwpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGJhc2UgdGV4dHVyZSBmcm9tIHRoZSBnaXZlbiBjYW52YXMgZWxlbWVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIFBJWEkuQmFzZVRleHR1cmVcbiAqL1xuQmFzZVRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIChjYW52YXMsIHNjYWxlTW9kZSlcbntcbiAgICBpZiAoIWNhbnZhcy5fcGl4aUlkKVxuICAgIHtcbiAgICAgICAgY2FudmFzLl9waXhpSWQgPSAnY2FudmFzXycgKyB1dGlscy51aWQoKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2NhbnZhcy5fcGl4aUlkXTtcblxuICAgIGlmICghYmFzZVRleHR1cmUpXG4gICAge1xuICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShjYW52YXMsIHNjYWxlTW9kZSk7XG4gICAgICAgIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbY2FudmFzLl9waXhpSWRdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS90ZXh0dXJlcy9CYXNlVGV4dHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpLFxuICAgIFZpZGVvQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuL1ZpZGVvQmFzZVRleHR1cmUnKSxcbiAgICBUZXh0dXJlVXZzID0gcmVxdWlyZSgnLi9UZXh0dXJlVXZzJyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpLFxuICAgIG1hdGggPSByZXF1aXJlKCcuLi9tYXRoJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgdGV4dHVyZSBzdG9yZXMgdGhlIGluZm9ybWF0aW9uIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZSBvciBwYXJ0IG9mIGFuIGltYWdlLiBJdCBjYW5ub3QgYmUgYWRkZWRcbiAqIHRvIHRoZSBkaXNwbGF5IGxpc3QgZGlyZWN0bHkuIEluc3RlYWQgdXNlIGl0IGFzIHRoZSB0ZXh0dXJlIGZvciBhIFNwcml0ZS4gSWYgbm8gZnJhbWUgaXMgcHJvdmlkZWQgdGhlbiB0aGUgd2hvbGUgaW1hZ2UgaXMgdXNlZC5cbiAqXG4gKiBZb3UgY2FuIGRpcmVjdGx5IGNyZWF0ZSBhIHRleHR1cmUgZnJvbSBhbiBpbWFnZSBhbmQgdGhlbiByZXVzZSBpdCBtdWx0aXBsZSB0aW1lcyBsaWtlIHRoaXMgOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoJ2Fzc2V0cy9pbWFnZS5wbmcnKTtcbiAqIHZhciBzcHJpdGUxID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuICogdmFyIHNwcml0ZTIgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gYmFzZVRleHR1cmUge1BJWEkuQmFzZVRleHR1cmV9IFRoZSBiYXNlIHRleHR1cmUgc291cmNlIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZSBmcm9tXG4gKiBAcGFyYW0gW2ZyYW1lXSB7UElYSS5SZWN0YW5nbGV9IFRoZSByZWN0YW5nbGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2hvd1xuICogQHBhcmFtIFtjcm9wXSB7UElYSS5SZWN0YW5nbGV9IFRoZSBhcmVhIG9mIG9yaWdpbmFsIHRleHR1cmVcbiAqIEBwYXJhbSBbdHJpbV0ge1BJWEkuUmVjdGFuZ2xlfSBUcmltbWVkIHRleHR1cmUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gW3JvdGF0ZV0ge251bWJlcn0gaW5kaWNhdGVzIGhvdyB0aGUgdGV4dHVyZSB3YXMgcm90YXRlZCBieSB0ZXh0dXJlIHBhY2tlci4gU2VlIHtAbGluayBQSVhJLkdyb3VwRDh9XG4gKi9cbmZ1bmN0aW9uIFRleHR1cmUoYmFzZVRleHR1cmUsIGZyYW1lLCBjcm9wLCB0cmltLCByb3RhdGUpXG57XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcblxuICAgIGlmICghZnJhbWUpXG4gICAge1xuICAgICAgICB0aGlzLm5vRnJhbWUgPSB0cnVlO1xuICAgICAgICBmcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBzcGVjaWZpZXMgdGhlIHJlZ2lvbiBvZiB0aGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHRyaW0gZGF0YS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIHRoaXMudHJpbSA9IHRyaW07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgbGV0IHRoZSByZW5kZXJlciBrbm93IGlmIHRoZSB0ZXh0dXJlIGlzIHZhbGlkLiBJZiBpdCdzIG5vdCB0aGVuIGl0IGNhbm5vdCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gdXBkYXRlZCAodXNlZCBtYWlubHkgZm9yIHdlYkdMIHV2IHVwZGF0ZXMpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWlyZXNVcGRhdGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJHTCBVViBkYXRhIGNhY2hlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlVXZzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdXZzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcbiAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICB0aGlzLmNyb3AgPSBjcm9wIHx8IGZyYW1lOy8vbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuXG4gICAgdGhpcy5fcm90YXRlID0gKyhyb3RhdGUgfHwgMCk7XG5cbiAgICBpZiAocm90YXRlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgb2xkIHRleHR1cmVwYWNrZXIgbGVnYWN5LCBzb21lIGdhbWVzL2xpYnJhcmllcyBhcmUgcGFzc2luZyBcInRydWVcIiBmb3Igcm90YXRlZCB0ZXh0dXJlc1xuICAgICAgICB0aGlzLl9yb3RhdGUgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3RhdGUgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnYXR0ZW1wdCB0byB1c2UgZGlhbW9uZC1zaGFwZWQgVVZzLiBJZiB5b3UgYXJlIHN1cmUsIHNldCByb3RhdGlvbiBtYW51YWxseSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubm9GcmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyYW1lIHdlIHNob3VsZCBtb25pdG9yIGZvciBhbnkgYmFzZSB0ZXh0dXJlIGNoYW5nZXMuLlxuICAgICAgICAgICAgYmFzZVRleHR1cmUub24oJ3VwZGF0ZScsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgYmFzZVRleHR1cmUub25jZSgnbG9hZGVkJywgdGhpcy5vbkJhc2VUZXh0dXJlTG9hZGVkLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQuIFRoaXMgaGFwcGVucyBpZiB0aGUgZnJhbWUgb3IgdGhlIGJhc2VUZXh0dXJlIGlzIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgdXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBJWEkuVGV4dHVyZSNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG59XG5cblRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZTtcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dHVyZS5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWUgc3BlY2lmaWVzIHRoZSByZWdpb24gb2YgdGhlIGJhc2UgdGV4dHVyZSB0aGF0IHRoaXMgdGV4dHVyZSB1c2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuVGV4dHVyZSNcbiAgICAgKi9cbiAgICBmcmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG5cbiAgICAgICAgICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGZyYW1lLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRyaW0gJiYgIXRoaXMucm90YXRlICYmIChmcmFtZS54ICsgZnJhbWUud2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoIHx8IGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQgPiB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9ucyAnICsgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdGhpcy52YWxpZCA9IGZyYW1lICYmIGZyYW1lLndpZHRoICYmIGZyYW1lLmhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnNvdXJjZSAmJiB0aGlzLmJhc2VUZXh0dXJlLmhhc0xvYWRlZDtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyaW0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudHJpbS53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudHJpbS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWUud2lkdGggPSB0aGlzLnRyaW0ud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gdGhpcy50cmltLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3AgPSBmcmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVXZzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIGlzIHJvdGF0ZWQgaW5zaWRlIHRoZSBhdGxhc1xuICAgICAqIHNldCB0byAyIHRvIGNvbXBlbnNhdGUgZm9yIHRleHR1cmUgcGFja2VyIHJvdGF0aW9uXG4gICAgICogc2V0IHRvIDYgdG8gY29tcGVuc2F0ZSBmb3Igc3BpbmUgcGFja2VyIHJvdGF0aW9uXG4gICAgICogY2FuIGJlIHVzZWQgdG8gcm90YXRlIG9yIG1pcnJvciBzcHJpdGVzXG4gICAgICogU2VlIHtAbGluayBQSVhJLkdyb3VwRDh9IGZvciBleHBsYW5hdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJvdGF0ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHJvdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fcm90YXRlID0gcm90YXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVXZzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgdGV4dHVyZSBvbiB0aGUgZ3B1LlxuICpcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmJhc2VUZXh0dXJlLnVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgYmFzZSB0ZXh0dXJlIGlzIGxvYWRlZFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLm9uQmFzZVRleHR1cmVMb2FkZWQgPSBmdW5jdGlvbiAoYmFzZVRleHR1cmUpXG57XG4gICAgLy8gVE9ETyB0aGlzIGNvZGUgbG9va3MgY29uZnVzaW5nLi4gYm9vIHRvIGFidXNpbmcgZ2V0dGVycyBhbmQgc2V0dGVyc3MhXG4gICAgaWYgKHRoaXMubm9GcmFtZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuZnJhbWUgPSB0aGlzLl9mcmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgYmFzZSB0ZXh0dXJlIGlzIHVwZGF0ZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5vbkJhc2VUZXh0dXJlVXBkYXRlZCA9IGZ1bmN0aW9uIChiYXNlVGV4dHVyZSlcbntcbiAgICB0aGlzLl9mcmFtZS53aWR0aCA9IGJhc2VUZXh0dXJlLndpZHRoO1xuICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IGJhc2VUZXh0dXJlLmhlaWdodDtcblxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcyk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICpcbiAqIEBwYXJhbSBbZGVzdHJveUJhc2U9ZmFsc2VdIHtib29sZWFufSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZGVzdHJveUJhc2UpXG57XG4gICAgaWYgKHRoaXMuYmFzZVRleHR1cmUpXG4gICAge1xuICAgICAgICBpZiAoZGVzdHJveUJhc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5vZmYoJ3VwZGF0ZScsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9mZignbG9hZGVkJywgdGhpcy5vbkJhc2VUZXh0dXJlTG9hZGVkLCB0aGlzKTtcblxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9mcmFtZSA9IG51bGw7XG4gICAgdGhpcy5fdXZzID0gbnVsbDtcbiAgICB0aGlzLnRyaW0gPSBudWxsO1xuICAgIHRoaXMuY3JvcCA9IG51bGw7XG5cbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSwgdGhpcyk7XG4gICAgdGhpcy5vZmYoJ3VwZGF0ZScsIHRoaXMudXBkYXRlLCB0aGlzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0ZXh0dXJlIG9iamVjdCB0aGF0IGFjdHMgdGhlIHNhbWUgYXMgdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB7UElYSS5UZXh0dXJlfVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIHRoaXMuZnJhbWUsIHRoaXMuY3JvcCwgdGhpcy50cmltLCB0aGlzLnJvdGF0ZSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLl91cGRhdGVVdnMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy5fdXZzKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdXZzID0gbmV3IFRleHR1cmVVdnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl91dnMuc2V0KHRoaXMuY3JvcCwgdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5yb3RhdGUpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgVGV4dHVyZSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gaW1hZ2UgdXJsLlxuICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlICBjcmVhdGVkIGFuZCBsb2FkZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGltYWdlVXJsIHtzdHJpbmd9IFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBjcm9zc29yaWdpbiB7Ym9vbGVhbn0gV2hldGhlciByZXF1ZXN0cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBjcm9zc29yaWdpblxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIChpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IHV0aWxzLlRleHR1cmVDYWNoZVtpbWFnZVVybF07XG5cbiAgICBpZiAoIXRleHR1cmUpXG4gICAge1xuICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuZnJvbUltYWdlKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKSk7XG4gICAgICAgIHV0aWxzLlRleHR1cmVDYWNoZVtpbWFnZVVybF0gPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcbiAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGZyYW1lSWQge3N0cmluZ30gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxuICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gKi9cblRleHR1cmUuZnJvbUZyYW1lID0gZnVuY3Rpb24gKGZyYW1lSWQpXG57XG4gICAgdmFyIHRleHR1cmUgPSB1dGlscy5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XG5cbiAgICBpZiAoIXRleHR1cmUpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmcmFtZUlkIFwiJyArIGZyYW1lSWQgKyAnXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRleHR1cmUgY2FjaGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSBnaXZlbiBjYW52YXMgZWxlbWVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9XG4gKi9cblRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIChjYW52YXMsIHNjYWxlTW9kZSlcbntcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXMsIHNjYWxlTW9kZSkpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFRleHR1cmUgYmFzZWQgb24gdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHZpZGVvIHtIVE1MVmlkZW9FbGVtZW50fVxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gQSBUZXh0dXJlXG4gKi9cblRleHR1cmUuZnJvbVZpZGVvID0gZnVuY3Rpb24gKHZpZGVvLCBzY2FsZU1vZGUpXG57XG4gICAgaWYgKHR5cGVvZiB2aWRlbyA9PT0gJ3N0cmluZycpXG4gICAge1xuICAgICAgICByZXR1cm4gVGV4dHVyZS5mcm9tVmlkZW9VcmwodmlkZW8sIHNjYWxlTW9kZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShWaWRlb0Jhc2VUZXh0dXJlLmZyb21WaWRlbyh2aWRlbywgc2NhbGVNb2RlKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFRleHR1cmUgYmFzZWQgb24gdGhlIHZpZGVvIHVybC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gdmlkZW9Vcmwge3N0cmluZ31cbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IEEgVGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21WaWRlb1VybCA9IGZ1bmN0aW9uICh2aWRlb1VybCwgc2NhbGVNb2RlKVxue1xuICAgIHJldHVybiBuZXcgVGV4dHVyZShWaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmwodmlkZW9VcmwsIHNjYWxlTW9kZSkpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdGV4dHVyZSB0byB0aGUgZ2xvYmFsIHV0aWxzLlRleHR1cmVDYWNoZS4gVGhpcyBjYWNoZSBpcyBzaGFyZWQgYWNyb3NzIHRoZSB3aG9sZSBQSVhJIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSBUaGUgVGV4dHVyZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxuICogQHBhcmFtIGlkIHtzdHJpbmd9IFRoZSBpZCB0aGF0IHRoZSB0ZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGFnYWluc3QuXG4gKi9cblRleHR1cmUuYWRkVGV4dHVyZVRvQ2FjaGUgPSBmdW5jdGlvbiAodGV4dHVyZSwgaWQpXG57XG4gICAgdXRpbHMuVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIHV0aWxzLlRleHR1cmVDYWNoZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gaWQge3N0cmluZ30gVGhlIGlkIG9mIHRoZSB0ZXh0dXJlIHRvIGJlIHJlbW92ZWRcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIHRleHR1cmUgdGhhdCB3YXMgcmVtb3ZlZFxuICovXG5UZXh0dXJlLnJlbW92ZVRleHR1cmVGcm9tQ2FjaGUgPSBmdW5jdGlvbiAoaWQpXG57XG4gICAgdmFyIHRleHR1cmUgPSB1dGlscy5UZXh0dXJlQ2FjaGVbaWRdO1xuXG4gICAgZGVsZXRlIHV0aWxzLlRleHR1cmVDYWNoZVtpZF07XG4gICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vKipcbiAqIEFuIGVtcHR5IHRleHR1cmUsIHVzZWQgb2Z0ZW4gdG8gbm90IGhhdmUgdG8gY3JlYXRlIG11bHRpcGxlIGVtcHR5IHRleHR1cmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICovXG5UZXh0dXJlLkVNUFRZID0gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlKCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3RleHR1cmVzL1RleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vQmFzZVRleHR1cmUnKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSB0ZXh0dXJlIG9mIGEgW3BsYXlpbmddIFZpZGVvLlxuICpcbiAqIFZpZGVvIGJhc2UgdGV4dHVyZXMgbWltaWMgUGl4aSBCYXNlVGV4dHVyZS5mcm9tLi4uLiBtZXRob2QgaW4gdGhlaXIgY3JlYXRpb24gcHJvY2Vzcy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIGluIHNldmVyYWwgd2F5cywgc3VjaCBhczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHRleHR1cmUgPSBQSVhJLlZpZGVvQmFzZVRleHR1cmUuZnJvbVVybCgnaHR0cDovL215ZG9tYWluLmNvbS92aWRlby5tcDQnKTtcbiAqXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsKHsgc3JjOiAnaHR0cDovL215ZG9tYWluLmNvbS92aWRlby5tcDQnLCBtaW1lOiAndmlkZW8vbXA0JyB9KTtcbiAqXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJscyhbJy92aWRlby53ZWJtJywgJy92aWRlby5tcDQnXSk7XG4gKlxuICogdmFyIHRleHR1cmUgPSBQSVhJLlZpZGVvQmFzZVRleHR1cmUuZnJvbVVybHMoW1xuICogICAgIHsgc3JjOiAnL3ZpZGVvLndlYm0nLCBtaW1lOiAndmlkZW8vd2VibScgfSxcbiAqICAgICB7IHNyYzogJy92aWRlby5tcDQnLCBtaW1lOiAndmlkZW8vbXA0JyB9XG4gKiBdKTtcbiAqIGBgYFxuICpcbiAqIFNlZSB0aGUgW1wiZGV1c1wiIGRlbW9dKGh0dHA6Ly93d3cuZ29vZGJveWRpZ2l0YWwuY29tL3BpeGlqcy9leGFtcGxlcy9kZXVzLykuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkJhc2VUZXh0dXJlXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHNvdXJjZSB7SFRNTFZpZGVvRWxlbWVudH1cbiAqIEBwYXJhbSBbc2NhbGVNb2RlXSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gVmlkZW9CYXNlVGV4dHVyZShzb3VyY2UsIHNjYWxlTW9kZSlcbntcbiAgICBpZiAoIXNvdXJjZSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmlkZW8gc291cmNlIGVsZW1lbnQgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIC8vIGhvb2sgaW4gaGVyZSB0byBjaGVjayBpZiB2aWRlbyBpcyBhbHJlYWR5IGF2YWlsYWJsZS5cbiAgICAvLyBCYXNlVGV4dHVyZSBsb29rcyBmb3IgYSBzb3VyY2UuY29tcGxldGUgYm9vbGVhbiwgcGx1cyB3aWR0aCAmIGhlaWdodC5cblxuICAgIGlmICgoc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0VOT1VHSF9EQVRBIHx8IHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9GVVRVUkVfREFUQSkgJiYgc291cmNlLndpZHRoICYmIHNvdXJjZS5oZWlnaHQpXG4gICAge1xuICAgICAgICBzb3VyY2UuY29tcGxldGUgPSB0cnVlO1xuICAgIH1cblxuICAgIEJhc2VUZXh0dXJlLmNhbGwodGhpcywgc291cmNlLCBzY2FsZU1vZGUpO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX29uVXBkYXRlID0gdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNhblBsYXkgPSB0aGlzLl9vbkNhblBsYXkuYmluZCh0aGlzKTtcblxuICAgIGlmICghc291cmNlLmNvbXBsZXRlKVxuICAgIHtcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9vbkNhblBsYXkpO1xuXG4gICAgICAgIC8vIHN0YXJ0ZWQgcGxheWluZy4uXG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgdGhpcy5fb25QbGF5U3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIHRoaXMuX29uUGxheVN0b3AuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fX2xvYWRlZCA9IGZhbHNlO1xufVxuXG5WaWRlb0Jhc2VUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZVRleHR1cmUucHJvdG90eXBlKTtcblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmlkZW9CYXNlVGV4dHVyZTtcbm1vZHVsZS5leHBvcnRzID0gVmlkZW9CYXNlVGV4dHVyZTtcblxuLyoqXG4gKiBUaGUgaW50ZXJuYWwgdXBkYXRlIGxvb3Agb2YgdGhlIHZpZGVvIGJhc2UgdGV4dHVyZSwgb25seSBydW5zIHdoZW4gYXV0b1VwZGF0ZSBpcyBzZXQgdG8gdHJ1ZVxuICpcbiAqIEBwcml2YXRlXG4gKi9cblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vblVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuYXV0b1VwZGF0ZSlcbiAgICB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fb25VcGRhdGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUnVucyB0aGUgdXBkYXRlIGxvb3Agd2hlbiB0aGUgdmlkZW8gaXMgcmVhZHkgdG8gcGxheVxuICpcbiAqIEBwcml2YXRlXG4gKi9cblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vblBsYXlTdGFydCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKCF0aGlzLmF1dG9VcGRhdGUpXG4gICAge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX29uVXBkYXRlKTtcbiAgICAgICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gYSBwYXVzZSBldmVudCBpcyB0cmlnZ2VyZWQsIHN0b3BzIHRoZSB1cGRhdGUgbG9vcFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vblBsYXlTdG9wID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmF1dG9VcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgbG9hZGVkIGFuZCByZWFkeSB0byBwbGF5XG4gKlxuICogQHByaXZhdGVcbiAqL1xuVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX29uQ2FuUGxheSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5oYXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuc291cmNlKVxuICAgIHtcbiAgICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5zb3VyY2UudmlkZW9XaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnNvdXJjZS52aWRlb0hlaWdodDtcblxuICAgICAgICB0aGlzLnNvdXJjZS5wbGF5KCk7XG5cbiAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBsb2FkZWQgZGlzcGF0Y2hlcy4uXG4gICAgICAgIGlmICghdGhpcy5fX2xvYWRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAqXG4gKi9cblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5fcGl4aUlkKVxuICAgIHtcbiAgICAgICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbIHRoaXMuc291cmNlLl9waXhpSWQgXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlLl9waXhpSWQ7XG4gICAgfVxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogTWltaWMgUGl4aSBCYXNlVGV4dHVyZS5mcm9tLi4uLiBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHZpZGVvIHtIVE1MVmlkZW9FbGVtZW50fVxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1BJWEkuVmlkZW9CYXNlVGV4dHVyZX1cbiAqL1xuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVmlkZW8gPSBmdW5jdGlvbiAodmlkZW8sIHNjYWxlTW9kZSlcbntcbiAgICBpZiAoIXZpZGVvLl9waXhpSWQpXG4gICAge1xuICAgICAgICB2aWRlby5fcGl4aUlkID0gJ3ZpZGVvXycgKyB1dGlscy51aWQoKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW3ZpZGVvLl9waXhpSWRdO1xuXG4gICAgaWYgKCFiYXNlVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IFZpZGVvQmFzZVRleHR1cmUodmlkZW8sIHNjYWxlTW9kZSk7XG4gICAgICAgIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbIHZpZGVvLl9waXhpSWQgXSA9IGJhc2VUZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBCYXNlVGV4dHVyZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gdmlkZW8gZWxlbWVudC5cbiAqIFRoaXMgQmFzZVRleHR1cmUgY2FuIHRoZW4gYmUgdXNlZCB0byBjcmVhdGUgYSB0ZXh0dXJlXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHZpZGVvU3JjIHtzdHJpbmd8b2JqZWN0fHN0cmluZ1tdfG9iamVjdFtdfSBUaGUgVVJMKHMpIGZvciB0aGUgdmlkZW8uXG4gKiBAcGFyYW0gW3ZpZGVvU3JjLnNyY10ge3N0cmluZ30gT25lIG9mIHRoZSBzb3VyY2UgdXJscyBmb3IgdGhlIHZpZGVvXG4gKiBAcGFyYW0gW3ZpZGVvU3JjLm1pbWVdIHtzdHJpbmd9IFRoZSBtaW1ldHlwZSBvZiB0aGUgdmlkZW8gKGUuZy4gJ3ZpZGVvL21wNCcpLiBJZiBub3Qgc3BlY2lmaWVkXG4gKiAgdGhlIHVybCdzIGV4dGVuc2lvbiB3aWxsIGJlIHVzZWQgYXMgdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBtaW1lIHR5cGUuXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICogQHJldHVybiB7UElYSS5WaWRlb0Jhc2VUZXh0dXJlfVxuICovXG5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmwgPSBmdW5jdGlvbiAodmlkZW9TcmMsIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuXG4gICAgLy8gYXJyYXkgb2Ygb2JqZWN0cyBvciBzdHJpbmdzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmlkZW9TcmMpKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWRlb1NyYy5sZW5ndGg7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQoY3JlYXRlU291cmNlKHZpZGVvU3JjW2ldLnNyYyB8fCB2aWRlb1NyY1tpXSwgdmlkZW9TcmNbaV0ubWltZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNpbmdsZSBvYmplY3Qgb3Igc3RyaW5nXG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQoY3JlYXRlU291cmNlKHZpZGVvU3JjLnNyYyB8fCB2aWRlb1NyYywgdmlkZW9TcmMubWltZSkpO1xuICAgIH1cblxuICAgIHZpZGVvLmxvYWQoKTtcbiAgICB2aWRlby5wbGF5KCk7XG5cbiAgICByZXR1cm4gVmlkZW9CYXNlVGV4dHVyZS5mcm9tVmlkZW8odmlkZW8sIHNjYWxlTW9kZSk7XG59O1xuXG5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmxzID0gVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsO1xuXG5mdW5jdGlvbiBjcmVhdGVTb3VyY2UocGF0aCwgdHlwZSlcbntcbiAgICBpZiAoIXR5cGUpXG4gICAge1xuICAgICAgICB0eXBlID0gJ3ZpZGVvLycgKyBwYXRoLnN1YnN0cihwYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG5cbiAgICBzb3VyY2Uuc3JjID0gcGF0aDtcbiAgICBzb3VyY2UudHlwZSA9IHR5cGU7XG5cbiAgICByZXR1cm4gc291cmNlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3RleHR1cmVzL1ZpZGVvQmFzZVRleHR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBBIHN0YW5kYXJkIG9iamVjdCB0byBzdG9yZSB0aGUgVXZzIG9mIGEgdGV4dHVyZVxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmVVdnMoKVxue1xuICAgIHRoaXMueDAgPSAwO1xuICAgIHRoaXMueTAgPSAwO1xuXG4gICAgdGhpcy54MSA9IDE7XG4gICAgdGhpcy55MSA9IDA7XG5cbiAgICB0aGlzLngyID0gMTtcbiAgICB0aGlzLnkyID0gMTtcblxuICAgIHRoaXMueDMgPSAwO1xuICAgIHRoaXMueTMgPSAxO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVVdnM7XG5cbnZhciBHcm91cEQ4ID0gcmVxdWlyZSgnLi4vbWF0aC9Hcm91cEQ4Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgdGV4dHVyZSBVdnMgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gZnJhbWUge1BJWEkuUmVjdGFuZ2xlfVxuICogQHBhcmFtIGJhc2VGcmFtZSB7UElYSS5SZWN0YW5nbGV9XG4gKiBAcGFyYW0gcm90YXRlIHtudW1iZXJ9IFJvdGF0aW9uIG9mIGZyYW1lLCBzZWUge0BsaW5rIFBJWEkuR3JvdXBEOH1cbiAqIEBwcml2YXRlXG4gKi9cblRleHR1cmVVdnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChmcmFtZSwgYmFzZUZyYW1lLCByb3RhdGUpXG57XG4gICAgdmFyIHR3ID0gYmFzZUZyYW1lLndpZHRoO1xuICAgIHZhciB0aCA9IGJhc2VGcmFtZS5oZWlnaHQ7XG5cbiAgICBpZihyb3RhdGUpXG4gICAge1xuICAgICAgICAvL3dpZHRoIGFuZCBoZWlnaHQgZGl2IDIgZGl2IGJhc2VGcmFtZSBzaXplXG4gICAgICAgIHZhciBzd2FwV2lkdGhIZWlnaHQgPSBHcm91cEQ4LmlzU3dhcFdpZHRoSGVpZ2h0KHJvdGF0ZSk7XG4gICAgICAgIHZhciB3MiA9IChzd2FwV2lkdGhIZWlnaHQgPyBmcmFtZS5oZWlnaHQgOiBmcmFtZS53aWR0aCkgLyAyIC8gdHc7XG4gICAgICAgIHZhciBoMiA9IChzd2FwV2lkdGhIZWlnaHQgPyBmcmFtZS53aWR0aCA6IGZyYW1lLmhlaWdodCkgLyAyIC8gdGg7XG4gICAgICAgIC8vY29vcmRpbmF0ZXMgb2YgY2VudGVyXG4gICAgICAgIHZhciBjWCA9IGZyYW1lLnggLyB0dyArIHcyO1xuICAgICAgICB2YXIgY1kgPSBmcmFtZS55IC8gdGggKyBoMjtcbiAgICAgICAgcm90YXRlID0gR3JvdXBEOC5hZGQocm90YXRlLCBHcm91cEQ4Lk5XKTsgLy9OVyBpcyB0b3AtbGVmdCBjb3JuZXJcbiAgICAgICAgdGhpcy54MCA9IGNYICsgdzIgKiBHcm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICAgIHRoaXMueTAgPSBjWSArIGgyICogR3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgICByb3RhdGUgPSBHcm91cEQ4LmFkZChyb3RhdGUsIDIpOyAvL3JvdGF0ZSA5MCBkZWdyZWVzIGNsb2Nrd2lzZVxuICAgICAgICB0aGlzLngxID0gY1ggKyB3MiAqIEdyb3VwRDgudVgocm90YXRlKTtcbiAgICAgICAgdGhpcy55MSA9IGNZICsgaDIgKiBHcm91cEQ4LnVZKHJvdGF0ZSk7XG4gICAgICAgIHJvdGF0ZSA9IEdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICAgIHRoaXMueDIgPSBjWCArIHcyICogR3JvdXBEOC51WChyb3RhdGUpO1xuICAgICAgICB0aGlzLnkyID0gY1kgKyBoMiAqIEdyb3VwRDgudVkocm90YXRlKTtcbiAgICAgICAgcm90YXRlID0gR3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgICAgdGhpcy54MyA9IGNYICsgdzIgKiBHcm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICAgIHRoaXMueTMgPSBjWSArIGgyICogR3JvdXBEOC51WShyb3RhdGUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIHRoaXMueDAgPSBmcmFtZS54IC8gdHc7XG4gICAgICAgIHRoaXMueTAgPSBmcmFtZS55IC8gdGg7XG5cbiAgICAgICAgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICAgIHRoaXMueTEgPSBmcmFtZS55IC8gdGg7XG5cbiAgICAgICAgdGhpcy54MiA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICAgIHRoaXMueTIgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcblxuICAgICAgICB0aGlzLngzID0gZnJhbWUueCAvIHR3O1xuICAgICAgICB0aGlzLnkzID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS90ZXh0dXJlcy9UZXh0dXJlVXZzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWF0aCA9IHJlcXVpcmUoJy4uLy4uLy4uL21hdGgnKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpLFxuICAgIC8vU3RlbmNpbE1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9TdGVuY2lsTWFuYWdlcicpLFxuICAgIFN0ZW5jaWxNYXNrU3RhY2sgPSByZXF1aXJlKCcuL1N0ZW5jaWxNYXNrU3RhY2snKTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgaG9yaXpvbnRhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSB2ZXJ0aWNhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gdGhlIGN1cnJlbnQgcmVzb2x1dGlvblxuICogQHBhcmFtIHJvb3Qge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgdGhlIHJvb3QgZWxlbWVudCBvciBub3RcbiAqL1xudmFyIFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24sIHJvb3QpXG57XG4gICAgLy9UT0RPIFJlc29sdXRpb24gY291bGQgZ28gaGVyZSAoIGVnIGxvdyByZXMgYmx1cnMgKVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vIG5leHQgdGltZSB0byBjcmVhdGUgYSBmcmFtZSBidWZmZXIgYW5kIHRleHR1cmVcblxuICAgIC8qKlxuICAgICAqIEEgZnJhbWUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEZyYW1lQnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgb2YgdGhlIG9iamVjdCBhcyBhIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgdGhpcy5zaXplID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcmVzb2x1dGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgQ09OU1QuUkVTT0xVVElPTjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0J3MgdHJhbnNmb3JtXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGVuY2lsIGJ1ZmZlciBzdG9yZXMgbWFza2luZyBkYXRhIGZvciB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIHN0ZW5jaWwgbWFza3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuU3RlbmNpbE1hc2tTdGFja31cbiAgICAgKi9cbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBuZXcgU3RlbmNpbE1hc2tTdGFjaygpO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGZpbHRlciBkYXRhIGZvciB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICovXG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0OnRoaXMsXG4gICAgICAgICAgICBmaWx0ZXI6W10sXG4gICAgICAgICAgICBib3VuZHM6dGhpcy5zaXplXG4gICAgICAgIH1cbiAgICBdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLlNDQUxFX01PREVTLkRFRkFVTFRcbiAgICAgKiBAc2VlIFBJWEkuU0NBTEVfTU9ERVNcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSB8fCBDT05TVC5TQ0FMRV9NT0RFUy5ERUZBVUxUO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIG9iamVjdCBpcyB0aGUgcm9vdCBlbGVtZW50IG9yIG5vdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgaWYgKCF0aGlzLnJvb3QpXG4gICAge1xuICAgICAgIC8vIHRoaXMuZmxpcFkgPSB0cnVlO1xuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgQSBmcmFtZSBidWZmZXIgbmVlZHMgYSB0YXJnZXQgdG8gcmVuZGVyIHRvLi5cbiAgICAgICAgICAgIGNyZWF0ZSBhIHRleHR1cmUgYW5kIGJpbmQgaXQgYXR0YWNoIGl0IHRvIHRoZSBmcmFtZWJ1ZmZlci4uXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCAgdGhpcy50ZXh0dXJlKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHNjYWxlIHByb3BlcnRpZXMgb2YgdGhlIHRleHR1cmUuLlxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHNjYWxlTW9kZSA9PT0gQ09OU1QuU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSB0ZXh0dXJlIGlzIGEgcG93ZXIgb2YgdHdvIVxuICAgICAgICB2YXIgaXNQb3dlck9mVHdvID0gdXRpbHMuaXNQb3dlck9mVHdvKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vVE9ETyBmb3IgOTklIG9mIHVzZSBjYXNlcyBpZiBhIHRleHR1cmUgaXMgcG93ZXIgb2YgdHdvIHdlIHNob3VsZCB0aWxlIHRoZSB0ZXh0dXJlLi4uXG4gICAgICAgICBpZiAoIWlzUG93ZXJPZlR3bylcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcblxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIgKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUsIDApO1xuICAgIH1cblxuICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xufTtcblxuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlbmRlclRhcmdldDtcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyVGFyZ2V0O1xuXG4vKipcbiAqIENsZWFycyB0aGUgZmlsdGVyIHRleHR1cmUuXG4gKlxuICogQHBhcmFtIFtiaW5kPWZhbHNlXSB7Ym9vbGVhbn0gU2hvdWxkIHdlIGJpbmQgb3VyIGZyYW1lYnVmZmVyIGJlZm9yZSBjbGVhcmluZz9cbiAqL1xuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGJpbmQpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBpZihiaW5kKVxuICAgIHtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcbiAgICB9XG5cbiAgICBnbC5jbGVhckNvbG9yKDAsMCwwLDApO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgc3RlbmNpbCBidWZmZXIuXG4gKlxuICovXG5SZW5kZXJUYXJnZXQucHJvdG90eXBlLmF0dGFjaFN0ZW5jaWxCdWZmZXIgPSBmdW5jdGlvbigpXG57XG5cbiAgICBpZiAodGhpcy5zdGVuY2lsQnVmZmVyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGVuY2lsIGJ1ZmZlciBpcyB1c2VkIGZvciBtYXNraW5nIGluIHBpeGlcbiAgICAgKiBsZXRzIGNyZWF0ZSBvbmUgYW5kIHRoZW4gYWRkIGF0dGFjaCBpdCB0byB0aGUgZnJhbWVidWZmZXIuLlxuICAgICAqL1xuICAgIGlmICghdGhpcy5yb290KVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbEJ1ZmZlcik7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5zdGVuY2lsQnVmZmVyKTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsICB0aGlzLnNpemUud2lkdGggKiB0aGlzLnJlc29sdXRpb24gICwgdGhpcy5zaXplLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbiApO1xuICAgIH1cbn07XG5cbi8qKlxuICogQmluZHMgdGhlIGJ1ZmZlcnMgYW5kIGluaXRpYWxpc2VzIHRoZSB2aWV3cG9ydC5cbiAqXG4gKi9cblJlbmRlclRhcmdldC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpXG57XG4gICAgLy9UT09EIHJlZmFjdG9yIHVzYWdlIG9mIGZyYW1lLi5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblxuICAgIHZhciBwcm9qZWN0aW9uRnJhbWUgPSB0aGlzLmZyYW1lIHx8IHRoaXMuc2l6ZTtcblxuICAgIC8vIFRPRE8gYWRkIGEgZGlydHkgZmxhZyB0byB0aGlzIG9mIGEgc2V0dGVyIGZvciB0aGUgZnJhbWU/XG4gICAgdGhpcy5jYWxjdWxhdGVQcm9qZWN0aW9uKCBwcm9qZWN0aW9uRnJhbWUgKTtcblxuICAgIGlmKHRoaXMudHJhbnNmb3JtKVxuICAgIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4LmFwcGVuZCh0aGlzLnRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgZ2wudmlld3BvcnQoMCwwLCBwcm9qZWN0aW9uRnJhbWUud2lkdGggKiB0aGlzLnJlc29sdXRpb24sIHByb2plY3Rpb25GcmFtZS5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBiYXNlZCBvbiBhIHByb2plY3Rpb24gZnJhbWUgKHdoaWNoIGlzIGEgcmVjdGFuZ2xlKVxuICpcbiAqL1xuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5jYWxjdWxhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKHByb2plY3Rpb25GcmFtZSlcbntcbiAgICB2YXIgcG0gPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG5cbiAgICBwbS5pZGVudGl0eSgpO1xuXG4gICAgaWYgKCF0aGlzLnJvb3QpXG4gICAge1xuICAgICAgICBwbS5hID0gMSAvIHByb2plY3Rpb25GcmFtZS53aWR0aCoyO1xuICAgICAgICBwbS5kID0gMSAvIHByb2plY3Rpb25GcmFtZS5oZWlnaHQqMjtcblxuICAgICAgICBwbS50eCA9IC0xIC0gcHJvamVjdGlvbkZyYW1lLnggKiBwbS5hO1xuICAgICAgICBwbS50eSA9IC0xIC0gcHJvamVjdGlvbkZyYW1lLnkgKiBwbS5kO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBwbS5hID0gMSAvIHByb2plY3Rpb25GcmFtZS53aWR0aCoyO1xuICAgICAgICBwbS5kID0gLTEgLyBwcm9qZWN0aW9uRnJhbWUuaGVpZ2h0KjI7XG5cbiAgICAgICAgcG0udHggPSAtMSAtIHByb2plY3Rpb25GcmFtZS54ICogcG0uYTtcbiAgICAgICAgcG0udHkgPSAxIC0gcHJvamVjdGlvbkZyYW1lLnkgKiBwbS5kO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZXNpemVzIHRoZSB0ZXh0dXJlIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICpcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gKi9cblJlbmRlclRhcmdldC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgd2lkdGggPSB3aWR0aCB8IDA7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHwgMDtcblxuICAgIGlmICh0aGlzLnNpemUud2lkdGggPT09IHdpZHRoICYmIHRoaXMuc2l6ZS5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zaXplLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5zaXplLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGlmICghdGhpcy5yb290KVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCAgdGhpcy50ZXh0dXJlKTtcblxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsICB3aWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uICwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RlbmNpbEJ1ZmZlciApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RlbmNpbCBidWZmZXIgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbEJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgIHdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb24gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9qZWN0aW9uRnJhbWUgPSB0aGlzLmZyYW1lIHx8IHRoaXMuc2l6ZTtcblxuICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbiggcHJvamVjdGlvbkZyYW1lICk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSByZW5kZXIgdGFyZ2V0LlxuICpcbiAqL1xuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggdGhpcy5zdGVuY2lsQnVmZmVyICk7XG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHRoaXMuZnJhbWVCdWZmZXIgKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKCB0aGlzLnRleHR1cmUgKTtcblxuICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9SZW5kZXJUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogR2VuZXJpYyBNYXNrIFN0YWNrIGRhdGEgc3RydWN0dXJlXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmZ1bmN0aW9uIFN0ZW5jaWxNYXNrU3RhY2soKVxue1xuXHQvKipcbiAgICAgKiBUaGUgYWN0dWFsIHN0YWNrXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHthbnlbXX1cbiAgICAgKi9cbiAgICB0aGlzLnN0ZW5jaWxTdGFjayA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVE9ETyBAYWx2aW5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXZlcnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNvdW50XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb3VudCA9IDA7XG59XG5cblN0ZW5jaWxNYXNrU3RhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RlbmNpbE1hc2tTdGFjaztcbm1vZHVsZS5leHBvcnRzID0gU3RlbmNpbE1hc2tTdGFjaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvU3RlbmNpbE1hc2tTdGFjay5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdlYkdMTWFuYWdlciA9IHJlcXVpcmUoJy4vV2ViR0xNYW5hZ2VyJyksXG4gICAgUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi4vdXRpbHMvUmVuZGVyVGFyZ2V0JyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdCcpLFxuICAgIFF1YWQgPSByZXF1aXJlKCcuLi91dGlscy9RdWFkJyksXG4gICAgbWF0aCA9ICByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5XZWJHTE1hbmFnZXJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gRmlsdGVyTWFuYWdlcihyZW5kZXJlcilcbntcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlclN0YWNrID0gW107XG5cbiAgICB0aGlzLmZpbHRlclN0YWNrLnB1c2goe1xuICAgICAgICByZW5kZXJUYXJnZXQ6cmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldCxcbiAgICAgICAgZmlsdGVyOltdLFxuICAgICAgICBib3VuZHM6bnVsbFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UElYSS5SZW5kZXJUYXJnZXRbXX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmVQb29sID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgdGV4dHVyZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgLy8gbGlzdGVuIGZvciBjb250ZXh0IGFuZCB1cGRhdGUgbmVjZXNzYXJ5IGJ1ZmZlcnNcbiAgICAvL1RPRE8gbWFrZSB0aGlzIGR5bmFtaWMhXG4gICAgLy9UT0RPIHRlc3QgdGhpcyBvdXQgYnkgZm9yY2VzIHBvd2VyIG9mIHR3bz9cbiAgICB0aGlzLnRleHR1cmVTaXplID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIHJlbmRlcmVyLndpZHRoLCByZW5kZXJlci5oZWlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZnJhbWVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gbnVsbDtcbn1cblxuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaWx0ZXJNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJNYW5hZ2VyO1xuXG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBXZWJHTCBjb250ZXh0IGNoYW5nZS5cbiAqXG4gKi9cbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy50ZXh0dXJlUG9vbC5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICB0aGlzLnF1YWQgPSBuZXcgUXVhZChnbCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfVxuICogQHBhcmFtIGJ1ZmZlciB7QXJyYXlCdWZmZXJ9XG4gKi9cbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLnNldEZpbHRlclN0YWNrID0gZnVuY3Rpb24gKCBmaWx0ZXJTdGFjayApXG57XG4gICAgdGhpcy5maWx0ZXJTdGFjayA9IGZpbHRlclN0YWNrO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBmaWx0ZXIgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQge1BJWEkuRGlzcGxheU9iamVjdH1cbiAqIEBwYXJhbSBmaWx0ZXJzIHtQSVhJLkFic3RyYWN0RmlsZXJbXX0gdGhlIGZpbHRlcnMgdGhhdCB3aWxsIGJlIHB1c2hlZCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2tcbiAqL1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucHVzaEZpbHRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGZpbHRlcnMpXG57XG4gICAgLy8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIG9iamVjdC4uXG4gICAgLy8gVE9ETyByZXBsYWNlIGNsb25lIHdpdGggYSBjb3B5IHRvIHNhdmUgb2JqZWN0IGNyZWF0aW9uXG4gICAgdmFyIGJvdW5kcyA9IHRhcmdldC5maWx0ZXJBcmVhID8gdGFyZ2V0LmZpbHRlckFyZWEuY2xvbmUoKSA6IHRhcmdldC5nZXRCb3VuZHMoKTtcblxuICAgIC8vYm91bmRzID0gYm91bmRzLmNsb25lKCk7XG5cbiAgICAvLyByb3VuZCBvZmYgdGhlIHJlY3RhbmdsZSB0byBnZXQgYSBuaWNlIHNtb29vb29vb3RoIGZpbHRlciA6KVxuICAgIGJvdW5kcy54ID0gYm91bmRzLnggfCAwO1xuICAgIGJvdW5kcy55ID0gYm91bmRzLnkgfCAwO1xuICAgIGJvdW5kcy53aWR0aCA9IGJvdW5kcy53aWR0aCB8IDA7XG4gICAgYm91bmRzLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQgfCAwO1xuXG5cbiAgICAvLyBwYWRkaW5nIVxuICAgIHZhciBwYWRkaW5nID0gZmlsdGVyc1swXS5wYWRkaW5nIHwgMDtcbiAgICBib3VuZHMueCAtPSBwYWRkaW5nO1xuICAgIGJvdW5kcy55IC09IHBhZGRpbmc7XG4gICAgYm91bmRzLndpZHRoICs9IHBhZGRpbmcgKiAyO1xuICAgIGJvdW5kcy5oZWlnaHQgKz0gcGFkZGluZyAqIDI7XG5cblxuICAgIGlmKHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldC50cmFuc2Zvcm0pXG4gICAge1xuICAgICAgICAvL1RPRE8gdGhpcyB3aWxsIGJyZWFrIGlmIHRoZSByZW5kZXJUZXh0dXJlIHRyYW5zZm9ybSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgdHJhbnNsYXRpb24uXG4gICAgICAgIC8vV2lsbCBuZWVkIHRvIHRha2UgdGhlIGZ1bGwgbWF0cml4IHRyYW5zZm9ybSBpbnRvIGFjb3VudC4uXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQudHJhbnNmb3JtO1xuXG4gICAgICAgIGJvdW5kcy54ICs9IHRyYW5zZm9ybS50eDtcbiAgICAgICAgYm91bmRzLnkgKz0gdHJhbnNmb3JtLnR5O1xuXG4gICAgICAgIHRoaXMuY2FwRmlsdGVyQXJlYSggYm91bmRzICk7XG5cbiAgICAgICAgYm91bmRzLnggLT0gdHJhbnNmb3JtLnR4O1xuICAgICAgICBib3VuZHMueSAtPSB0cmFuc2Zvcm0udHk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgICB0aGlzLmNhcEZpbHRlckFyZWEoIGJvdW5kcyApO1xuICAgIH1cblxuICAgIGlmKGJvdW5kcy53aWR0aCA+IDAgJiYgYm91bmRzLmhlaWdodCA+IDApXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGJvdW5kcztcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGV4dHVyZSk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHRleHR1cmUuLlxuICAgICAgICB0ZXh0dXJlLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gVE9ETyBnZXQgcmlkIG9mIG9iamVjdCBjcmVhdGlvbiFcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldDogdGV4dHVyZSxcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyc1xuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyBwdXNoIHNvbXRoaW5nIG9uIHRvIHRoZSBzdGFjayB0aGF0IGlzIGVtcHR5XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucHVzaCh7XG4gICAgICAgICAgICByZW5kZXJUYXJnZXQ6IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKi9cbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLnBvcEZpbHRlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGZpbHRlckRhdGEgPSB0aGlzLmZpbHRlclN0YWNrLnBvcCgpO1xuICAgIHZhciBwcmV2aW91c0ZpbHRlckRhdGEgPSB0aGlzLmZpbHRlclN0YWNrW3RoaXMuZmlsdGVyU3RhY2subGVuZ3RoLTFdO1xuXG4gICAgdmFyIGlucHV0ID0gZmlsdGVyRGF0YS5yZW5kZXJUYXJnZXQ7XG5cbiAgICAvLyBpZiB0aGUgcmVuZGVyVGFyZ2V0IGlzIG51bGwgdGhlbiB3ZSBkb24ndCBhcHBseSB0aGUgZmlsdGVyIGFzIGl0cyBvZmZzY3JlZW5cbiAgICBpZighZmlsdGVyRGF0YS5yZW5kZXJUYXJnZXQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IHByZXZpb3VzRmlsdGVyRGF0YS5yZW5kZXJUYXJnZXQ7XG5cbiAgICAvLyB1c2UgcHJvZ3JhbVxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cblxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gaW5wdXQuZnJhbWU7XG5cbiAgICB0aGlzLnF1YWQubWFwKHRoaXMudGV4dHVyZVNpemUsIGlucHV0LmZyYW1lKTtcblxuXG4gICAgLy8gVE9ETy4uIHRoaXMgcHJvYmFibHkgb25seSBuZWVkcyB0byBiZSBkb25lIG9uY2UhXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMucXVhZC52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMucXVhZC5pbmRleEJ1ZmZlcik7XG5cbiAgICB2YXIgZmlsdGVycyA9IGZpbHRlckRhdGEuZmlsdGVyO1xuXG4gICAgLy8gYXNzdW1pbmcgYWxsIGZpbHRlcnMgZm9sbG93IHRoZSBjb3JyZWN0IGZvcm1hdD8/XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuZGVmYXVsdFNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAyICogNCAqIDQpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXIuYXR0cmlidXRlcy5hQ29sb3IsIDQsIGdsLkZMT0FULCBmYWxzZSwgMCwgNCAqIDQgKiA0KTtcblxuICAgIC8vIHJlc3RvcmUgdGhlIG5vcm1hbCBibGVuZG1vZGUhXG4gICAgdGhpcy5yZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShDT05TVC5CTEVORF9NT0RFUy5OT1JNQUwpO1xuXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKVxuICAgIHtcbiAgICAgICAgLy8gVE9ETyAoY2VuZ2xlcikgLSBUaGVyZSBoYXMgdG8gYmUgYSBiZXR0ZXIgd2F5IHRoZW4gc2V0dGluZyB0aGlzIGVhY2ggdGltZT9cbiAgICAgICAgaWYgKGZpbHRlcnNbMF0udW5pZm9ybXMuZGltZW5zaW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyc1swXS51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzBdID0gdGhpcy5yZW5kZXJlci53aWR0aDtcbiAgICAgICAgICAgIGZpbHRlcnNbMF0udW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVsxXSA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0O1xuICAgICAgICAgICAgZmlsdGVyc1swXS51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzJdID0gdGhpcy5xdWFkLnZlcnRpY2VzWzBdO1xuICAgICAgICAgICAgZmlsdGVyc1swXS51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzNdID0gdGhpcy5xdWFkLnZlcnRpY2VzWzVdO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyc1swXS5hcHBseUZpbHRlciggdGhpcy5yZW5kZXJlciwgaW5wdXQsIG91dHB1dCApO1xuICAgICAgICB0aGlzLnJldHVyblJlbmRlclRhcmdldCggaW5wdXQgKTtcblxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgZmxpcFRleHR1cmUgPSBpbnB1dDtcbiAgICAgICAgdmFyIGZsb3BUZXh0dXJlID0gdGhpcy5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aC0xOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBUT0RPIChjZW5nbGVyKSAtIFRoZXJlIGhhcyB0byBiZSBhIGJldHRlciB3YXkgdGhlbiBzZXR0aW5nIHRoaXMgZWFjaCB0aW1lP1xuICAgICAgICAgICAgaWYgKGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzBdID0gdGhpcy5yZW5kZXJlci53aWR0aDtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVsxXSA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzJdID0gdGhpcy5xdWFkLnZlcnRpY2VzWzBdO1xuICAgICAgICAgICAgICAgIGZpbHRlci51bmlmb3Jtcy5kaW1lbnNpb25zLnZhbHVlWzNdID0gdGhpcy5xdWFkLnZlcnRpY2VzWzVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXIuYXBwbHlGaWx0ZXIoIHRoaXMucmVuZGVyZXIsIGZsaXBUZXh0dXJlLCBmbG9wVGV4dHVyZSApO1xuXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGZsaXBUZXh0dXJlO1xuICAgICAgICAgICAgZmxpcFRleHR1cmUgPSBmbG9wVGV4dHVyZTtcbiAgICAgICAgICAgIGZsb3BUZXh0dXJlID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlcnNbZmlsdGVycy5sZW5ndGgtMV0uYXBwbHlGaWx0ZXIoIHRoaXMucmVuZGVyZXIsIGZsaXBUZXh0dXJlLCBvdXRwdXQgKTtcblxuICAgICAgICB0aGlzLnJldHVyblJlbmRlclRhcmdldCggZmxpcFRleHR1cmUgKTtcbiAgICAgICAgdGhpcy5yZXR1cm5SZW5kZXJUYXJnZXQoIGZsb3BUZXh0dXJlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlckRhdGEuZmlsdGVyO1xufTtcblxuLyoqXG4gKiBHcmFicyBhbiByZW5kZXIgdGFyZ2V0IGZyb20gdGhlIGludGVybmFsIHBvb2xcbiAqXG4gKiBAcGFyYW0gY2xlYXIge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gY2xlYXIgdGhlIFJlbmRlclRhcmdldFxuICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fVxuICovXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIGNsZWFyIClcbntcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy50ZXh0dXJlUG9vbC5wb3AoKSB8fCBuZXcgUmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyZXIuZ2wsIHRoaXMudGV4dHVyZVNpemUud2lkdGgsIHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0LCBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIsIHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbiAqIENPTlNULkZJTFRFUl9SRVNPTFVUSU9OKTtcbiAgICByZW5kZXJUYXJnZXQuZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblxuICAgIGlmIChjbGVhcilcbiAgICB7XG4gICAgICAgIHJlbmRlclRhcmdldC5jbGVhcih0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xufTtcblxuLypcbiAqIFJldHVybnMgYSBSZW5kZXJUYXJnZXQgdG8gdGhlIGludGVybmFsIHBvb2xcbiAqIEBwYXJhbSByZW5kZXJUYXJnZXQge1JlbmRlclRhcmdldH0gVGhlIFJlbmRlclRhcmdldCB3ZSB3YW50IHRvIHJldHVybiB0byB0aGUgcG9vbFxuICovXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5yZXR1cm5SZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0KVxue1xuICAgIHRoaXMudGV4dHVyZVBvb2wucHVzaCggcmVuZGVyVGFyZ2V0ICk7XG59O1xuXG4vKlxuICogQXBwbGllcyB0aGUgZmlsdGVyXG4gKiBAcGFyYW0gc2hhZGVyIHtTaGFkZXJ9IFRoZSBzaGFkZXIgdG8gdXBsb2FkXG4gKiBAcGFyYW0gaW5wdXRUYXJnZXQge1JlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBvdXRwdXRUYXJnZXQge1JlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBjbGVhciB7Ym9vbGVhbn0gV2hldGhlciBvciBub3Qgd2Ugd2FudCB0byBjbGVhciB0aGUgb3V0cHV0VGFyZ2V0XG4gKi9cbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHNoYWRlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIpXG57XG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG91dHB1dFRhcmdldCk7XG5cbiAgICBpZiAoY2xlYXIpXG4gICAge1xuICAgICAgICBvdXRwdXRUYXJnZXQuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIHNoYWRlclxuICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcblxuICAgIC8vIFRPRE8gKGNlbmdsZXIpIC0gQ2FuIHRoaXMgYmUgY2FjaGVkIGFuZCBub3QgYHRvQXJyYXlgZWQgZWFjaCBmcmFtZT9cbiAgICBzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZSA9IHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldC5wcm9qZWN0aW9uTWF0cml4LnRvQXJyYXkodHJ1ZSk7XG5cbiAgICAvL1RPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkP1xuICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoKTtcbi8qXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDIgKiA0ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hQ29sb3IsIDQsIGdsLkZMT0FULCBmYWxzZSwgMCwgNCAqIDQgKiA0KTtcbiovXG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRhcmdldC50ZXh0dXJlKTtcblxuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG4gICAgdGhpcy5yZW5kZXJlci5kcmF3Q291bnQrKztcbn07XG5cbi8qXG4gKiBDYWxjdWxhdGVzIHRoZSBtYXBwZWQgbWF0cml4XG4gKiBAcGFyYW0gZmlsdGVyQXJlYSB7UmVjdGFuZ2xlfSBUaGUgZmlsdGVyIGFyZWFcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHRhcmdldCBzcHJpdGVcbiAqIEBwYXJhbSBvdXRwdXRNYXRyaXgge01hdHJpeH0gQGFsdmluXG4gKi9cbi8vIFRPRE8gcGxheWluZyBhcm91bmQgaGVyZS4uIHRoaXMgaXMgdGVtcG9yYXJ5IC0gKHdpbGwgZW5kIHVwIGluIHRoZSBzaGFkZXIpXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5jYWxjdWxhdGVNYXBwZWRNYXRyaXggPSBmdW5jdGlvbiAoZmlsdGVyQXJlYSwgc3ByaXRlLCBvdXRwdXRNYXRyaXgpXG57XG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHkobWF0aC5NYXRyaXguVEVNUF9NQVRSSVgpLFxuICAgIHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG5cbiAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LmlkZW50aXR5KCk7XG5cbiAgICAvLyBzY2FsZS4uXG4gICAgdmFyIHJhdGlvID0gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLyB0aGlzLnRleHR1cmVTaXplLndpZHRoO1xuXG4gICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShmaWx0ZXJBcmVhLnggLyB0aGlzLnRleHR1cmVTaXplLndpZHRoLCBmaWx0ZXJBcmVhLnkgLyB0aGlzLnRleHR1cmVTaXplLmhlaWdodCApO1xuXG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKDEgLCByYXRpbyk7XG5cbiAgICB2YXIgdHJhbnNsYXRlU2NhbGVYID0gKHRoaXMudGV4dHVyZVNpemUud2lkdGggLyB0ZXh0dXJlLndpZHRoKTtcbiAgICB2YXIgdHJhbnNsYXRlU2NhbGVZID0gKHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0IC8gdGV4dHVyZS5oZWlnaHQpO1xuXG4gICAgd29ybGRUcmFuc2Zvcm0udHggLz0gdGV4dHVyZS53aWR0aCAqIHRyYW5zbGF0ZVNjYWxlWDtcbiAgICB3b3JsZFRyYW5zZm9ybS50eSAvPSB0ZXh0dXJlLndpZHRoICogdHJhbnNsYXRlU2NhbGVYO1xuXG4gICAgd29ybGRUcmFuc2Zvcm0uaW52ZXJ0KCk7XG5cbiAgICBtYXBwZWRNYXRyaXgucHJlcGVuZCh3b3JsZFRyYW5zZm9ybSk7XG5cbiAgICAvLyBhcHBseSBpbnZlcnNlIHNjYWxlLi5cbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoMSAsIDEvcmF0aW8pO1xuXG4gICAgbWFwcGVkTWF0cml4LnNjYWxlKCB0cmFuc2xhdGVTY2FsZVggLCB0cmFuc2xhdGVTY2FsZVkgKTtcblxuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoc3ByaXRlLmFuY2hvci54LCBzcHJpdGUuYW5jaG9yLnkpO1xuXG4gICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcblxuICAgIC8vIEtlZXBpbmcgdGhlIG9yZ2luYWwgYXMgYSByZW1pbmRlciB0byBtZSBvbiBob3cgdGhpcyB3b3JrcyFcbiAgICAvL1xuICAgIC8vIHZhciBtID0gbmV3IG1hdGguTWF0cml4KCk7XG5cbiAgICAvLyAvLyBzY2FsZS4uXG4gICAgLy8gdmFyIHJhdGlvID0gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLyB0aGlzLnRleHR1cmVTaXplLndpZHRoO1xuXG4gICAgLy8gbS50cmFuc2xhdGUoZmlsdGVyQXJlYS54IC8gdGhpcy50ZXh0dXJlU2l6ZS53aWR0aCwgZmlsdGVyQXJlYS55IC8gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQpO1xuXG5cbiAgICAvLyBtLnNjYWxlKDEgLCByYXRpbyk7XG5cblxuICAgIC8vIHZhciB0cmFuc2Zvcm0gPSB3dC5jbG9uZSgpO1xuXG4gICAgLy8gdmFyIHRyYW5zbGF0ZVNjYWxlWCA9ICh0aGlzLnRleHR1cmVTaXplLndpZHRoIC8gNjIwKTtcbiAgICAvLyB2YXIgdHJhbnNsYXRlU2NhbGVZID0gKHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0IC8gMzgwKTtcblxuICAgIC8vIHRyYW5zZm9ybS50eCAvPSA2MjAgKiB0cmFuc2xhdGVTY2FsZVg7XG4gICAgLy8gdHJhbnNmb3JtLnR5IC89IDYyMCAqIHRyYW5zbGF0ZVNjYWxlWDtcblxuICAgIC8vIHRyYW5zZm9ybS5pbnZlcnQoKTtcblxuICAgIC8vIHRyYW5zZm9ybS5hcHBlbmQobSk7XG5cbiAgICAvLyAvLyBhcHBseSBpbnZlcnNlIHNjYWxlLi5cbiAgICAvLyB0cmFuc2Zvcm0uc2NhbGUoMSAsIDEvcmF0aW8pO1xuXG4gICAgLy8gdHJhbnNmb3JtLnNjYWxlKCB0cmFuc2xhdGVTY2FsZVggLCB0cmFuc2xhdGVTY2FsZVkgKTtcblxuICAgIC8vIHJldHVybiB0cmFuc2Zvcm07XG59O1xuXG4vKlxuICogQ29uc3RyYWlucyB0aGUgZmlsdGVyIGFyZWEgdG8gdGhlIHRleHR1cmUgc2l6ZVxuICogQHBhcmFtIGZpbHRlckFyZWEge1JlY3RhbmdsZX0gVGhlIGZpbHRlciBhcmVhIHdlIHdhbnQgdG8gY2FwXG4gKi9cbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNhcEZpbHRlckFyZWEgPSBmdW5jdGlvbiAoZmlsdGVyQXJlYSlcbntcbiAgICBpZiAoZmlsdGVyQXJlYS54IDwgMClcbiAgICB7XG4gICAgICAgIGZpbHRlckFyZWEud2lkdGggKz0gZmlsdGVyQXJlYS54O1xuICAgICAgICBmaWx0ZXJBcmVhLnggPSAwO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJBcmVhLnkgPCAwKVxuICAgIHtcbiAgICAgICAgZmlsdGVyQXJlYS5oZWlnaHQgKz0gZmlsdGVyQXJlYS55O1xuICAgICAgICBmaWx0ZXJBcmVhLnkgPSAwO1xuICAgIH1cblxuICAgIGlmICggZmlsdGVyQXJlYS54ICsgZmlsdGVyQXJlYS53aWR0aCA+IHRoaXMudGV4dHVyZVNpemUud2lkdGggKVxuICAgIHtcbiAgICAgICAgZmlsdGVyQXJlYS53aWR0aCA9IHRoaXMudGV4dHVyZVNpemUud2lkdGggLSBmaWx0ZXJBcmVhLng7XG4gICAgfVxuXG4gICAgaWYgKCBmaWx0ZXJBcmVhLnkgKyBmaWx0ZXJBcmVhLmhlaWdodCA+IHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0IClcbiAgICB7XG4gICAgICAgIGZpbHRlckFyZWEuaGVpZ2h0ID0gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLSBmaWx0ZXJBcmVhLnk7XG4gICAgfVxufTtcblxuLypcbiAqIFJlc2l6ZXMgYWxsIHRoZSByZW5kZXIgdGFyZ2V0cyBpbiB0aGUgcG9vbFxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSBuZXcgd2lkdGhcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHRcbiAqL1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0IClcbntcbiAgICB0aGlzLnRleHR1cmVTaXplLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dHVyZVBvb2wubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnRleHR1cmVQb29sW2ldLnJlc2l6ZSggd2lkdGgsIGhlaWdodCApO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIGZpbHRlciBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBmaWx0ZXIgc3RhY2suXG4gKlxuICovXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnF1YWQuZGVzdHJveSgpO1xuICAgIFxuICAgIFdlYkdMTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBudWxsO1xuICAgIHRoaXMub2Zmc2V0WSA9IDA7XG5cbiAgICAvLyBkZXN0cm95IHRleHR1cmVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHR1cmVQb29sLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbFtpXS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9GaWx0ZXJNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gV2ViR0xNYW5hZ2VyKHJlbmRlcmVyKVxue1xuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5XZWJHTFJlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgIHRoaXMucmVuZGVyZXIub24oJ2NvbnRleHQnLCB0aGlzLm9uQ29udGV4dENoYW5nZSwgdGhpcyk7XG59XG5cbldlYkdMTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMTWFuYWdlcjtcblxuLyoqXG4gKiBHZW5lcmljIG1ldGhvZCBjYWxsZWQgd2hlbiB0aGVyZSBpcyBhIFdlYkdMIGNvbnRleHQgY2hhbmdlLlxuICpcbiAqL1xuV2ViR0xNYW5hZ2VyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbiAoKVxue1xuXHQvLyBkbyBzb21lIGNvZGVzIGluaXQhXG59O1xuXG4vKipcbiAqIEdlbmVyaWMgZGVzdHJveSBtZXRob2RzIHRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN1YmNsYXNzXG4gKlxuICovXG5XZWJHTE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMucmVuZGVyZXIub2ZmKCdjb250ZXh0JywgdGhpcy5vbkNvbnRleHRDaGFuZ2UsIHRoaXMpO1xuXG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9XZWJHTE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHF1YWRcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGdsIGNvbnRleHQgZm9yIHRoaXMgcXVhZCB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIFF1YWQoZ2wpXG57XG4gICAgLypcbiAgICAgKiB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbi8vICAgIHRoaXMudGV4dHVyZXMgPSBuZXcgVGV4dHVyZVV2cygpO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDAsMCxcbiAgICAgICAgMjAwLDAsXG4gICAgICAgIDIwMCwyMDAsXG4gICAgICAgIDAsMjAwXG4gICAgXSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgVXZzIG9mIHRoZSBxdWFkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMCwwLFxuICAgICAgICAxLDAsXG4gICAgICAgIDEsMSxcbiAgICAgICAgMCwxXG4gICAgXSk7XG5cbi8vICAgIHZhciB3aGl0ZSA9ICgweEZGRkZGRiA+PiAxNikgKyAoMHhGRkZGRkYgJiAweGZmMDApICsgKCgweEZGRkZGRiAmIDB4ZmYpIDw8IDE2KSArICgxICogMjU1IDw8IDI0KTtcbiAgICAvL1RPRE8gY29udmVydCB0aGlzIHRvIGEgMzIgdW5zaWduZWQgaW50IGFycmF5XG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIGNvbXBvbmVudHMgb2YgdGhlIHRyaWFuZ2xlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsMSwxLDEsXG4gICAgICAgIDEsMSwxLDEsXG4gICAgICAgIDEsMSwxLDEsXG4gICAgICAgIDEsMSwxLDFcbiAgICBdKTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAgICAgMCwgMSwgMiwgMCwgMywgMlxuICAgIF0pO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXJcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn0gVGhlIGluZGV4IGJ1ZmZlclxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsICg4ICsgOCArIDE2KSAqIDQsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMudXBsb2FkKCk7XG59XG5cblF1YWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZDtcblxuLyoqXG4gKiBNYXBzIHR3byBSZWN0YW5nbGUgdG8gdGhlIHF1YWRcbiAqIEBwYXJhbSByZWN0IHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZpcnN0IHJlY3RhbmdsZVxuICogQHBhcmFtIHJlY3QyIHtQSVhJLlJlY3RhbmdsZX0gdGhlIHNlY29uZCByZWN0YW5nbGVcbiAqL1xuUXVhZC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24ocmVjdCwgcmVjdDIpXG57XG4gICAgdmFyIHggPSAwOyAvL3JlY3QyLnggLyByZWN0LndpZHRoO1xuICAgIHZhciB5ID0gMDsgLy9yZWN0Mi55IC8gcmVjdC5oZWlnaHQ7XG5cbiAgICB0aGlzLnV2c1swXSA9IHg7XG4gICAgdGhpcy51dnNbMV0gPSB5O1xuXG4gICAgdGhpcy51dnNbMl0gPSB4ICsgcmVjdDIud2lkdGggLyByZWN0LndpZHRoO1xuICAgIHRoaXMudXZzWzNdID0geTtcblxuICAgIHRoaXMudXZzWzRdID0geCArIHJlY3QyLndpZHRoIC8gcmVjdC53aWR0aDtcbiAgICB0aGlzLnV2c1s1XSA9IHkgKyByZWN0Mi5oZWlnaHQgLyByZWN0LmhlaWdodDtcblxuICAgIHRoaXMudXZzWzZdID0geDtcbiAgICB0aGlzLnV2c1s3XSA9IHkgKyByZWN0Mi5oZWlnaHQgLyByZWN0LmhlaWdodDtcblxuICAgIC8vLyAtLS0tLVxuICAgIHggPSByZWN0Mi54O1xuICAgIHkgPSByZWN0Mi55O1xuXG4gICAgdGhpcy52ZXJ0aWNlc1swXSA9IHg7XG4gICAgdGhpcy52ZXJ0aWNlc1sxXSA9IHk7XG5cbiAgICB0aGlzLnZlcnRpY2VzWzJdID0geCArIHJlY3QyLndpZHRoO1xuICAgIHRoaXMudmVydGljZXNbM10gPSB5O1xuXG4gICAgdGhpcy52ZXJ0aWNlc1s0XSA9IHggKyByZWN0Mi53aWR0aDtcbiAgICB0aGlzLnZlcnRpY2VzWzVdID0geSArIHJlY3QyLmhlaWdodDtcblxuICAgIHRoaXMudmVydGljZXNbNl0gPSB4O1xuICAgIHRoaXMudmVydGljZXNbN10gPSB5ICsgcmVjdDIuaGVpZ2h0O1xuXG4gICAgdGhpcy51cGxvYWQoKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIGJ1ZmZlciBhbmQgdXBsb2FkcyB0aGUgZGF0YVxuICovXG5RdWFkLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIFRPRE8gY291bGQgcHJvYmFibHkgYmUgcHVzaGVkIGludG8gb25lIHVwbG9hZCFcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyICk7XG5cbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy52ZXJ0aWNlcyk7XG5cbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgOCAqIDQsIHRoaXMudXZzKTtcblxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAoOCArIDgpICogNCwgdGhpcy5jb2xvcnMpO1xufTtcblxuUXVhZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIFxuICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1YWQ7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9RdWFkLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZXMgYSBDYW52YXMgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2l6ZS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIHdpZHRoIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIGhlaWdodCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgY2FudmFzXG4gKi9cbmZ1bmN0aW9uIENhbnZhc0J1ZmZlcih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBDYW52YXMgb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIENhbnZhc0J1ZmZlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbn1cblxuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc0J1ZmZlcjtcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzQnVmZmVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYW52YXNCdWZmZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5DYW52YXNCdWZmZXIjXG4gICAgICovXG4gICAgd2lkdGg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB2YWw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyBidWZmZXIgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNhbnZhc0J1ZmZlciNcbiAgICAgKi9cbiAgICBoZWlnaHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENsZWFycyB0aGUgY2FudmFzIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIENhbnZhc0J1ZmZlciBjbGFzcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAqL1xuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyBjYW52YXMuXG4gKlxuICovXG5DYW52YXNCdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0J1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hdGggPSByZXF1aXJlKCcuLi9tYXRoJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLFxuICAgIERpc3BsYXlPYmplY3QgPSByZXF1aXJlKCcuL0Rpc3BsYXlPYmplY3QnKSxcbiAgICBSZW5kZXJUZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvUmVuZGVyVGV4dHVyZScpLFxuICAgIF90ZW1wTWF0cml4ID0gbmV3IG1hdGguTWF0cml4KCk7XG5cbi8qKlxuICogQSBDb250YWluZXIgcmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgZGlzcGxheSBvYmplY3RzLlxuICogSXQgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXkgb2JqZWN0cyB0aGF0IGFjdCBhcyBhIGNvbnRhaW5lciBmb3Igb3RoZXIgb2JqZWN0cy5cbiAqXG4gKmBgYGpzXG4gKiB2YXIgY29udGFpbmVyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XG4gKiBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqIGBgYFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkRpc3BsYXlPYmplY3RcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmZ1bmN0aW9uIENvbnRhaW5lcigpXG57XG4gICAgRGlzcGxheU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0W119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuQ29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGlzcGxheU9iamVjdC5wcm90b3R5cGUpO1xuQ29udGFpbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhaW5lcjtcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb250YWluZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xuICAgICAqL1xuICAgIHdpZHRoOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAod2lkdGggIT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnggPSAxO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgQ29udGFpbmVyLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkNvbnRhaW5lciNcbiAgICAgKi9cbiAgICBoZWlnaHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuc2NhbGUueSAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gaGVpZ2h0IDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIE92ZXJyaWRhYmxlIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGJ5IENvbnRhaW5lciBzdWJjbGFzc2VzIHdoZW5ldmVyIHRoZSBjaGlsZHJlbiBhcnJheSBpcyBtb2RpZmllZFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUub25DaGlsZHJlbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vKipcbiAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyLlxuICogXG4gKiBZb3UgY2FuIGFsc28gYWRkIG11bHRwbGUgaXRlbXMgbGlrZSBzbzogbXlDb250YWluZXIuYWRkQ2hpbGQodGhpbmtPbmUsIHRoaW5nVHdvLCB0aGluZ1RocmVlKVxuICogQHBhcmFtIGNoaWxkIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIGFkZCB0byB0aGUgY29udGFpbmVyXG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZClcbnsgXG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBhcmd1bWVudCB3ZSBjYW4gYnlwYXNzIGxvb3BpbmcgdGhyb3VnaCB0aGUgdGhlbVxuICAgIGlmKGFyZ3VtZW50c0xlbmd0aCA+IDEpXG4gICAge1xuICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGFyZ3VtZW50cyBwcm9wZXJ0eSBhbmQgYWRkIGFsbCBjaGlsZHJlblxuICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXNlZCBieSBKUyBydW50aW1lc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c0xlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKCBhcmd1bWVudHNbaV0gKTtcbiAgICAgICAgfVxuICAgIH0gICAgIFxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIGlmIHRoZSBjaGlsZCBoYXMgYSBwYXJlbnQgdGhlbiBsZXRzIHJlbW92ZSBpdCBhcyBQaXhpIG9iamVjdHMgY2FuIG9ubHkgZXhpc3QgaW4gb25lIHBsYWNlXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZSh0aGlzLmNoaWxkcmVuLmxlbmd0aC0xKTtcbiAgICAgICAgY2hpbGQuZW1pdCgnYWRkZWQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICpcbiAqIEBwYXJhbSBjaGlsZCB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdG8gYWRkXG4gKiBAcGFyYW0gaW5kZXgge251bWJlcn0gVGhlIGluZGV4IHRvIHBsYWNlIHRoZSBjaGlsZCBpblxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpXG57XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICAgICAgY2hpbGQuZW1pdCgnYWRkZWQnLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjaGlsZCArICdhZGRDaGlsZEF0OiBUaGUgaW5kZXggJysgaW5kZXggKycgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAnICsgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU3dhcHMgdGhlIHBvc2l0aW9uIG9mIDIgRGlzcGxheSBPYmplY3RzIHdpdGhpbiB0aGlzIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0gY2hpbGQge1BJWEkuRGlzcGxheU9iamVjdH1cbiAqIEBwYXJhbSBjaGlsZDIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5zd2FwQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkMilcbntcbiAgICBpZiAoY2hpbGQgPT09IGNoaWxkMilcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICB2YXIgaW5kZXgyID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkMik7XG5cbiAgICBpZiAoaW5kZXgxIDwgMCB8fCBpbmRleDIgPCAwKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzd2FwQ2hpbGRyZW46IEJvdGggdGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3RzIG11c3QgYmUgY2hpbGRyZW4gb2YgdGhlIGNhbGxlci4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4MV0gPSBjaGlsZDI7XG4gICAgdGhpcy5jaGlsZHJlbltpbmRleDJdID0gY2hpbGQ7XG4gICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4MSA8IGluZGV4MiA/IGluZGV4MSA6IGluZGV4Mik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IHBvc2l0aW9uIG9mIGEgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSBjaGlsZCB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB0byBpZGVudGlmeVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0IHRvIGlkZW50aWZ5XG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZClcbntcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXJcbiAqXG4gKiBAcGFyYW0gY2hpbGQge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXG4gKiBAcGFyYW0gaW5kZXgge251bWJlcn0gVGhlIHJlc3VsdGluZyBpbmRleCBudW1iZXIgZm9yIHRoZSBjaGlsZCBkaXNwbGF5IG9iamVjdFxuICovXG5Db250YWluZXIucHJvdG90eXBlLnNldENoaWxkSW5kZXggPSBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KVxue1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdXBwbGllZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XG5cbiAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBjdXJyZW50SW5kZXgsIDEpOyAvLyByZW1vdmUgZnJvbSBvbGQgcG9zaXRpb25cbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpOyAvL2FkZCBhdCBuZXcgcG9zaXRpb25cbiAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gKlxuICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGF0XG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGFueS5cbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEF0ID0gZnVuY3Rpb24gKGluZGV4KVxue1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENoaWxkQXQ6IFN1cHBsaWVkIGluZGV4ICcgKyBpbmRleCArICcgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNoaWxkIGxpc3QsIG9yIHRoZSBzdXBwbGllZCBEaXNwbGF5T2JqZWN0IGlzIG5vdCBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIGNoaWxkIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZClcbntcbiAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGFyZ3VtZW50IHdlIGNhbiBieXBhc3MgbG9vcGluZyB0aHJvdWdoIHRoZSB0aGVtXG4gICAgaWYoYXJndW1lbnRzTGVuZ3RoID4gMSlcbiAgICB7XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXG4gICAgICAgIC8vIHVzZSBpdCB0aGUgcmlnaHQgd2F5ICgubGVuZ3RoIGFuZCBbaV0pIHNvIHRoYXQgdGhpcyBmdW5jdGlvbiBjYW4gc3RpbGwgYmUgb3B0aW1pc2VkIGJ5IEpTIHJ1bnRpbWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzTGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoIGFyZ3VtZW50c1tpXSApO1xuICAgICAgICB9XG4gICAgfSAgICAgXG4gICAgZWxzZVxuICAgIHsgICBcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG5cbiAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgICAgICBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBmcm9tXG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxuICovXG5Db250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkQXQgPSBmdW5jdGlvbiAoaW5kZXgpXG57XG4gICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcblxuICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgdXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpO1xuXG4gICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgY2hpbGQuZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICpcbiAqIEBwYXJhbSBiZWdpbkluZGV4IHtudW1iZXJ9IFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAqIEBwYXJhbSBlbmRJbmRleCB7bnVtYmVyfSBUaGUgZW5kaW5nIHBvc2l0aW9uLiBEZWZhdWx0IHZhbHVlIGlzIHNpemUgb2YgdGhlIGNvbnRhaW5lci5cbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChiZWdpbkluZGV4LCBlbmRJbmRleClcbntcbiAgICB2YXIgYmVnaW4gPSBiZWdpbkluZGV4IHx8IDA7XG4gICAgdmFyIGVuZCA9IHR5cGVvZiBlbmRJbmRleCA9PT0gJ251bWJlcicgPyBlbmRJbmRleCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciByYW5nZSA9IGVuZCAtIGJlZ2luO1xuICAgIHZhciByZW1vdmVkLCBpO1xuXG4gICAgaWYgKHJhbmdlID4gMCAmJiByYW5nZSA8PSBlbmQpXG4gICAge1xuICAgICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVtb3ZlZFtpXS5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGJlZ2luSW5kZXgpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW1vdmVkW2ldLmVtaXQoJ3JlbW92ZWQnLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5nZSA9PT0gMCAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS4nKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcbiAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGRpc3BsYXlPYmplY3QgaXMgc3RhdGljIC8gY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSByZXNvbHV0aW9uIHtudW1iZXJ9IFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZFxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxuICovXG5Db250YWluZXIucHJvdG90eXBlLmdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIChyZW5kZXJlciwgcmVzb2x1dGlvbiwgc2NhbGVNb2RlKVxue1xuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG5cbiAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBSZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCBib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcblxuICAgIF90ZW1wTWF0cml4LnR4ID0gLWJvdW5kcy54O1xuICAgIF90ZW1wTWF0cml4LnR5ID0gLWJvdW5kcy55O1xuXG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcywgX3RlbXBNYXRyaXgpO1xuXG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9uIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBmb3IgcmVuZGVyaW5nXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy52aXNpYmxlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxufTtcblxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxuQ29udGFpbmVyLnByb3RvdHlwZS5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSBDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgQ29udGFpbmVyIGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIGFsbCB2aXNpYmxlIGNoaWxkcmVuIGludG8gY29uc2lkZXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmKCF0aGlzLl9jdXJyZW50Qm91bmRzKVxuICAgIHtcblxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLlJlY3RhbmdsZS5FTVBUWTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gdGhlIGJvdW5kcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxjdWxhdGVkIHRoaXMgcmVuZGVyIHNlc3Npb24gc28gcmV0dXJuIHdoYXQgd2UgaGF2ZVxuXG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG5cbiAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAgIHZhciBjaGlsZEJvdW5kcztcbiAgICAgICAgdmFyIGNoaWxkTWF4WDtcbiAgICAgICAgdmFyIGNoaWxkTWF4WTtcblxuICAgICAgICB2YXIgY2hpbGRWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZFZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBjaGlsZEJvdW5kcyA9IHRoaXMuY2hpbGRyZW5baV0uZ2V0Qm91bmRzKCk7XG5cbiAgICAgICAgICAgIG1pblggPSBtaW5YIDwgY2hpbGRCb3VuZHMueCA/IG1pblggOiBjaGlsZEJvdW5kcy54O1xuICAgICAgICAgICAgbWluWSA9IG1pblkgPCBjaGlsZEJvdW5kcy55ID8gbWluWSA6IGNoaWxkQm91bmRzLnk7XG5cbiAgICAgICAgICAgIGNoaWxkTWF4WCA9IGNoaWxkQm91bmRzLndpZHRoICsgY2hpbGRCb3VuZHMueDtcbiAgICAgICAgICAgIGNoaWxkTWF4WSA9IGNoaWxkQm91bmRzLmhlaWdodCArIGNoaWxkQm91bmRzLnk7XG5cbiAgICAgICAgICAgIG1heFggPSBtYXhYID4gY2hpbGRNYXhYID8gbWF4WCA6IGNoaWxkTWF4WDtcbiAgICAgICAgICAgIG1heFkgPSBtYXhZID4gY2hpbGRNYXhZID8gbWF4WSA6IGNoaWxkTWF4WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hpbGRWaXNpYmxlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5SZWN0YW5nbGUuRU1QVFk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICAgICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgICAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICAgICAgYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBib3VuZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCb3VuZHM7XG59O1xuXG5Db250YWluZXIucHJvdG90eXBlLmNvbnRhaW5lckdldEJvdW5kcyA9IENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Qm91bmRzO1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbm9uLWdsb2JhbCBsb2NhbCBib3VuZHMgb2YgdGhlIENvbnRhaW5lciBhcyBhIHJlY3RhbmdsZS5cbiAqIFRoZSBjYWxjdWxhdGlvbiB0YWtlcyBhbGwgdmlzaWJsZSBjaGlsZHJlbiBpbnRvIGNvbnNpZGVyYXRpb24uXG4gKlxuICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBtYXRyaXhDYWNoZSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbWF0aC5NYXRyaXguSURFTlRJVFk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbWF0cml4Q2FjaGU7XG5cbiAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcblxuICAgIHJldHVybiB0aGlzLmdldEJvdW5kcyggbWF0aC5NYXRyaXguSURFTlRJVFkgKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXJcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcblxuICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpLCBqO1xuXG4gICAgLy8gZG8gYSBxdWljayBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBhIG1hc2sgb3IgYSBmaWx0ZXIuXG4gICAgaWYgKHRoaXMuX21hc2sgfHwgdGhpcy5fZmlsdGVycylcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xuXG4gICAgICAgIC8vIHB1c2ggZmlsdGVyIGZpcnN0IGFzIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyBjb3JyZWN0IGZvciBhbnkgbWFza2luZ1xuICAgICAgICBpZiAodGhpcy5fZmlsdGVycyAmJiB0aGlzLl9maWx0ZXJzLmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVyKHRoaXMsIHRoaXMuX2ZpbHRlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMsIHRoaXMuX21hc2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG5cbiAgICAgICAgLy8gYWRkIHRoaXMgb2JqZWN0IHRvIHRoZSBiYXRjaCwgb25seSByZW5kZXJlZCBpZiBpdCBoYXMgYSB0ZXh0dXJlLlxuICAgICAgICB0aGlzLl9yZW5kZXJXZWJHTChyZW5kZXJlcik7XG5cbiAgICAgICAgLy8gbm93IGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gYW5kIG1ha2Ugc3VyZSB0aGV5IGdldCByZW5kZXJlZFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyV2ViR0wocmVuZGVyZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnBvcE1hc2sodGhpcywgdGhpcy5fbWFzayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmlsdGVycylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5wb3BGaWx0ZXIoKTtcblxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9yZW5kZXJXZWJHTChyZW5kZXJlcik7XG5cbiAgICAgICAgLy8gc2ltcGxlIHJlbmRlciBjaGlsZHJlbiFcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcldlYkdMKHJlbmRlcmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVG8gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3ViY2xhc3NcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5Db250YWluZXIucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcikgLy8ganNoaW50IHVudXNlZDpmYWxzZVxue1xuICAgIC8vIHRoaXMgaXMgd2hlcmUgY29udGVudCBpdHNlbGYgZ2V0cyByZW5kZXJlZC4uLlxufTtcblxuLyoqXG4gKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc1xuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5Db250YWluZXIucHJvdG90eXBlLl9yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiAocmVuZGVyZXIpIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbntcbiAgICAvLyB0aGlzIGlzIHdoZXJlIGNvbnRlbnQgaXRzZWxmIGdldHMgcmVuZGVyZWQuLi5cbn07XG5cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIC8vIGlmIG5vdCB2aXNpYmxlIG9yIHRoZSBhbHBoYSBpcyAwIHRoZW4gbm8gbmVlZCB0byByZW5kZXIgdGhpc1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMuYWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5fbWFzaywgcmVuZGVyZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFzaylcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLm1hc2tNYW5hZ2VyLnBvcE1hc2socmVuZGVyZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtIFtkZXN0cm95Q2hpbGRyZW49ZmFsc2VdIHtib29sZWFufSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGxcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGRlc3Ryb3lDaGlsZHJlbilcbntcbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICBpZiAoZGVzdHJveUNoaWxkcmVuKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kZXN0cm95KGRlc3Ryb3lDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cbiAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvZGlzcGxheS9Db250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpLFxuICAgIFRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlJyksXG4gICAgQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vZGlzcGxheS9Db250YWluZXInKSxcbiAgICBDYW52YXNUaW50ZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc1RpbnRlcicpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgdGVtcFBvaW50ID0gbmV3IG1hdGguUG9pbnQoKSxcbiAgICBHcm91cEQ4ID0gbWF0aC5Hcm91cEQ4LFxuICAgIGNhbnZhc1JlbmRlcldvcmxkVHJhbnNmb3JtID0gbmV3IG1hdGguTWF0cml4KCk7XG5cbi8qKlxuICogVGhlIFNwcml0ZSBvYmplY3QgaXMgdGhlIGJhc2UgZm9yIGFsbCB0ZXh0dXJlZCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBzY3JlZW5cbiAqXG4gKiBBIHNwcml0ZSBjYW4gYmUgY3JlYXRlZCBkaXJlY3RseSBmcm9tIGFuIGltYWdlIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ2Fzc2V0cy9pbWFnZS5wbmcnKTtcbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSBUaGUgdGV4dHVyZSBmb3IgdGhpcyBzcHJpdGVcbiAqL1xuZnVuY3Rpb24gU3ByaXRlKHRleHR1cmUpXG57XG4gICAgQ29udGFpbmVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBUaGUgZGVmYXVsdCBpcyAwLDAgdGhpcyBtZWFucyB0aGUgdGV4dHVyZSdzIG9yaWdpbiBpcyB0aGUgdG9wIGxlZnRcbiAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMC41LDAuNSBtZWFucyB0aGUgdGV4dHVyZSdzIG9yaWdpbiBpcyBjZW50ZXJlZFxuICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAxLDEgd291bGQgbWVhbiB0aGUgdGV4dHVyZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yID0gbmV3IG1hdGguUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fd2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlICh0aGlzIGlzIGluaXRpYWxseSBzZXQgYnkgdGhlIHRleHR1cmUpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAqL1xuICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kTW9kZSA9IENPTlNULkJMRU5EX01PREVTLk5PUk1BTDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFkZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBzcHJpdGUuIFNldCB0byBudWxsIHRvIHJlbW92ZSBhIGN1cnJlbnQgc2hhZGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5BYnN0cmFjdEZpbHRlcnxQSVhJLlNoYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZWQgdmFsdWUgb2YgdGhlIHRpbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcblxuICAgIC8vIGNhbGwgdGV4dHVyZSBzZXR0ZXJcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlIHx8IFRleHR1cmUuRU1QVFk7XG59XG5cbi8vIGNvbnN0cnVjdG9yXG5TcHJpdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb250YWluZXIucHJvdG90eXBlKTtcblNwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGU7XG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3ByaXRlLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLlNwcml0ZSNcbiAgICAgKi9cbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy50ZXh0dXJlLl9mcmFtZS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzaWduID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSBzaWduICogdmFsdWUgLyB0aGlzLnRleHR1cmUuX2ZyYW1lLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuU3ByaXRlI1xuICAgICAqL1xuICAgIGhlaWdodDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAgTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMudGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNpZ24gPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHNpZ24gKiB2YWx1ZSAvIHRoaXMudGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuU3ByaXRlI1xuICAgICAqL1xuICAgIHRleHR1cmU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuX3RleHR1cmU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSA9PT0gdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSB0ZXh0dXJlIHRvIGxvYWRcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLm9uY2UoJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICpcbiAqIEBwcml2YXRlXG4gKi9cblNwcml0ZS5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gc28gaWYgX3dpZHRoIGlzIDAgdGhlbiB3aWR0aCB3YXMgbm90IHNldC4uXG4gICAgaWYgKHRoaXMuX3dpZHRoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLngpICogdGhpcy5fd2lkdGggLyB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2hlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9IHV0aWxzLnNpZ24odGhpcy5zY2FsZS55KSAqIHRoaXMuX2hlaWdodCAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgfVxufTtcblxuLyoqXG4qXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbipcbiogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9XG4qIEBwcml2YXRlXG4qL1xuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5zcHJpdGUpO1xuICAgIHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlLnJlbmRlcih0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBTcHJpdGUgYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cbiAqXG4gKiBAcGFyYW0gbWF0cml4IHtQSVhJLk1hdHJpeH0gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgc3ByaXRlXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gKi9cblNwcml0ZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKG1hdHJpeClcbntcbiAgICBpZighdGhpcy5fY3VycmVudEJvdW5kcylcbiAgICB7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl90ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHcwID0gd2lkdGggKiAoMS10aGlzLmFuY2hvci54KTtcbiAgICAgICAgdmFyIHcxID0gd2lkdGggKiAtdGhpcy5hbmNob3IueDtcblxuICAgICAgICB2YXIgaDAgPSBoZWlnaHQgKiAoMS10aGlzLmFuY2hvci55KTtcbiAgICAgICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XG5cbiAgICAgICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gbWF0cml4IHx8IHRoaXMud29ybGRUcmFuc2Zvcm0gO1xuXG4gICAgICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcbiAgICAgICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5iO1xuICAgICAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmM7XG4gICAgICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcbiAgICAgICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xuXG4gICAgICAgIHZhciBtaW5YLFxuICAgICAgICAgICAgbWF4WCxcbiAgICAgICAgICAgIG1pblksXG4gICAgICAgICAgICBtYXhZO1xuXG4gICAgICAgIC8vVE9ETyAtIEkgYW0gU1VSRSB0aGlzIGNhbiBiZSBvcHRpbWlzZWQsIGJ1dCB0aGUgYmVsb3cgaXMgbm90IGFjY3VyYXRlIGVub3VnaC4uXG4gICAgICAgIC8qXG4gICAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHNjYWxlIG1heSBiZSBuZWdhdGl2ZSFcbiAgICAgICAgICAgIGlmIChhIDwgMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhICo9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZCAqPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGVyZSBpcyBubyByb3RhdGlvbiBnb2luZyBvbiByaWdodD8gUklHSFQ/XG4gICAgICAgICAgICAvLyBpZiB0aGF0cyB0aGUgY2FzZSB0aGVuIHdlIGNhbiBhdm9pZCBjaGVja2luZyB0aGUgYm91bmQgdmFsdWVzISB5YXlcbiAgICAgICAgICAgIG1pblggPSBhICogdzEgKyB0eDtcbiAgICAgICAgICAgIG1heFggPSBhICogdzAgKyB0eDtcbiAgICAgICAgICAgIG1pblkgPSBkICogaDEgKyB0eTtcbiAgICAgICAgICAgIG1heFkgPSBkICogaDAgKyB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgKi9cblxuICAgICAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICAgICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgICAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgICAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgICAgICBtaW5YID0geDE7XG4gICAgICAgIG1pblggPSB4MiA8IG1pblggPyB4MiA6IG1pblg7XG4gICAgICAgIG1pblggPSB4MyA8IG1pblggPyB4MyA6IG1pblg7XG4gICAgICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XG5cbiAgICAgICAgbWluWSA9IHkxO1xuICAgICAgICBtaW5ZID0geTIgPCBtaW5ZID8geTIgOiBtaW5ZO1xuICAgICAgICBtaW5ZID0geTMgPCBtaW5ZID8geTMgOiBtaW5ZO1xuICAgICAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgICAgIG1heFggPSB4MTtcbiAgICAgICAgbWF4WCA9IHgyID4gbWF4WCA/IHgyIDogbWF4WDtcbiAgICAgICAgbWF4WCA9IHgzID4gbWF4WCA/IHgzIDogbWF4WDtcbiAgICAgICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgICAgICBtYXhZID0geTE7XG4gICAgICAgIG1heFkgPSB5MiA+IG1heFkgPyB5MiA6IG1heFk7XG4gICAgICAgIG1heFkgPSB5MyA+IG1heFkgPyB5MyA6IG1heFk7XG4gICAgICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XG5cbiAgICAgICAgLy99XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGNoaWxkcmVuXG4gICAgICAgIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2hpbGRCb3VuZHMgPSB0aGlzLmNvbnRhaW5lckdldEJvdW5kcygpO1xuXG4gICAgICAgICAgICB3MCA9IGNoaWxkQm91bmRzLng7XG4gICAgICAgICAgICB3MSA9IGNoaWxkQm91bmRzLnggKyBjaGlsZEJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgIGgwID0gY2hpbGRCb3VuZHMueTtcbiAgICAgICAgICAgIGgxID0gY2hpbGRCb3VuZHMueSArIGNoaWxkQm91bmRzLmhlaWdodDtcblxuICAgICAgICAgICAgbWluWCA9IChtaW5YIDwgdzApID8gbWluWCA6IHcwO1xuICAgICAgICAgICAgbWluWSA9IChtaW5ZIDwgaDApID8gbWluWSA6IGgwO1xuXG4gICAgICAgICAgICBtYXhYID0gKG1heFggPiB3MSkgPyBtYXhYIDogdzE7XG4gICAgICAgICAgICBtYXhZID0gKG1heFkgPiBoMSkgPyBtYXhZIDogaDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICAgICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG5cbiAgICAgICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgICAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAgICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJvdW5kcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBzcHJpdGUgb2JqZWN0LlxuICpcbiAqL1xuU3ByaXRlLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fYm91bmRzLnggPSAtdGhpcy5fdGV4dHVyZS5fZnJhbWUud2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgIHRoaXMuX2JvdW5kcy55ID0gLXRoaXMuX3RleHR1cmUuX2ZyYW1lLmhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG4gICAgdGhpcy5fYm91bmRzLndpZHRoID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgdGhpcy5fYm91bmRzLmhlaWdodCA9IHRoaXMuX3RleHR1cmUuX2ZyYW1lLmhlaWdodDtcbiAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xufTtcblxuLyoqXG4qIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgc3ByaXRlXG4qXG4qIEBwYXJhbSBwb2ludCB7UElYSS5Qb2ludH0gdGhlIHBvaW50IHRvIHRlc3RcbiogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxuKi9cblNwcml0ZS5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKCBwb2ludCApXG57XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsICB0ZW1wUG9pbnQpO1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX3RleHR1cmUuX2ZyYW1lLmhlaWdodDtcbiAgICB2YXIgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgIHZhciB5MTtcblxuICAgIGlmICggdGVtcFBvaW50LnggPiB4MSAmJiB0ZW1wUG9pbnQueCA8IHgxICsgd2lkdGggKVxuICAgIHtcbiAgICAgICAgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcblxuICAgICAgICBpZiAoIHRlbXBQb2ludC55ID4geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qXG4qIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXG4qIEBwcml2YXRlXG4qL1xuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIGlmICh0aGlzLnRleHR1cmUuY3JvcC53aWR0aCA8PSAwIHx8IHRoaXMudGV4dHVyZS5jcm9wLmhlaWdodCA8PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3RoaXMuYmxlbmRNb2RlXTtcbiAgICBpZiAoY29tcG9zaXRlT3BlcmF0aW9uICE9PSByZW5kZXJlci5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbilcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIH1cblxuICAgIC8vICBJZ25vcmUgbnVsbCBzb3VyY2VzXG4gICAgaWYgKHRoaXMudGV4dHVyZS52YWxpZClcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZSxcbiAgICAgICAgICAgIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybSxcbiAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgZHksXG4gICAgICAgICAgICB3aWR0aCA9IHRleHR1cmUuY3JvcC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRleHR1cmUuY3JvcC5oZWlnaHQ7XG5cbiAgICAgICAgcmVuZGVyZXIuY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcblxuICAgICAgICAvLyBJZiBzbW9vdGhpbmdFbmFibGVkIGlzIHN1cHBvcnRlZCBhbmQgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIHNtb290aGluZyBwcm9wZXJ0eSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIHZhciBzbW9vdGhpbmdFbmFibGVkID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGUgPT09IENPTlNULlNDQUxFX01PREVTLkxJTkVBUjtcbiAgICAgICAgaWYgKHJlbmRlcmVyLnNtb290aFByb3BlcnR5ICYmIHJlbmRlcmVyLmNvbnRleHRbcmVuZGVyZXIuc21vb3RoUHJvcGVydHldICE9PSBzbW9vdGhpbmdFbmFibGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0W3JlbmRlcmVyLnNtb290aFByb3BlcnR5XSA9IHNtb290aGluZ0VuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lubGluZSBHcm91cEQ4LmlzU3dhcFdpZHRoSGVpZ2h0XG4gICAgICAgIGlmICgodGV4dHVyZS5yb3RhdGUgJiAzKSA9PT0gMikge1xuICAgICAgICAgICAgd2lkdGggPSB0ZXh0dXJlLmNyb3AuaGVpZ2h0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGV4dHVyZS5jcm9wLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLnRyaW0pIHtcbiAgICAgICAgICAgIGR4ID0gdGV4dHVyZS5jcm9wLndpZHRoLzIgKyB0ZXh0dXJlLnRyaW0ueCAtIHRoaXMuYW5jaG9yLnggKiB0ZXh0dXJlLnRyaW0ud2lkdGg7XG4gICAgICAgICAgICBkeSA9IHRleHR1cmUuY3JvcC5oZWlnaHQvMiArIHRleHR1cmUudHJpbS55IC0gdGhpcy5hbmNob3IueSAqIHRleHR1cmUudHJpbS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkeCA9ICgwLjUgLSB0aGlzLmFuY2hvci54KSAqIHRleHR1cmUuX2ZyYW1lLndpZHRoO1xuICAgICAgICAgICAgZHkgPSAoMC41IC0gdGhpcy5hbmNob3IueSkgKiB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGV4dHVyZS5yb3RhdGUpIHtcbiAgICAgICAgICAgIHd0LmNvcHkoY2FudmFzUmVuZGVyV29ybGRUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgd3QgPSBjYW52YXNSZW5kZXJXb3JsZFRyYW5zZm9ybTtcbiAgICAgICAgICAgIEdyb3VwRDgubWF0cml4QXBwZW5kUm90YXRpb25JbnYod3QsIHRleHR1cmUucm90YXRlLCBkeCwgZHkpO1xuICAgICAgICAgICAgLy8gdGhlIGFuY2hvciBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYWJvdmUsIHNvIGxldHMgc2V0IGl0IHRvIHplcm9cbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkeCAtPSB3aWR0aC8yO1xuICAgICAgICBkeSAtPSBoZWlnaHQvMjtcbiAgICAgICAgLy8gQWxsb3cgZm9yIHBpeGVsIHJvdW5kaW5nXG4gICAgICAgIGlmIChyZW5kZXJlci5yb3VuZFBpeGVscylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgd3QuYSxcbiAgICAgICAgICAgICAgICB3dC5iLFxuICAgICAgICAgICAgICAgIHd0LmMsXG4gICAgICAgICAgICAgICAgd3QuZCxcbiAgICAgICAgICAgICAgICAod3QudHggKiByZW5kZXJlci5yZXNvbHV0aW9uKSB8IDAsXG4gICAgICAgICAgICAgICAgKHd0LnR5ICogcmVuZGVyZXIucmVzb2x1dGlvbikgfCAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkeCA9IGR4IHwgMDtcbiAgICAgICAgICAgIGR5ID0gZHkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuXG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICB3dC5hLFxuICAgICAgICAgICAgICAgIHd0LmIsXG4gICAgICAgICAgICAgICAgd3QuYyxcbiAgICAgICAgICAgICAgICB3dC5kLFxuICAgICAgICAgICAgICAgIHd0LnR4ICogcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICB3dC50eSAqIHJlbmRlcmVyLnJlc29sdXRpb25cbiAgICAgICAgICAgICk7XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMudGludCAhPT0gMHhGRkZGRkYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlZFRpbnQgIT09IHRoaXMudGludClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSB0aGlzLnRpbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIGNsZWFuIHVwIGNhY2hpbmcgLSBob3cgdG8gY2xlYW4gdXAgdGhlIGNhY2hlcz9cbiAgICAgICAgICAgICAgICB0aGlzLnRpbnRlZFRleHR1cmUgPSBDYW52YXNUaW50ZXIuZ2V0VGludGVkVGV4dHVyZSh0aGlzLCB0aGlzLnRpbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0aGlzLnRpbnRlZFRleHR1cmUsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHdpZHRoICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQgKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIGR4ICogcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBkeSAqIHJlbmRlcmVyLnJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgd2lkdGggKiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIGhlaWdodCAqIHJlbmRlcmVyLnJlc29sdXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmNyb3AueCAqIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5jcm9wLnkgKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIHdpZHRoICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQgKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIGR4ICAqIHJlbmRlcmVyLnJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgZHkgICogcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aCAqIHJlbmRlcmVyLnJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICogcmVuZGVyZXIucmVzb2x1dGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyBzcHJpdGUgYW5kIG9wdGlvbmFsbHkgaXRzIHRleHR1cmVcbiAqXG4gKiBAcGFyYW0gW2Rlc3Ryb3lUZXh0dXJlPWZhbHNlXSB7Ym9vbGVhbn0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAqIEBwYXJhbSBbZGVzdHJveUJhc2VUZXh0dXJlPWZhbHNlXSB7Ym9vbGVhbn0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAqL1xuU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGRlc3Ryb3lUZXh0dXJlLCBkZXN0cm95QmFzZVRleHR1cmUpXG57XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmFuY2hvciA9IG51bGw7XG5cbiAgICBpZiAoZGVzdHJveVRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koZGVzdHJveUJhc2VUZXh0dXJlKTtcbiAgICB9XG5cbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG59O1xuXG4vLyBzb21lIGhlbHBlciBmdW5jdGlvbnMuLlxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVDYWNoZSBiYXNlZCBvbiB0aGUgZnJhbWVJZFxuICogVGhlIGZyYW1lIGlkcyBhcmUgY3JlYXRlZCB3aGVuIGEgVGV4dHVyZSBwYWNrZXIgZmlsZSBoYXMgYmVlbiBsb2FkZWRcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZnJhbWVJZCB7c3RyaW5nfSBUaGUgZnJhbWUgSWQgb2YgdGhlIHRleHR1cmUgaW4gdGhlIGNhY2hlXG4gKiBAcGFyYW0gW2Nyb3Nzb3JpZ2luPShhdXRvKV0ge2Jvb2xlYW59IGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIGNyb3NzLW9yaWdpbiBwYXJhbWV0ZXJcbiAqIEBwYXJhbSBbc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuREVGQVVMVF0ge251bWJlcn0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgc2NhbGUgbW9kZSwgc2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gQSBuZXcgU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBmcmFtZUlkXG4gKi9cblNwcml0ZS5mcm9tRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJZClcbntcbiAgICB2YXIgdGV4dHVyZSA9IHV0aWxzLlRleHR1cmVDYWNoZVtmcmFtZUlkXTtcblxuICAgIGlmICghdGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZScpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3ByaXRlKHRleHR1cmUpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBiYXNlZCBvbiBhbiBpbWFnZSB1cmxcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBsb2FkZWRcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gaW1hZ2VJZCB7c3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gQSBuZXcgU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBpbWFnZSBpZFxuICovXG5TcHJpdGUuZnJvbUltYWdlID0gZnVuY3Rpb24gKGltYWdlSWQsIGNyb3Nzb3JpZ2luLCBzY2FsZU1vZGUpXG57XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUoVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9zcHJpdGVzL1Nwcml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZHMgZm9yIFNwcml0ZS9UZXh0dXJlIHRpbnRpbmcuXG4gKiBAc3RhdGljXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBDYW52YXNUaW50ZXIgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzVGludGVyO1xuXG4vKipcbiAqIEJhc2ljYWxseSB0aGlzIG1ldGhvZCBqdXN0IG5lZWRzIGEgc3ByaXRlIGFuZCBhIGNvbG9yIGFuZCB0aW50cyB0aGUgc3ByaXRlIHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICpcbiAqIEBwYXJhbSBzcHJpdGUge1BJWEkuU3ByaXRlfSB0aGUgc3ByaXRlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHRpbnRlZCBjYW52YXNcbiAqL1xuQ2FudmFzVGludGVyLmdldFRpbnRlZFRleHR1cmUgPSBmdW5jdGlvbiAoc3ByaXRlLCBjb2xvcilcbntcbiAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlO1xuXG4gICAgY29sb3IgPSBDYW52YXNUaW50ZXIucm91bmRDb2xvcihjb2xvcik7XG5cbiAgICB2YXIgc3RyaW5nQ29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggY29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG5cbiAgICB0ZXh0dXJlLnRpbnRDYWNoZSA9IHRleHR1cmUudGludENhY2hlIHx8IHt9O1xuXG4gICAgaWYgKHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl07XG4gICAgfVxuXG4gICAgIC8vIGNsb25lIHRleHR1cmUuLlxuICAgIHZhciBjYW52YXMgPSBDYW52YXNUaW50ZXIuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLy9DYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbCh0ZXh0dXJlLCBzdHJpbmdDb2xvciwgY2FudmFzKTtcbiAgICBDYW52YXNUaW50ZXIudGludE1ldGhvZCh0ZXh0dXJlLCBjb2xvciwgY2FudmFzKTtcblxuICAgIGlmIChDYW52YXNUaW50ZXIuY29udmVydFRpbnRUb0ltYWdlKVxuICAgIHtcbiAgICAgICAgLy8gaXMgdGhpcyBiZXR0ZXI/XG4gICAgICAgIHZhciB0aW50SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdGludEltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcblxuICAgICAgICB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0gPSB0aW50SW1hZ2U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSA9IGNhbnZhcztcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBjb252ZXJ0aW5nIHRoZSB0ZXh0dXJlIHRvIGFuIGltYWdlIHRoZW4gd2UgbmVlZCB0byBsb3NlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhc1xuICAgICAgICBDYW52YXNUaW50ZXIuY2FudmFzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzO1xufTtcblxuLyoqXG4gKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgJ211bHRpcGx5JyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHRleHR1cmUge1BJWEkuVGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdGludFxuICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcbiAqL1xuQ2FudmFzVGludGVyLnRpbnRXaXRoTXVsdGlwbHkgPSBmdW5jdGlvbiAodGV4dHVyZSwgY29sb3IsIGNhbnZhcylcbntcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcblxuICAgIHZhciBjcm9wID0gdGV4dHVyZS5jcm9wLmNsb25lKCk7XG4gICAgY3JvcC54ICo9IHJlc29sdXRpb247XG4gICAgY3JvcC55ICo9IHJlc29sdXRpb247XG4gICAgY3JvcC53aWR0aCAqPSByZXNvbHV0aW9uO1xuICAgIGNyb3AuaGVpZ2h0ICo9IHJlc29sdXRpb247XG5cbiAgICBjYW52YXMud2lkdGggPSBjcm9wLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjcm9wLmhlaWdodDtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIGNyb3AueCxcbiAgICAgICAgY3JvcC55LFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY3JvcC53aWR0aCxcbiAgICAgICAgY3JvcC5oZWlnaHRcbiAgICApO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tYXRvcCc7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIGNyb3AueCxcbiAgICAgICAgY3JvcC55LFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY3JvcC53aWR0aCxcbiAgICAgICAgY3JvcC5oZWlnaHRcbiAgICApO1xufTtcblxuLyoqXG4gKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgJ292ZXJsYXknIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige251bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjdXJyZW50IGNhbnZhc1xuICovXG5DYW52YXNUaW50ZXIudGludFdpdGhPdmVybGF5ID0gZnVuY3Rpb24gKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXG57XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXG4gICAgdmFyIHJlc29sdXRpb24gPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG5cbiAgICB2YXIgY3JvcCA9IHRleHR1cmUuY3JvcC5jbG9uZSgpO1xuICAgIGNyb3AueCAqPSByZXNvbHV0aW9uO1xuICAgIGNyb3AueSAqPSByZXNvbHV0aW9uO1xuICAgIGNyb3Aud2lkdGggKj0gcmVzb2x1dGlvbjtcbiAgICBjcm9wLmhlaWdodCAqPSByZXNvbHV0aW9uO1xuXG4gICAgY2FudmFzLndpZHRoID0gY3JvcC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY3JvcC5oZWlnaHQ7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWF0b3AnO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgY3JvcC54LFxuICAgICAgICBjcm9wLnksXG4gICAgICAgIGNyb3Aud2lkdGgsXG4gICAgICAgIGNyb3AuaGVpZ2h0LFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodFxuICAgICk7XG5cbiAgICAvLyBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5Jztcbn07XG5cbi8qKlxuICogVGludCBhIHRleHR1cmUgcGl4ZWwgcGVyIHBpeGVsLlxuICpcbiAqIEBwYXJhbSB0ZXh0dXJlIHtQSVhJLlRleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGN1cnJlbnQgY2FudmFzXG4gKi9cbkNhbnZhc1RpbnRlci50aW50V2l0aFBlclBpeGVsID0gZnVuY3Rpb24gKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXG57XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXG4gICAgdmFyIHJlc29sdXRpb24gPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG5cbiAgICB2YXIgY3JvcCA9IHRleHR1cmUuY3JvcC5jbG9uZSgpO1xuICAgIGNyb3AueCAqPSByZXNvbHV0aW9uO1xuICAgIGNyb3AueSAqPSByZXNvbHV0aW9uO1xuICAgIGNyb3Aud2lkdGggKj0gcmVzb2x1dGlvbjtcbiAgICBjcm9wLmhlaWdodCAqPSByZXNvbHV0aW9uO1xuXG4gICAgY2FudmFzLndpZHRoID0gY3JvcC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY3JvcC5oZWlnaHQ7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIGNyb3AueCxcbiAgICAgICAgY3JvcC55LFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY3JvcC53aWR0aCxcbiAgICAgICAgY3JvcC5oZWlnaHRcbiAgICApO1xuXG4gICAgdmFyIHJnYlZhbHVlcyA9IHV0aWxzLmhleDJyZ2IoY29sb3IpO1xuICAgIHZhciByID0gcmdiVmFsdWVzWzBdLCBnID0gcmdiVmFsdWVzWzFdLCBiID0gcmdiVmFsdWVzWzJdO1xuXG4gICAgdmFyIHBpeGVsRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgIHZhciBwaXhlbHMgPSBwaXhlbERhdGEuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGl4ZWxzLmxlbmd0aDsgaSArPSA0KVxuICAgIHtcbiAgICAgICAgcGl4ZWxzW2krMF0gKj0gcjtcbiAgICAgICAgcGl4ZWxzW2krMV0gKj0gZztcbiAgICAgICAgcGl4ZWxzW2krMl0gKj0gYjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShwaXhlbERhdGEsIDAsIDApO1xufTtcblxuLyoqXG4gKiBSb3VuZHMgdGhlIHNwZWNpZmllZCBjb2xvciBhY2NvcmRpbmcgdG8gdGhlIENhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsLlxuICpcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gcm91bmQsIHNob3VsZCBiZSBhIGhleCBjb2xvclxuICovXG5DYW52YXNUaW50ZXIucm91bmRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcilcbntcbiAgICB2YXIgc3RlcCA9IENhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsO1xuXG4gICAgdmFyIHJnYlZhbHVlcyA9IHV0aWxzLmhleDJyZ2IoY29sb3IpO1xuXG4gICAgcmdiVmFsdWVzWzBdID0gTWF0aC5taW4oMjU1LCAocmdiVmFsdWVzWzBdIC8gc3RlcCkgKiBzdGVwKTtcbiAgICByZ2JWYWx1ZXNbMV0gPSBNYXRoLm1pbigyNTUsIChyZ2JWYWx1ZXNbMV0gLyBzdGVwKSAqIHN0ZXApO1xuICAgIHJnYlZhbHVlc1syXSA9IE1hdGgubWluKDI1NSwgKHJnYlZhbHVlc1syXSAvIHN0ZXApICogc3RlcCk7XG5cbiAgICByZXR1cm4gdXRpbHMucmdiMmhleChyZ2JWYWx1ZXMpO1xufTtcblxuLyoqXG4gKiBOdW1iZXIgb2Ygc3RlcHMgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgY2FwIHdoZW4gcm91bmRpbmcgY29sb3JzLlxuICpcbiAqIEBtZW1iZXJcbiAqL1xuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWwgPSA4O1xuXG4vKipcbiAqIFRpbnQgY2FjaGUgYm9vbGVhbiBmbGFnLlxuICpcbiAqIEBtZW1iZXJcbiAqL1xuQ2FudmFzVGludGVyLmNvbnZlcnRUaW50VG9JbWFnZSA9IGZhbHNlO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkLCBjb25zZXF1ZW50bHkgdGhlIGFiaWxpdHkgdG8gdGludCB1c2luZyB0aGUgbXVsdGlwbHkgbWV0aG9kLlxuICpcbiAqIEBtZW1iZXJcbiAqL1xuQ2FudmFzVGludGVyLmNhblVzZU11bHRpcGx5ID0gdXRpbHMuY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlcygpO1xuXG4vKipcbiAqIFRoZSB0aW50aW5nIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAqXG4gKi9cbkNhbnZhc1RpbnRlci50aW50TWV0aG9kID0gQ2FudmFzVGludGVyLmNhblVzZU11bHRpcGx5ID8gQ2FudmFzVGludGVyLnRpbnRXaXRoTXVsdGlwbHkgOiAgQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNUaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWluZXIgPSByZXF1aXJlKCcuLi9kaXNwbGF5L0NvbnRhaW5lcicpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBUaGUgUGFydGljbGVDb250YWluZXIgY2xhc3MgaXMgYSByZWFsbHkgZmFzdCB2ZXJzaW9uIG9mIHRoZSBDb250YWluZXIgYnVpbHQgc29sZWx5IGZvciBzcGVlZCxcbiAqIHNvIHVzZSB3aGVuIHlvdSBuZWVkIGEgbG90IG9mIHNwcml0ZXMgb3IgcGFydGljbGVzLiBUaGUgdHJhZGVvZmYgb2YgdGhlIFBhcnRpY2xlQ29udGFpbmVyIGlzIHRoYXQgYWR2YW5jZWRcbiAqIGZ1bmN0aW9uYWxpdHkgd2lsbCBub3Qgd29yay4gUGFydGljbGVDb250YWluZXIgaW1wbGVtZW50cyBvbmx5IHRoZSBiYXNpYyBvYmplY3QgdHJhbnNmb3JtIChwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uKS5cbiAqIEFueSBvdGhlciBmdW5jdGlvbmFsaXR5IGxpa2UgdGludGluZywgbWFza2luZywgZXRjIHdpbGwgbm90IHdvcmsgb24gc3ByaXRlcyBpbiB0aGlzIGJhdGNoLlxuICpcbiAqIEl0J3MgZXh0cmVtZWx5IGVhc3kgdG8gdXNlIDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGNvbnRhaW5lciA9IG5ldyBQYXJ0aWNsZUNvbnRhaW5lcigpO1xuICpcbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwOyArK2kpXG4gKiB7XG4gKiAgICAgdmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoXCJteUltYWdlLnBuZ1wiKTtcbiAqICAgICBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCBoZXJlIHlvdSBoYXZlIGEgaHVuZHJlZCBzcHJpdGVzIHRoYXQgd2lsbCBiZSByZW5kZXJlciBhdCB0aGUgc3BlZWQgb2YgbGlnaHQuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkNvbnRhaW5lclxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBbbWF4U2l6ZT0xNTAwMF0ge251bWJlcn0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHBhcnRpY2xlcyB0aGF0IGNhbiBiZSByZW5kZXJlciBieSB0aGUgY29udGFpbmVyLlxuICogQHBhcmFtIFtwcm9wZXJ0aWVzXSB7b2JqZWN0fSBUaGUgcHJvcGVydGllcyBvZiBjaGlsZHJlbiB0aGF0IHNob3VsZCBiZSB1cGxvYWRlZCB0byB0aGUgZ3B1IGFuZCBhcHBsaWVkLlxuICogQHBhcmFtIFtwcm9wZXJ0aWVzLnNjYWxlPWZhbHNlXSB7Ym9vbGVhbn0gV2hlbiB0cnVlLCBzY2FsZSBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAqIEBwYXJhbSBbcHJvcGVydGllcy5wb3NpdGlvbj10cnVlXSB7Ym9vbGVhbn0gV2hlbiB0cnVlLCBwb3NpdGlvbiBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAqIEBwYXJhbSBbcHJvcGVydGllcy5yb3RhdGlvbj1mYWxzZV0ge2Jvb2xlYW59IFdoZW4gdHJ1ZSwgcm90YXRpb24gYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gKiBAcGFyYW0gW3Byb3BlcnRpZXMudXZzPWZhbHNlXSB7Ym9vbGVhbn0gV2hlbiB0cnVlLCB1dnMgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gKiBAcGFyYW0gW3Byb3BlcnRpZXMuYWxwaGE9ZmFsc2VdIHtib29sZWFufSBXaGVuIHRydWUsIGFscGhhIGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxuICogQHBhcmFtIFtiYXRjaFNpemU9MTUwMDBdIHtudW1iZXJ9IE51bWJlciBvZiBwYXJ0aWNsZXMgcGVyIGJhdGNoLlxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZUNvbnRhaW5lcihtYXhTaXplLCBwcm9wZXJ0aWVzLCBiYXRjaFNpemUpXG57XG4gICAgQ29udGFpbmVyLmNhbGwodGhpcyk7XG5cbiAgICBiYXRjaFNpemUgPSBiYXRjaFNpemUgfHwgMTUwMDA7IC8vQ09OU1QuU1BSSVRFX0JBVENIX1NJWkU7IC8vIDIwMDAgaXMgYSBuaWNlIGJhbGFuY2UgYmV0d2VlbiBtb2JpbGUgLyBkZXNrdG9wXG4gICAgbWF4U2l6ZSA9IG1heFNpemUgfHwgMTUwMDA7XG5cbiAgICAvLyBNYWtpbmcgc3VyZSB0aGUgYmF0Y2ggc2l6ZSBpcyB2YWxpZFxuICAgIC8vIDY1NTM1IGlzIG1heCB2ZXJ0ZXggaW5kZXggaW4gdGhlIGluZGV4IGJ1ZmZlciAoc2VlIFBhcnRpY2xlUmVuZGVyZXIpXG4gICAgLy8gc28gbWF4IG51bWJlciBvZiBwYXJ0aWNsZXMgaXMgNjU1MzYgLyA0ID0gMTYzODRcbiAgICB2YXIgbWF4QmF0Y2hTaXplID0gMTYzODQ7XG4gICAgaWYgKGJhdGNoU2l6ZSA+IG1heEJhdGNoU2l6ZSkge1xuICAgICAgICBiYXRjaFNpemUgPSBtYXhCYXRjaFNpemU7XG4gICAgfVxuXG4gICAgaWYgKGJhdGNoU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgYmF0Y2hTaXplID0gbWF4U2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcHJvcGVydGllcyB0byBiZSBkeW5hbWljICh0cnVlKSAvIHN0YXRpYyAoZmFsc2UpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFuW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW2ZhbHNlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21heFNpemUgPSBtYXhTaXplO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2J1ZmZlclRvVXBkYXRlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gQXBwbHkgYSB2YWx1ZSBvZiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMXG4gICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBDT05TVC5CTEVORF9NT0RFUy5OT1JNQUw7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBjYW52YXMgcmVuZGVyZXJpbmcuIElmIHRydWUgdGhlbiB0aGUgZWxlbWVudHMgd2lsbCBiZSBwb3NpdGlvbmVkIGF0IHRoZSBuZWFyZXN0IHBpeGVsLiBUaGlzIHByb3ZpZGVzIGEgbmljZSBzcGVlZCBib29zdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZTtcbiAgICAgKi9cbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gdHJ1ZTtcblxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbn1cblxuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb250YWluZXIucHJvdG90eXBlKTtcblBhcnRpY2xlQ29udGFpbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlQ29udGFpbmVyO1xubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZUNvbnRhaW5lcjtcblxuLyoqXG4gKiBTZXRzIHRoZSBwcml2YXRlIHByb3BlcnRpZXMgYXJyYXkgdG8gZHluYW1pYyAvIHN0YXRpYyBiYXNlZCBvbiB0aGUgcGFzc2VkIHByb3BlcnRpZXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHByb3BlcnRpZXMge29iamVjdH0gVGhlIHByb3BlcnRpZXMgdG8gYmUgdXBsb2FkZWRcbiAqL1xuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLnNldFByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKVxue1xuICAgIGlmICggcHJvcGVydGllcyApIHtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1swXSA9ICdzY2FsZScgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5zY2FsZSA6IHRoaXMuX3Byb3BlcnRpZXNbMF07XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbMV0gPSAncG9zaXRpb24nIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucG9zaXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzFdO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzJdID0gJ3JvdGF0aW9uJyBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnJvdGF0aW9uIDogdGhpcy5fcHJvcGVydGllc1syXTtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1szXSA9ICd1dnMnIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudXZzIDogdGhpcy5fcHJvcGVydGllc1szXTtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1s0XSA9ICdhbHBoYScgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5hbHBoYSA6IHRoaXMuX3Byb3BlcnRpZXNbNF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKClcbntcblxuICAgIC8vIFRPRE8gZG9uJ3QgbmVlZCB0byFcbiAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAvLyAgUElYSS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNvbnRhaW5lciB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHdlYmdsIHJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLnJlbmRlcmFibGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIoIHJlbmRlcmVyLnBsdWdpbnMucGFydGljbGUgKTtcbiAgICByZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlLnJlbmRlciggdGhpcyApO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGZsYWcgdGhhdCBzdGF0aWMgZGF0YSBzaG91bGQgYmUgdXBkYXRlZCB0byB0cnVlXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLm9uQ2hpbGRyZW5DaGFuZ2UgPSBmdW5jdGlvbiAoc21hbGxlc3RDaGlsZEluZGV4KVxue1xuICAgIHZhciBidWZmZXJJbmRleCA9IE1hdGguZmxvb3Ioc21hbGxlc3RDaGlsZEluZGV4IC8gdGhpcy5fYmF0Y2hTaXplKTtcbiAgICBpZiAoYnVmZmVySW5kZXggPCB0aGlzLl9idWZmZXJUb1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9idWZmZXJUb1VwZGF0ZSA9IGJ1ZmZlckluZGV4O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IFRoZSBjYW52YXMgcmVuZGVyZXJcbiAqIEBwcml2YXRlXG4gKi9cblBhcnRpY2xlQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLnJlbmRlcmFibGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIHZhciBpc1JvdGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIHBvc2l0aW9uWCA9IDA7XG4gICAgdmFyIHBvc2l0aW9uWSA9IDA7XG5cbiAgICB2YXIgZmluYWxXaWR0aCA9IDA7XG4gICAgdmFyIGZpbmFsSGVpZ2h0ID0gMDtcblxuICAgIHZhciBjb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3RoaXMuYmxlbmRNb2RlXTtcbiAgICBpZiAoY29tcG9zaXRlT3BlcmF0aW9uICE9PSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbilcbiAgICB7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIH1cblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcmFtZSA9IGNoaWxkLnRleHR1cmUuZnJhbWU7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYSAqIGNoaWxkLmFscGhhO1xuXG4gICAgICAgIGlmIChjaGlsZC5yb3RhdGlvbiAlIChNYXRoLlBJICogMikgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZhc3Rlc3QgIHdheSB0byBvcHRpbWlzZSEgLSBpZiByb3RhdGlvbiBpcyAwIHRoZW4gd2UgY2FuIGF2b2lkIGFueSBraW5kIG9mIHNldFRyYW5zZm9ybSBjYWxsXG4gICAgICAgICAgICBpZiAoaXNSb3RhdGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uYSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5jLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLnR4LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaXNSb3RhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uWCA9ICgoY2hpbGQuYW5jaG9yLngpICogKC1mcmFtZS53aWR0aCAqIGNoaWxkLnNjYWxlLngpICsgY2hpbGQucG9zaXRpb24ueCAgKyAwLjUpO1xuICAgICAgICAgICAgcG9zaXRpb25ZID0gKChjaGlsZC5hbmNob3IueSkgKiAoLWZyYW1lLmhlaWdodCAqIGNoaWxkLnNjYWxlLnkpICsgY2hpbGQucG9zaXRpb24ueSAgKyAwLjUpO1xuXG4gICAgICAgICAgICBmaW5hbFdpZHRoID0gZnJhbWUud2lkdGggKiBjaGlsZC5zY2FsZS54O1xuICAgICAgICAgICAgZmluYWxIZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiBjaGlsZC5zY2FsZS55O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzUm90YXRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpc1JvdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZFRyYW5zZm9ybSA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIucm91bmRQaXhlbHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmEsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmMsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLnR4IHwgMCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0udHkgfCAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYyxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uZCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0udHgsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLnR5XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb25YID0gKChjaGlsZC5hbmNob3IueCkgKiAoLWZyYW1lLndpZHRoKSArIDAuNSk7XG4gICAgICAgICAgICBwb3NpdGlvblkgPSAoKGNoaWxkLmFuY2hvci55KSAqICgtZnJhbWUuaGVpZ2h0KSArIDAuNSk7XG5cbiAgICAgICAgICAgIGZpbmFsV2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICAgICAgICAgIGZpbmFsSGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBjaGlsZC50ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgICAgIGZyYW1lLngsXG4gICAgICAgICAgICBmcmFtZS55LFxuICAgICAgICAgICAgZnJhbWUud2lkdGgsXG4gICAgICAgICAgICBmcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICBwb3NpdGlvblgsXG4gICAgICAgICAgICBwb3NpdGlvblksXG4gICAgICAgICAgICBmaW5hbFdpZHRoLFxuICAgICAgICAgICAgZmluYWxIZWlnaHRcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBjb250YWluZXJcbiAqXG4gKiBAcGFyYW0gW2Rlc3Ryb3lDaGlsZHJlbj1mYWxzZV0ge2Jvb2xlYW59IGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95IG1ldGhvZCBjYWxsZWQgYXMgd2VsbFxuICovXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBDb250YWluZXIucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9idWZmZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcGFydGljbGVzL1BhcnRpY2xlQ29udGFpbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXInKSxcbiAgICBXZWJHTFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXInKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKlxuICogQmlnIHRoYW5rcyB0byB0aGUgdmVyeSBjbGV2ZXIgTWF0dCBEZXNMYXVyaWVycyA8bWF0dGRlc2w+IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9cbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgcGl4aSB2ZXJzaW9uIVxuICogQWxzbyBhIHRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vYmNoZXZhbGllciBmb3IgdHdlYWtpbmcgdGhlIHRpbnQgYW5kIGFscGhhIHNvIHRoYXQgdGhleSBub3cgc2hhcmUgNCBieXRlcyBvbiB0aGUgdmVydGV4IGJ1ZmZlclxuICpcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgU3ByaXRlUmVuZGVyZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbGliZ2R4L2xpYmdkeC9ibG9iL21hc3Rlci9nZHgvc3JjL2NvbS9iYWRsb2dpYy9nZHgvZ3JhcGhpY3MvZzJkL1Nwcml0ZVJlbmRlcmVyLmphdmFcbiAqL1xuXG4vKipcbiAqIFJlbmRlcmVyIGRlZGljYXRlZCB0byBkcmF3aW5nIGFuZCBiYXRjaGluZyBzcHJpdGVzLlxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gU3ByaXRlUmVuZGVyZXIocmVuZGVyZXIpXG57XG4gICAgT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdmFsdWVzIHNlbnQgaW4gdGhlIHZlcnRleCBidWZmZXIuXG4gICAgICogcG9zaXRpb25YLCBwb3NpdGlvblksIGNvbG9yUiwgY29sb3JHLCBjb2xvckIgPSA1XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0U2l6ZSA9IDU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgdmVydGV4IGluZm9ybWF0aW9uIGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVydEJ5dGVTaXplID0gdGhpcy52ZXJ0U2l6ZSAqIDQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlQmF0Y2ggYmVmb3JlIGl0IGZsdXNoZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaXplID0gQ09OU1QuU1BSSVRFX0JBVENIX1NJWkU7IC8vIDIwMDAgaXMgYSBuaWNlIGJhbGFuY2UgYmV0d2VlbiBtb2JpbGUgLyBkZXNrdG9wXG5cbiAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIG91ciBiYXRjaFxuICAgIHZhciBudW1WZXJ0cyA9ICh0aGlzLnNpemUgKiA0KSAqIHRoaXMudmVydEJ5dGVTaXplO1xuXG4gICAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiBpbmRpY2VzIGluIG91ciBiYXRjaCwgdGhlcmUgYXJlIDYgcG9pbnRzIHBlciBxdWFkLlxuICAgIHZhciBudW1JbmRpY2VzID0gdGhpcy5zaXplICogNjtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSB2ZXJ0ZXggZGF0YSB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgdmVydGV4IHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0FycmF5QnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBuZXcgQXJyYXlCdWZmZXIobnVtVmVydHMpO1xuXG4gICAgLyoqXG4gICAgICogVmlldyBvbiB0aGUgdmVydGljZXMgYXMgYSBGbG9hdDMyQXJyYXkgZm9yIHBvc2l0aW9uc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRpY2VzKTtcblxuICAgIC8qKlxuICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgVWludDMyQXJyYXkgZm9yIGNvbG9yc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7VWludDMyQXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgVWludDMyQXJyYXkodGhpcy52ZXJ0aWNlcyk7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgaW5kaWNlcyBvZiB0aGUgZ2VvbWV0cnkgKHF1YWRzKSB0byBkcmF3XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobnVtSW5kaWNlcyk7XG5cbiAgICAvLyBmaWxsIHRoZSBpbmRpY2VzIHdpdGggdGhlIHF1YWRzIHRvIGRyYXdcbiAgICBmb3IgKHZhciBpPTAsIGo9MDsgaSA8IG51bUluZGljZXM7IGkgKz0gNiwgaiArPSA0KVxuICAgIHtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAwXSA9IGogKyAwO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDFdID0gaiArIDE7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMl0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAzXSA9IGogKyAwO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDRdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNV0gPSBqICsgMztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzaXplIG9mIHRoZSBiYXRjaCwgZWFjaCByZW5kZXIoKSBjYWxsIGFkZHMgdG8gdGhpcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNwcml0ZXMgaW4gdGhlIGJhdGNoLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5TcHJpdGVbXX1cbiAgICAgKi9cbiAgICB0aGlzLnNwcml0ZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNoYWRlciB0aGF0IGlzIHVzZWQgaWYgYSBzcHJpdGUgZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG59XG5cblNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlKTtcblNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcml0ZVJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVSZW5kZXJlcjtcblxuV2ViR0xSZW5kZXJlci5yZWdpc3RlclBsdWdpbignc3ByaXRlJywgU3ByaXRlUmVuZGVyZXIpO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKi9cblNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAvLyBzZXR1cCBkZWZhdWx0IHNoYWRlclxuICAgIHRoaXMuc2hhZGVyID0gdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXI7XG5cbiAgICAvLyBjcmVhdGUgYSBjb3VwbGUgb2YgYnVmZmVyc1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLy91cGxvYWQgdGhlIGluZGV4IGRhdGFcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSA5OTk5OTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgc3ByaXRlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gc3ByaXRlIHtQSVhJLlNwcml0ZX0gdGhlIHNwcml0ZSB0byByZW5kZXIgd2hlbiB1c2luZyB0aGlzIHNwcml0ZWJhdGNoXG4gKi9cblNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3ByaXRlKVxue1xuICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuXG4gICAgLy9UT0RPIHNldCBibGVuZCBtb2Rlcy4uXG4gICAgLy8gY2hlY2sgdGV4dHVyZS4uXG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB1dnMgZm9yIHRoZSB0ZXh0dXJlXG4gICAgdmFyIHV2cyA9IHRleHR1cmUuX3V2cztcblxuICAgIC8vIGlmIHRoZSB1dnMgaGF2ZSBub3QgdXBkYXRlZCB0aGVuIG5vIHBvaW50IHJlbmRlcmluZyBqdXN0IHlldCFcbiAgICBpZiAoIXV2cylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIHRyaW0/P1xuICAgIHZhciBhWCA9IHNwcml0ZS5hbmNob3IueDtcbiAgICB2YXIgYVkgPSBzcHJpdGUuYW5jaG9yLnk7XG5cbiAgICB2YXIgdzAsIHcxLCBoMCwgaDE7XG5cbiAgICBpZiAodGV4dHVyZS50cmltICYmIHNwcml0ZS50aWxlU2NhbGUgPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCBhbmQgaXMgbm90IGEgdGlsaW5nc3ByaXRlIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuLlxuICAgICAgICB2YXIgdHJpbSA9IHRleHR1cmUudHJpbTtcblxuICAgICAgICB3MSA9IHRyaW0ueCAtIGFYICogdHJpbS53aWR0aDtcbiAgICAgICAgdzAgPSB3MSArIHRleHR1cmUuY3JvcC53aWR0aDtcblxuICAgICAgICBoMSA9IHRyaW0ueSAtIGFZICogdHJpbS5oZWlnaHQ7XG4gICAgICAgIGgwID0gaDEgKyB0ZXh0dXJlLmNyb3AuaGVpZ2h0O1xuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHcwID0gKHRleHR1cmUuX2ZyYW1lLndpZHRoICkgKiAoMS1hWCk7XG4gICAgICAgIHcxID0gKHRleHR1cmUuX2ZyYW1lLndpZHRoICkgKiAtYVg7XG5cbiAgICAgICAgaDAgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgKiAoMS1hWSk7XG4gICAgICAgIGgxID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ICogLWFZO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIHRoaXMudmVydEJ5dGVTaXplO1xuXG4gICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xuICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmM7XG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xuICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xuXG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9ucztcblxuICAgIGlmICh0aGlzLnJlbmRlcmVyLnJvdW5kUGl4ZWxzKVxuICAgIHtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgcG9zaXRpb25zW2luZGV4XSA9ICgoKGEgKiB3MSArIGMgKiBoMSArIHR4KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMV0gPSAoKChkICogaDEgKyBiICogdzEgKyB0eSkgKiByZXNvbHV0aW9uKSB8IDApIC8gcmVzb2x1dGlvbjtcblxuICAgICAgICAvLyB4eVxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrNV0gPSAoKChhICogdzAgKyBjICogaDEgKyB0eCkgKiByZXNvbHV0aW9uKSB8IDApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzZdID0gKCgoZCAqIGgxICsgYiAqIHcwICsgdHkpICogcmVzb2x1dGlvbikgfCAwKSAvIHJlc29sdXRpb247XG5cbiAgICAgICAgIC8vIHh5XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxMF0gPSAoKChhICogdzAgKyBjICogaDAgKyB0eCkgKiByZXNvbHV0aW9uKSB8IDApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzExXSA9ICgoKGQgKiBoMCArIGIgKiB3MCArIHR5KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xuXG4gICAgICAgIC8vIHh5XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxNV0gPSAoKChhICogdzEgKyBjICogaDAgKyB0eCkgKiByZXNvbHV0aW9uKSB8IDApIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzE2XSA9ICgoKGQgKiBoMCArIGIgKiB3MSArIHR5KSAqIHJlc29sdXRpb24pIHwgMCkgLyByZXNvbHV0aW9uO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIC8vIHh5XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleF0gPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzFdID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzVdID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCs2XSA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgICAgICAvLyB4eVxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMTBdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxMV0gPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMTVdID0gYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxNl0gPSBkICogaDAgKyBiICogdzEgKyB0eTtcbiAgICB9XG5cbiAgICAvLyB1dlxuICAgIHBvc2l0aW9uc1tpbmRleCsyXSA9IHV2cy54MDtcbiAgICBwb3NpdGlvbnNbaW5kZXgrM10gPSB1dnMueTA7XG5cbiAgICAvLyB1dlxuICAgIHBvc2l0aW9uc1tpbmRleCs3XSA9IHV2cy54MTtcbiAgICBwb3NpdGlvbnNbaW5kZXgrOF0gPSB1dnMueTE7XG5cbiAgICAgLy8gdXZcbiAgICBwb3NpdGlvbnNbaW5kZXgrMTJdID0gdXZzLngyO1xuICAgIHBvc2l0aW9uc1tpbmRleCsxM10gPSB1dnMueTI7XG5cbiAgICAvLyB1dlxuICAgIHBvc2l0aW9uc1tpbmRleCsxN10gPSB1dnMueDM7XG4gICAgcG9zaXRpb25zW2luZGV4KzE4XSA9IHV2cy55MztcblxuICAgIC8vIGNvbG9yIGFuZCBhbHBoYVxuICAgIHZhciB0aW50ID0gc3ByaXRlLnRpbnQ7XG4gICAgY29sb3JzW2luZGV4KzRdID0gY29sb3JzW2luZGV4KzldID0gY29sb3JzW2luZGV4KzE0XSA9IGNvbG9yc1tpbmRleCsxOV0gPSAodGludCA+PiAxNikgKyAodGludCAmIDB4ZmYwMCkgKyAoKHRpbnQgJiAweGZmKSA8PCAxNikgKyAoc3ByaXRlLndvcmxkQWxwaGEgKiAyNTUgPDwgMjQpO1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNpemVcbiAgICB0aGlzLnNwcml0ZXNbdGhpcy5jdXJyZW50QmF0Y2hTaXplKytdID0gc3ByaXRlO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICpcbiAqL1xuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBJZiB0aGUgYmF0Y2ggaXMgbGVuZ3RoIDAgdGhlbiByZXR1cm4gYXMgdGhlcmUgaXMgbm90aGluZyB0byBkcmF3XG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHZhciBzaGFkZXI7XG5cbiAgICAvLyB1cGxvYWQgdGhlIHZlcnRzIHRvIHRoZSBidWZmZXJcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplID4gKCB0aGlzLnNpemUgKiAwLjUgKSApXG4gICAge1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy52ZXJ0aWNlcyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5wb3NpdGlvbnMuc3ViYXJyYXkoMCwgdGhpcy5jdXJyZW50QmF0Y2hTaXplICogdGhpcy52ZXJ0Qnl0ZVNpemUpO1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmlldyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRUZXh0dXJlLCBuZXh0QmxlbmRNb2RlLCBuZXh0U2hhZGVyO1xuICAgIHZhciBiYXRjaFNpemUgPSAwO1xuICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICB2YXIgY3VycmVudEJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICB2YXIgY3VycmVudEJsZW5kTW9kZSA9IHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5jdXJyZW50QmxlbmRNb2RlO1xuICAgIHZhciBjdXJyZW50U2hhZGVyID0gbnVsbDtcblxuICAgIHZhciBibGVuZFN3YXAgPSBmYWxzZTtcbiAgICB2YXIgc2hhZGVyU3dhcCA9IGZhbHNlO1xuICAgIHZhciBzcHJpdGU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZTsgaSA8IGo7IGkrKylcbiAgICB7XG5cbiAgICAgICAgc3ByaXRlID0gdGhpcy5zcHJpdGVzW2ldO1xuXG4gICAgICAgIG5leHRUZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICBuZXh0QmxlbmRNb2RlID0gc3ByaXRlLmJsZW5kTW9kZTtcbiAgICAgICAgbmV4dFNoYWRlciA9IHNwcml0ZS5zaGFkZXIgfHwgdGhpcy5zaGFkZXI7XG5cbiAgICAgICAgYmxlbmRTd2FwID0gY3VycmVudEJsZW5kTW9kZSAhPT0gbmV4dEJsZW5kTW9kZTtcbiAgICAgICAgc2hhZGVyU3dhcCA9IGN1cnJlbnRTaGFkZXIgIT09IG5leHRTaGFkZXI7IC8vIHNob3VsZCBJIHVzZSB1aWRTPz8/XG5cbiAgICAgICAgaWYgKGN1cnJlbnRCYXNlVGV4dHVyZSAhPT0gbmV4dFRleHR1cmUgfHwgYmxlbmRTd2FwIHx8IHNoYWRlclN3YXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmF0Y2goY3VycmVudEJhc2VUZXh0dXJlLCBiYXRjaFNpemUsIHN0YXJ0KTtcblxuICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnRCYXNlVGV4dHVyZSA9IG5leHRUZXh0dXJlO1xuXG4gICAgICAgICAgICBpZiAoYmxlbmRTd2FwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZE1vZGUgPSBuZXh0QmxlbmRNb2RlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoIGN1cnJlbnRCbGVuZE1vZGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYWRlclN3YXApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNoYWRlciA9IG5leHRTaGFkZXI7XG5cblxuXG4gICAgICAgICAgICAgICAgc2hhZGVyID0gY3VycmVudFNoYWRlci5zaGFkZXJzID8gY3VycmVudFNoYWRlci5zaGFkZXJzW2dsLmlkXSA6IGN1cnJlbnRTaGFkZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNoYWRlcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlciA9IGN1cnJlbnRTaGFkZXIuZ2V0U2hhZGVyKHRoaXMucmVuZGVyZXIpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHNoYWRlciBmdW5jdGlvbj8/P1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyAtIGkgS05PVyB0aGlzIGNhbiBiZSBvcHRpbWlzZWQhIE9uY2UgdjMgaXMgc3RhYmxlIGlsIGxvb2sgYXQgdGhpcyBuZXh0Li4uXG4gICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgudmFsdWUgPSB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgICAgIC8vTWFrZSB0aGlzIGEgbGl0dGxlIG1vcmUgZHluYW1pYyAvIGludGVsbGlnZW50IVxuICAgICAgICAgICAgICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoKTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyBpbnZlc3RpZ2F0ZSBzb21lIGtpbmQgb2YgdGV4dHVyZSBzdGF0ZSBtYW5hZ21lbnQ/P1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgdGV4dHVyZSBpcyB0aGUgYWN0aXZlIG9uZSBmb3IgYWxsIHRoZSBiYXRjaCBzd2Fwcy4uXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBib3RoIHRoZWFzZSBvbmx5IG5lZWQgdG8gYmUgc2V0IGlmIHRoZXkgYXJlIGNoYW5naW5nLi5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHByb2plY3Rpb25cbiAgICAgICAgICAgICAgICAvL2dsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKSk7XG5cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmF0Y2hTaXplKys7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJCYXRjaChjdXJyZW50QmFzZVRleHR1cmUsIGJhdGNoU2l6ZSwgc3RhcnQpO1xuXG4gICAgLy8gdGhlbiByZXNldCB0aGUgYmF0Y2ghXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIGN1cnJlbnRseSBiYXRjaGVzIHNwcml0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtQSVhJLlRleHR1cmV9XG4gKiBAcGFyYW0gc2l6ZSB7bnVtYmVyfVxuICogQHBhcmFtIHN0YXJ0SW5kZXgge251bWJlcn1cbiAqL1xuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJhdGNoID0gZnVuY3Rpb24gKHRleHR1cmUsIHNpemUsIHN0YXJ0SW5kZXgpXG57XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIGlmICghdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XG4gICAgfVxuXG4gICAgLy8gbm93IGRyYXcgdGhvc2Ugc3Vja2FzIVxuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHNpemUgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnRJbmRleCAqIDYgKiAyKTtcblxuICAgIC8vIGluY3JlbWVudCB0aGUgZHJhdyBjb3VudFxuICAgIHRoaXMucmVuZGVyZXIuZHJhd0NvdW50Kys7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIG5ldyBzcHJpdGUgYmF0Y2guXG4gKlxuICovXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAvLyBiaW5kIHRoZSBtYWluIHRleHR1cmVcblxuXG4gICAgLy8gYmluZCB0aGUgYnVmZmVyc1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGZvciBlYWNoIHNoYWRlcj9cbiAgICB2YXIgc3RyaWRlID0gIHRoaXMudmVydEJ5dGVTaXplO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDIgKiA0KTtcblxuICAgIC8vIGNvbG9yIGF0dHJpYnV0ZXMgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyB1bnNpZ25lZCBieXRlcyBhbmQgbm9ybWFsaXplZFxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hQ29sb3IsIDQsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIHN0cmlkZSwgNCAqIDQpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgU3ByaXRlQmF0Y2guXG4gKlxuICovXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5yZW5kZXJlci5nbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIHRoaXMucmVuZGVyZXIuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG51bGw7XG4gICAgdGhpcy5wb3NpdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuY29sb3JzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgdGhpcy5zcHJpdGVzID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXZWJHTE1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9XZWJHTE1hbmFnZXInKTtcblxuLyoqXG4gKiBCYXNlIGZvciBhIGNvbW1vbiBvYmplY3QgcmVuZGVyZXIgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHN5c3RlbSByZW5kZXJlciBwbHVnaW4uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLldlYkdMTWFuYWdlclxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBvYmplY3QgcmVuZGVyZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBPYmplY3RSZW5kZXJlcihyZW5kZXJlcilcbntcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG59XG5cblxuT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXZWJHTE1hbmFnZXIucHJvdG90eXBlKTtcbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9iamVjdFJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RSZW5kZXJlcjtcblxuLyoqXG4gKiBTdGFydHMgdGhlIHJlbmRlcmVyIGFuZCBzZXRzIHRoZSBzaGFkZXJcbiAqXG4gKi9cbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gc2V0IHRoZSBzaGFkZXIuLlxufTtcblxuLyoqXG4gKiBTdG9wcyB0aGUgcmVuZGVyZXJcbiAqXG4gKi9cbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIGZsdXNoZXNcbiAqXG4gKi9cbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gZmx1c2ghXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIG9iamVjdCB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgb2JqZWN0IHRvIHJlbmRlci5cbiAqL1xuT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChvYmplY3QpIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbntcbiAgICAvLyByZW5kZXIgdGhlIG9iamVjdFxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeXN0ZW1SZW5kZXJlciA9IHJlcXVpcmUoJy4uL1N5c3RlbVJlbmRlcmVyJyksXG4gICAgU2hhZGVyTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvU2hhZGVyTWFuYWdlcicpLFxuICAgIE1hc2tNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9NYXNrTWFuYWdlcicpLFxuICAgIFN0ZW5jaWxNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9TdGVuY2lsTWFuYWdlcicpLFxuICAgIEZpbHRlck1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXJzL0ZpbHRlck1hbmFnZXInKSxcbiAgICBCbGVuZE1vZGVNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9CbGVuZE1vZGVNYW5hZ2VyJyksXG4gICAgUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi91dGlscy9SZW5kZXJUYXJnZXQnKSxcbiAgICBPYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4vdXRpbHMvT2JqZWN0UmVuZGVyZXInKSxcbiAgICBGWEFBRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL0ZYQUFGaWx0ZXInKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIFRoZSBXZWJHTFJlbmRlcmVyIGRyYXdzIHRoZSBzY2VuZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSB3ZWJHTCBlbmFibGVkIGNhbnZhcy4gVGhpcyByZW5kZXJlclxuICogc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB3ZWJHTC4gVGhpcyBSZW5kZXIgd29ya3MgYnkgYXV0b21hdGljYWxseSBtYW5hZ2luZyB3ZWJHTEJhdGNocy5cbiAqIFNvIG5vIG5lZWQgZm9yIFNwcml0ZSBCYXRjaGVzIG9yIFNwcml0ZSBDbG91ZHMuXG4gKiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSB2aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLlN5c3RlbVJlbmRlcmVyXG4gKiBAcGFyYW0gW3dpZHRoPTBdIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBbaGVpZ2h0PTBdIHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9IFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gW29wdGlvbnMudmlld10ge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIHRvIHVzZSBhcyBhIHZpZXcsIG9wdGlvbmFsXG4gKiBAcGFyYW0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcbiAqIEBwYXJhbSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0ge2Jvb2xlYW59IHNldHMgYW50aWFsaWFzLiBJZiBub3QgYXZhaWxhYmxlIG5hdGl2ZWx5IHRoZW4gRlhBQSBhbnRpYWxpYXNpbmcgaXMgdXNlZFxuICogQHBhcmFtIFtvcHRpb25zLmZvcmNlRlhBQT1mYWxzZV0ge2Jvb2xlYW59IGZvcmNlcyBGWEFBIGFudGlhbGlhc2luZyB0byBiZSB1c2VkIG92ZXIgbmF0aXZlLiBGWEFBIGlzIGZhc3RlciwgYnV0IG1heSBub3QgYWx3YXlzIGxvb2sgYXMgZ3JlYXRcbiAqIEBwYXJhbSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIHtudW1iZXJ9IHRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMlxuICogQHBhcmFtIFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIHtib29sZWFufSBUaGlzIHNldHMgaWYgdGhlIENhbnZhc1JlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvclxuICogICAgICBub3QgYmVmb3JlIHRoZSBuZXcgcmVuZGVyIHBhc3MuIElmIHlvdSB3aXNoIHRvIHNldCB0aGlzIHRvIGZhbHNlLCB5b3UgKm11c3QqIHNldCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIgdG8gYHRydWVgLlxuICogQHBhcmFtIFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0ge2Jvb2xlYW59IGVuYWJsZXMgZHJhd2luZyBidWZmZXIgcHJlc2VydmF0aW9uLCBlbmFibGUgdGhpcyBpZlxuICogICAgICB5b3UgbmVlZCB0byBjYWxsIHRvRGF0YVVybCBvbiB0aGUgd2ViZ2wgY29udGV4dC5cbiAqIEBwYXJhbSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0ge2Jvb2xlYW59IElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBXZWJHTFJlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpXG57XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBTeXN0ZW1SZW5kZXJlci5jYWxsKHRoaXMsICdXZWJHTCcsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyByZW5kZXJlciBhcyBhIHN0YW5kYXJkaXNlZCBjb25zdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQ09OU1QuUkVOREVSRVJfVFlQRS5XRUJHTDtcblxuICAgIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LCBmYWxzZSk7XG4gICAgdGhpcy52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQsIGZhbHNlKTtcblxuICAgIC8vVE9ETyBwb3NzaWJpbGl0eSB0byBmb3JjZSBGWEFBIGFzIGl0IG1heSBvZmZlciBiZXR0ZXIgcGVyZm9ybWFuY2U/XG4gICAgLyoqXG4gICAgICogRG9lcyBpdCB1c2UgRlhBQSA/XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdXNlRlhBQSA9ICEhb3B0aW9ucy5mb3JjZUZYQUEgJiYgb3B0aW9ucy5hbnRpYWxpYXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnhhYSBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRlhBQUZpbHRlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX0ZYQUFGaWx0ZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGluIHRvIGNyZWF0ZSBhIG5ldyB3ZWJnbCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY29udGV4dE9wdGlvbnMgPSB7XG4gICAgICAgIGFscGhhOiB0aGlzLnRyYW5zcGFyZW50LFxuICAgICAgICBhbnRpYWxpYXM6IG9wdGlvbnMuYW50aWFsaWFzLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRoaXMudHJhbnNwYXJlbnQgJiYgdGhpcy50cmFuc3BhcmVudCAhPT0gJ25vdE11bHRpcGxpZWQnLFxuICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvdW50ZXIgZm9yIHRoZSBudW1iZXIgb2YgZHJhd3MgbWFkZSBlYWNoIGZyYW1lXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kcmF3Q291bnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRGVhbHMgd2l0aCBtYW5hZ2luZyB0aGUgc2hhZGVyIHByb2dyYW1zIGFuZCB0aGVpciBhdHRyaWJzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IG5ldyBTaGFkZXJNYW5hZ2VyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgbWFza3MgdXNpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5NYXNrTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IE1hc2tNYW5hZ2VyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgc3RlbmNpbCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlN0ZW5jaWxNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIgPSBuZXcgU3RlbmNpbE1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IG5ldyBGaWx0ZXJNYW5hZ2VyKHRoaXMpO1xuXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSBibGVuZE1vZGVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJsZW5kTW9kZU1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGVNYW5hZ2VyID0gbmV3IEJsZW5kTW9kZU1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlbmRlclRhcmdldH1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgT2JqZWN0UmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk9iamVjdFJlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyKHRoaXMpO1xuXG4gICAgdGhpcy5pbml0UGx1Z2lucygpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgY29udGV4dCBzbyBpdCBpcyByZWFkeSBmb3IgdGhlIG1hbmFnZXJzLlxuICAgIHRoaXMuX2NyZWF0ZUNvbnRleHQoKTtcbiAgICB0aGlzLl9pbml0Q29udGV4dCgpO1xuXG4gICAgLy8gbWFwIHNvbWUgd2ViR0wgYmxlbmQgbW9kZXMuLlxuICAgIHRoaXMuX21hcEdsTW9kZXMoKTtcblxuICAgIC8vIHRyYWNrIHRleHR1cmVzIGluIHRoZSByZW5kZXJlciBzbyB3ZSBjYW4gbm8gbG9uZ2VyIGxpc3RlbiB0byB0aGVtIG9uIGRlc3RydWN0aW9uLlxuICAgIHRoaXMuX21hbmFnZWRUZXh0dXJlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgcmVuZGVyIHRhcmdldHNcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlbmRlclRhcmdldFtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2sgPSBbXTtcbn1cblxuLy8gY29uc3RydWN0b3JcbldlYkdMUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUpO1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTFJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBXZWJHTFJlbmRlcmVyO1xudXRpbHMucGx1Z2luVGFyZ2V0Lm1peGluKFdlYkdMUmVuZGVyZXIpO1xuXG5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkID0gMDtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBnbCBjb250ZXh0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLl9jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnbCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCd3ZWJnbCcsIHRoaXMuX2NvbnRleHRPcHRpb25zKSB8fCB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgdGhpcy5fY29udGV4dE9wdGlvbnMpO1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIGlmICghZ2wpXG4gICAge1xuICAgICAgICAvLyBmYWlsLCBub3QgYWJsZSB0byBnZXQgYSBjb250ZXh0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd2ViR0wuIFRyeSB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5nbENvbnRleHRJZCA9IFdlYkdMUmVuZGVyZXIuZ2xDb250ZXh0SWQrKztcbiAgICBnbC5pZCA9IHRoaXMuZ2xDb250ZXh0SWQ7XG4gICAgZ2wucmVuZGVyZXIgPSB0aGlzO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBXZWJHTCBjb250ZXh0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuX2luaXRDb250ZXh0ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gc2V0IHVwIHRoZSBkZWZhdWx0IHBpeGkgc2V0dGluZ3MuLlxuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBudWxsLCB0aGlzLnJlc29sdXRpb24sIHRydWUpO1xuXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUYXJnZXQpO1xuXG4gICAgdGhpcy5lbWl0KCdjb250ZXh0JywgZ2wpO1xuXG4gICAgLy8gc2V0dXAgdGhlIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzIGFuZCBnbCB2aWV3cG9ydFxuICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIGlmKCF0aGlzLl91c2VGWEFBKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdXNlRlhBQSA9ICh0aGlzLl9jb250ZXh0T3B0aW9ucy5hbnRpYWxpYXMgJiYgISBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFudGlhbGlhcyk7XG4gICAgfVxuXG5cbiAgICBpZih0aGlzLl91c2VGWEFBKVxuICAgIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUud2FybignRlhBQSBhbnRpYWxpYXNpbmcgYmVpbmcgdXNlZCBpbnN0ZWFkIG9mIG5hdGl2ZSBhbnRpYWxpYXNpbmcnKTtcbiAgICAgICAgdGhpcy5fRlhBQUZpbHRlciA9IFtuZXcgRlhBQUZpbHRlcigpXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byBpdHMgd2ViR0wgdmlld1xuICpcbiAqIEBwYXJhbSBvYmplY3Qge1BJWEkuRGlzcGxheU9iamVjdH0gdGhlIG9iamVjdCB0byBiZSByZW5kZXJlZFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob2JqZWN0KVxue1xuXG4gICAgdGhpcy5lbWl0KCdwcmVyZW5kZXInKTtcblxuICAgIC8vIG5vIHBvaW50IHJlbmRlcmluZyBpZiBvdXIgY29udGV4dCBoYXMgYmVlbiBibG93biB1cCFcbiAgICBpZiAodGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3Q291bnQgPSAwO1xuXG4gICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gb2JqZWN0O1xuXG4gICAgaWYodGhpcy5fdXNlRlhBQSlcbiAgICB7XG4gICAgICAgIHRoaXMuX0ZYQUFGaWx0ZXJbMF0udW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS54ID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy5fRlhBQUZpbHRlclswXS51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnkgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgb2JqZWN0LmZpbHRlckFyZWEgPSB0aGlzLnJlbmRlclRhcmdldC5zaXplO1xuICAgICAgICBvYmplY3QuZmlsdGVycyA9IHRoaXMuX0ZYQUFGaWx0ZXI7XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlUGFyZW50ID0gb2JqZWN0LnBhcmVudDtcbiAgICBvYmplY3QucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHNjZW5lIGdyYXBoXG4gICAgb2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgb2JqZWN0LnBhcmVudCA9IGNhY2hlUGFyZW50O1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgYm91bmQgdG8gdGhlIG1haW4gZnJhbWUgYnVmZmVyXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUYXJnZXQpO1xuXG4gICAgaWYgKHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IodGhpcy5fYmFja2dyb3VuZENvbG9yUmdiWzBdLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JbMV0sIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYlsyXSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckRpc3BsYXlPYmplY3Qob2JqZWN0LCB0aGlzLnJlbmRlclRhcmdldCk7Ly90aGlzLnByb2plY3Rpb24pO1xuXG4gICAgdGhpcy5lbWl0KCdwb3N0cmVuZGVyJyk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBEaXNwbGF5IE9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byByZW5kZXJcbiAqIEBwYXJhbSByZW5kZXJUYXJnZXQge1BJWEkuUmVuZGVyVGFyZ2V0fSBUaGUgcmVuZGVyIHRhcmdldCB0byB1c2UgdG8gcmVuZGVyIHRoaXMgZGlzcGxheSBvYmplY3RcbiAqXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckRpc3BsYXlPYmplY3QgPSBmdW5jdGlvbiAoZGlzcGxheU9iamVjdCwgcmVuZGVyVGFyZ2V0LCBjbGVhcikvL3Byb2plY3Rpb24sIGJ1ZmZlcilcbntcbiAgICAvLyBUT0RPIGlzIHRoaXMgbmVlZGVkLi4uXG4gICAgLy90aGlzLmJsZW5kTW9kZU1hbmFnZXIuc2V0QmxlbmRNb2RlKENPTlNULkJMRU5EX01PREVTLk5PUk1BTCk7XG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcblxuICAgIGlmKGNsZWFyKVxuICAgIHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgdGhlIGZpbHRlciBtYW5hZ2VyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLnNldEZpbHRlclN0YWNrKCByZW5kZXJUYXJnZXQuZmlsdGVyU3RhY2sgKTtcblxuICAgIC8vIHJlbmRlciB0aGUgc2NlbmUhXG4gICAgZGlzcGxheU9iamVjdC5yZW5kZXJXZWJHTCh0aGlzKTtcblxuICAgIC8vIGZpbmlzaCB0aGUgY3VycmVudCByZW5kZXJlci4uXG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCByZW5kZXJlciB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSBvYmplY3RSZW5kZXJlciB7UElYSS5PYmplY3RSZW5kZXJlcn0gVGhlIG9iamVjdCByZW5kZXJlciB0byB1c2UuXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldE9iamVjdFJlbmRlcmVyID0gZnVuY3Rpb24gKG9iamVjdFJlbmRlcmVyKVxue1xuICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciA9PT0gb2JqZWN0UmVuZGVyZXIpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RvcCgpO1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gb2JqZWN0UmVuZGVyZXI7XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHJlbmRlclRhcmdldCB7UElYSS5SZW5kZXJUYXJnZXR9IHRoZSBuZXcgcmVuZGVyIHRhcmdldFxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0KVxue1xuICAgIGlmKCB0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPT09IHJlbmRlclRhcmdldClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVE9ETyAtIG1heWJlIGRvd24gdGhlIGxpbmUgdGhpcyBzaG91bGQgYmUgYSBwdXNoIHBvcyB0aGluZz8gTGVhdmluZyBmb3Igbm93IHRob3VnaC5cbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0LmFjdGl2YXRlKCk7XG4gICAgdGhpcy5zdGVuY2lsTWFuYWdlci5zZXRNYXNrU3RhY2soIHJlbmRlclRhcmdldC5zdGVuY2lsTWFza1N0YWNrICk7XG59O1xuXG5cbi8qKlxuICogUmVzaXplcyB0aGUgd2ViR0wgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHdlYkdMIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHdlYkdMIHZpZXdcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLnJlbmRlclRhcmdldC5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZih0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPT09IHRoaXMucmVuZGVyVGFyZ2V0KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIGFuZC9vciBDcmVhdGVzIGEgV2ViR0wgdGV4dHVyZSBmb3IgdGhlIHJlbmRlcmVyJ3MgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHVwZGF0ZVxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpXG57XG4gICAgdGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUgfHwgdGV4dHVyZTtcblxuICAgIGlmICghdGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGlmICghdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXG4gICAge1xuICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgdGV4dHVyZS5vbigndXBkYXRlJywgdGhpcy51cGRhdGVUZXh0dXJlLCB0aGlzKTtcbiAgICAgICAgdGV4dHVyZS5vbignZGlzcG9zZScsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICB9XG5cblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5zb3VyY2UpO1xuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcblxuXG4gICAgaWYgKHRleHR1cmUubWlwbWFwICYmIHRleHR1cmUuaXNQb3dlck9mVHdvKVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICB9XG5cbiAgICBpZiAoIXRleHR1cmUuaXNQb3dlck9mVHdvKVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgIH1cblxuICAgIHJldHVybiAgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF07XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTFxuICpcbiAqIEBwYXJhbSB0ZXh0dXJlIHtQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gZGVzdHJveVxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95VGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBfc2tpcFJlbW92ZSlcbntcbiAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xuXG4gICAgaWYgKCF0ZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLmdsLmlkXSlcbiAgICB7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuZ2wuaWRdKTtcbiAgICAgICAgZGVsZXRlIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5nbC5pZF07XG5cbiAgICAgICAgaWYgKCFfc2tpcFJlbW92ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuX21hbmFnZWRUZXh0dXJlcywgaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVDb250ZXh0TG9zdCA9IGZ1bmN0aW9uIChldmVudClcbntcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcmVzdG9yZWQgd2ViZ2wgY29udGV4dFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5faW5pdENvbnRleHQoKTtcblxuICAgIC8vIGVtcHR5IGFsbCB0aGUgb2xkIGdsIHRleHR1cmVzIGFzIHRoZXkgYXJlIHVzZWxlc3Mgbm93XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyArK2kpXG4gICAge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX21hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5nbC5pZF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuZ2wuaWRdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgKGV2ZW50IGxpc3RlbmVycywgc3ByaXRlYmF0Y2gsIGV0Yy4uLilcbiAqXG4gKiBAcGFyYW0gW3JlbW92ZVZpZXc9ZmFsc2VdIHtib29sZWFufSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlVmlldylcbntcbiAgICB0aGlzLmRlc3Ryb3lQbHVnaW5zKCk7XG5cbiAgICAvLyByZW1vdmUgbGlzdGVuZXJzXG4gICAgdGhpcy52aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcbiAgICB0aGlzLnZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCk7XG5cbiAgICAvLyBkZXN0cm95IG1hbmFnZWQgdGV4dHVyZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21hbmFnZWRUZXh0dXJlcy5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fbWFuYWdlZFRleHR1cmVzW2ldO1xuICAgICAgICB0aGlzLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xuICAgICAgICB0ZXh0dXJlLm9mZigndXBkYXRlJywgdGhpcy51cGRhdGVUZXh0dXJlLCB0aGlzKTtcbiAgICAgICAgdGV4dHVyZS5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBjYWxsIGJhc2UgZGVzdHJveVxuICAgIFN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgcmVtb3ZlVmlldyk7XG5cbiAgICB0aGlzLnVpZCA9IDA7XG5cbiAgICAvLyBkZXN0cm95IHRoZSBtYW5hZ2Vyc1xuICAgIHRoaXMuc2hhZGVyTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zdGVuY2lsTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmJsZW5kTW9kZU1hbmFnZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuYmxlbmRNb2RlTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuXG4gICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IG51bGw7XG4gICAgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29udGV4dE9wdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5fbWFuYWdlZFRleHR1cmVzID0gbnVsbDtcblxuICAgIHRoaXMuZHJhd0NvdW50ID0gMDtcblxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShudWxsKTtcblxuICAgIHRoaXMuZ2wuZmx1c2goKTtcblxuICAgIHRoaXMuZ2wgPSBudWxsO1xufTtcblxuLyoqXG4gKiBNYXBzIFBpeGkgYmxlbmQgbW9kZXMgdG8gV2ViR0wgYmxlbmQgbW9kZXMuIEl0IHdvcmtzIG9ubHkgZm9yIHByZS1tdWx0aXBsaWVkIHRleHR1cmVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLl9tYXBHbE1vZGVzID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgaWYgKCF0aGlzLmJsZW5kTW9kZXMpXG4gICAge1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXMgPSB7fTtcblxuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTk9STUFMXSAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkFERF0gICAgICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuRFNUX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk1VTFRJUExZXSAgICAgID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5TQ1JFRU5dICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQ09MT1JdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRBUktFTl0gICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5MSUdIVEVOXSAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SX0JVUk5dICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5FWENMVVNJT05dICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuSFVFXSAgICAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNBVFVSQVRJT05dICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl0gICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHJhd01vZGVzKVxuICAgIHtcbiAgICAgICAgdGhpcy5kcmF3TW9kZXMgPSB7fTtcblxuICAgICAgICB0aGlzLmRyYXdNb2Rlc1tDT05TVC5EUkFXX01PREVTLlBPSU5UU10gICAgICAgICA9IGdsLlBPSU5UUztcbiAgICAgICAgdGhpcy5kcmF3TW9kZXNbQ09OU1QuRFJBV19NT0RFUy5MSU5FU10gICAgICAgICAgPSBnbC5MSU5FUztcbiAgICAgICAgdGhpcy5kcmF3TW9kZXNbQ09OU1QuRFJBV19NT0RFUy5MSU5FX0xPT1BdICAgICAgPSBnbC5MSU5FX0xPT1A7XG4gICAgICAgIHRoaXMuZHJhd01vZGVzW0NPTlNULkRSQVdfTU9ERVMuTElORV9TVFJJUF0gICAgID0gZ2wuTElORV9TVFJJUDtcbiAgICAgICAgdGhpcy5kcmF3TW9kZXNbQ09OU1QuRFJBV19NT0RFUy5UUklBTkdMRVNdICAgICAgPSBnbC5UUklBTkdMRVM7XG4gICAgICAgIHRoaXMuZHJhd01vZGVzW0NPTlNULkRSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVBdID0gZ2wuVFJJQU5HTEVfU1RSSVA7XG4gICAgICAgIHRoaXMuZHJhd01vZGVzW0NPTlNULkRSQVdfTU9ERVMuVFJJQU5HTEVfRkFOXSAgID0gZ2wuVFJJQU5HTEVfRkFOO1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG4gICAgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xuXG4vKipcbiAqIFRoZSBDYW52YXNSZW5kZXJlciBkcmF3cyB0aGUgc2NlbmUgYW5kIGFsbCBpdHMgY29udGVudCBvbnRvIGEgMmQgY2FudmFzLiBUaGlzIHJlbmRlcmVyIHNob3VsZCBiZSB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHdlYkdMLlxuICogRG9uJ3QgZm9yZ2V0IHRvIGFkZCB0aGUgQ2FudmFzUmVuZGVyZXIudmlldyB0byB5b3VyIERPTSBvciB5b3Ugd2lsbCBub3Qgc2VlIGFueXRoaW5nIDopXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHN5c3RlbSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgc3lzdGVtIHRoaXMgcmVuZGVyZXIgaXMgZm9yLlxuICogQHBhcmFtIFt3aWR0aD04MDBdIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBbaGVpZ2h0PTYwMF0ge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBbb3B0aW9uc10ge29iamVjdH0gVGhlIG9wdGlvbmFsIHJlbmRlcmVyIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBbb3B0aW9ucy52aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAqIEBwYXJhbSBbb3B0aW9ucy50cmFuc3BhcmVudD1mYWxzZV0ge2Jvb2xlYW59IElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgYXV0b21hdGljYWxseSByZXNpemVkLCBkZWZhdWx0IGZhbHNlXG4gKiBAcGFyYW0gW29wdGlvbnMuYW50aWFsaWFzPWZhbHNlXSB7Ym9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAqIEBwYXJhbSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIHtudW1iZXJ9IHRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMlxuICogQHBhcmFtIFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIHtib29sZWFufSBUaGlzIHNldHMgaWYgdGhlIENhbnZhc1JlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvclxuICogICAgICBub3QgYmVmb3JlIHRoZSBuZXcgcmVuZGVyIHBhc3MuXG4gKiBAcGFyYW0gW29wdGlvbnMuYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXSB7bnVtYmVyfSBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgcmVuZGVyZWQgYXJlYSAoc2hvd24gaWYgbm90IHRyYW5zcGFyZW50KS5cbiAqIEBwYXJhbSBbb3B0aW9ucy5yb3VuZFBpeGVscz1mYWxzZV0ge2Jvb2xlYW59IElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBTeXN0ZW1SZW5kZXJlcihzeXN0ZW0sIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpXG57XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB1dGlscy5zYXlIZWxsbyhzeXN0ZW0pO1xuXG4gICAgLy8gcHJlcGFyZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpIGluIENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1tpXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tpXSA9IENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgb3B0aW9ucyA9IENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuUkVOREVSRVJfVFlQRS5VTktOT1dOXG4gICAgICogQHNlZSBQSVhJLlJFTkRFUkVSX1RZUEVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBDT05TVC5SRU5ERVJFUl9UWVBFLlVOS05PV047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgODAwXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDgwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNjAwXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgNjAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0b1xuICAgICAqXG4gICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy52aWV3ID0gb3B0aW9ucy52aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBvcHRpb25zLnRyYW5zcGFyZW50O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgc2hvdWxkIGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseVxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9SZXNpemUgPSBvcHRpb25zLmF1dG9SZXNpemUgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUcmFja3MgdGhlIGJsZW5kIG1vZGVzIHVzZWZ1bCBmb3IgdGhpcyByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIG1peGVkPn1cbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kTW9kZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIgZmxhZyBhZmZlY3RzIHdoZXRoZXIgb3Igbm90IHRoZSBjb250ZW50cyBvZiB0aGUgc3RlbmNpbCBidWZmZXIgaXMgcmV0YWluZWQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3Igbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICAgICAqIElmIHRoZSBzY2VuZSBpcyBOT1QgdHJhbnNwYXJlbnQgUGl4aSB3aWxsIHVzZSBhIGNhbnZhcyBzaXplZCBmaWxsUmVjdCBvcGVyYXRpb24gZXZlcnkgZnJhbWUgdG8gc2V0IHRoZSBjYW52YXMgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgKiBJZiB0aGUgc2NlbmUgaXMgdHJhbnNwYXJlbnQgUGl4aSB3aWxsIHVzZSBjbGVhclJlY3QgdG8gY2xlYXIgdGhlIGNhbnZhcyBldmVyeSBmcmFtZS5cbiAgICAgKiBEaXNhYmxlIHRoaXMgYnkgc2V0dGluZyB0aGlzIHRvIGZhbHNlLiBGb3IgZXhhbXBsZSBpZiB5b3VyIGdhbWUgaGFzIGEgY2FudmFzIGZpbGxpbmcgYmFja2dyb3VuZCBpbWFnZSB5b3Ugb2Z0ZW4gZG9uJ3QgbmVlZCB0aGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcjtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEhhbmR5IGZvciBjcmlzcCBwaXhlbCBhcnQgYW5kIHNwZWVkIG9uIGxlZ2FjeSBkZXZpY2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gb3B0aW9ucy5yb3VuZFBpeGVscztcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciBhcyBhbiBbUiwgRywgQl0gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYiA9IFswLCAwLCAwXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gJyMwMDAwMDAnO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7IC8vIHJ1biBiZyBjb2xvciBzZXR0ZXJcblxuICAgIC8qKlxuICAgICAqIFRoaXMgdGVtcG9yYXJ5IGRpc3BsYXkgb2JqZWN0IHVzZWQgYXMgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkIGl0ZW1cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0ge3dvcmxkVHJhbnNmb3JtOm5ldyBtYXRoLk1hdHJpeCgpLCB3b3JsZEFscGhhOjEsIGNoaWxkcmVuOltdfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IHJvb3Qgb2JqZWN0IHRoYXQgdGhlIHJlbmRlcmVyIHRyaWVkIHRvIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5c3RlbVJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBTeXN0ZW1SZW5kZXJlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCBpZiBub3QgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5TeXN0ZW1SZW5kZXJlciNcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6XG4gICAge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gdXRpbHMuaGV4MnN0cmluZyh2YWwpO1xuICAgICAgICAgICAgdXRpbHMuaGV4MnJnYih2YWwsIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZXNpemVzIHRoZSBjYW52YXMgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAqXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKi9cblN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcblxuICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcbiAgICB7XG4gICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggLyB0aGlzLnJlc29sdXRpb24gKyAncHgnO1xuICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb24gKyAncHgnO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gW3JlbW92ZVZpZXc9ZmFsc2VdIHtib29sZWFufSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gKi9cblN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZVZpZXcpIHtcbiAgICBpZiAocmVtb3ZlVmlldyAmJiB0aGlzLnZpZXcucGFyZW50Tm9kZSlcbiAgICB7XG4gICAgICAgIHRoaXMudmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudmlldyk7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gQ09OU1QuUkVOREVSRVJfVFlQRS5VTktOT1dOO1xuXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuXG4gICAgdGhpcy52aWV3ID0gbnVsbDtcblxuICAgIHRoaXMucmVzb2x1dGlvbiA9IDA7XG5cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1dG9SZXNpemUgPSBmYWxzZTtcblxuICAgIHRoaXMuYmxlbmRNb2RlcyA9IG51bGw7XG5cbiAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBmYWxzZTtcblxuICAgIHRoaXMucm91bmRQaXhlbHMgPSBmYWxzZTtcblxuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDA7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiID0gbnVsbDtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvU3lzdGVtUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXZWJHTE1hbmFnZXIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpLFxuICAgIFRleHR1cmVTaGFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXJzL1RleHR1cmVTaGFkZXInKSxcbiAgICBDb21wbGV4UHJpbWl0aXZlU2hhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9Db21wbGV4UHJpbWl0aXZlU2hhZGVyJyksXG4gICAgUHJpbWl0aXZlU2hhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9QcmltaXRpdmVTaGFkZXInKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5XZWJHTE1hbmFnZXJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gU2hhZGVyTWFuYWdlcihyZW5kZXJlcilcbntcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhBdHRpYnMgPSAxMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2FueVtdfVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmliU3RhdGUgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2FueVtdfVxuICAgICAqL1xuICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWF4QXR0aWJzOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7YW55W119XG4gICAgICovXG4gICAgdGhpcy5zdGFjayA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudElkID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFNoYWRlciA9IG51bGw7XG5cbi8vICAgIHRoaXMuaW5pdFBsdWdpbnMoKTtcbn1cblxuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkZXJNYW5hZ2VyO1xudXRpbHMucGx1Z2luVGFyZ2V0Lm1peGluKFNoYWRlck1hbmFnZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlck1hbmFnZXI7XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBXZWJHTCBjb250ZXh0IGNoYW5nZS5cbiAqXG4gKi9cblNoYWRlck1hbmFnZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5pbml0UGx1Z2lucygpO1xuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIC8vIGdldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYXR0cmlidXRlIGNvcnJlY3RseSBhcyB0aGlzIHRlbmRzIHRvIHZhcnlcbiAgICB0aGlzLm1heEF0dGlicyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX0FUVFJJQlMpO1xuXG4gICAgdGhpcy5hdHRyaWJTdGF0ZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1heEF0dGliczsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZVtpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBXaHkgYXJlIHRoZXNlIG5vdCBwbHVnaW5zPyBXZSBjYW4ndCBkZWNvdXBsZSBwcmltaXRpdmVzIHVubGVzcyB0aGV5IGFyZS4uLi5cbiAgICB0aGlzLmRlZmF1bHRTaGFkZXIgPSBuZXcgVGV4dHVyZVNoYWRlcih0aGlzKTtcbiAgICB0aGlzLnByaW1pdGl2ZVNoYWRlciA9IG5ldyBQcmltaXRpdmVTaGFkZXIodGhpcyk7XG4gICAgdGhpcy5jb21wbGV4UHJpbWl0aXZlU2hhZGVyID0gbmV3IENvbXBsZXhQcmltaXRpdmVTaGFkZXIodGhpcyk7XG59O1xuXG4vKipcbiAqIFRha2VzIHRoZSBhdHRyaWJ1dGVzIGdpdmVuIGluIHBhcmFtZXRlcnMgYW5kIHVwbG9hZHMgdGhlbS5cbiAqXG4gKiBAcGFyYW0gYXR0cmlicyB7YW55W119IGF0dHJpYnNcbiAqL1xuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuc2V0QXR0cmlicyA9IGZ1bmN0aW9uIChhdHRyaWJzKVxue1xuICAgIC8vIHJlc2V0IHRlbXAgc3RhdGVcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRlbXBBdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBuZXcgYXR0cmlic1xuICAgIGZvciAodmFyIGEgaW4gYXR0cmlicylcbiAgICB7XG4gICAgICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlW2F0dHJpYnNbYV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJTdGF0ZVtpXSAhPT0gdGhpcy50ZW1wQXR0cmliU3RhdGVbaV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmliU3RhdGVbaV0gPSB0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmliU3RhdGVbaV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHNoYWRlci5cbiAqXG4gKiBAcGFyYW0gc2hhZGVyIHtQSVhJLlNoYWRlcn0gdGhlIHNoYWRlciB0byB1cGxvYWRcbiAqL1xuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuc2V0U2hhZGVyID0gZnVuY3Rpb24gKHNoYWRlcilcbntcbiAgICBpZiAodGhpcy5fY3VycmVudElkID09PSBzaGFkZXIudWlkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRJZCA9IHNoYWRlci51aWQ7XG5cbiAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG5cbiAgICB0aGlzLnJlbmRlcmVyLmdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgIHRoaXMuc2V0QXR0cmlicyhzaGFkZXIuYXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyBvYmplY3QuXG4gKlxuICovXG5TaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnByaW1pdGl2ZVNoYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5jb21wbGV4UHJpbWl0aXZlU2hhZGVyLmRlc3Ryb3koKTtcbiAgICBXZWJHTE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuZGVzdHJveVBsdWdpbnMoKTtcblxuICAgIHRoaXMuYXR0cmliU3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy50ZW1wQXR0cmliU3RhdGUgPSBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvU2hhZGVyTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNoYWRlciA9IHJlcXVpcmUoJy4vU2hhZGVyJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5TaGFkZXJcbiAqIEBwYXJhbSBzaGFkZXJNYW5hZ2VyIHtQSVhJLlNoYWRlck1hbmFnZXJ9IFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gKiBAcGFyYW0gW3ZlcnRleFNyY10ge3N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cbiAqIEBwYXJhbSBbZnJhZ21lbnRTcmNdIHtzdHJpbmd9IFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSBbY3VzdG9tVW5pZm9ybXNdIHtvYmplY3R9IEN1c3RvbSB1bmlmb3JtcyB0byB1c2UgdG8gYXVnbWVudCB0aGUgYnVpbHQtaW4gb25lcy5cbiAqIEBwYXJhbSBbZnJhZ21lbnRTcmNdIHtzdHJpbmd9IFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqL1xuZnVuY3Rpb24gVGV4dHVyZVNoYWRlcihzaGFkZXJNYW5hZ2VyLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBjdXN0b21Vbmlmb3JtcywgY3VzdG9tQXR0cmlidXRlcylcbntcbiAgICB2YXIgdW5pZm9ybXMgPSB7XG5cbiAgICAgICAgdVNhbXBsZXI6ICAgICAgICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogMCB9LFxuICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiAgIHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAxXSkgfVxuICAgIH07XG5cbiAgICBpZiAoY3VzdG9tVW5pZm9ybXMpXG4gICAge1xuICAgICAgICBmb3IgKHZhciB1IGluIGN1c3RvbVVuaWZvcm1zKVxuICAgICAgICB7XG4gICAgICAgICAgICB1bmlmb3Jtc1t1XSA9IGN1c3RvbVVuaWZvcm1zW3VdO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgYVZlcnRleFBvc2l0aW9uOiAgICAwLFxuICAgICAgICBhVGV4dHVyZUNvb3JkOiAgICAgIDAsXG4gICAgICAgIGFDb2xvcjogICAgICAgICAgICAgMFxuICAgIH07XG5cbiAgICBpZiAoY3VzdG9tQXR0cmlidXRlcylcbiAgICB7XG4gICAgICAgIGZvciAodmFyIGEgaW4gY3VzdG9tQXR0cmlidXRlcylcbiAgICAgICAge1xuICAgICAgICAgICAgYXR0cmlidXRlc1thXSA9IGN1c3RvbUF0dHJpYnV0ZXNbYV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGV4IHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB2ZXJ0ZXhTcmMgPSB2ZXJ0ZXhTcmMgfHwgVGV4dHVyZVNoYWRlci5kZWZhdWx0VmVydGV4U3JjO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBmcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IFRleHR1cmVTaGFkZXIuZGVmYXVsdEZyYWdtZW50U3JjO1xuXG4gICAgU2hhZGVyLmNhbGwodGhpcywgc2hhZGVyTWFuYWdlciwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMsIGF0dHJpYnV0ZXMpO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuVGV4dHVyZVNoYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNoYWRlci5wcm90b3R5cGUpO1xuVGV4dHVyZVNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0dXJlU2hhZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlU2hhZGVyO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKi9cblRleHR1cmVTaGFkZXIuZGVmYXVsdFZlcnRleFNyYyA9IFtcbiAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAnYXR0cmlidXRlIHZlYzQgYUNvbG9yOycsXG5cbiAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcblxuICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsXG4gICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgJyAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZVxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICovXG5UZXh0dXJlU2hhZGVyLmRlZmF1bHRGcmFnbWVudFNyYyA9IFtcbiAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcblxuICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICd2b2lkIG1haW4odm9pZCl7JyxcbiAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvciA7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvVGV4dHVyZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypnbG9iYWwgY29uc29sZSAqL1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBCYXNlIHNoYWRlciBjbGFzcyBmb3IgUElYSSBtYW5hZ2VkIHNoYWRlcnMuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1BJWEkuU2hhZGVyTWFuYWdlcn0gVGhlIHdlYmdsIHNoYWRlciBtYW5hZ2VyIHRoaXMgc2hhZGVyIHdvcmtzIGZvci5cbiAqIEBwYXJhbSBbdmVydGV4U3JjXSB7c3RyaW5nfSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICogQHBhcmFtIFtmcmFnbWVudFNyY10ge3N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICogQHBhcmFtIFt1bmlmb3Jtc10ge29iamVjdH0gVW5pZm9ybXMgZm9yIHRoaXMgc2hhZGVyLlxuICogQHBhcmFtIFthdHRyaWJ1dGVzXSB7b2JqZWN0fSBBdHRyaWJ1dGVzIGZvciB0aGlzIHNoYWRlci5cbiAqL1xuZnVuY3Rpb24gU2hhZGVyKHNoYWRlck1hbmFnZXIsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKVxue1xuICAgIGlmICghdmVydGV4U3JjIHx8ICFmcmFnbWVudFNyYylcbiAgICB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpeGkuanMgRXJyb3IuIFNoYWRlciByZXF1aXJlcyB2ZXJ0ZXhTcmMgYW5kIGZyYWdtZW50U3JjJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgaWRcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy51aWQgPSB1dGlscy51aWQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gc2hhZGVyTWFuYWdlci5yZW5kZXJlci5nbDtcblxuICAgIC8vVE9ETyBtYXliZSB3ZSBzaG91bGQgcGFzcyByZW5kZXJlciByYXRoZXIgdGhhbiBzaGFkZXIgbWFuZ2VyPz8gZm9vZCBmb3IgdGhvdWdodC4uXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyID0gc2hhZGVyTWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xQcm9ncmFtfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5pZm9ybXMgYXMgYW4gb2JqZWN0XG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dHJpYnV0ZXMgYXMgYW4gb2JqZWN0XG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHRleHR1cmUgY291bnRlclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyIGFzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYztcblxuICAgIHRoaXMuaW5pdCgpO1xufVxuXG5TaGFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBTaGFkZXI7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgc2hhZGVyIGFuZCB1c2VzIGl0XG4gKlxuICovXG5TaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuY29tcGlsZSgpO1xuXG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cbiAgICB0aGlzLmNhY2hlVW5pZm9ybUxvY2F0aW9ucyhPYmplY3Qua2V5cyh0aGlzLnVuaWZvcm1zKSk7XG4gICAgdGhpcy5jYWNoZUF0dHJpYnV0ZUxvY2F0aW9ucyhPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpKTtcbn07XG5cbi8qKlxuICogQ2FjaGVzIHRoZSBsb2NhdGlvbnMgb2YgdGhlIHVuaWZvcm0gZm9yIHJldXNlLlxuICpcbiAqIEBwYXJhbSBrZXlzIHtzdHJpbmd9IHRoZSB1bmlmb3JtcyB0byBjYWNoZVxuICovXG5TaGFkZXIucHJvdG90eXBlLmNhY2hlVW5pZm9ybUxvY2F0aW9ucyA9IGZ1bmN0aW9uIChrZXlzKVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIHRoaXMudW5pZm9ybXNba2V5c1tpXV0uX2xvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBrZXlzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENhY2hlcyB0aGUgbG9jYXRpb25zIG9mIHRoZSBhdHRyaWJ1dGUgZm9yIHJldXNlLlxuICpcbiAqIEBwYXJhbSBrZXlzIHtzdHJpbmd9IHRoZSBhdHRyaWJ1dGVzIHRvIGNhY2hlXG4gKi9cblNoYWRlci5wcm90b3R5cGUuY2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMgPSBmdW5jdGlvbiAoa2V5cylcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNba2V5c1tpXV0gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwga2V5c1tpXSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyBpcyBuZWVkZWQgYW55bW9yZS4uLlxuXG4gICAgLy8gQmVnaW4gd29yc3QgaGFjayBldmEgLy9cblxuICAgIC8vIFdIWT8/PyBPTkxZIG9uIG15IGNocm9tZSBwaXhlbCB0aGUgbGluZSBhYm92ZSByZXR1cm5zIC0xIHdoZW4gdXNpbmcgZmlsdGVycz9cbiAgICAvLyBtYXliZSBpdHMgc29tZXRoaW5nIHRvIGRvIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdsIGNvbnRleHQuXG4gICAgLy8gSSdtIGNvbnZpbmNlZCB0aGlzIGlzIGEgYnVnIGluIHRoZSBjaHJvbWUgYnJvd3NlciBhcyB0aGVyZSBpcyBOTyByZWFzb24gd2h5IHRoaXMgc2hvdWxkIGJlIHJldHVybmluZyAtMSBlc3BlY2lhbGx5IGFzIGl0IG9ubHkgbWFuaWZlc3RzIG9uIG15IGNocm9tZSBwaXhlbFxuICAgIC8vIElmIHRoZXJlcyBhbnkgd2ViR0wgcGVvcGxlIHRoYXQga25vdyB3aHkgY291bGQgaGFwcGVuIHBsZWFzZSBoZWxwIDopXG4gICAgLy8gaWYgKHRoaXMuYXR0cmlidXRlcy5hQ29sb3IgPT09IC0xKXtcbiAgICAvLyAgICAgdGhpcy5hdHRyaWJ1dGVzLmFDb2xvciA9IDI7XG4gICAgLy8gfVxuXG4gICAgLy8gRW5kIHdvcnN0IGhhY2sgZXZhIC8vXG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIHRoZSBzaGFkZXJzIGFuZCBjcmVhdGVzIHRoZSBwcm9ncmFtLlxuICpcbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX1cbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIGdsVmVydFNoYWRlciA9IHRoaXMuX2dsQ29tcGlsZShnbC5WRVJURVhfU0hBREVSLCB0aGlzLnZlcnRleFNyYyk7XG4gICAgdmFyIGdsRnJhZ1NoYWRlciA9IHRoaXMuX2dsQ29tcGlsZShnbC5GUkFHTUVOVF9TSEFERVIsIHRoaXMuZnJhZ21lbnRTcmMpO1xuXG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xGcmFnU2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGlmIGxpbmtpbmcgZmFpbHMsIHRoZW4gbG9nIGFuZCBjbGVhbnVwXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BpeGkuanMgRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci4nKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2wuZ2V0RXJyb3IoKScsIGdsLmdldEVycm9yKCkpO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcHJvZ3JhbSBpbmZvIGxvZywgbG9nIGl0XG4gICAgICAgIGlmIChnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSAhPT0gJycpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGl4aS5qcyBXYXJuaW5nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgcHJvZ3JhbSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2xlYW4gdXAgc29tZSBzaGFkZXJzXG4gICAgZ2wuZGVsZXRlU2hhZGVyKGdsVmVydFNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG5cbiAgICByZXR1cm4gKHRoaXMucHJvZ3JhbSA9IHByb2dyYW0pO1xufTtcblxuLypcblNoYWRlci5wcm90b3R5cGUuYnVpbGRTeW5jID0gZnVuY3Rpb24gKClcbntcbiAgIC8vIHZhciBzdHIgPSBcIlwiXG5cbiAgIC8vIHN0ciA9ICBcIlNoYWRlci5wcm90b3R5cGUuc3luY1VuaWZvcm1zID0gZnVuY3Rpb24oKVwiO1xuICAgLy8gc3RyICs9IFwie1xcblwiO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMudW5pZm9ybXMpXG4gICAge1xuICAgICAgICB2YXIgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNba2V5XTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5pZm9ybS52YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybSh1bmlmb3JtLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCBtYWtlUHJvcFNldHRlcigga2V5LCBcIiBibG9vcFwiLCB1bmlmb3JtLnR5cGUgKSAgKVxuICAvLyAgICAgIE9iamVjdC5kZWZcbiAgICAgICAgLy8gICAgbG9jYXRpb24gPSB1bmlmb3JtLl9sb2NhdGlvbixcbiAgICAgICAgICAvLyAgdmFsdWUgPSB1bmlmb3JtLnZhbHVlLFxuICAgICAgICAgICAgLy9pLCBpbDtcblxuICAgIC8vICAgIHN0ciArPSBcImdsLnVuaWZvcm0xaSh0aGlzLnVuaWZvcm1zLlwiKyBrZXkgK1wiLl9sb2NhdGlvbiwgdGhpcy51bmlmb3Jtcy5cIiArIGtleSArIFwiLnZhbHVlICk7XFxuXCJcblxuICAgIH1cblxufSovXG5cbi8qKlxuKiBBZGRzIGEgbmV3IHVuaWZvcm1cbipcbiogQHBhcmFtIHVuaWZvcm0ge29iamVjdH0gdGhlIG5ldyB1bmlmb3JtIHRvIGF0dGFjaFxuKi9cblNoYWRlci5wcm90b3R5cGUuc3luY1VuaWZvcm0gPSBmdW5jdGlvbiAodW5pZm9ybSlcbntcbiAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3JtLl9sb2NhdGlvbixcbiAgICAgICAgdmFsdWUgPSB1bmlmb3JtLnZhbHVlLFxuICAgICAgICBnbCA9IHRoaXMuZ2wsXG4gICAgICAgIGksIGlsO1xuXG4gICAgc3dpdGNoICh1bmlmb3JtLnR5cGUpXG4gICAge1xuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIHNpbmdsZSBpbnQgdmFsdWVcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJzFpJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gc2luZ2xlIGZsb2F0IHZhbHVlXG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICBjYXNlICcxZic6XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSgyKSBvciBKUyBBcnJyYXlcbiAgICAgICAgY2FzZSAnMmYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5KDMpIG9yIEpTIEFycnJheVxuICAgICAgICBjYXNlICczZic6XG4gICAgICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5KDQpIG9yIEpTIEFycnJheVxuICAgICAgICBjYXNlICc0Zic6XG4gICAgICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzNdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGEgMkQgUG9pbnQgb2JqZWN0XG4gICAgICAgIGNhc2UgJ3YyJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBhIDNEIFBvaW50IG9iamVjdFxuICAgICAgICBjYXNlICd2Myc6XG4gICAgICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnopO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gYSA0RCBQb2ludCBvYmplY3RcbiAgICAgICAgY2FzZSAndjQnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmKGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56LCB2YWx1ZS53KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEludDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnMWl2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEludDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnMml2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEludDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnM2l2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEludDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnNGl2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm00aXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICcxZnYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IG9yIEpTIEFycmF5XG4gICAgICAgIGNhc2UgJzJmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnM2Z2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICc0ZnYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IG9yIEpTIEFycmF5XG4gICAgICAgIGNhc2UgJ20yJzpcbiAgICAgICAgY2FzZSAnbWF0Mic6XG4gICAgICAgIGNhc2UgJ01hdHJpeDJmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCB1bmlmb3JtLnRyYW5zcG9zZSwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IG9yIEpTIEFycmF5XG4gICAgICAgIGNhc2UgJ20zJzpcbiAgICAgICAgY2FzZSAnbWF0Myc6XG4gICAgICAgIGNhc2UgJ01hdHJpeDNmdic6XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIHVuaWZvcm0udHJhbnNwb3NlLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnbTQnOlxuICAgICAgICBjYXNlICdtYXQ0JzpcbiAgICAgICAgY2FzZSAnTWF0cml4NGZ2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIHVuaWZvcm0udHJhbnNwb3NlLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBhIENvbG9yIFZhbHVlXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1dGlscy5oZXgycmdiKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICBjYXNlICdpdjEnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICBjYXNlICdpdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtM2l2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgIGNhc2UgJ2Z2MSc6XG4gICAgICAgICAgICBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICBjYXNlICdmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBhcnJheSBvZiAyRCBQb2ludCBvYmplY3RzXG4gICAgICAgIGNhc2UgJ3Yydic6XG4gICAgICAgICAgICBpZiAoIXVuaWZvcm0uX2FycmF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgyICogdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgKytpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiAyXSAgICAgICA9IHZhbHVlW2ldLng7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDIgKyAxXSAgID0gdmFsdWVbaV0ueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gYXJyYXkgb2YgM0QgUG9pbnQgb2JqZWN0c1xuICAgICAgICBjYXNlICd2M3YnOlxuICAgICAgICAgICAgaWYgKCF1bmlmb3JtLl9hcnJheSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7ICsraSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogM10gICAgICAgPSB2YWx1ZVtpXS54O1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiAzICsgMV0gICA9IHZhbHVlW2ldLnk7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDMgKyAyXSAgID0gdmFsdWVbaV0uejtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBhcnJheSBvZiA0RCBQb2ludCBvYmplY3RzXG4gICAgICAgIGNhc2UgJ3Y0dic6XG4gICAgICAgICAgICBpZiAoIXVuaWZvcm0uX2FycmF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg0ICogdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgKytpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiA0XSAgICAgICA9IHZhbHVlW2ldLng7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDQgKyAxXSAgID0gdmFsdWVbaV0ueTtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogNCArIDJdICAgPSB2YWx1ZVtpXS56O1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiA0ICsgM10gICA9IHZhbHVlW2ldLnc7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gUElYSS5UZXh0dXJlXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICBjYXNlICdzYW1wbGVyMkQnOlxuXG4gICAgICAgICAgICBpZiAoIXVuaWZvcm0udmFsdWUgfHwgIXVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhY3RpdmF0ZSB0aGlzIHRleHR1cmVcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbJ1RFWFRVUkUnICsgdGhpcy50ZXh0dXJlQ291bnRdKTtcblxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXTtcblxuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNhbXBsZXIyRCh1bmlmb3JtKTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgdGV4dHVyIHRvIHRoZSBuZXdseSBjcmVhdGVkIG9uZS4uXG4gICAgICAgICAgICAgICAgdGV4dHVyZSA9IHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiaW5kIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICAgICAgLy8gc2V0IHVuaWZvcm0gdG8gdGV4dHVyZSBpbmRleFxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm0uX2xvY2F0aW9uLCB0aGlzLnRleHR1cmVDb3VudCk7XG5cbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBuZXh0IHRleHR1cmUgaWRcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUNvdW50Kys7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpeGkuanMgU2hhZGVyIFdhcm5pbmc6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdW5pZm9ybS50eXBlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHNoYWRlciB1bmlmb3JtIHZhbHVlcy5cbiAqXG4gKi9cblNoYWRlci5wcm90b3R5cGUuc3luY1VuaWZvcm1zID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnRleHR1cmVDb3VudCA9IDE7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy51bmlmb3JtcylcbiAgICB7XG4gICAgICAgIHRoaXMuc3luY1VuaWZvcm0odGhpcy51bmlmb3Jtc1trZXldKTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGlzZXMgYSBTYW1wbGVyMkQgdW5pZm9ybSAod2hpY2ggbWF5IG9ubHkgYmUgYXZhaWxhYmxlIGxhdGVyIG9uIGFmdGVyIGluaXRVbmlmb3JtcyBvbmNlIHRoZSB0ZXh0dXJlIGhhcyBsb2FkZWQpXG4gKlxuICovXG5TaGFkZXIucHJvdG90eXBlLmluaXRTYW1wbGVyMkQgPSBmdW5jdGlvbiAodW5pZm9ybSlcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHRleHR1cmUgPSB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlO1xuXG4gICAgaWYoIXRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG5cbiAgICBpZiAodW5pZm9ybS50ZXh0dXJlRGF0YSlcbiAgICB7XG5cbiAgICAgICAgLy9UT0RPIG1vdmUgdGhpcy4uLlxuICAgICAgICB2YXIgZGF0YSA9IHVuaWZvcm0udGV4dHVyZURhdGE7XG5cbiAgICAgICAgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuICAgICAgICAvLyBHTFRleHR1cmUgPSBtYWcgbGluZWFyLCBtaW4gbGluZWFyX21pcG1hcF9saW5lYXIsIHdyYXAgcmVwZWF0ICsgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgIC8vIEdMVGV4dHVyZUxpbmVhciA9IG1hZy9taW4gbGluZWFyLCB3cmFwIGNsYW1wXG4gICAgICAgIC8vIEdMVGV4dHVyZU5lYXJlc3RSZXBlYXQgPSBtYWcvbWluIE5FQVJFU1QsIHdyYXAgcmVwZWF0XG4gICAgICAgIC8vIEdMVGV4dHVyZU5lYXJlc3QgPSBtYWcvbWluIG5lYXJlc3QsIHdyYXAgY2xhbXBcbiAgICAgICAgLy8gQXVkaW9UZXh0dXJlID0gd2hhdGV2ZXIgKyBsdW1pbmFuY2UgKyB3aWR0aCA1MTIsIGhlaWdodCAyLCBib3JkZXIgMFxuICAgICAgICAvLyBLZXlUZXh0dXJlID0gd2hhdGV2ZXIgKyBsdW1pbmFuY2UgKyB3aWR0aCAyNTYsIGhlaWdodCAyLCBib3JkZXIgMFxuXG4gICAgICAgIC8vICBtYWdGaWx0ZXIgY2FuIGJlOiBnbC5MSU5FQVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIG9yIGdsLk5FQVJFU1RcbiAgICAgICAgLy8gIHdyYXBTL1QgY2FuIGJlOiBnbC5DTEFNUF9UT19FREdFIG9yIGdsLlJFUEVBVFxuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZGF0YS5sdW1pbmFuY2UgPyBnbC5MVU1JTkFOQ0UgOiBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlLnNvdXJjZSk7XG5cbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGRhdGEubWFnRmlsdGVyID8gZGF0YS5tYWdGaWx0ZXIgOiBnbC5MSU5FQVIgKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGRhdGEud3JhcFMgPyBkYXRhLndyYXBTIDogZ2wuQ0xBTVBfVE9fRURHRSApO1xuXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGRhdGEud3JhcFMgPyBkYXRhLndyYXBTIDogZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGRhdGEud3JhcFQgPyBkYXRhLndyYXBUIDogZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuc2hhZGVyTWFuYWdlci5yZW5kZXJlci51cGRhdGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHNoYWRlci5cbiAqXG4gKi9cblNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuXG4gICAgdGhpcy52ZXJ0ZXhTcmMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBudWxsO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5fZ2xDb21waWxlID0gZnVuY3Rpb24gKHR5cGUsIHNyYylcbntcbiAgICB2YXIgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cbiAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICBpZiAoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9zaGFkZXJzL1NoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNoYWRlciA9IHJlcXVpcmUoJy4vU2hhZGVyJyk7XG5cbi8qKlxuICogVGhpcyBzaGFkZXIgaXMgdXNlZCB0byBkcmF3IGNvbXBsZXggcHJpbWl0aXZlIHNoYXBlcyBmb3Ige0BsaW5rIFBJWEkuR3JhcGhpY3N9LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFBJWEkuU2hhZGVyXG4gKiBAcGFyYW0gc2hhZGVyTWFuYWdlciB7UElYSS5TaGFkZXJNYW5hZ2VyfSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBDb21wbGV4UHJpbWl0aXZlU2hhZGVyKHNoYWRlck1hbmFnZXIpXG57XG4gICAgU2hhZGVyLmNhbGwodGhpcyxcbiAgICAgICAgc2hhZGVyTWFuYWdlcixcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBbXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLFxuXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIHRpbnQ7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGNvbG9yOycsXG5cbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcbiAgICAgICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsXG4gICAgICAgICAgICAnICAgdkNvbG9yID0gdmVjNChjb2xvciAqIGFscGhhICogdGludCwgYWxwaGEpOycsLy9cIiAqIHZlYzQodGludCAqIGFscGhhLCBhbHBoYSk7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcbiAgICAgICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgdGludDogICB7IHR5cGU6ICczZicsIHZhbHVlOiBbMCwgMCwgMF0gfSxcbiAgICAgICAgICAgIGFscGhhOiAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogMCB9LFxuICAgICAgICAgICAgY29sb3I6ICB7IHR5cGU6ICczZicsIHZhbHVlOiBbMCwwLDBdIH0sXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDkpIH0sXG4gICAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBhdHRyaWJ1dGVzXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFWZXJ0ZXhQb3NpdGlvbjowXG4gICAgICAgIH1cbiAgICApO1xufVxuXG5Db21wbGV4UHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2hhZGVyLnByb3RvdHlwZSk7XG5Db21wbGV4UHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbXBsZXhQcmltaXRpdmVTaGFkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IENvbXBsZXhQcmltaXRpdmVTaGFkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvQ29tcGxleFByaW1pdGl2ZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNoYWRlciA9IHJlcXVpcmUoJy4vU2hhZGVyJyk7XG5cbi8qKlxuICogVGhpcyBzaGFkZXIgaXMgdXNlZCB0byBkcmF3IHNpbXBsZSBwcmltaXRpdmUgc2hhcGVzIGZvciB7QGxpbmsgUElYSS5HcmFwaGljc30uXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5TaGFkZXJcbiAqIEBwYXJhbSBzaGFkZXJNYW5hZ2VyIHtTaGFkZXJNYW5hZ2VyfSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBQcmltaXRpdmVTaGFkZXIoc2hhZGVyTWFuYWdlcilcbntcbiAgICBTaGFkZXIuY2FsbCh0aGlzLFxuICAgICAgICBzaGFkZXJNYW5hZ2VyLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFtcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBmbGlwWTsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyB0aW50OycsXG5cbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcbiAgICAgICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsXG4gICAgICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBbXG4gICAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICB0aW50OiAgIHsgdHlwZTogJzNmJywgdmFsdWU6IFswLCAwLCAwXSB9LFxuICAgICAgICAgICAgYWxwaGE6ICB7IHR5cGU6ICcxZicsIHZhbHVlOiAwIH0sXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDkpIH0sXG4gICAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBjdXN0b20gYXR0cmlidXRlc1xuICAgICAgICB7XG4gICAgICAgICAgICBhVmVydGV4UG9zaXRpb246MCxcbiAgICAgICAgICAgIGFDb2xvcjowXG4gICAgICAgIH1cbiAgICApO1xufVxuXG5QcmltaXRpdmVTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaGFkZXIucHJvdG90eXBlKTtcblByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmltaXRpdmVTaGFkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFByaW1pdGl2ZVNoYWRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9QcmltaXRpdmVTaGFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBXZWJHTE1hbmFnZXIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpLFxuICAgIEFscGhhTWFza0ZpbHRlciA9IHJlcXVpcmUoJy4uL2ZpbHRlcnMvU3ByaXRlTWFza0ZpbHRlcicpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gTWFza01hbmFnZXIocmVuZGVyZXIpXG57XG4gICAgV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xuXG4gICAgdGhpcy5zdGVuY2lsU3RhY2sgPSBbXTtcbiAgICB0aGlzLnJldmVyc2UgPSB0cnVlO1xuICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgdGhpcy5hbHBoYU1hc2tQb29sID0gW107XG59XG5cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV2ViR0xNYW5hZ2VyLnByb3RvdHlwZSk7XG5NYXNrTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXNrTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gTWFza01hbmFnZXI7XG5cbi8qKlxuICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4gKlxuICogQHBhcmFtIGdyYXBoaWNzIHtQSVhJLkdyYXBoaWNzfVxuICogQHBhcmFtIHdlYkdMRGF0YSB7YW55W119XG4gKi9cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoTWFzayA9IGZ1bmN0aW9uICh0YXJnZXQsIG1hc2tEYXRhKVxue1xuICAgIGlmIChtYXNrRGF0YS50ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhpcy5wdXNoU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5wdXNoU3RlbmNpbE1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgbWFzayBmcm9tIHRoZSBtYXNrIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IHtQSVhJLlJlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XG4gKi9cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BNYXNrID0gZnVuY3Rpb24gKHRhcmdldCwgbWFza0RhdGEpXG57XG4gICAgaWYgKG1hc2tEYXRhLnRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLnBvcFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMucG9wU3RlbmNpbE1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IHtQSVhJLlJlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XG4gKi9cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoU3ByaXRlTWFzayA9IGZ1bmN0aW9uICh0YXJnZXQsIG1hc2tEYXRhKVxue1xuICAgIHZhciBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2wucG9wKCk7XG5cbiAgICBpZiAoIWFscGhhTWFza0ZpbHRlcilcbiAgICB7XG4gICAgICAgIGFscGhhTWFza0ZpbHRlciA9IFtuZXcgQWxwaGFNYXNrRmlsdGVyKG1hc2tEYXRhKV07XG4gICAgfVxuXG4gICAgYWxwaGFNYXNrRmlsdGVyWzBdLm1hc2tTcHJpdGUgPSBtYXNrRGF0YTtcbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0YXJnZXQsIGFscGhhTWFza0ZpbHRlcik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gKlxuICovXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU3ByaXRlTWFzayA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG5cbiAgICB0aGlzLmFscGhhTWFza1Bvb2wucHVzaChmaWx0ZXJzKTtcbn07XG5cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IHtQSVhJLlJlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XG4gKi9cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoU3RlbmNpbE1hc2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBtYXNrRGF0YSlcbntcbiAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWxNYW5hZ2VyLnB1c2hNYXNrKG1hc2tEYXRhKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IHtQSVhJLlJlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XG4gKi9cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BTdGVuY2lsTWFzayA9IGZ1bmN0aW9uICh0YXJnZXQsIG1hc2tEYXRhKVxue1xuICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbE1hbmFnZXIucG9wTWFzayhtYXNrRGF0YSk7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL01hc2tNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQWJzdHJhY3RGaWx0ZXIgPSByZXF1aXJlKCcuL0Fic3RyYWN0RmlsdGVyJyksXG4gICAgbWF0aCA9ICByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGUgU3ByaXRlTWFza0ZpbHRlciBjbGFzc1xuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBzcHJpdGUge1BJWEkuU3ByaXRlfSB0aGUgdGFyZ2V0IHNwcml0ZVxuICovXG5mdW5jdGlvbiBTcHJpdGVNYXNrRmlsdGVyKHNwcml0ZSlcbntcbiAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuXG4gICAgQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdk1hc2tDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcbiAgICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcbn1cXG5cIixcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFzaztcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIC8vIGNoZWNrIGNsaXAhIHRoaXMgd2lsbCBzdG9wIHRoZSBtYXNrIGJsZWVkaW5nIG91dCBmcm9tIHRoZSBlZGdlc1xcbiAgICB2ZWMyIHRleHQgPSBhYnMoIHZNYXNrQ29vcmQgLSAwLjUgKTtcXG4gICAgdGV4dCA9IHN0ZXAoMC41LCB0ZXh0KTtcXG4gICAgZmxvYXQgY2xpcCA9IDEuMCAtIG1heCh0ZXh0LnksIHRleHQueCk7XFxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKG1hc2ssIHZNYXNrQ29vcmQpO1xcbiAgICBvcmlnaW5hbCAqPSAobWFza3kuciAqIG1hc2t5LmEgKiBhbHBoYSAqIGNsaXApO1xcbiAgICBnbF9GcmFnQ29sb3IgPSBvcmlnaW5hbDtcXG59XFxuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1hc2s6ICAgICAgICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogc3ByaXRlLl90ZXh0dXJlIH0sXG4gICAgICAgICAgICBhbHBoYTogICAgICAgICAgeyB0eXBlOiAnZicsIHZhbHVlOiAxfSxcbiAgICAgICAgICAgIG90aGVyTWF0cml4OiAgICB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG1hc2tNYXRyaXgudG9BcnJheSh0cnVlKSB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgIHRoaXMubWFza01hdHJpeCA9IG1hc2tNYXRyaXg7XG59XG5cblNwcml0ZU1hc2tGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuU3ByaXRlTWFza0ZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGVNYXNrRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVNYXNrRmlsdGVyO1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gKiBAcGFyYW0gaW5wdXQge1BJWEkuUmVuZGVyVGFyZ2V0fVxuICogQHBhcmFtIG91dHB1dCB7UElYSS5SZW5kZXJUYXJnZXR9XG4gKi9cblNwcml0ZU1hc2tGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxue1xuICAgIHZhciBmaWx0ZXJNYW5hZ2VyID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlcjtcblxuICAgIHRoaXMudW5pZm9ybXMubWFzay52YWx1ZSA9IHRoaXMubWFza1Nwcml0ZS5fdGV4dHVyZTtcblxuICAgIGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlTWFwcGVkTWF0cml4KGlucHV0LmZyYW1lLCB0aGlzLm1hc2tTcHJpdGUsIHRoaXMubWFza01hdHJpeCk7XG5cbiAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4LnZhbHVlID0gdGhpcy5tYXNrTWF0cml4LnRvQXJyYXkodHJ1ZSk7XG4gICAgdGhpcy51bmlmb3Jtcy5hbHBoYS52YWx1ZSA9IHRoaXMubWFza1Nwcml0ZS53b3JsZEFscGhhO1xuXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKHJlbmRlcmVyKTtcbiAgICAgLy8gZHJhdyB0aGUgZmlsdGVyLi4uXG4gICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIGlucHV0LCBvdXRwdXQpO1xufTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhTcHJpdGVNYXNrRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW1lbnQgbWFwLiBNdXN0IGJlIHBvd2VyIG9mIDIgc2l6ZWQgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5TcHJpdGVNYXNrRmlsdGVyI1xuICAgICAqL1xuICAgIG1hcDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLm1hc2sudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IHVzZWQgdG8gbW92ZSB0aGUgZGlzcGxhY2VtZW50IG1hcC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuU3ByaXRlTWFza0ZpbHRlciNcbiAgICAgKi9cbiAgICBvZmZzZXQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL1Nwcml0ZU1hc2tGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEZWZhdWx0U2hhZGVyID0gcmVxdWlyZSgnLi4vc2hhZGVycy9UZXh0dXJlU2hhZGVyJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgYSBQSVhJIGZpbHRlci4gQ3VycmVudGx5IG9ubHkgV2ViR0wgc3VwcG9ydHMgZmlsdGVycy5cbiAqIElmIHlvdSB3YW50IHRvIG1ha2UgYSBjdXN0b20gZmlsdGVyIHRoaXMgc2hvdWxkIGJlIHlvdXIgYmFzZSBjbGFzcy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gdmVydGV4U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSB2ZXJ0ZXggc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIGZyYWdtZW50U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gdW5pZm9ybXMge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVuaWZvcm1zIGZvciB0aGlzIGZpbHRlci5cbiAqL1xuZnVuY3Rpb24gQWJzdHJhY3RGaWx0ZXIodmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpXG57XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBzaGFkZXJzXG4gICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dHJhIHBhZGRpbmcgdGhhdCB0aGUgZmlsdGVyIG1pZ2h0IG5lZWRcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wYWRkaW5nID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlmb3JtcyBhcyBhbiBvYmplY3RcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zIHx8IHt9O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZSBvZiB0aGUgdmVydGV4IHNoYWRlclxuICAgICAqIEBtZW1iZXIge3N0cmluZ1tdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTcmMgPSB2ZXJ0ZXhTcmMgfHwgRGVmYXVsdFNoYWRlci5kZWZhdWx0VmVydGV4U3JjO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvZGUgb2YgdGhlIGZyYW1lbnQgc2hhZGVyXG4gICAgICogQG1lbWJlciB7c3RyaW5nW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMgfHwgRGVmYXVsdFNoYWRlci5kZWZhdWx0RnJhZ21lbnRTcmM7XG5cbiAgICAvL1RPRE8gYSByZW1pbmRlciAtIHdvdWxkIGJlIGNvb2wgdG8gaGF2ZSBsb3dlciByZXMgZmlsdGVycyBhcyB0aGlzIHdvdWxkIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlLlxuXG4gICAgLy90eXBlb2YgZnJhZ21lbnRTcmMgPT09ICdzdHJpbmcnID8gZnJhZ21lbnRTcmMuc3BsaXQoJycpIDogKGZyYWdtZW50U3JjIHx8IFtdKTtcblxufVxuXG5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RGaWx0ZXI7XG5cbi8qKlxuICogR3JhYnMgYSBzaGFkZXIgZnJvbSB0aGUgY3VycmVudCByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIHNoYWRlciBmcm9tXG4gKi9cbkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZS5nZXRTaGFkZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICB2YXIgc2hhZGVyID0gdGhpcy5zaGFkZXJzW2dsLmlkXTtcblxuICAgIGlmICghc2hhZGVyKVxuICAgIHtcbiAgICAgICAgc2hhZGVyID0gbmV3IERlZmF1bHRTaGFkZXIocmVuZGVyZXIuc2hhZGVyTWFuYWdlcixcbiAgICAgICAgICAgIHRoaXMudmVydGV4U3JjLFxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNyYyxcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMsXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNoYWRlcnNbZ2wuaWRdID0gc2hhZGVyO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gKiBAcGFyYW0gaW5wdXQge1BJWEkuUmVuZGVyVGFyZ2V0fVxuICogQHBhcmFtIG91dHB1dCB7UElYSS5SZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gY2xlYXIge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gY2xlYXIgdGhlIG91dHB1dFRhcmdldFxuICovXG5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKVxue1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XG5cbiAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xufTtcblxuLyoqXG4gKiBTeW5jcyBhIHVuaWZvcm0gYmV0d2VlbiB0aGUgY2xhc3Mgb2JqZWN0IGFuZCB0aGUgc2hhZGVycy5cbiAqXG4gKi9cbkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZS5zeW5jVW5pZm9ybSA9IGZ1bmN0aW9uICh1bmlmb3JtKVxue1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5zaGFkZXJzLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2hhZGVyc1tpXS5zeW5jVW5pZm9ybSh1bmlmb3JtKTtcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0Fic3RyYWN0RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgV2ViR0xNYW5hZ2VyID0gcmVxdWlyZSgnLi9XZWJHTE1hbmFnZXInKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBXZWJHTE1hc2tNYW5hZ2VyKHJlbmRlcmVyKVxue1xuICAgIFdlYkdMTWFuYWdlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBudWxsO1xufVxuXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV2ViR0xNYW5hZ2VyLnByb3RvdHlwZSk7XG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMTWFza01hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMTWFza01hbmFnZXI7XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgbWFzayBzdGFjayB0aGF0IGlzIHVzZWQgYnkgdGhpcyBtYW5hZ2VyLlxuICpcbiAqIEBwYXJhbSBzdGVuY2lsTWFza1N0YWNrIHtQSVhJLlN0ZW5jaWxNYXNrU3RhY2t9IFRoZSBtYXNrIHN0YWNrXG4gKi9cbldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnNldE1hc2tTdGFjayA9IGZ1bmN0aW9uICggc3RlbmNpbE1hc2tTdGFjayApXG57XG4gICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gc3RlbmNpbE1hc2tTdGFjaztcblxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICBpZiAoc3RlbmNpbE1hc2tTdGFjay5zdGVuY2lsU3RhY2subGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLiBAYWx2aW5cbiAqXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9XG4gKiBAcGFyYW0gd2ViR0xEYXRhIHthbnlbXX1cbiAqL1xuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaFN0ZW5jaWwgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIHdlYkdMRGF0YSlcbntcbiAgICB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQuYXR0YWNoU3RlbmNpbEJ1ZmZlcigpO1xuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbCxcbiAgICAgICAgc21zID0gdGhpcy5zdGVuY2lsTWFza1N0YWNrO1xuXG4gICAgdGhpcy5iaW5kR3JhcGhpY3MoZ3JhcGhpY3MsIHdlYkdMRGF0YSk7XG5cbiAgICBpZiAoc21zLnN0ZW5jaWxTdGFjay5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbiAgICAgICAgc21zLnJldmVyc2UgPSB0cnVlO1xuICAgICAgICBzbXMuY291bnQgPSAwO1xuICAgIH1cblxuICAgIHNtcy5zdGVuY2lsU3RhY2sucHVzaCh3ZWJHTERhdGEpO1xuXG4gICAgdmFyIGxldmVsID0gc21zLmNvdW50O1xuXG4gICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywwLDB4RkYpO1xuICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5WRVJUKTtcblxuICAgIC8vIGRyYXcgdGhlIHRyaWFuZ2xlIHN0cmlwIVxuXG4gICAgaWYgKHdlYkdMRGF0YS5tb2RlID09PSAxKVxuICAgIHtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgaWYgKHNtcy5yZXZlcnNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhGRiAtIGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyBhIHF1YWQgdG8gaW5jcmVtZW50Li5cbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgNCwgZ2wuVU5TSUdORURfU0hPUlQsICggd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCApICogMiApO1xuXG4gICAgICAgIGlmIChzbXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwrMSksIDB4RkYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwrMSwgMHhGRik7XG4gICAgICAgIH1cblxuICAgICAgICBzbXMucmV2ZXJzZSA9ICFzbXMucmV2ZXJzZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYgKCFzbXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4RkYgLSBsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9TVFJJUCwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICBpZiAoIXNtcy5yZXZlcnNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwweEZGLShsZXZlbCsxKSwgMHhGRik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLktFRVApO1xuXG4gICAgc21zLmNvdW50Kys7XG59O1xuXG4vKipcbiAqIFRPRE8gdGhpcyBkb2VzIG5vdCBiZWxvbmcgaGVyZSFcbiAqXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9XG4gKiBAcGFyYW0gd2ViR0xEYXRhIHthbnlbXX1cbiAqL1xuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUuYmluZEdyYXBoaWNzID0gZnVuY3Rpb24gKGdyYXBoaWNzLCB3ZWJHTERhdGEpXG57XG4gICAgLy9pZiAodGhpcy5fY3VycmVudEdyYXBoaWNzID09PSBncmFwaGljcylyZXR1cm47XG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAvLyBiaW5kIHRoZSBncmFwaGljcyBvYmplY3QuLlxuICAgIHZhciBzaGFkZXI7Ly8gPSB0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIucGx1Z2lucy5wcmltaXRpdmVTaGFkZXI7XG5cbiAgICBpZiAod2ViR0xEYXRhLm1vZGUgPT09IDEpXG4gICAge1xuICAgICAgICBzaGFkZXIgPSB0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuY29tcGxleFByaW1pdGl2ZVNoYWRlcjtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC5fbG9jYXRpb24sIGZhbHNlLCB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpKTtcblxuICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci51bmlmb3Jtcy50aW50Ll9sb2NhdGlvbiwgdXRpbHMuaGV4MnJnYihncmFwaGljcy50aW50KSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudW5pZm9ybXMuY29sb3IuX2xvY2F0aW9uLCB3ZWJHTERhdGEuY29sb3IpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybXMuYWxwaGEuX2xvY2F0aW9uLCBncmFwaGljcy53b3JsZEFscGhhKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDIsIDApO1xuXG5cbiAgICAgICAgLy8gbm93IGRvIHRoZSByZXN0Li5cbiAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5pbmRleEJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmFjdGl2YXRlUHJpbWl0aXZlU2hhZGVyKCk7XG4gICAgICAgIHNoYWRlciA9IHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5wcmltaXRpdmVTaGFkZXI7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4Ll9sb2NhdGlvbiwgZmFsc2UsIGdyYXBoaWNzLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudW5pZm9ybXMudGludC5fbG9jYXRpb24sIHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3MudGludCkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybXMuYWxwaGEuX2xvY2F0aW9uLCBncmFwaGljcy53b3JsZEFscGhhKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDYsIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hdHRyaWJ1dGVzLmFDb2xvciwgNCwgZ2wuRkxPQVQsIGZhbHNlLDQgKiA2LCAyICogNCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5pbmRleEJ1ZmZlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUT0RPIEBhbHZpblxuICogQHBhcmFtIGdyYXBoaWNzIHtQSVhJLkdyYXBoaWNzfVxuICogQHBhcmFtIHdlYkdMRGF0YSB7YW55W119XG4gKi9cbldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnBvcFN0ZW5jaWwgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIHdlYkdMRGF0YSlcbntcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsLFxuICAgICAgICBzbXMgPSB0aGlzLnN0ZW5jaWxNYXNrU3RhY2s7XG5cbiAgICBzbXMuc3RlbmNpbFN0YWNrLnBvcCgpO1xuXG4gICAgc21zLmNvdW50LS07XG5cbiAgICBpZiAoc21zLnN0ZW5jaWxTdGFjay5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICAvLyB0aGUgc3RhY2sgaXMgZW1wdHkhXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIHZhciBsZXZlbCA9IHNtcy5jb3VudDtcblxuICAgICAgICB0aGlzLmJpbmRHcmFwaGljcyhncmFwaGljcywgd2ViR0xEYXRhKTtcblxuICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIGlmICh3ZWJHTERhdGEubW9kZSA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgc21zLnJldmVyc2UgPSAhc21zLnJldmVyc2U7XG5cbiAgICAgICAgICAgIGlmIChzbXMucmV2ZXJzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHhGRiAtIChsZXZlbCsxKSwgMHhGRik7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkcmF3IGEgcXVhZCB0byBpbmNyZW1lbnQuLlxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgNCwgZ2wuVU5TSUdORURfU0hPUlQsICggd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCApICogMiApO1xuXG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsMCwweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5WRVJUKTtcblxuICAgICAgICAgICAgLy8gZHJhdyB0aGUgdHJpYW5nbGUgc3RyaXAhXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kcmF3Q291bnQgKz0gMjtcblxuICAgICAgICAgICAgaWYgKCFzbXMucmV2ZXJzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwweEZGLShsZXZlbCksIDB4RkYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIC8vICBjb25zb2xlLmxvZyhcIjw8Pj5cIilcbiAgICAgICAgICAgIGlmICghc21zLnJldmVyc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4RkYgLSAobGV2ZWwrMSksIDB4RkYpO1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5DUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwrMSwgMHhGRik7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5ERUNSKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX1NUUklQLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmRyYXdDb3VudCsrO1xuXG4gICAgICAgICAgICBpZiAoIXNtcy5yZXZlcnNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLDB4RkYtKGxldmVsKSwgMHhGRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLktFRVApO1xuXG5cbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBtYXNrIHN0YWNrLlxuICpcbiAqL1xuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgV2ViR0xNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2suc3RlbmNpbFN0YWNrID0gbnVsbDtcbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4gKlxuICogQHBhcmFtIG1hc2tEYXRhIHthbnlbXX0gVGhlIG1hc2sgZGF0YSBzdHJ1Y3R1cmUgdG8gdXNlXG4gKi9cbldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hNYXNrID0gZnVuY3Rpb24gKG1hc2tEYXRhKVxue1xuXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHRoaXMucmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcyk7XG5cbiAgICBpZiAobWFza0RhdGEuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MudXBkYXRlR3JhcGhpY3MobWFza0RhdGEsIHRoaXMucmVuZGVyZXIuZ2wpO1xuICAgIH1cblxuICAgIGlmICghbWFza0RhdGEuX3dlYkdMW3RoaXMucmVuZGVyZXIuZ2wuaWRdLmRhdGEubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHVzaFN0ZW5jaWwobWFza0RhdGEsIG1hc2tEYXRhLl93ZWJHTFt0aGlzLnJlbmRlcmVyLmdsLmlkXS5kYXRhWzBdKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAqXG4gKiBAcGFyYW0gbWFza0RhdGEge2FueVtdfVxuICovXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BNYXNrID0gZnVuY3Rpb24gKG1hc2tEYXRhKVxue1xuICAgIHRoaXMucmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5yZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzKTtcblxuICAgIHRoaXMucG9wU3RlbmNpbChtYXNrRGF0YSwgbWFza0RhdGEuX3dlYkdMW3RoaXMucmVuZGVyZXIuZ2wuaWRdLmRhdGFbMF0pO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9TdGVuY2lsTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFdlYkdMTWFuYWdlciA9IHJlcXVpcmUoJy4vV2ViR0xNYW5hZ2VyJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5XZWJHbE1hbmFnZXJcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gQmxlbmRNb2RlTWFuYWdlcihyZW5kZXJlcilcbntcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gOTk5OTk7XG59XG5cbkJsZW5kTW9kZU1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXZWJHTE1hbmFnZXIucHJvdG90eXBlKTtcbkJsZW5kTW9kZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmxlbmRNb2RlTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gQmxlbmRNb2RlTWFuYWdlcjtcblxuLyoqXG4gKiBTZXRzLXVwIHRoZSBnaXZlbiBibGVuZE1vZGUgZnJvbSBXZWJHTCdzIHBvaW50IG9mIHZpZXcuXG4gKlxuICogQHBhcmFtIGJsZW5kTW9kZSB7bnVtYmVyfSB0aGUgYmxlbmRNb2RlLCBzaG91bGQgYmUgYSBQaXhpIGNvbnN0LCBzdWNoIGFzIGBQSVhJLkJMRU5EX01PREVTLkFERGAuIFNlZVxuICogIHtAbGluayBQSVhJLkJMRU5EX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzLlxuICovXG5CbGVuZE1vZGVNYW5hZ2VyLnByb3RvdHlwZS5zZXRCbGVuZE1vZGUgPSBmdW5jdGlvbiAoYmxlbmRNb2RlKVxue1xuICAgIGlmICh0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPT09IGJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBibGVuZE1vZGU7XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMucmVuZGVyZXIuYmxlbmRNb2Rlc1t0aGlzLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIHRoaXMucmVuZGVyZXIuZ2wuYmxlbmRGdW5jKG1vZGVbMF0sIG1vZGVbMV0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9CbGVuZE1vZGVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQWJzdHJhY3RGaWx0ZXIgPSByZXF1aXJlKCcuL0Fic3RyYWN0RmlsdGVyJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICpcbiAqIEJhc2ljIEZYQUEgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIGNvZGUgb24gZ2Vla3MzZC5jb20gd2l0aCB0aGVcbiAqIG1vZGlmaWNhdGlvbiB0aGF0IHRoZSB0ZXh0dXJlMkRMb2Qgc3R1ZmYgd2FzIHJlbW92ZWQgc2luY2UgaXQnc1xuICogdW5zdXBwb3J0ZWQgYnkgV2ViR0wuXG4gKlxuICogLS1cbiAqIEZyb206XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWl0c3VoaWtvL3dlYmdsLW1laW5jcmFmdFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqXG4gKi9cbmZ1bmN0aW9uIEZYQUFGaWx0ZXIoKVxue1xuICAgIEFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBcIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZhcnlpbmcgdmVjMiB2UmVzb2x1dGlvbjtcXG5cXG4vL3RleGNvb3JkcyBjb21wdXRlZCBpbiB2ZXJ0ZXggc3RlcFxcbi8vdG8gYXZvaWQgZGVwZW5kZW50IHRleHR1cmUgcmVhZHNcXG52YXJ5aW5nIHZlYzIgdl9yZ2JOVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xcblxcblxcbnZvaWQgdGV4Y29vcmRzKHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIHJlc29sdXRpb24sXFxuICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JOVywgb3V0IHZlYzIgdl9yZ2JORSxcXG4gICAgICAgICAgICBvdXQgdmVjMiB2X3JnYlNXLCBvdXQgdmVjMiB2X3JnYlNFLFxcbiAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiTSkge1xcbiAgICB2ZWMyIGludmVyc2VWUCA9IDEuMCAvIHJlc29sdXRpb24ueHk7XFxuICAgIHZfcmdiTlcgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlA7XFxuICAgIHZfcmdiTkUgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JTVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYlNFID0gKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JNID0gdmVjMihmcmFnQ29vcmQgKiBpbnZlcnNlVlApO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgdkNvbG9yID0gdmVjNChhQ29sb3IucmdiICogYUNvbG9yLmEsIGFDb2xvci5hKTtcXG4gICB2UmVzb2x1dGlvbiA9IHJlc29sdXRpb247XFxuXFxuICAgLy9jb21wdXRlIHRoZSB0ZXh0dXJlIGNvb3JkcyBhbmQgc2VuZCB0aGVtIHRvIHZhcnlpbmdzXFxuICAgdGV4Y29vcmRzKGFUZXh0dXJlQ29vcmQgKiByZXNvbHV0aW9uLCByZXNvbHV0aW9uLCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xcbn1cXG5cIixcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuXFxuXFxuLyoqXFxuQmFzaWMgRlhBQSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgY29kZSBvbiBnZWVrczNkLmNvbSB3aXRoIHRoZVxcbm1vZGlmaWNhdGlvbiB0aGF0IHRoZSB0ZXh0dXJlMkRMb2Qgc3R1ZmYgd2FzIHJlbW92ZWQgc2luY2UgaXQnc1xcbnVuc3VwcG9ydGVkIGJ5IFdlYkdMLlxcblxcbi0tXFxuXFxuRnJvbTpcXG5odHRwczovL2dpdGh1Yi5jb20vbWl0c3VoaWtvL3dlYmdsLW1laW5jcmFmdFxcblxcbkNvcHlyaWdodCAoYykgMjAxMSBieSBBcm1pbiBSb25hY2hlci5cXG5cXG5Tb21lIHJpZ2h0cyByZXNlcnZlZC5cXG5cXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG5tb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXFxubWV0OlxcblxcbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcXG4gICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xcbiAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxcbiAgICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4gICAgKiBUaGUgbmFtZXMgb2YgdGhlIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvclxcbiAgICAgIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xcbiAgICAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXFxuXFxcIkFTIElTXFxcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcXG5MSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcXG5BIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxcbk9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxcblNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcXG5MSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcXG5EQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcXG5USEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXFxuT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG4qL1xcblxcbiNpZm5kZWYgRlhBQV9SRURVQ0VfTUlOXFxuICAgICNkZWZpbmUgRlhBQV9SRURVQ0VfTUlOICAgKDEuMC8gMTI4LjApXFxuI2VuZGlmXFxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NVUxcXG4gICAgI2RlZmluZSBGWEFBX1JFRFVDRV9NVUwgICAoMS4wIC8gOC4wKVxcbiNlbmRpZlxcbiNpZm5kZWYgRlhBQV9TUEFOX01BWFxcbiAgICAjZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcbiNlbmRpZlxcblxcbi8vb3B0aW1pemVkIHZlcnNpb24gZm9yIG1vYmlsZSwgd2hlcmUgZGVwZW5kZW50XFxuLy90ZXh0dXJlIHJlYWRzIGNhbiBiZSBhIGJvdHRsZW5lY2tcXG52ZWM0IGZ4YWEoc2FtcGxlcjJEIHRleCwgdmVjMiBmcmFnQ29vcmQsIHZlYzIgcmVzb2x1dGlvbixcXG4gICAgICAgICAgICB2ZWMyIHZfcmdiTlcsIHZlYzIgdl9yZ2JORSxcXG4gICAgICAgICAgICB2ZWMyIHZfcmdiU1csIHZlYzIgdl9yZ2JTRSxcXG4gICAgICAgICAgICB2ZWMyIHZfcmdiTSkge1xcbiAgICB2ZWM0IGNvbG9yO1xcbiAgICBtZWRpdW1wIHZlYzIgaW52ZXJzZVZQID0gdmVjMigxLjAgLyByZXNvbHV0aW9uLngsIDEuMCAvIHJlc29sdXRpb24ueSk7XFxuICAgIHZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5XKS54eXo7XFxuICAgIHZlYzMgcmdiTkUgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5FKS54eXo7XFxuICAgIHZlYzMgcmdiU1cgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYlNXKS54eXo7XFxuICAgIHZlYzMgcmdiU0UgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYlNFKS54eXo7XFxuICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk0pO1xcbiAgICB2ZWMzIHJnYk0gID0gdGV4Q29sb3IueHl6O1xcbiAgICB2ZWMzIGx1bWEgPSB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpO1xcbiAgICBmbG9hdCBsdW1hTlcgPSBkb3QocmdiTlcsIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hTkUgPSBkb3QocmdiTkUsIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hU1cgPSBkb3QocmdiU1csIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hU0UgPSBkb3QocmdiU0UsIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hTSAgPSBkb3QocmdiTSwgIGx1bWEpO1xcbiAgICBmbG9hdCBsdW1hTWluID0gbWluKGx1bWFNLCBtaW4obWluKGx1bWFOVywgbHVtYU5FKSwgbWluKGx1bWFTVywgbHVtYVNFKSkpO1xcbiAgICBmbG9hdCBsdW1hTWF4ID0gbWF4KGx1bWFNLCBtYXgobWF4KGx1bWFOVywgbHVtYU5FKSwgbWF4KGx1bWFTVywgbHVtYVNFKSkpO1xcblxcbiAgICBtZWRpdW1wIHZlYzIgZGlyO1xcbiAgICBkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XFxuICAgIGRpci55ID0gICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcXG5cXG4gICAgZmxvYXQgZGlyUmVkdWNlID0gbWF4KChsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UpICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSwgRlhBQV9SRURVQ0VfTUlOKTtcXG5cXG4gICAgZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XFxuICAgIGRpciA9IG1pbih2ZWMyKEZYQUFfU1BBTl9NQVgsIEZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcXG4gICAgICAgICAgICAgIGRpciAqIHJjcERpck1pbikpICogaW52ZXJzZVZQO1xcblxcbiAgICB2ZWMzIHJnYkEgPSAwLjUgKiAoXFxuICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xcbiAgICB2ZWMzIHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqIC0wLjUpLnh5eiArXFxuICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAwLjUpLnh5eik7XFxuXFxuICAgIGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcbiAgICBpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQSwgdGV4Q29sb3IuYSk7XFxuICAgIGVsc2VcXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JCLCB0ZXhDb2xvci5hKTtcXG4gICAgcmV0dXJuIGNvbG9yO1xcbn1cXG5cXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2UmVzb2x1dGlvbjtcXG5cXG4vL3RleGNvb3JkcyBjb21wdXRlZCBpbiB2ZXJ0ZXggc3RlcFxcbi8vdG8gYXZvaWQgZGVwZW5kZW50IHRleHR1cmUgcmVhZHNcXG52YXJ5aW5nIHZlYzIgdl9yZ2JOVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcblxcbnZvaWQgbWFpbih2b2lkKXtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gZnhhYSh1U2FtcGxlciwgdlRleHR1cmVDb29yZCAqIHZSZXNvbHV0aW9uLCB2UmVzb2x1dGlvbiwgdl9yZ2JOVywgdl9yZ2JORSwgdl9yZ2JTVywgdl9yZ2JTRSwgdl9yZ2JNKTtcXG5cXG59XFxuXCIsXG4gICAgICAgIC8vIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc29sdXRpb246IHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMSwgeTogMSB9IH1cbiAgICAgICAgfVxuICAgICk7XG5cbn1cblxuRlhBQUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5GWEFBRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZYQUFGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEZYQUFGaWx0ZXI7XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZmlsdGVyXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0byByZXRyaWV2ZSB0aGUgZmlsdGVyIGZyb21cbiAqIEBwYXJhbSBpbnB1dCB7UElYSS5SZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gb3V0cHV0IHtQSVhJLlJlbmRlclRhcmdldH1cbiAqL1xuRlhBQUZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpXG57XG4gICAgdmFyIGZpbHRlck1hbmFnZXIgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyO1xuXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKCByZW5kZXJlciApO1xuICAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0ZYQUFGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBPYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpLFxuICAgIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpLFxuICAgIFBhcnRpY2xlU2hhZGVyID0gcmVxdWlyZSgnLi9QYXJ0aWNsZVNoYWRlcicpLFxuICAgIFBhcnRpY2xlQnVmZmVyID0gcmVxdWlyZSgnLi9QYXJ0aWNsZUJ1ZmZlcicpLFxuICAgIG1hdGggICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL21hdGgnKTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXNcbiAqXG4gKiBCaWcgdGhhbmtzIHRvIHRoZSB2ZXJ5IGNsZXZlciBNYXR0IERlc0xhdXJpZXJzIDxtYXR0ZGVzbD4gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL1xuICogZm9yIGNyZWF0aW5nIHRoZSBvcmlnaW5hbCBwaXhpIHZlcnNpb24hXG4gKiBBbHNvIGEgdGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9iY2hldmFsaWVyIGZvciB0d2Vha2luZyB0aGUgdGludCBhbmQgYWxwaGEgc28gdGhhdCB0aGV5IG5vdyBzaGFyZSA0IGJ5dGVzIG9uIHRoZSB2ZXJ0ZXggYnVmZmVyXG4gKlxuICogSGVhdmlseSBpbnNwaXJlZCBieSBMaWJHRFgncyBQYXJ0aWNsZVJlbmRlcmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9QYXJ0aWNsZVJlbmRlcmVyLmphdmFcbiAqL1xuXG4vKipcbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIHNwcml0ZSBiYXRjaCB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlUmVuZGVyZXIocmVuZGVyZXIpXG57XG4gICAgT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cbiAgICAvLyA2NTUzNSBpcyBtYXggdmVydGV4IGluZGV4IGluIHRoZSBpbmRleCBidWZmZXIgKHNlZSBQYXJ0aWNsZVJlbmRlcmVyKVxuICAgIC8vIHNvIG1heCBudW1iZXIgb2YgcGFydGljbGVzIGlzIDY1NTM2IC8gNCA9IDE2Mzg0XG4gICAgLy8gYW5kIG1heCBudW1iZXIgb2YgZWxlbWVudCBpbiB0aGUgaW5kZXggYnVmZmVyIGlzIDE2Mzg0ICogNiA9IDk4MzA0XG4gICAgLy8gQ3JlYXRpbmcgYSBmdWxsIGluZGV4IGJ1ZmZlciwgb3ZlcmhlYWQgaXMgOTgzMDQgKiAyID0gMTk2S29cbiAgICB2YXIgbnVtSW5kaWNlcyA9IDk4MzA0O1xuXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIGluZGljZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcblxuICAgIGZvciAodmFyIGk9MCwgaj0wOyBpIDwgbnVtSW5kaWNlczsgaSArPSA2LCBqICs9IDQpXG4gICAge1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDBdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDNdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNoYWRlciB0aGF0IGlzIHVzZWQgaWYgYSBzcHJpdGUgZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMucHJvcGVydGllcyA9IG51bGw7XG5cbiAgICB0aGlzLnRlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcbn1cblxuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZSk7XG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlUmVuZGVyZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlUmVuZGVyZXI7XG5cbldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3BhcnRpY2xlJywgUGFydGljbGVSZW5kZXJlcik7XG5cbi8qKlxuICogV2hlbiB0aGVyZSBpcyBhIFdlYkdMIGNvbnRleHQgY2hhbmdlXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgLy8gc2V0dXAgZGVmYXVsdCBzaGFkZXJcbiAgICB0aGlzLnNoYWRlciA9IG5ldyBQYXJ0aWNsZVNoYWRlcih0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIpO1xuXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLy8gNjU1MzUgaXMgbWF4IGluZGV4LCBzbyA2NTUzNSAvIDYgPSAxMDkyMi5cblxuICAgIC8vdXBsb2FkIHRoZSBpbmRleCBkYXRhXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICB0aGlzLnByb3BlcnRpZXMgPSBbXG4gICAgICAgIC8vIHZlcnRpY2VzRGF0YVxuICAgICAgICB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6dGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sXG4gICAgICAgICAgICBzaXplOjIsXG4gICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjp0aGlzLnVwbG9hZFZlcnRpY2VzLFxuICAgICAgICAgICAgb2Zmc2V0OjBcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcG9zaXRpb25EYXRhXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTp0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFQb3NpdGlvbkNvb3JkLFxuICAgICAgICAgICAgc2l6ZToyLFxuICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246dGhpcy51cGxvYWRQb3NpdGlvbixcbiAgICAgICAgICAgIG9mZnNldDowXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJvdGF0aW9uRGF0YVxuICAgICAgICB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6dGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hUm90YXRpb24sXG4gICAgICAgICAgICBzaXplOjEsXG4gICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjp0aGlzLnVwbG9hZFJvdGF0aW9uLFxuICAgICAgICAgICAgb2Zmc2V0OjBcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdXZzRGF0YVxuICAgICAgICB7XG4gICAgICAgICAgICBhdHRyaWJ1dGU6dGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLFxuICAgICAgICAgICAgc2l6ZToyLFxuICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246dGhpcy51cGxvYWRVdnMsXG4gICAgICAgICAgICBvZmZzZXQ6MFxuICAgICAgICB9LFxuICAgICAgICAvLyBhbHBoYURhdGFcbiAgICAgICAge1xuICAgICAgICAgICAgYXR0cmlidXRlOnRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLFxuICAgICAgICAgICAgc2l6ZToxLFxuICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246dGhpcy51cGxvYWRBbHBoYSxcbiAgICAgICAgICAgIG9mZnNldDowXG4gICAgICAgIH1cbiAgICBdO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBuZXcgcGFydGljbGUgYmF0Y2guXG4gKlxuICovXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIC8vIGJpbmQgdGhlIG1haW4gdGV4dHVyZVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXG4gICAgLy8gYmluZCB0aGUgYnVmZmVyc1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICB2YXIgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHNoYWRlcik7XG59O1xuXG5cbi8qKlxuICogUmVuZGVycyB0aGUgcGFydGljbGUgY29udGFpbmVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY29udGFpbmVyIHtQSVhJLlBhcnRpY2xlQ29udGFpbmVyfSBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB1c2luZyB0aGlzIFBhcnRpY2xlUmVuZGVyZXJcbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lcilcbntcbiAgICB2YXIgY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW4sXG4gICAgICAgIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgIG1heFNpemUgPSBjb250YWluZXIuX21heFNpemUsXG4gICAgICAgIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuXG4gICAgaWYodG90YWxDaGlsZHJlbiA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZih0b3RhbENoaWxkcmVuID4gbWF4U2l6ZSlcbiAgICB7XG4gICAgICAgIHRvdGFsQ2hpbGRyZW4gPSBtYXhTaXplO1xuICAgIH1cblxuICAgIGlmKCFjb250YWluZXIuX2J1ZmZlcnMpXG4gICAge1xuICAgICAgICBjb250YWluZXIuX2J1ZmZlcnMgPSB0aGlzLmdlbmVyYXRlQnVmZmVycyggY29udGFpbmVyICk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSk7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgdmFyIG0gPSAgY29udGFpbmVyLndvcmxkVHJhbnNmb3JtLmNvcHkoIHRoaXMudGVtcE1hdHJpeCApO1xuICAgIG0ucHJlcGVuZCggdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXggKTtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgbS50b0FycmF5KHRydWUpKTtcbiAgICBnbC51bmlmb3JtMWYodGhpcy5zaGFkZXIudW5pZm9ybXMudUFscGhhLl9sb2NhdGlvbiwgY29udGFpbmVyLndvcmxkQWxwaGEpO1xuXG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHRleHR1cmUgaXMgYm91bmQuLlxuICAgIHZhciBiYXNlVGV4dHVyZSA9IGNoaWxkcmVuWzBdLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuXG4gICAgaWYgKCFiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXG4gICAge1xuICAgICAgICAvLyBpZiB0aGUgdGV4dHVyZSBoYXMgbm90IHVwZGF0ZWQgdGhlbiBsZXRzIG5vdCB1cGxvYWQgYW55IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgICAgIGlmKCF0aGlzLnJlbmRlcmVyLnVwZGF0ZVRleHR1cmUoYmFzZVRleHR1cmUpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZighY29udGFpbmVyLl9wcm9wZXJ0aWVzWzBdIHx8ICFjb250YWluZXIuX3Byb3BlcnRpZXNbM10pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5fYnVmZmVyVG9VcGRhdGUgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XG4gICAgfVxuXG4gICAgLy8gbm93IGxldHMgdXBsb2FkIGFuZCByZW5kZXIgdGhlIGJ1ZmZlcnMuLlxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsQ2hpbGRyZW47IGkgKz0gYmF0Y2hTaXplLCBqICs9IDEpXG4gICAge1xuICAgICAgICB2YXIgYW1vdW50ID0gKCB0b3RhbENoaWxkcmVuIC0gaSk7XG4gICAgICAgIGlmKGFtb3VudCA+IGJhdGNoU2l6ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgYW1vdW50ID0gYmF0Y2hTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IGNvbnRhaW5lci5fYnVmZmVyc1tqXTtcblxuICAgICAgICAvLyB3ZSBhbHdheXMgdXBsb2FkIHRoZSBkeW5hbWljXG4gICAgICAgIGJ1ZmZlci51cGxvYWREeW5hbWljKGNoaWxkcmVuLCBpLCBhbW91bnQpO1xuXG4gICAgICAgIC8vIHdlIG9ubHkgdXBsb2FkIHRoZSBzdGF0aWMgY29udGVudCB3aGVuIHdlIGhhdmUgdG8hXG4gICAgICAgIGlmKGNvbnRhaW5lci5fYnVmZmVyVG9VcGRhdGUgPT09IGopXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJ1ZmZlci51cGxvYWRTdGF0aWMoY2hpbGRyZW4sIGksIGFtb3VudCk7XG4gICAgICAgICAgICBjb250YWluZXIuX2J1ZmZlclRvVXBkYXRlID0gaiArIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiaW5kIHRoZSBidWZmZXJcbiAgICAgICAgYnVmZmVyLmJpbmQoIHRoaXMuc2hhZGVyICk7XG5cbiAgICAgICAgIC8vIG5vdyBkcmF3IHRob3NlIHN1Y2thcyFcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgYW1vdW50ICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmRyYXdDb3VudCsrO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBvbmUgcGFydGljbGUgYnVmZmVyIGZvciBlYWNoIGNoaWxkIGluIHRoZSBjb250YWluZXIgd2Ugd2FudCB0byByZW5kZXIgYW5kIHVwZGF0ZXMgaW50ZXJuYWwgcHJvcGVydGllc1xuICpcbiAqIEBwYXJhbSBjb250YWluZXIge1BJWEkuUGFydGljbGVDb250YWluZXJ9IFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICovXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUJ1ZmZlcnMgPSBmdW5jdGlvbiAoY29udGFpbmVyKVxue1xuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2wsXG4gICAgICAgIGJ1ZmZlcnMgPSBbXSxcbiAgICAgICAgc2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZSxcbiAgICAgICAgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemUsXG4gICAgICAgIGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkgKz0gYmF0Y2hTaXplKVxuICAgIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBQYXJ0aWNsZUJ1ZmZlcihnbCwgdGhpcy5wcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgYmF0Y2hTaXplKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcnM7XG59O1xuXG4vKipcbiAqIFVwbG9hZHMgdGhlIHZlcnRpY2llcy5cbiAqXG4gKiBAcGFyYW0gY2hpbGRyZW4ge1BJWEkuRGlzcGxheU9iamVjdFtdfSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxuICogQHBhcmFtIHN0YXJ0SW5kZXgge251bWJlcn0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgdmVydGljZXMgdXBsb2FkZWRcbiAqIEBwYXJhbSBhcnJheSB7bnVtYmVyW119XG4gKiBAcGFyYW0gc3RyaWRlIHtudW1iZXJ9XG4gKiBAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9XG4gKi9cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVwbG9hZFZlcnRpY2VzID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldClcbntcbiAgICB2YXIgc3ByaXRlLFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICB0cmltLFxuICAgICAgICBzeCxcbiAgICAgICAgc3ksXG4gICAgICAgIHcwLCB3MSwgaDAsIGgxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXG4gICAgICAgIHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcbiAgICAgICAgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZTtcbiAgICAgICAgc3ggPSBzcHJpdGUuc2NhbGUueDtcbiAgICAgICAgc3kgPSBzcHJpdGUuc2NhbGUueTtcblxuICAgICAgICBpZiAodGV4dHVyZS50cmltKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy4uXG4gICAgICAgICAgICB0cmltID0gdGV4dHVyZS50cmltO1xuXG4gICAgICAgICAgICB3MSA9IHRyaW0ueCAtIHNwcml0ZS5hbmNob3IueCAqIHRyaW0ud2lkdGg7XG4gICAgICAgICAgICB3MCA9IHcxICsgdGV4dHVyZS5jcm9wLndpZHRoO1xuXG4gICAgICAgICAgICBoMSA9IHRyaW0ueSAtIHNwcml0ZS5hbmNob3IueSAqIHRyaW0uaGVpZ2h0O1xuICAgICAgICAgICAgaDAgPSBoMSArIHRleHR1cmUuY3JvcC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3MCA9ICh0ZXh0dXJlLl9mcmFtZS53aWR0aCApICogKDEtc3ByaXRlLmFuY2hvci54KTtcbiAgICAgICAgICAgIHcxID0gKHRleHR1cmUuX2ZyYW1lLndpZHRoICkgKiAtc3ByaXRlLmFuY2hvci54O1xuXG4gICAgICAgICAgICBoMCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAqICgxLXNwcml0ZS5hbmNob3IueSk7XG4gICAgICAgICAgICBoMSA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAqIC1zcHJpdGUuYW5jaG9yLnk7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtvZmZzZXRdID0gdzEgKiBzeDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBoMSAqIHN5O1xuXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSB3MCAqIHN4O1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IGgxICogc3k7XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB3MCAqIHN4O1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBoMCAqIHN5O1xuXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gdzEgKiBzeDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gaDAgKiBzeTtcblxuICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG5cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjaGlsZHJlbiB7UElYSS5EaXNwbGF5T2JqZWN0W119IHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBwb3NpdGlvbnMgdXBsb2FkZWRcbiAqIEBwYXJhbSBhcnJheSB7bnVtYmVyW119XG4gKiBAcGFyYW0gc3RyaWRlIHtudW1iZXJ9XG4gKiBAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9XG4gKi9cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVwbG9hZFBvc2l0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuLHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG4gICAge1xuICAgICAgICB2YXIgc3ByaXRlUG9zaXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucG9zaXRpb247XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcblxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcblxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XG5cbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gY2hpbGRyZW4ge1BJWEkuRGlzcGxheU9iamVjdFtdfSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxuICogQHBhcmFtIHN0YXJ0SW5kZXgge251bWJlcn0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgcm90YXRpb24gdXBsb2FkZWRcbiAqIEBwYXJhbSBhcnJheSB7bnVtYmVyW119XG4gKiBAcGFyYW0gc3RyaWRlIHtudW1iZXJ9XG4gKiBAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9XG4gKi9cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVwbG9hZFJvdGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuLHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG4gICAge1xuICAgICAgICB2YXIgc3ByaXRlUm90YXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucm90YXRpb247XG5cblxuICAgICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUm90YXRpb247XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSBzcHJpdGVSb3RhdGlvbjtcblxuICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gY2hpbGRyZW4ge1BJWEkuRGlzcGxheU9iamVjdFtdfSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxuICogQHBhcmFtIHN0YXJ0SW5kZXgge251bWJlcn0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgVXZzIHVwbG9hZGVkXG4gKiBAcGFyYW0gYXJyYXkge251bWJlcltdfVxuICogQHBhcmFtIHN0cmlkZSB7bnVtYmVyfVxuICogQHBhcmFtIG9mZnNldCB7bnVtYmVyfVxuICovXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS51cGxvYWRVdnMgPSBmdW5jdGlvbiAoY2hpbGRyZW4sc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlVXZzID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLl90ZXh0dXJlLl91dnM7XG5cbiAgICAgICAgaWYgKHRleHR1cmVVdnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSB0ZXh0dXJlVXZzLngwO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xuXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gdGV4dHVyZVV2cy55MTtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSB0ZXh0dXJlVXZzLngyO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMiArIDFdID0gdGV4dHVyZVV2cy55MjtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSB0ZXh0dXJlVXZzLngzO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gdGV4dHVyZVV2cy55MztcblxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvL1RPRE8geW91IGtub3cgdGhpcyBjYW4gYmUgZWFzaWVyIVxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IDA7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSAwO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSAwO1xuXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IDA7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSAwO1xuXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IDA7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzICsgMV0gPSAwO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjaGlsZHJlbiB7UElYSS5EaXNwbGF5T2JqZWN0W119IHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBhbHBoYSB1cGxvYWRlZFxuICogQHBhcmFtIGFycmF5IHtudW1iZXJbXX1cbiAqIEBwYXJhbSBzdHJpZGUge251bWJlcn1cbiAqIEBwYXJhbSBvZmZzZXQge251bWJlcn1cbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUudXBsb2FkQWxwaGEgPSBmdW5jdGlvbiAoY2hpbGRyZW4sc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpXG57XG4gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG4gICAgIHtcbiAgICAgICAgdmFyIHNwcml0ZUFscGhhID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLmFscGhhO1xuXG4gICAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVBbHBoYTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZUFscGhhO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHNwcml0ZUFscGhhO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZUFscGhhO1xuXG4gICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgUGFydGljbGVSZW5kZXJlci5cbiAqXG4gKi9cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLmdsKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgIH1cblxuICAgIE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZVJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGV4dHVyZVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC9zaGFkZXJzL1RleHR1cmVTaGFkZXInKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuVGV4dHVyZVNoYWRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBzaGFkZXJNYW5hZ2VyIHtTaGFkZXJNYW5hZ2VyfSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZVNoYWRlcihzaGFkZXJNYW5hZ2VyKVxue1xuICAgIFRleHR1cmVTaGFkZXIuY2FsbCh0aGlzLFxuICAgICAgICBzaGFkZXJNYW5hZ2VyLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFtcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFDb2xvcjsnLFxuXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uQ29vcmQ7JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhU2NhbGU7JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uOycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICAgICAnICAgdmVjMiB2ID0gYVZlcnRleFBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICcgICB2LnggPSAoYVZlcnRleFBvc2l0aW9uLngpICogY29zKGFSb3RhdGlvbikgLSAoYVZlcnRleFBvc2l0aW9uLnkpICogc2luKGFSb3RhdGlvbik7JyxcbiAgICAgICAgICAgICcgICB2LnkgPSAoYVZlcnRleFBvc2l0aW9uLngpICogc2luKGFSb3RhdGlvbikgKyAoYVZlcnRleFBvc2l0aW9uLnkpICogY29zKGFSb3RhdGlvbik7JyxcbiAgICAgICAgICAgICcgICB2ID0gdiArIGFQb3NpdGlvbkNvb3JkOycsXG5cbiAgICAgICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHYsIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcblxuICAgICAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gaGVsbG9cbiAgICAgICAgIFtcbiAgICAgICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVBbHBoYTsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICAgICAnICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvciAqIHVBbHBoYTsnLFxuICAgICAgICAgICAgJyAgaWYgKGNvbG9yLmEgPT0gMC4wKSBkaXNjYXJkOycsXG4gICAgICAgICAgICAnICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICB1QWxwaGE6ICB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gY3VzdG9tIGF0dHJpYnV0ZXNcbiAgICAgICAge1xuICAgICAgICAgICAgYVBvc2l0aW9uQ29vcmQ6IDAsXG4gICAgICAgICAgIC8vIGFTY2FsZTogICAgICAgICAwLFxuICAgICAgICAgICAgYVJvdGF0aW9uOiAgICAgIDBcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBURU1QIEhBQ0tcblxufVxuXG5QYXJ0aWNsZVNoYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRleHR1cmVTaGFkZXIucHJvdG90eXBlKTtcblBhcnRpY2xlU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlU2hhZGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlU2hhZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZVNoYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXkgbm93IHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIFBhcnRpY2xlQnVmZmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9QYXJ0aWNsZUJ1ZmZlci5qYXZhXG4gKi9cblxuLyoqXG4gKiBUaGUgcGFydGljbGUgYnVmZmVyIG1hbmFnZXMgdGhlIHN0YXRpYyBhbmQgZHluYW1pYyBidWZmZXJzIGZvciBhIHBhcnRpY2xlIGNvbnRhaW5lci5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZUJ1ZmZlcihnbCwgcHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpXG57XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgYSBzaW5nbGUgdmVydGV4LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVydFNpemUgPSAyO1xuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBhIHNpbmdsZSB2ZXJ0ZXggaW4gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0Qnl0ZVNpemUgPSB0aGlzLnZlcnRTaXplICogNDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgcGFydGljbGVzIHRoZSBidWZmZXIgY2FuIGhvbGRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpemUgPSBzaXplO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgdGhhdCBhcmUgc3RhdGljLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICovXG4gICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgIGlmKGR5bmFtaWNQcm9wZXJ0eUZsYWdzW2ldKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xuICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBudWxsO1xuXG4gICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuXG4gICAgdGhpcy5pbml0QnVmZmVycygpO1xuXG59XG5cblBhcnRpY2xlQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnRpY2xlQnVmZmVyO1xubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZUJ1ZmZlcjtcblxuLyoqXG4gKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUuaW5pdEJ1ZmZlcnMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGk7XG4gICAgdmFyIHByb3BlcnR5O1xuXG4gICAgdmFyIGR5bmFtaWNPZmZzZXQgPSAwO1xuICAgIHRoaXMuZHluYW1pY1N0cmlkZSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcblxuICAgICAgICBwcm9wZXJ0eS5vZmZzZXQgPSBkeW5hbWljT2Zmc2V0O1xuICAgICAgICBkeW5hbWljT2Zmc2V0ICs9IHByb3BlcnR5LnNpemU7XG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSArPSBwcm9wZXJ0eS5zaXplO1xuICAgIH1cblxuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnNpemUgKiB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0KTtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmR5bmFtaWNCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmR5bmFtaWNEYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG5cbiAgICAvLyBzdGF0aWMgLy9cbiAgICB2YXIgc3RhdGljT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG5cbiAgICAgICAgcHJvcGVydHkub2Zmc2V0ID0gc3RhdGljT2Zmc2V0O1xuICAgICAgICBzdGF0aWNPZmZzZXQgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLnNpemUgKiB0aGlzLnN0YXRpY1N0cmlkZSAqIDQpO1xuICAgIHRoaXMuc3RhdGljQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5zdGF0aWNCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnN0YXRpY0RhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XG59O1xuXG4vKipcbiAqIFVwbG9hZHMgdGhlIGR5bmFtaWMgcHJvcGVydGllcy5cbiAqXG4gKi9cblBhcnRpY2xlQnVmZmVyLnByb3RvdHlwZS51cGxvYWREeW5hbWljID0gZnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgdGhpcy5keW5hbWljRGF0YSwgdGhpcy5keW5hbWljU3RyaWRlLCBwcm9wZXJ0eS5vZmZzZXQpO1xuICAgIH1cblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmR5bmFtaWNCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLmR5bmFtaWNEYXRhKTtcbn07XG5cbi8qKlxuICogVXBsb2FkcyB0aGUgc3RhdGljIHByb3BlcnRpZXMuXG4gKlxuICovXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUudXBsb2FkU3RhdGljID0gZnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG4gICAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHRoaXMuc3RhdGljRGF0YSwgdGhpcy5zdGF0aWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XG4gICAgfVxuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuc3RhdGljQnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy5zdGF0aWNEYXRhKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIGJ1ZmZlcnMgdG8gdGhlIEdQVVxuICpcbiAqL1xuUGFydGljbGVCdWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGksIHByb3BlcnR5O1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuZHluYW1pY0J1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9wZXJ0eS5hdHRyaWJ1dGUsIHByb3BlcnR5LnNpemUsIGdsLkZMT0FULCBmYWxzZSwgdGhpcy5keW5hbWljU3RyaWRlICogNCwgcHJvcGVydHkub2Zmc2V0ICogNCk7XG4gICAgfVxuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuc3RhdGljQnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9wZXJ0eS5hdHRyaWJ1dGUsIHByb3BlcnR5LnNpemUsIGdsLkZMT0FULCBmYWxzZSwgdGhpcy5zdGF0aWNTdHJpZGUgKiA0LCBwcm9wZXJ0eS5vZmZzZXQgKiA0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBQYXJ0aWNsZUJ1ZmZlci5cbiAqXG4gKi9cblBhcnRpY2xlQnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNEYXRhID0gbnVsbDtcbiAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmR5bmFtaWNCdWZmZXIpO1xuXG4gICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuc3RhdGljQnVmZmVyKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcGFydGljbGVzL3dlYmdsL1BhcnRpY2xlQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ByaXRlID0gcmVxdWlyZSgnLi4vc3ByaXRlcy9TcHJpdGUnKSxcbiAgICBUZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvVGV4dHVyZScpLFxuICAgIG1hdGggPSByZXF1aXJlKCcuLi9tYXRoJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBBIFRleHQgT2JqZWN0IHdpbGwgY3JlYXRlIGEgbGluZSBvciBtdWx0aXBsZSBsaW5lcyBvZiB0ZXh0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicgaW4geW91ciB0ZXh0IHN0cmluZyxcbiAqIG9yIGFkZCBhIHdvcmRXcmFwIHByb3BlcnR5IHNldCB0byB0cnVlIGFuZCBhbmQgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eSB3aXRoIGEgdmFsdWUgaW4gdGhlIHN0eWxlIG9iamVjdC5cbiAqXG4gKiBBIFRleHQgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBhIHN0cmluZyBhbmQgYSBzdHlsZSBvYmplY3RcbiAqXG4gKiBgYGBqc1xuICogdmFyIHRleHQgPSBuZXcgUElYSS5UZXh0KCdUaGlzIGlzIGEgcGl4aSB0ZXh0Jyx7Zm9udCA6ICcyNHB4IEFyaWFsJywgZmlsbCA6IDB4ZmYxMDEwLCBhbGlnbiA6ICdjZW50ZXInfSk7XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuU3ByaXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHRleHQge3N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKiBAcGFyYW0gW3N0eWxlXSB7b2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xuICogQHBhcmFtIFtzdHlsZS5mb250XSB7c3RyaW5nfSBkZWZhdWx0ICdib2xkIDIwcHggQXJpYWwnIFRoZSBzdHlsZSBhbmQgc2l6ZSBvZiB0aGUgZm9udFxuICogQHBhcmFtIFtzdHlsZS5maWxsPSdibGFjayddIHtTdHJpbmd8TnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nICdyZWQnLCAnIzAwRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuYWxpZ249J2xlZnQnXSB7c3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICogQHBhcmFtIFtzdHlsZS5zdHJva2VdIHtTdHJpbmd8TnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlIGUuZyAnYmx1ZScsICcjRkNGRjAwJ1xuICogQHBhcmFtIFtzdHlsZS5zdHJva2VUaGlja25lc3M9MF0ge251bWJlcn0gQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS4gRGVmYXVsdCBpcyAwIChubyBzdHJva2UpXG4gKiBAcGFyYW0gW3N0eWxlLndvcmRXcmFwPWZhbHNlXSB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZFxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcFdpZHRoPTEwMF0ge251bWJlcn0gVGhlIHdpZHRoIGF0IHdoaWNoIHRleHQgd2lsbCB3cmFwLCBpdCBuZWVkcyB3b3JkV3JhcCB0byBiZSBzZXQgdG8gdHJ1ZVxuICogQHBhcmFtIFtzdHlsZS5sZXR0ZXJTcGFjaW5nPTBdIHtudW1iZXJ9IFRoZSBhbW91bnQgb2Ygc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMsIGRlZmF1bHQgaXMgMFxuICogQHBhcmFtIFtzdHlsZS5icmVha1dvcmRzPWZhbHNlXSB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIGxpbmVzIGNhbiBiZSB3cmFwcGVkIHdpdGhpbiB3b3JkcywgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSBbc3R5bGUubGluZUhlaWdodF0ge251bWJlcn0gVGhlIGxpbmUgaGVpZ2h0LCBhIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsIHNwYWNlIHRoYXQgYSBsZXR0ZXIgdXNlc1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93PWZhbHNlXSB7Ym9vbGVhbn0gU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dDb2xvcj0nIzAwMDAwMCddIHtzdHJpbmd9IEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dBbmdsZT1NYXRoLlBJLzRdIHtudW1iZXJ9IFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge251bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dCbHVyPTBdIHtudW1iZXJ9IFNldCBhIHNoYWRvdyBibHVyIHJhZGl1c1xuICogQHBhcmFtIFtzdHlsZS5wYWRkaW5nPTBdIHtudW1iZXJ9IE9jY2FzaW9uYWxseSBzb21lIGZvbnRzIGFyZSBjcm9wcGVkIG9uIHRvcCBvciBib3R0b20uIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbFxuICogICAgICBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcgYnkgYWRkaW5nIHBhZGRpbmcgdG8gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRleHQgaGVpZ2h0LlxuICogQHBhcmFtIFtzdHlsZS50ZXh0QmFzZWxpbmU9J2FscGhhYmV0aWMnXSB7c3RyaW5nfSBUaGUgYmFzZWxpbmUgb2YgdGhlIHRleHQgdGhhdCBpcyByZW5kZXJlZC5cbiAqIEBwYXJhbSBbc3R5bGUubGluZUpvaW49J21pdGVyJ10ge3N0cmluZ30gVGhlIGxpbmVKb2luIHByb3BlcnR5IHNldHMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIGl0IGNhbiByZXNvbHZlXG4gKiAgICAgIHNwaWtlZCB0ZXh0IGlzc3Vlcy4gRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cbiAqIEBwYXJhbSBbc3R5bGUubWl0ZXJMaW1pdD0xMF0ge251bWJlcn0gVGhlIG1pdGVyIGxpbWl0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnbWl0ZXInIGxpbmVKb2luIG1vZGUuIFRoaXMgY2FuIHJlZHVjZVxuICogICAgICBvciBpbmNyZWFzZSB0aGUgc3Bpa2luZXNzIG9mIHJlbmRlcmVkIHRleHQuXG4gKi9cbmZ1bmN0aW9uIFRleHQodGV4dCwgc3R5bGUsIHJlc29sdXRpb24pXG57XG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0b1xuICAgICAqXG4gICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aFxuICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IENPTlNULlJFU09MVVRJT047XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IHRleHQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZXh0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG5cbiAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmUuZnJvbUNhbnZhcyh0aGlzLmNhbnZhcyk7XG4gICAgdGV4dHVyZS50cmltID0gbmV3IG1hdGguUmVjdGFuZ2xlKCk7XG4gICAgU3ByaXRlLmNhbGwodGhpcywgdGV4dHVyZSk7XG5cbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbn1cblxuLy8gY29uc3RydWN0b3JcblRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTcHJpdGUucHJvdG90eXBlKTtcblRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcblxuVGV4dC5mb250UHJvcGVydGllc0NhY2hlID0ge307XG5UZXh0LmZvbnRQcm9wZXJ0aWVzQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5UZXh0LmZvbnRQcm9wZXJ0aWVzQ29udGV4dCA9IFRleHQuZm9udFByb3BlcnRpZXNDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dC5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuVGV4dCNcbiAgICAgKi9cbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy5fdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHRoaXMuX3RleHR1cmUuX2ZyYW1lLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLlRleHQjXG4gICAgICovXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5zY2FsZS55ICogdGhpcy5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gdmFsdWUgLyB0aGlzLl90ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0eWxlIG9mIHRoZSB0ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gW3N0eWxlXSB7b2JqZWN0fSBUaGUgc3R5bGUgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBbc3R5bGUuZm9udD0nYm9sZCAyMHB0IEFyaWFsJ10ge3N0cmluZ30gVGhlIHN0eWxlIGFuZCBzaXplIG9mIHRoZSBmb250XG4gICAgICogQHBhcmFtIFtzdHlsZS5maWxsPSdibGFjayddIHtzdHJpbmd8bnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZWcgJ3JlZCcsICcjMDBGRjAwJ1xuICAgICAqIEBwYXJhbSBbc3R5bGUuYWxpZ249J2xlZnQnXSB7c3RyaW5nfSBBbGlnbm1lbnQgZm9yIG11bHRpbGluZSB0ZXh0ICgnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCcpLCBkb2VzIG5vdCBhZmZlY3Qgc2luZ2xlIGxpbmUgdGV4dFxuICAgICAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlPSdibGFjayddIHtzdHJpbmd8bnVtYmVyfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlIGVnICdibHVlJywgJyNGQ0ZGMDAnXG4gICAgICogQHBhcmFtIFtzdHlsZS5zdHJva2VUaGlja25lc3M9MF0ge251bWJlcn0gQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS4gRGVmYXVsdCBpcyAwIChubyBzdHJva2UpXG4gICAgICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcD1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcbiAgICAgKiBAcGFyYW0gW3N0eWxlLndvcmRXcmFwV2lkdGg9MTAwXSB7bnVtYmVyfSBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXBcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmxpbmVIZWlnaHRdIHtudW1iZXJ9IFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3c9ZmFsc2VdIHtib29sZWFufSBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dDb2xvcj0nIzAwMDAwMCddIHtzdHJpbmd8bnVtYmVyfSBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICAgICAqIEBwYXJhbSBbc3R5bGUuZHJvcFNoYWRvd0FuZ2xlPU1hdGguUEkvNl0ge251bWJlcn0gU2V0IGEgYW5nbGUgb2YgdGhlIGRyb3Agc2hhZG93XG4gICAgICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge251bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gICAgICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93Qmx1cj0wXSB7bnVtYmVyfSBTZXQgYSBzaGFkb3cgYmx1ciByYWRpdXNcbiAgICAgKiBAcGFyYW0gW3N0eWxlLnBhZGRpbmc9MF0ge251bWJlcn0gT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQgb24gdG9wIG9yIGJvdHRvbS4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsXG4gICAgICogICAgICBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcgYnkgYWRkaW5nIHBhZGRpbmcgdG8gdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRleHQgaGVpZ2h0LlxuICAgICAqIEBwYXJhbSBbc3R5bGUudGV4dEJhc2VsaW5lPSdhbHBoYWJldGljJ10ge3N0cmluZ30gVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIFtzdHlsZS5saW5lSm9pbj0nbWl0ZXInXSB7c3RyaW5nfSBUaGUgbGluZUpvaW4gcHJvcGVydHkgc2V0cyB0aGUgdHlwZSBvZiBjb3JuZXIgY3JlYXRlZCwgaXQgY2FuIHJlc29sdmVcbiAgICAgKiAgICAgIHNwaWtlZCB0ZXh0IGlzc3Vlcy4gRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cbiAgICAgKiBAcGFyYW0gW3N0eWxlLm1pdGVyTGltaXQ9MTBdIHtudW1iZXJ9IFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlLiBUaGlzIGNhbiByZWR1Y2VcbiAgICAgKiAgICAgIG9yIGluY3JlYXNlIHRoZSBzcGlraW5lc3Mgb2YgcmVuZGVyZWQgdGV4dC5cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5UZXh0I1xuICAgICAqL1xuICAgIHN0eWxlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzdHlsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5maWxsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmZpbGwgPSB1dGlscy5oZXgyc3RyaW5nKHN0eWxlLmZpbGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLnN0cm9rZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zdHJva2UgPSB1dGlscy5oZXgyc3RyaW5nKHN0eWxlLnN0cm9rZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZHJvcFNoYWRvd0NvbG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmRyb3BTaGFkb3dDb2xvciA9IHV0aWxzLmhleDJzdHJpbmcoc3R5bGUuZHJvcFNoYWRvd0NvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGUuZm9udCA9IHN0eWxlLmZvbnQgfHwgJ2JvbGQgMjBwdCBBcmlhbCc7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gc3R5bGUuZmlsbCB8fCAnYmxhY2snO1xuICAgICAgICAgICAgc3R5bGUuYWxpZ24gPSBzdHlsZS5hbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICBzdHlsZS5zdHJva2UgPSBzdHlsZS5zdHJva2UgfHwgJ2JsYWNrJzsgLy9wcm92aWRlIGEgZGVmYXVsdCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMvaXNzdWVzLzEzNlxuICAgICAgICAgICAgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIHx8IDA7XG4gICAgICAgICAgICBzdHlsZS53b3JkV3JhcCA9IHN0eWxlLndvcmRXcmFwIHx8IGZhbHNlO1xuICAgICAgICAgICAgc3R5bGUud29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggfHwgMTAwO1xuICAgICAgICAgICAgc3R5bGUuYnJlYWtXb3JkcyA9IHN0eWxlLmJyZWFrV29yZHMgfHwgZmFsc2U7XG4gICAgICAgICAgICBzdHlsZS5sZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZyB8fCAwO1xuXG4gICAgICAgICAgICBzdHlsZS5kcm9wU2hhZG93ID0gc3R5bGUuZHJvcFNoYWRvdyB8fCBmYWxzZTtcbiAgICAgICAgICAgIHN0eWxlLmRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvciB8fCAnIzAwMDAwMCc7XG4gICAgICAgICAgICBzdHlsZS5kcm9wU2hhZG93QW5nbGUgPSBzdHlsZS5kcm9wU2hhZG93QW5nbGUgIT09IHVuZGVmaW5lZCA/IHN0eWxlLmRyb3BTaGFkb3dBbmdsZSA6IE1hdGguUEkgLyA2O1xuICAgICAgICAgICAgc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlID0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlICE9PSB1bmRlZmluZWQgPyBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgOiA1O1xuICAgICAgICAgICAgc3R5bGUuZHJvcFNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1ciAhPT0gdW5kZWZpbmVkID8gc3R5bGUuZHJvcFNoYWRvd0JsdXIgOiAwOyAvL3NoYWRvd0JsdXIgaXMgJzAnIGJ5IGRlZmF1bHQgYWNjb3JkaW5nIHRvIEhUTUxcblxuICAgICAgICAgICAgc3R5bGUucGFkZGluZyA9IHN0eWxlLnBhZGRpbmcgfHwgMDtcblxuICAgICAgICAgICAgc3R5bGUudGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lIHx8ICdhbHBoYWJldGljJztcblxuICAgICAgICAgICAgc3R5bGUubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbiB8fCAnbWl0ZXInO1xuICAgICAgICAgICAgc3R5bGUubWl0ZXJMaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQgfHwgMTA7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvcHkgZm9yIHRoZSB0ZXh0IG9iamVjdC4gVG8gc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHQge3N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gICAgICogQG1lbWJlcm9mIFBJWEkuVGV4dCNcbiAgICAgKi9cbiAgICB0ZXh0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodGV4dCl7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b1N0cmluZygpIHx8ICcgJztcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcbiAgICB0aGlzLmNvbnRleHQuZm9udCA9IHN0eWxlLmZvbnQ7XG5cbiAgICAvLyB3b3JkIHdyYXBcbiAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB0ZXh0XG4gICAgdmFyIG91dHB1dFRleHQgPSBzdHlsZS53b3JkV3JhcCA/IHRoaXMud29yZFdyYXAodGhpcy5fdGV4dCkgOiB0aGlzLl90ZXh0O1xuXG4gICAgLy8gc3BsaXQgdGV4dCBpbnRvIGxpbmVzXG4gICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGV4dCB3aWR0aFxuICAgIHZhciBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XG4gICAgdmFyIGZvbnRQcm9wZXJ0aWVzID0gdGhpcy5kZXRlcm1pbmVGb250UHJvcGVydGllcyhzdHlsZS5mb250KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGggKyAoKGxpbmVzW2ldLmxlbmd0aCAtIDEpICogc3R5bGUubGV0dGVyU3BhY2luZyk7XG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBtYXhMaW5lV2lkdGggKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpXG4gICAge1xuICAgICAgICB3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwoICggd2lkdGggKyB0aGlzLmNvbnRleHQubGluZVdpZHRoICkgKiB0aGlzLnJlc29sdXRpb24gKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0ZXh0IGhlaWdodFxuICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5zdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuXG4gICAgdmFyIGhlaWdodCA9IGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGg7XG4gICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpXG4gICAge1xuICAgICAgICBoZWlnaHQgKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbCggKCBoZWlnaHQgKyB0aGlzLl9zdHlsZS5wYWRkaW5nICogMiApICogdGhpcy5yZXNvbHV0aW9uICk7XG5cbiAgICB0aGlzLmNvbnRleHQuc2NhbGUoIHRoaXMucmVzb2x1dGlvbiwgdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgIGlmIChuYXZpZ2F0b3IuaXNDb2Nvb25KUylcbiAgICB7XG4gICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG5cbiAgICB9XG5cbiAgICAvL3RoaXMuY29udGV4dC5maWxsU3R5bGU9XCIjRkYwMDAwXCI7XG4gICAgLy90aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG5cbiAgICB0aGlzLmNvbnRleHQuZm9udCA9IHN0eWxlLmZvbnQ7XG4gICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHRoaXMuY29udGV4dC5saW5lV2lkdGggPSBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgdGhpcy5jb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICB0aGlzLmNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbjtcbiAgICB0aGlzLmNvbnRleHQubWl0ZXJMaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQ7XG5cbiAgICB2YXIgbGluZVBvc2l0aW9uWDtcbiAgICB2YXIgbGluZVBvc2l0aW9uWTtcblxuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KVxuICAgIHtcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3dCbHVyID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNoYWRvd0NvbG9yID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeFNoYWRvd09mZnNldCA9IE1hdGguY29zKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgIHZhciB5U2hhZG93T2Zmc2V0ID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9IChzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaSAqIGxpbmVIZWlnaHQpICsgZm9udFByb3BlcnRpZXMuYXNjZW50O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09ICdjZW50ZXInKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlLmZpbGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHhTaGFkb3dPZmZzZXQsIGxpbmVQb3NpdGlvblkgKyB5U2hhZG93T2Zmc2V0ICsgc3R5bGUucGFkZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL3NldCBjYW52YXMgdGV4dCBzdHlsZXNcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcblxuICAgIC8vZHJhdyBsaW5lcyBsaW5lIGJ5IGxpbmVcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IChzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaSAqIGxpbmVIZWlnaHQpICsgZm9udFByb3BlcnRpZXMuYXNjZW50O1xuXG4gICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJylcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHlsZS5zdHJva2VUaGlja25lc3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbaV0sIGxpbmVQb3NpdGlvblgsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZS5maWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKGxpbmVzW2ldLCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbn07XG5cbi8qKlxuICogUmVuZGVyIHRoZSB0ZXh0IHdpdGggbGV0dGVyLXNwYWNpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGV4dC5wcm90b3R5cGUuZHJhd0xldHRlclNwYWNpbmcgPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBpc1N0cm9rZSlcbntcbiAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblxuICAgIC8vIGxldHRlclNwYWNpbmcgb2YgMCBtZWFucyBub3JtYWxcbiAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XG5cbiAgICBpZiAobGV0dGVyU3BhY2luZyA9PT0gMClcbiAgICB7XG4gICAgICAgIGlmIChpc1N0cm9rZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQodGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGFyYWN0ZXJzID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdC5jYWxsKHRleHQsICcnKSxcbiAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBjdXJyZW50UG9zaXRpb24gPSB4O1xuXG4gICAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpXG4gICAge1xuICAgICAgICBjdXJyZW50ID0gY2hhcmFjdGVyc1tpbmRleCsrXTtcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQoY3VycmVudCwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChjdXJyZW50LCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoY3VycmVudCkud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0ZXh0dXJlIHNpemUgYmFzZWQgb24gY2FudmFzIHNpemVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRleHR1cmUuY3JvcC53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGV4dHVyZS5jcm9wLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcblxuICAgIHRleHR1cmUudHJpbS54ID0gMDtcbiAgICB0ZXh0dXJlLnRyaW0ueSA9IC1zdHlsZS5wYWRkaW5nO1xuXG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgdGV4dHVyZS50cmltLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAtIHN0eWxlLnBhZGRpbmcqMjtcblxuICAgIHRoaXMuX3dpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5lbWl0KCd1cGRhdGUnLCAgdGV4dHVyZS5iYXNlVGV4dHVyZSk7XG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn1cbiAqL1xuVGV4dC5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgaWYgKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICAvL3RoaXMucmVzb2x1dGlvbiA9IDEvL3JlbmRlcmVyLnJlc29sdXRpb247XG5cbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgfVxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5yZW5kZXJXZWJHTC5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0LnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIGlmICh0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgLy8gICB0aGlzLnJlc29sdXRpb24gPSAxLy9yZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgIH1cblxuICAgIFNwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcy5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYXNjZW50LCBkZXNjZW50IGFuZCBmb250U2l6ZSBvZiBhIGdpdmVuIGZvbnRTdHlsZVxuICpcbiAqIEBwYXJhbSBmb250U3R5bGUge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblRleHQucHJvdG90eXBlLmRldGVybWluZUZvbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGZvbnRTdHlsZSlcbntcbiAgICB2YXIgcHJvcGVydGllcyA9IFRleHQuZm9udFByb3BlcnRpZXNDYWNoZVtmb250U3R5bGVdO1xuXG4gICAgaWYgKCFwcm9wZXJ0aWVzKVxuICAgIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FudmFzO1xuICAgICAgICB2YXIgY29udGV4dCA9IFRleHQuZm9udFByb3BlcnRpZXNDb250ZXh0O1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHlsZTtcblxuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dCgnfE3DiXEnKS53aWR0aCk7XG4gICAgICAgIHZhciBiYXNlbGluZSA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KCdNJykud2lkdGgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMiAqIGJhc2VsaW5lO1xuXG4gICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgKiAxLjQgfCAwO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmMDAnO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHlsZTtcblxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoJ3xNw4lxJywgMCwgYmFzZWxpbmUpO1xuXG4gICAgICAgIHZhciBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmUgPSB3aWR0aCAqIDQ7XG5cbiAgICAgICAgdmFyIGksIGo7XG5cbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBzdG9wID0gZmFsc2U7XG5cbiAgICAgICAgLy8gYXNjZW50LiBzY2FuIGZyb20gdG9wIHRvIGJvdHRvbSB1bnRpbCB3ZSBmaW5kIGEgbm9uIHJlZCBwaXhlbFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZWxpbmU7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpbmU7IGogKz0gNClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdG9wKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkeCArPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5hc2NlbnQgPSBiYXNlbGluZSAtIGk7XG5cbiAgICAgICAgaWR4ID0gcGl4ZWxzIC0gbGluZTtcbiAgICAgICAgc3RvcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGRlc2NlbnQuIHNjYW4gZnJvbSBib3R0b20gdG8gdG9wIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXG4gICAgICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyBpLS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZHggLT0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BlcnRpZXMuZGVzY2VudCA9IGkgLSBiYXNlbGluZTtcbiAgICAgICAgcHJvcGVydGllcy5mb250U2l6ZSA9IHByb3BlcnRpZXMuYXNjZW50ICsgcHJvcGVydGllcy5kZXNjZW50O1xuXG4gICAgICAgIFRleHQuZm9udFByb3BlcnRpZXNDYWNoZVtmb250U3R5bGVdID0gcHJvcGVydGllcztcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydGllcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBuZXdsaW5lcyB0byBhIHN0cmluZyB0byBoYXZlIGl0IG9wdGltYWxseSBmaXQgaW50byB0aGUgaG9yaXpvbnRhbFxuICogYm91bmRzIHNldCBieSB0aGUgVGV4dCBvYmplY3QncyB3b3JkV3JhcFdpZHRoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB0ZXh0IHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0LnByb3RvdHlwZS53b3JkV3JhcCA9IGZ1bmN0aW9uICh0ZXh0KVxue1xuICAgIC8vIEdyZWVkeSB3cmFwcGluZyBhbGdvcml0aG0gdGhhdCB3aWxsIHdyYXAgd29yZHMgYXMgdGhlIGxpbmUgZ3Jvd3MgbG9uZ2VyXG4gICAgLy8gdGhhbiBpdHMgaG9yaXpvbnRhbCBib3VuZHMuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIHZhciB3b3JkV3JhcFdpZHRoID0gdGhpcy5fc3R5bGUud29yZFdyYXBXaWR0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHNwYWNlTGVmdCA9IHdvcmRXcmFwV2lkdGg7XG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmVzW2ldLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd29yZHMubGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3b3JkV2lkdGggPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQod29yZHNbal0pLndpZHRoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlLmJyZWFrV29yZHMgJiYgd29yZFdpZHRoID4gd29yZFdyYXBXaWR0aCkgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gV29yZCBzaG91bGQgYmUgc3BsaXQgaW4gdGhlIG1pZGRsZVxuICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gd29yZHNbal0uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hhcmFjdGVycy5sZW5ndGg7IGMrKykgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcldpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcnNbY10pLndpZHRoO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3RlcldpZHRoID4gc3BhY2VMZWZ0KSBcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nICsgY2hhcmFjdGVyc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VMZWZ0ID0gd29yZFdyYXBXaWR0aCAtIGNoYXJhY3RlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAwKSBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnNbY107XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlTGVmdCAtPSBjaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB3b3JkV2lkdGhXaXRoU3BhY2UgPSB3b3JkV2lkdGggKyB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoJyAnKS53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCB8fCB3b3JkV2lkdGhXaXRoU3BhY2UgPiBzcGFjZUxlZnQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHByaW50aW5nIHRoZSBuZXdsaW5lIGlmIGl0J3MgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGxpbmUgdGhhdCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBncmVhdGVyIHRoYW4gdGhlIHdvcmQgd3JhcCB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPiAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdvcmRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZUxlZnQgPSB3b3JkV3JhcFdpZHRoIC0gd29yZFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzcGFjZUxlZnQgLT0gd29yZFdpZHRoV2l0aFNwYWNlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnICsgd29yZHNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGgtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgVGV4dCBhcyBhIHJlY3RhbmdsZS4gVGhlIGJvdW5kcyBjYWxjdWxhdGlvbiB0YWtlcyB0aGUgd29ybGRUcmFuc2Zvcm0gaW50byBhY2NvdW50LlxuICpcbiAqIEBwYXJhbSBtYXRyaXgge1BJWEkuTWF0cml4fSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBUZXh0XG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gKi9cblRleHQucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChtYXRyaXgpXG57XG4gICAgaWYgKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3ByaXRlLnByb3RvdHlwZS5nZXRCb3VuZHMuY2FsbCh0aGlzLCBtYXRyaXgpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHRleHQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBbZGVzdHJveUJhc2VUZXh0dXJlPXRydWVdIHtib29sZWFufSB3aGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gKi9cblRleHQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZGVzdHJveUJhc2VUZXh0dXJlKVxue1xuICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCB0aGUgdGhlIGNvbnRleHQgYW5kIGNhbnZhcy4uIGRvbnQgd2FudCB0aGlzIGhhbmdpbmcgYXJvdW5kIGluIG1lbW9yeSFcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcblxuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcblxuICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveShkZXN0cm95QmFzZVRleHR1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBkZXN0cm95QmFzZVRleHR1cmUpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS90ZXh0L1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDb250YWluZXIgPSByZXF1aXJlKCcuLi9kaXNwbGF5L0NvbnRhaW5lcicpLFxuICAgIFRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9UZXh0dXJlJyksXG4gICAgQ2FudmFzQnVmZmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNCdWZmZXInKSxcbiAgICBDYW52YXNHcmFwaGljcyA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzR3JhcGhpY3MnKSxcbiAgICBHcmFwaGljc0RhdGEgPSByZXF1aXJlKCcuL0dyYXBoaWNzRGF0YScpLFxuICAgIG1hdGggPSByZXF1aXJlKCcuLi9tYXRoJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHRlbXBQb2ludCA9IG5ldyBtYXRoLlBvaW50KCk7XG5cbi8qKlxuICogVGhlIEdyYXBoaWNzIGNsYXNzIGNvbnRhaW5zIG1ldGhvZHMgdXNlZCB0byBkcmF3IHByaW1pdGl2ZSBzaGFwZXMgc3VjaCBhcyBsaW5lcywgY2lyY2xlcyBhbmRcbiAqIHJlY3RhbmdsZXMgdG8gdGhlIGRpc3BsYXksIGFuZCB0byBjb2xvciBhbmQgZmlsbCB0aGVtLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmZ1bmN0aW9uIEdyYXBoaWNzKClcbntcbiAgICBDb250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbHBoYSB2YWx1ZSB1c2VkIHdoZW4gZmlsbGluZyB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggKHRoaWNrbmVzcykgb2YgYW55IGxpbmVzIGRyYXduLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3Igb2YgYW55IGxpbmVzIGRyYXduLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVDb2xvciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBHcmFwaGljcyBkYXRhXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzRGF0YVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEFwcGx5IGEgdmFsdWUgb2YgMHhGRkZGRkYgdG8gcmVzZXQgdGhlIHRpbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFVzZWQgdG8gY29tcGFyZSB0byB0aGUgY3VycmVudCB0aW50IGFuZCBjaGVjayBpZiB0aGVyZXMgY2hhbmdlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLl9wcmV2VGludCA9IDB4RkZGRkZGO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZS4gQXBwbHkgYSB2YWx1ZSBvZiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlID0gQ09OU1QuQkxFTkRfTU9ERVMuTk9STUFMO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBwYXRoXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzRGF0YX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgY29udGFpbmluZyBzb21lIFdlYkdMLXJlbGF0ZWQgcHJvcGVydGllcyB1c2VkIGJ5IHRoZSBXZWJHTCByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIG9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvLyBUT0RPIC0gX3dlYmdsIHNob3VsZCB1c2UgYSBwcm90b3R5cGUgb2JqZWN0LCBub3QgYSByYW5kb20gdW5kb2N1bWVudGVkIG9iamVjdC4uLlxuICAgIHRoaXMuX3dlYkdMID0ge307XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2hhcGUgaXMgYmVpbmcgdXNlZCBhcyBhIG1hc2suXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNNYXNrID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRzJyBwYWRkaW5nIHVzZWQgZm9yIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kc1BhZGRpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiB0aGUgbG9jYWwgYm91bmRzIHRvIHByZXZlbnQgcmVjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgbWF0aC5SZWN0YW5nbGUoMCwwLDEsMSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGRldGVjdCBpZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0IGhhcyBjaGFuZ2VkLiBJZiB0aGlzIGlzIHNldCB0byB0cnVlIHRoZW4gdGhlIGdyYXBoaWNzXG4gICAgICogb2JqZWN0IHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIFdlYkdMIGdyYXBoaWNzIG9iamVjdCBoYXMgY2hhbmdlZC4gSWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSB0aGVuIHRoZVxuICAgICAqIGdyYXBoaWNzIG9iamVjdCB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdsRGlydHkgPSBmYWxzZTtcblxuICAgIHRoaXMuYm91bmRzRGlydHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIGNhY2hlZCBzcHJpdGUgb2JqZWN0IG5lZWRzIHRvIGJlIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBjYWNoZUFzQml0bWFwIGlzIHNldCB0byB0cnVlIHRoZSBncmFwaGljcyBvYmplY3Qgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiBpdCB3YXMgYSBzcHJpdGUuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91ciBncmFwaGljcyBlbGVtZW50IGRvZXMgbm90IGNoYW5nZSBvZnRlbiwgYXMgaXQgd2lsbCBzcGVlZCB1cCB0aGUgcmVuZGVyaW5nXG4gICAgICogb2YgdGhlIG9iamVjdCBpbiBleGNoYW5nZSBmb3IgdGFraW5nIHVwIHRleHR1cmUgbWVtb3J5LiBJdCBpcyBhbHNvIHVzZWZ1bCBpZiB5b3UgbmVlZCB0aGUgZ3JhcGhpY3NcbiAgICAgKiBvYmplY3QgdG8gYmUgYW50aS1hbGlhc2VkLCBiZWNhdXNlIGl0IHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgY2FudmFzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCBpZlxuICAgICAqIHlvdSBhcmUgY29uc3RhbnRseSByZWRyYXdpbmcgdGhlIGdyYXBoaWNzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjYWNoZUFzQml0bWFwXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5HcmFwaGljcyNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuR3JhcGhpY3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb250YWluZXIucHJvdG90eXBlKTtcbkdyYXBoaWNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyYXBoaWNzO1xubW9kdWxlLmV4cG9ydHMgPSBHcmFwaGljcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAqIE5vdGUgdGhhdCB0aGUgb25seSB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGFyZSBjbG9uZWQsIG5vdCBpdHMgdHJhbnNmb3JtIChwb3NpdGlvbixzY2FsZSxldGMpXG4gKlxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgY2xvbmUgPSBuZXcgR3JhcGhpY3MoKTtcblxuICAgIGNsb25lLnJlbmRlcmFibGUgICAgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgY2xvbmUuZmlsbEFscGhhICAgICA9IHRoaXMuZmlsbEFscGhhO1xuICAgIGNsb25lLmxpbmVXaWR0aCAgICAgPSB0aGlzLmxpbmVXaWR0aDtcbiAgICBjbG9uZS5saW5lQ29sb3IgICAgID0gdGhpcy5saW5lQ29sb3I7XG4gICAgY2xvbmUudGludCAgICAgICAgICA9IHRoaXMudGludDtcbiAgICBjbG9uZS5ibGVuZE1vZGUgICAgID0gdGhpcy5ibGVuZE1vZGU7XG4gICAgY2xvbmUuaXNNYXNrICAgICAgICA9IHRoaXMuaXNNYXNrO1xuICAgIGNsb25lLmJvdW5kc1BhZGRpbmcgPSB0aGlzLmJvdW5kc1BhZGRpbmc7XG4gICAgY2xvbmUuZGlydHkgICAgICAgICA9IHRydWU7XG4gICAgY2xvbmUuZ2xEaXJ0eSAgICAgICA9IHRydWU7XG4gICAgY2xvbmUuY2FjaGVkU3ByaXRlRGlydHkgPSB0aGlzLmNhY2hlZFNwcml0ZURpcnR5O1xuXG4gICAgLy8gY29weSBncmFwaGljcyBkYXRhXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIGNsb25lLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmNsb25lKCkpO1xuICAgIH1cblxuICAgIGNsb25lLmN1cnJlbnRQYXRoID0gY2xvbmUuZ3JhcGhpY3NEYXRhW2Nsb25lLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcblxuICAgIGNsb25lLnVwZGF0ZUxvY2FsQm91bmRzKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbGluZSBzdHlsZSB1c2VkIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIEdyYXBoaWNzIG1ldGhvZHMgc3VjaCBhcyB0aGUgbGluZVRvKCkgbWV0aG9kIG9yIHRoZSBkcmF3Q2lyY2xlKCkgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBsaW5lV2lkdGgge251bWJlcn0gd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gKiBAcGFyYW0gY29sb3Ige251bWJlcn0gY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gKiBAcGFyYW0gYWxwaGEge251bWJlcn0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUubGluZVN0eWxlID0gZnVuY3Rpb24gKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhKVxue1xuICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDA7XG4gICAgdGhpcy5saW5lQ29sb3IgPSBjb2xvciB8fCAwO1xuICAgIHRoaXMubGluZUFscGhhID0gKGFscGhhID09PSB1bmRlZmluZWQpID8gMSA6IGFscGhhO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBoYWxmd2F5IHRocm91Z2ggYSBsaW5lPyBzdGFydCBhIG5ldyBvbmUhXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBuZXcgbWF0aC5Qb2x5Z29uKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICBzaGFwZS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NoYXBlKHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpdHMgZW1wdHkgc28gbGV0cyBqdXN0IHNldCB0aGUgbGluZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5saW5lQ29sb3IgPSB0aGlzLmxpbmVDb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgubGluZUFscGhhID0gdGhpcy5saW5lQWxwaGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTW92ZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byB4LCB5LlxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IHRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICogQHBhcmFtIHkge251bWJlcn0gdGhlIFkgY29vcmRpbmF0ZSB0byBtb3ZlIHRvXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICAqL1xuR3JhcGhpY3MucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KVxue1xuICAgIHZhciBzaGFwZSA9IG5ldyBtYXRoLlBvbHlnb24oW3gseV0pO1xuICAgIHNoYXBlLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhd1NoYXBlKHNoYXBlKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhIGxpbmUgdXNpbmcgdGhlIGN1cnJlbnQgbGluZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8gKHgsIHkpO1xuICogVGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiBpcyB0aGVuIHNldCB0byAoeCwgeSkuXG4gKlxuICogQHBhcmFtIHgge251bWJlcn0gdGhlIFggY29vcmRpbmF0ZSB0byBkcmF3IHRvXG4gKiBAcGFyYW0geSB7bnVtYmVyfSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXG4gKlxuICogQHBhcmFtIGNwWCB7bnVtYmVyfSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSBjcFkge251bWJlcn0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gdG9YIHtudW1iZXJ9IERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSB0b1kge251bWJlcn0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiAoY3BYLCBjcFksIHRvWCwgdG9ZKVxue1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMgPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oMCwwKTtcbiAgICB9XG5cbiAgICB2YXIgeGEsXG4gICAgICAgIHlhLFxuICAgICAgICBuID0gMjAsXG4gICAgICAgIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXTtcbiAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXTtcblxuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpXG4gICAge1xuICAgICAgICBqID0gaSAvIG47XG5cbiAgICAgICAgeGEgPSBmcm9tWCArICggKGNwWCAtIGZyb21YKSAqIGogKTtcbiAgICAgICAgeWEgPSBmcm9tWSArICggKGNwWSAtIGZyb21ZKSAqIGogKTtcblxuICAgICAgICBwb2ludHMucHVzaCggeGEgKyAoICgoY3BYICsgKCAodG9YIC0gY3BYKSAqIGogKSkgLSB4YSkgKiBqICksXG4gICAgICAgICAgICAgICAgICAgICB5YSArICggKChjcFkgKyAoICh0b1kgLSBjcFkpICogaiApKSAtIHlhKSAqIGogKSApO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0aGlzLmJvdW5kc0RpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gKlxuICogQHBhcmFtIGNwWCB7bnVtYmVyfSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSBjcFkge251bWJlcn0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gY3BYMiB7bnVtYmVyfSBTZWNvbmQgQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0gY3BZMiB7bnVtYmVyfSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gdG9YIHtudW1iZXJ9IERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSB0b1kge251bWJlcn0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKVxue1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMgPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oMCwwKTtcbiAgICB9XG5cbiAgICB2YXIgbiA9IDIwLFxuICAgICAgICBkdCxcbiAgICAgICAgZHQyLFxuICAgICAgICBkdDMsXG4gICAgICAgIHQyLFxuICAgICAgICB0MyxcbiAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHM7XG5cbiAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0yXTtcbiAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXTtcblxuICAgIHZhciBqID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSlcbiAgICB7XG4gICAgICAgIGogPSBpIC8gbjtcblxuICAgICAgICBkdCA9ICgxIC0gaik7XG4gICAgICAgIGR0MiA9IGR0ICogZHQ7XG4gICAgICAgIGR0MyA9IGR0MiAqIGR0O1xuXG4gICAgICAgIHQyID0gaiAqIGo7XG4gICAgICAgIHQzID0gdDIgKiBqO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCBkdDMgKiBmcm9tWCArIDMgKiBkdDIgKiBqICogY3BYICsgMyAqIGR0ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsXG4gICAgICAgICAgICAgICAgICAgICBkdDMgKiBmcm9tWSArIDMgKiBkdDIgKiBqICogY3BZICsgMyAqIGR0ICogdDIgKiBjcFkyICsgdDMgKiB0b1kpO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0aGlzLmJvdW5kc0RpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgYXJjVG8oKSBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgYmV0d2VlbiB0d28gdGFuZ2VudHMgb24gdGhlIGNhbnZhcy5cbiAqXG4gKiBcImJvcnJvd2VkXCIgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Z4Y2FudmFzLyAtIHRoYW5rcyBnb29nbGUhXG4gKlxuICogQHBhcmFtIHgxIHtudW1iZXJ9IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJjXG4gKiBAcGFyYW0geTEge251bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcbiAqIEBwYXJhbSB4MiB7bnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xuICogQHBhcmFtIHkyIHtudW1iZXJ9IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXG4gKiBAcGFyYW0gcmFkaXVzIHtudW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGFyY1xuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmFyY1RvID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpXG57XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHgxLCB5MSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oeDEsIHkxKTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMsXG4gICAgICAgIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl0sXG4gICAgICAgIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV0sXG4gICAgICAgIGExID0gZnJvbVkgLSB5MSxcbiAgICAgICAgYjEgPSBmcm9tWCAtIHgxLFxuICAgICAgICBhMiA9IHkyICAgLSB5MSxcbiAgICAgICAgYjIgPSB4MiAgIC0geDEsXG4gICAgICAgIG1tID0gTWF0aC5hYnMoYTEgKiBiMiAtIGIxICogYTIpO1xuXG4gICAgaWYgKG1tIDwgMS4wZS04IHx8IHJhZGl1cyA9PT0gMClcbiAgICB7XG4gICAgICAgIGlmIChwb2ludHNbcG9pbnRzLmxlbmd0aC0yXSAhPT0geDEgfHwgcG9pbnRzW3BvaW50cy5sZW5ndGgtMV0gIT09IHkxKVxuICAgICAgICB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBkZCA9IGExICogYTEgKyBiMSAqIGIxLFxuICAgICAgICAgICAgY2MgPSBhMiAqIGEyICsgYjIgKiBiMixcbiAgICAgICAgICAgIHR0ID0gYTEgKiBhMiArIGIxICogYjIsXG4gICAgICAgICAgICBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbSxcbiAgICAgICAgICAgIGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tLFxuICAgICAgICAgICAgajEgPSBrMSAqIHR0IC8gZGQsXG4gICAgICAgICAgICBqMiA9IGsyICogdHQgLyBjYyxcbiAgICAgICAgICAgIGN4ID0gazEgKiBiMiArIGsyICogYjEsXG4gICAgICAgICAgICBjeSA9IGsxICogYTIgKyBrMiAqIGExLFxuICAgICAgICAgICAgcHggPSBiMSAqIChrMiArIGoxKSxcbiAgICAgICAgICAgIHB5ID0gYTEgKiAoazIgKyBqMSksXG4gICAgICAgICAgICBxeCA9IGIyICogKGsxICsgajIpLFxuICAgICAgICAgICAgcXkgPSBhMiAqIChrMSArIGoyKSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpLFxuICAgICAgICAgICAgZW5kQW5nbGUgICA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG5cbiAgICAgICAgdGhpcy5hcmMoY3ggKyB4MSwgY3kgKyB5MSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYjEgKiBhMiA+IGIyICogYTEpO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0aGlzLmJvdW5kc0RpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgYXJjIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSAodXNlZCB0byBjcmVhdGUgY2lyY2xlcywgb3IgcGFydHMgb2YgY2lyY2xlcykuXG4gKlxuICogQHBhcmFtIGN4IHtudW1iZXJ9IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0gY3kge251bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSByYWRpdXMge251bWJlcn0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0gc3RhcnRBbmdsZSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvbiBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICogQHBhcmFtIGVuZEFuZ2xlIHtudW1iZXJ9IFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnNcbiAqIEBwYXJhbSBhbnRpY2xvY2t3aXNlIHtib29sZWFufSBPcHRpb25hbC4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRyYXdpbmcgc2hvdWxkIGJlIGNvdW50ZXJjbG9ja3dpc2Ugb3IgY2xvY2t3aXNlLiBGYWxzZSBpcyBkZWZhdWx0LCBhbmQgaW5kaWNhdGVzIGNsb2Nrd2lzZSwgd2hpbGUgdHJ1ZSBpbmRpY2F0ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24oY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKVxue1xuICAgIGFudGljbG9ja3dpc2UgPSBhbnRpY2xvY2t3aXNlIHx8IGZhbHNlO1xuXG4gICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoICFhbnRpY2xvY2t3aXNlICYmIGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUgKVxuICAgIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGVsc2UgaWYoIGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSApXG4gICAge1xuICAgICAgICBzdGFydEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgIH1cblxuICAgIHZhciBzd2VlcCA9IGFudGljbG9ja3dpc2UgPyAoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAqIC0xIDogKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgdmFyIHNlZ3MgPSAgTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIChNYXRoLlBJICogMikpICogNDA7XG5cbiAgICBpZihzd2VlcCA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIHZhciBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHN0YXJ0WCwgc3RhcnRZKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpO1xuICAgIH1cblxuICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcblxuICAgIHZhciB0aGV0YSA9IHN3ZWVwLyhzZWdzKjIpO1xuICAgIHZhciB0aGV0YTIgPSB0aGV0YSoyO1xuXG4gICAgdmFyIGNUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICB2YXIgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgdmFyIHNlZ01pbnVzID0gc2VncyAtIDE7XG5cbiAgICB2YXIgcmVtYWluZGVyID0gKCBzZWdNaW51cyAlIDEgKSAvIHNlZ01pbnVzO1xuXG4gICAgZm9yKHZhciBpPTA7IGk8PXNlZ01pbnVzOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgcmVhbCA9ICBpICsgcmVtYWluZGVyICogaTtcblxuXG4gICAgICAgIHZhciBhbmdsZSA9ICgodGhldGEpICsgc3RhcnRBbmdsZSArICh0aGV0YTIgKiByZWFsKSk7XG5cbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciBzID0gLU1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgICBwb2ludHMucHVzaCgoIChjVGhldGEgKiAgYykgKyAoc1RoZXRhICogcykgKSAqIHJhZGl1cyArIGN4LFxuICAgICAgICAgICAgICAgICAgICAoIChjVGhldGEgKiAtcykgKyAoc1RoZXRhICogYykgKSAqIHJhZGl1cyArIGN5KTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5ib3VuZHNEaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgc2ltcGxlIG9uZS1jb2xvciBmaWxsIHRoYXQgc3Vic2VxdWVudCBjYWxscyB0byBvdGhlciBHcmFwaGljcyBtZXRob2RzXG4gKiAoc3VjaCBhcyBsaW5lVG8oKSBvciBkcmF3Q2lyY2xlKCkpIHVzZSB3aGVuIGRyYXdpbmcuXG4gKlxuICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9IHRoZSBjb2xvciBvZiB0aGUgZmlsbFxuICogQHBhcmFtIGFscGhhIHtudW1iZXJ9IHRoZSBhbHBoYSBvZiB0aGUgZmlsbFxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmJlZ2luRmlsbCA9IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpXG57XG4gICAgdGhpcy5maWxsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxDb2xvciA9IGNvbG9yIHx8IDA7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAoYWxwaGEgPT09IHVuZGVmaW5lZCkgPyAxIDogYWxwaGE7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPD0gMilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5maWxsID0gdGhpcy5maWxsaW5nO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5maWxsQ29sb3IgPSB0aGlzLmZpbGxDb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguZmlsbEFscGhhID0gdGhpcy5maWxsQWxwaGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBmaWxsIHRvIHRoZSBsaW5lcyBhbmQgc2hhcGVzIHRoYXQgd2VyZSBhZGRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBiZWdpbkZpbGwoKSBtZXRob2QuXG4gKlxuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5lbmRGaWxsID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmZpbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGxDb2xvciA9IG51bGw7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3UmVjdCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApXG57XG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IG1hdGguUmVjdGFuZ2xlKHgseSwgd2lkdGgsIGhlaWdodCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSByYWRpdXMge251bWJlcn0gUmFkaXVzIG9mIHRoZSByZWN0YW5nbGUgY29ybmVyc1xuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzIClcbntcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgbWF0aC5Sb3VuZGVkUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERyYXdzIGEgY2lyY2xlLlxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICogQHBhcmFtIHJhZGl1cyB7bnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3Q2lyY2xlID0gZnVuY3Rpb24gKHgsIHksIHJhZGl1cylcbntcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgbWF0aC5DaXJjbGUoeCx5LCByYWRpdXMpKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhbiBlbGxpcHNlLlxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlXG4gKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuZHJhd0VsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgbWF0aC5FbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhIHBvbHlnb24gdXNpbmcgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtIHBhdGgge251bWJlcltdfFBJWEkuUG9pbnRbXX0gVGhlIHBhdGggZGF0YSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcG9seWdvbi5cbiAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3UG9seWdvbiA9IGZ1bmN0aW9uIChwYXRoKVxue1xuICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGFzc2lnbm1lbnQgZGVvcHRcbiAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgIHZhciBwb2ludHMgPSBwYXRoO1xuXG4gICAgdmFyIGNsb3NlZCA9IHRydWU7XG5cbiAgICBpZiAocG9pbnRzIGluc3RhbmNlb2YgbWF0aC5Qb2x5Z29uKVxuICAgIHtcbiAgICAgICAgY2xvc2VkID0gcG9pbnRzLmNsb3NlZDtcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzLnBvaW50cztcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICB7XG4gICAgICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGxlYWsgZGVvcHRcbiAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4yOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcbiAgICAgICAgcG9pbnRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICBwb2ludHNbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBuZXcgbWF0aC5Qb2x5Z29uKHBvaW50cyk7XG4gICAgc2hhcGUuY2xvc2VkID0gY2xvc2VkO1xuXG4gICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXG4gKlxuICogQHJldHVybiB7UElYSS5HcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDA7XG4gICAgdGhpcy5maWxsaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXNlZnVsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcbiAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGdlb21ldHJ5IGlzIGNvbXBsaWNhdGVkIGFuZCBuZWVkcyB0byBiZSByZXVzZWQgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIHNjYWxlTW9kZSBjb25zdHNcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gYSB0ZXh0dXJlIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmdlbmVyYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIChyZW5kZXJlciwgcmVzb2x1dGlvbiwgc2NhbGVNb2RlKVxue1xuXG4gICAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgMTtcblxuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG5cbiAgICB2YXIgY2FudmFzQnVmZmVyID0gbmV3IENhbnZhc0J1ZmZlcihib3VuZHMud2lkdGggKiByZXNvbHV0aW9uLCBib3VuZHMuaGVpZ2h0ICogcmVzb2x1dGlvbik7XG5cbiAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXNCdWZmZXIuY2FudmFzLCBzY2FsZU1vZGUpO1xuICAgIHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG5cbiAgICBjYW52YXNCdWZmZXIuY29udGV4dC5zY2FsZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcblxuICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LnRyYW5zbGF0ZSgtYm91bmRzLngsLWJvdW5kcy55KTtcblxuICAgIENhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzKHRoaXMsIGNhbnZhc0J1ZmZlci5jb250ZXh0KTtcblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcblxuICAgIC8vIHRoaXMgY29kZSBtYXkgc3RpbGwgYmUgbmVlZGVkIHNvIGxlYXZpbmcgZm9yIG5vdy4uXG4gICAgLy9cbiAgICAvKlxuICAgIGlmICh0aGlzLl9jYWNoZUFzQml0bWFwKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgfHwgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUoKTtcblxuICAgICAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlIG9uIHRoZSBncHUgdG9vIVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRTcHJpdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3ByaXRlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUucmVuZGVyV2ViR0wuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlcmVyKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgKi9cblxuICAgIGlmICh0aGlzLmdsRGlydHkpXG4gICAge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nbERpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcyk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy5yZW5kZXIodGhpcyk7XG5cbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICBpZiAodGhpcy5pc01hc2sgPT09IHRydWUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHRpbnQgaGFzIGNoYW5nZWQsIHNldCB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIGRpcnR5LlxuICAgIGlmICh0aGlzLl9wcmV2VGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHRoaXMgY29kZSBtYXkgc3RpbGwgYmUgbmVlZGVkIHNvIGxlYXZpbmcgZm9yIG5vdy4uXG4gICAgLy9cbiAgICAvKlxuICAgIGlmICh0aGlzLl9jYWNoZUFzQml0bWFwKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgfHwgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUoKTtcblxuICAgICAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFNwcml0ZVRleHR1cmUoKTtcblxuICAgICAgICAgICAgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFscGhhID0gdGhpcy5hbHBoYTtcblxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJDYW52YXMuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlcmVyKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgICovXG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IHJlbmRlcmVyLmJsZW5kTW9kZXNbdGhpcy5ibGVuZE1vZGVdO1xuICAgIGlmIChjb21wb3NpdGVPcGVyYXRpb24gIT09IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKVxuICAgIHtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKFxuICAgICAgICB0cmFuc2Zvcm0uYSAqIHJlc29sdXRpb24sXG4gICAgICAgIHRyYW5zZm9ybS5iICogcmVzb2x1dGlvbixcbiAgICAgICAgdHJhbnNmb3JtLmMgKiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc2Zvcm0uZCAqIHJlc29sdXRpb24sXG4gICAgICAgIHRyYW5zZm9ybS50eCAqIHJlc29sdXRpb24sXG4gICAgICAgIHRyYW5zZm9ybS50eSAqIHJlc29sdXRpb25cbiAgICApO1xuXG4gICAgQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgY29udGV4dCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBncmFwaGljIHNoYXBlIGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICpcbiAqIEBwYXJhbSBbbWF0cml4XSB7UElYSS5NYXRyaXh9IFRoZSB3b3JsZCB0cmFuc2Zvcm0gbWF0cml4IHRvIHVzZSwgZGVmYXVsdHMgdG8gdGhpc1xuICogIG9iamVjdCdzIHdvcmxkVHJhbnNmb3JtLlxuICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAobWF0cml4KVxue1xuICAgIGlmKCF0aGlzLl9jdXJyZW50Qm91bmRzKVxuICAgIHtcblxuICAgICAgICAvLyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGlmIHRoZSBpdGVtIGlzIGEgbWFzayFcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmFibGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLlJlY3RhbmdsZS5FTVBUWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJvdW5kc0RpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsQm91bmRzKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2xEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFNwcml0ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9sb2NhbEJvdW5kcztcblxuICAgICAgICB2YXIgdzAgPSBib3VuZHMueDtcbiAgICAgICAgdmFyIHcxID0gYm91bmRzLndpZHRoICsgYm91bmRzLng7XG5cbiAgICAgICAgdmFyIGgwID0gYm91bmRzLnk7XG4gICAgICAgIHZhciBoMSA9IGJvdW5kcy5oZWlnaHQgKyBib3VuZHMueTtcblxuICAgICAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgICAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICAgICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgICAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgICAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcblxuICAgICAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICAgICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgICAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgICAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgICAgICB2YXIgbWF4WCA9IHgxO1xuICAgICAgICB2YXIgbWF4WSA9IHkxO1xuXG4gICAgICAgIHZhciBtaW5YID0geDE7XG4gICAgICAgIHZhciBtaW5ZID0geTE7XG5cbiAgICAgICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICAgICAgbWluWCA9IHgzIDwgbWluWCA/IHgzIDogbWluWDtcbiAgICAgICAgbWluWCA9IHg0IDwgbWluWCA/IHg0IDogbWluWDtcblxuICAgICAgICBtaW5ZID0geTIgPCBtaW5ZID8geTIgOiBtaW5ZO1xuICAgICAgICBtaW5ZID0geTMgPCBtaW5ZID8geTMgOiBtaW5ZO1xuICAgICAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgICAgIG1heFggPSB4MiA+IG1heFggPyB4MiA6IG1heFg7XG4gICAgICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XG4gICAgICAgIG1heFggPSB4NCA+IG1heFggPyB4NCA6IG1heFg7XG5cbiAgICAgICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICAgICAgbWF4WSA9IHkzID4gbWF4WSA/IHkzIDogbWF4WTtcbiAgICAgICAgbWF4WSA9IHk0ID4gbWF4WSA/IHk0IDogbWF4WTtcblxuICAgICAgICB0aGlzLl9ib3VuZHMueCA9IG1pblg7XG4gICAgICAgIHRoaXMuX2JvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kcy55ID0gbWluWTtcbiAgICAgICAgdGhpcy5fYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCb3VuZHM7XG59O1xuXG4vKipcbiogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBncmFwaGljcyBvYmplY3RcbipcbiogQHBhcmFtIHBvaW50IHtQSVhJLlBvaW50fSB0aGUgcG9pbnQgdG8gdGVzdFxuKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4qL1xuR3JhcGhpY3MucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiggcG9pbnQgKVxue1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCAgdGVtcFBvaW50KTtcblxuICAgIHZhciBncmFwaGljc0RhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgaWYgKCFkYXRhLmZpbGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBkZWFsIHdpdGggZmlsbHMuLlxuICAgICAgICBpZiAoZGF0YS5zaGFwZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCBkYXRhLnNoYXBlLmNvbnRhaW5zKCB0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkgKSApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAqXG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS51cGRhdGVMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBpZiAodGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdmFyIHNoYXBlLCBwb2ludHMsIHgsIHksIHcsIGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YVtpXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGRhdGEubGluZVdpZHRoO1xuICAgICAgICAgICAgc2hhcGUgPSBkYXRhLnNoYXBlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJFQ1QgfHwgdHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJSRUMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeCA9IHNoYXBlLnggLSBsaW5lV2lkdGgvMjtcbiAgICAgICAgICAgICAgICB5ID0gc2hhcGUueSAtIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgICAgIHcgPSBzaGFwZS53aWR0aCArIGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgbGluZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBDT05TVC5TSEFQRVMuQ0lSQylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgICAgICB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgICAgICB3ID0gc2hhcGUucmFkaXVzICsgbGluZVdpZHRoLzI7XG4gICAgICAgICAgICAgICAgaCA9IHNoYXBlLnJhZGl1cyArIGxpbmVXaWR0aC8yO1xuXG4gICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcbiAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gQ09OU1QuU0hBUEVTLkVMSVApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICAgICAgdyA9IHNoYXBlLndpZHRoICsgbGluZVdpZHRoLzI7XG4gICAgICAgICAgICAgICAgaCA9IHNoYXBlLmhlaWdodCArIGxpbmVXaWR0aC8yO1xuXG4gICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcbiAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFBPTFlcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGogKz0gMilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal07XG4gICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaisxXTtcblxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geC1saW5lV2lkdGggPCBtaW5YID8geC1saW5lV2lkdGggOiBtaW5YO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0geCtsaW5lV2lkdGggPiBtYXhYID8geCtsaW5lV2lkdGggOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5LWxpbmVXaWR0aCA8IG1pblkgPyB5LWxpbmVXaWR0aCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5K2xpbmVXaWR0aCA+IG1heFkgPyB5K2xpbmVXaWR0aCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIG1pblggPSAwO1xuICAgICAgICBtYXhYID0gMDtcbiAgICAgICAgbWluWSA9IDA7XG4gICAgICAgIG1heFkgPSAwO1xuICAgIH1cblxuICAgIHZhciBwYWRkaW5nID0gdGhpcy5ib3VuZHNQYWRkaW5nO1xuXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMueCA9IG1pblggLSBwYWRkaW5nO1xuICAgIHRoaXMuX2xvY2FsQm91bmRzLndpZHRoID0gKG1heFggLSBtaW5YKSArIHBhZGRpbmcgKiAyO1xuXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMueSA9IG1pblkgLSBwYWRkaW5nO1xuICAgIHRoaXMuX2xvY2FsQm91bmRzLmhlaWdodCA9IChtYXhZIC0gbWluWSkgKyBwYWRkaW5nICogMjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBjYWNoZWQgc3ByaXRlIHdoZW4gdGhlIHNwcml0ZSBoYXMgY2FjaGVBc0JpdG1hcCA9IHRydWVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG4vKlxuR3JhcGhpY3MucHJvdG90eXBlLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcblxuICAgIGlmICghdGhpcy5fY2FjaGVkU3ByaXRlKVxuICAgIHtcbiAgICAgICAgdmFyIGNhbnZhc0J1ZmZlciA9IG5ldyBDYW52YXNCdWZmZXIoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLmZyb21DYW52YXMoY2FudmFzQnVmZmVyLmNhbnZhcyk7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlciA9IGNhbnZhc0J1ZmZlcjtcblxuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLnJlc2l6ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIGxldmVyYWdlIHRoZSBhbmNob3IgdG8gYWNjb3VudCBmb3IgdGhlIG9mZnNldCBvZiB0aGUgZWxlbWVudFxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLSggYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0ICk7XG5cbiAgICAvLyB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLmNvbnRleHQuc2F2ZSgpO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dC50cmFuc2xhdGUoLWJvdW5kcy54LC1ib3VuZHMueSk7XG5cbiAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBhbHBoYSBvZiB0aGUgZ3JhcGhpY3MgdG8gMSBmb3IgdGhlIHJlbmRlci4uXG4gICAgdGhpcy53b3JsZEFscGhhID0gMTtcblxuICAgIC8vIG5vdyByZW5kZXIgdGhlIGdyYXBoaWMuLlxuICAgIENhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzKHRoaXMsIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIuY29udGV4dCk7XG5cbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYWxwaGEgPSB0aGlzLmFscGhhO1xufTtcbiovXG4vKipcbiAqIFVwZGF0ZXMgdGV4dHVyZSBzaXplIGJhc2VkIG9uIGNhbnZhcyBzaXplXG4gKlxuICogQHByaXZhdGVcbiAqL1xuLypcbkdyYXBoaWNzLnByb3RvdHlwZS51cGRhdGVDYWNoZWRTcHJpdGVUZXh0dXJlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgY2FjaGVkU3ByaXRlID0gdGhpcy5fY2FjaGVkU3ByaXRlO1xuICAgIHZhciB0ZXh0dXJlID0gY2FjaGVkU3ByaXRlLnRleHR1cmU7XG4gICAgdmFyIGNhbnZhcyA9IGNhY2hlZFNwcml0ZS5idWZmZXIuY2FudmFzO1xuXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgdGV4dHVyZS5jcm9wLndpZHRoID0gdGV4dHVyZS5mcmFtZS53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB0ZXh0dXJlLmNyb3AuaGVpZ2h0ID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgY2FjaGVkU3ByaXRlLl93aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBjYWNoZWRTcHJpdGUuX2hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAvLyB1cGRhdGUgdGhlIGRpcnR5IGJhc2UgdGV4dHVyZXNcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmRpcnR5KCk7XG59OyovXG5cbi8qKlxuICogRGVzdHJveXMgYSBwcmV2aW91cyBjYWNoZWQgc3ByaXRlLlxuICpcbiAqL1xuLypcbkdyYXBoaWNzLnByb3RvdHlwZS5kZXN0cm95Q2FjaGVkU3ByaXRlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUudGV4dHVyZS5kZXN0cm95KHRydWUpO1xuXG4gICAgLy8gbGV0IHRoZSBnYyBjb2xsZWN0IHRoZSB1bnVzZWQgc3ByaXRlXG4gICAgLy8gVE9ETyBjb3VsZCBiZSBvYmplY3QgcG9vbGVkIVxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG51bGw7XG59OyovXG5cbi8qKlxuICogRHJhd3MgdGhlIGdpdmVuIHNoYXBlIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBDYW4gYmUgYW55IG9mIENpcmNsZSwgUmVjdGFuZ2xlLCBFbGxpcHNlLCBMaW5lIG9yIFBvbHlnb24uXG4gKlxuICogQHBhcmFtIHNoYXBlIHtQSVhJLkNpcmNsZXxQSVhJLlJlY3RhbmdsZXxQSVhJLkVsbGlwc2V8UElYSS5MaW5lfFBJWEkuUG9seWdvbn0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICogQHJldHVybiB7UElYSS5HcmFwaGljc0RhdGF9IFRoZSBnZW5lcmF0ZWQgR3JhcGhpY3NEYXRhIG9iamVjdC5cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSlcbntcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICB7XG4gICAgICAgIC8vIGNoZWNrIGN1cnJlbnQgcGF0aCFcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA8PSAyKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuXG4gICAgdmFyIGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhKHRoaXMubGluZVdpZHRoLCB0aGlzLmxpbmVDb2xvciwgdGhpcy5saW5lQWxwaGEsIHRoaXMuZmlsbENvbG9yLCB0aGlzLmZpbGxBbHBoYSwgdGhpcy5maWxsaW5nLCBzaGFwZSk7XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKGRhdGEpO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlBPTFkpXG4gICAge1xuICAgICAgICBkYXRhLnNoYXBlLmNsb3NlZCA9IGRhdGEuc2hhcGUuY2xvc2VkIHx8IHRoaXMuZmlsbGluZztcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IGRhdGE7XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eSA9IHRoaXMuYm91bmRzRGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gZGVzdHJveSBlYWNoIG9mIHRoZSBHcmFwaGljc0RhdGEgb2JqZWN0c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFbaV0uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8vIGZvciBlYWNoIHdlYmdsIGRhdGEgZW50cnksIGRlc3Ryb3kgdGhlIFdlYkdMR3JhcGhpY3NEYXRhXG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fd2ViZ2wpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl93ZWJnbFtpZF0uZGF0YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdGhpcy5fd2ViZ2xbaWRdLmRhdGFbal0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBudWxsO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgdGhpcy5fd2ViZ2wgPSBudWxsO1xuICAgIHRoaXMuX2xvY2FsQm91bmRzID0gbnVsbDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvZ3JhcGhpY3MvR3JhcGhpY3MuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogQSBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlciB0byBkcmF3IHRoZSBwcmltaXRpdmUgZ3JhcGhpY3MgZGF0YS5cbiAqIEBzdGF0aWNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENhbnZhc0dyYXBoaWNzID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0dyYXBoaWNzO1xuXG4vKlxuICogUmVuZGVycyBhIEdyYXBoaWNzIG9iamVjdCB0byBhIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9IHRoZSBhY3R1YWwgZ3JhcGhpY3Mgb2JqZWN0IHRvIHJlbmRlclxuICogQHBhcmFtIGNvbnRleHQge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gdGhlIDJkIGRyYXdpbmcgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqL1xuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3MgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIGNvbnRleHQpXG57XG4gICAgdmFyIHdvcmxkQWxwaGEgPSBncmFwaGljcy53b3JsZEFscGhhO1xuXG4gICAgaWYgKGdyYXBoaWNzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljc1RpbnQoZ3JhcGhpY3MpO1xuICAgICAgICBncmFwaGljcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGU7XG5cbiAgICAgICAgdmFyIGZpbGxDb2xvciA9IGRhdGEuX2ZpbGxUaW50O1xuICAgICAgICB2YXIgbGluZUNvbG9yID0gZGF0YS5fbGluZVRpbnQ7XG5cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcblxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUE9MWSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaiAqIDJdLCBwb2ludHNbaiAqIDIgKyAxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFwZS5jbG9zZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgIGlmIChwb2ludHNbMF0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoLTJdICYmIHBvaW50c1sxXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggbGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUkVDVClcbiAgICAgICAge1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5maWxsQ29sb3IgfHwgZGF0YS5maWxsQ29sb3IgPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBmaWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBsaW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkNJUkMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMsMCwyKk1hdGguUEkpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggbGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuRUxJUClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gZWxsaXBzZSBjb2RlIHRha2VuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuXG4gICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoICogMjtcbiAgICAgICAgICAgIHZhciBoID0gc2hhcGUuaGVpZ2h0ICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54IC0gdy8yO1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55IC0gaC8yO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgICAgICAgICAgb3ggPSAodyAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgICAgICAgICAgICBveSA9IChoIC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgICAgICAgICAgICB4ZSA9IHggKyB3LCAgICAgICAgICAgLy8geC1lbmRcbiAgICAgICAgICAgICAgICB5ZSA9IHkgKyBoLCAgICAgICAgICAgLy8geS1lbmRcbiAgICAgICAgICAgICAgICB4bSA9IHggKyB3IC8gMiwgICAgICAgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICB5bSA9IHkgKyBoIC8gMjsgICAgICAgLy8geS1taWRkbGVcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcblxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggbGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUlJFQylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJ4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciByeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gc2hhcGUucmFkaXVzO1xuXG4gICAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIHwgMDtcbiAgICAgICAgICAgIHJhZGl1cyA9IHJhZGl1cyA+IG1heFJhZGl1cyA/IG1heFJhZGl1cyA6IHJhZGl1cztcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGggLSByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSArIGhlaWdodCwgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5LCByeCArIHdpZHRoIC0gcmFkaXVzLCByeSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmZpbGxDb2xvciB8fCBkYXRhLmZpbGxDb2xvciA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBsaW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gKiBSZW5kZXJzIGEgZ3JhcGhpY3MgbWFza1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9IHRoZSBncmFwaGljcyB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBtYXNrXG4gKiBAcGFyYW0gY29udGV4dCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSB0aGUgY29udGV4dCAyZCBtZXRob2Qgb2YgdGhlIGNhbnZhc1xuICovXG5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljc01hc2sgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIGNvbnRleHQpXG57XG4gICAgdmFyIGxlbiA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7XG5cbiAgICBpZiAobGVuID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGU7XG5cbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlBPTFkpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaiAqIDJdLCBwb2ludHNbaiAqIDIgKyAxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludCBhcmUgdGhlIHNhbWUgY2xvc2UgdGhlIHBhdGggLSBtdWNoIG5lYXRlciA6KVxuICAgICAgICAgICAgaWYgKHBvaW50c1swXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl0gJiYgcG9pbnRzWzFdID09PSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUkVDVClcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5DSVJDKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPIC0gbmVlZCB0byBiZSBVbmRlZmluZWQhXG4gICAgICAgICAgICBjb250ZXh0LmFyYyhzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuRUxJUClcbiAgICAgICAge1xuXG4gICAgICAgICAgICAvLyBlbGxpcHNlIGNvZGUgdGFrZW4gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTcyNzk4L2hvdy10by1kcmF3LWFuLW92YWwtaW4taHRtbDUtY2FudmFzXG5cbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggKiAyO1xuICAgICAgICAgICAgdmFyIGggPSBzaGFwZS5oZWlnaHQgKiAyO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLnggLSB3LzI7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnkgLSBoLzI7XG5cbiAgICAgICAgICAgIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICAgICAgICAgICAgICBveCA9ICh3IC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgIG95ID0gKGggLyAyKSAqIGthcHBhLCAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgIHhlID0geCArIHcsICAgICAgICAgICAvLyB4LWVuZFxuICAgICAgICAgICAgICAgIHllID0geSArIGgsICAgICAgICAgICAvLyB5LWVuZFxuICAgICAgICAgICAgICAgIHhtID0geCArIHcgLyAyLCAgICAgICAvLyB4LW1pZGRsZVxuICAgICAgICAgICAgICAgIHltID0geSArIGggLyAyOyAgICAgICAvLyB5LW1pZGRsZVxuXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5bSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5SUkVDKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHZhciByeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgcnkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHNoYXBlLnJhZGl1cztcblxuICAgICAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMiB8IDA7XG4gICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPiBtYXhSYWRpdXMgPyBtYXhSYWRpdXMgOiByYWRpdXM7XG5cbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGggLSByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSArIGhlaWdodCwgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5LCByeCArIHdpZHRoIC0gcmFkaXVzLCByeSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgdGludCBvZiBhIGdyYXBoaWNzIG9iamVjdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge1BJWEkuR3JhcGhpY3N9IHRoZSBncmFwaGljcyB0aGF0IHdpbGwgaGF2ZSBpdHMgdGludCB1cGRhdGVkXG4gKlxuICovXG5DYW52YXNHcmFwaGljcy51cGRhdGVHcmFwaGljc1RpbnQgPSBmdW5jdGlvbiAoZ3JhcGhpY3MpXG57XG4gICAgaWYgKGdyYXBoaWNzLnRpbnQgPT09IDB4RkZGRkZGICYmIGdyYXBoaWNzLl9wcmV2VGludCA9PT0gZ3JhcGhpY3MudGludClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ3JhcGhpY3MuX3ByZXZUaW50ID0gZ3JhcGhpY3MudGludDtcblxuICAgIHZhciB0aW50UiA9IChncmFwaGljcy50aW50ID4+IDE2ICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIHRpbnRHID0gKGdyYXBoaWNzLnRpbnQgPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgIHZhciB0aW50QiA9IChncmFwaGljcy50aW50ICYgMHhGRikvIDI1NTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgdmFyIGZpbGxDb2xvciA9IGRhdGEuZmlsbENvbG9yIHwgMDtcbiAgICAgICAgdmFyIGxpbmVDb2xvciA9IGRhdGEubGluZUNvbG9yIHwgMDtcblxuICAgICAgICAvKlxuICAgICAgICB2YXIgY29sb3JSID0gKGZpbGxDb2xvciA+PiAxNiAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgY29sb3JHID0gKGZpbGxDb2xvciA+PiA4ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHZhciBjb2xvckIgPSAoZmlsbENvbG9yICYgMHhGRikgLyAyNTU7XG5cbiAgICAgICAgY29sb3JSICo9IHRpbnRSO1xuICAgICAgICBjb2xvckcgKj0gdGludEc7XG4gICAgICAgIGNvbG9yQiAqPSB0aW50QjtcblxuICAgICAgICBmaWxsQ29sb3IgPSAoKGNvbG9yUioyNTUgPDwgMTYpICsgKGNvbG9yRyoyNTUgPDwgOCkgKyBjb2xvckIqMjU1KTtcblxuICAgICAgICBjb2xvclIgPSAobGluZUNvbG9yID4+IDE2ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIGNvbG9yRyA9IChsaW5lQ29sb3IgPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgICAgICBjb2xvckIgPSAobGluZUNvbG9yICYgMHhGRikgLyAyNTU7XG5cbiAgICAgICAgY29sb3JSICo9IHRpbnRSO1xuICAgICAgICBjb2xvckcgKj0gdGludEc7XG4gICAgICAgIGNvbG9yQiAqPSB0aW50QjtcblxuICAgICAgICBsaW5lQ29sb3IgPSAoKGNvbG9yUioyNTUgPDwgMTYpICsgKGNvbG9yRyoyNTUgPDwgOCkgKyBjb2xvckIqMjU1KTtcbiAgICAgICAgKi9cblxuICAgICAgICAvLyBzdXBlciBpbmxpbmUgY29zIGltIGFuIG9wdGltaXphdGlvbiBOQVpJIDopXG4gICAgICAgIGRhdGEuX2ZpbGxUaW50ID0gKCgoZmlsbENvbG9yID4+IDE2ICYgMHhGRikgLyAyNTUgKiB0aW50UioyNTUgPDwgMTYpICsgKChmaWxsQ29sb3IgPj4gOCAmIDB4RkYpIC8gMjU1ICogdGludEcqMjU1IDw8IDgpICsgIChmaWxsQ29sb3IgJiAweEZGKSAvIDI1NSAqIHRpbnRCKjI1NSk7XG4gICAgICAgIGRhdGEuX2xpbmVUaW50ID0gKCgobGluZUNvbG9yID4+IDE2ICYgMHhGRikgLyAyNTUgKiB0aW50UioyNTUgPDwgMTYpICsgKChsaW5lQ29sb3IgPj4gOCAmIDB4RkYpIC8gMjU1ICogdGludEcqMjU1IDw8IDgpICsgIChsaW5lQ29sb3IgJiAweEZGKSAvIDI1NSAqIHRpbnRCKjI1NSk7XG5cbiAgICB9XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNHcmFwaGljcy5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIEdyYXBoaWNzRGF0YSBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIGxpbmVXaWR0aCB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhd1xuICogQHBhcmFtIGxpbmVDb2xvciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhd1xuICogQHBhcmFtIGxpbmVBbHBoYSB7bnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhd1xuICogQHBhcmFtIGZpbGxDb2xvciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAqIEBwYXJhbSBmaWxsQWxwaGEge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gKiBAcGFyYW0gZmlsbCAgICAgIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgaXMgZmlsbGVkIHdpdGggYSBjb2xvdXJcbiAqIEBwYXJhbSBzaGFwZSAgICAge0NpcmNsZXxSZWN0YW5nbGV8RWxsaXBzZXxMaW5lfFBvbHlnb259IFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAqL1xuZnVuY3Rpb24gR3JhcGhpY3NEYXRhKGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsIGZpbGxDb2xvciwgZmlsbEFscGhhLCBmaWxsLCBzaGFwZSlcbntcbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgICAqL1xuICAgIHRoaXMubGluZUNvbG9yID0gbGluZUNvbG9yO1xuICAgIC8qXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgICAqL1xuICAgIHRoaXMubGluZUFscGhhID0gbGluZUFscGhhO1xuICAgIC8qXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBjYWNoZWQgdGludCBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAgICovXG4gICAgdGhpcy5fbGluZVRpbnQgPSBsaW5lQ29sb3I7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGNvbG9yIG9mIHRoZSBmaWxsXG4gICAgICovXG4gICAgdGhpcy5maWxsQ29sb3IgPSBmaWxsQ29sb3I7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gICAgICovXG4gICAgdGhpcy5maWxsQWxwaGEgPSBmaWxsQWxwaGE7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gY2FjaGVkIHRpbnQgb2YgdGhlIGZpbGxcbiAgICAgKi9cbiAgICB0aGlzLl9maWxsVGludCA9IGZpbGxDb2xvcjtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIHNoYXBlIGlzIGZpbGxlZCB3aXRoIGEgY29sb3VyXG4gICAgICovXG4gICAgdGhpcy5maWxsID0gZmlsbDtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7UElYSS5DaXJjbGV8UElYSS5SZWN0YW5nbGV8UElYSS5FbGxpcHNlfFBJWEkuTGluZXxQSVhJLlBvbHlnb259IFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gVGhlIHR5cGUgb2YgdGhlIHNoYXBlLCBzZWUgdGhlIENvbnN0LlNoYXBlcyBmaWxlIGZvciBhbGwgdGhlIGV4aXN0aW5nIHR5cGVzLFxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHNoYXBlLnR5cGU7XG59XG5cbkdyYXBoaWNzRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmFwaGljc0RhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoaWNzRGF0YTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzRGF0YSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB7UElYSS5HcmFwaGljc0RhdGF9XG4gKi9cbkdyYXBoaWNzRGF0YS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKFxuICAgICAgICB0aGlzLmxpbmVXaWR0aCxcbiAgICAgICAgdGhpcy5saW5lQ29sb3IsXG4gICAgICAgIHRoaXMubGluZUFscGhhLFxuICAgICAgICB0aGlzLmZpbGxDb2xvcixcbiAgICAgICAgdGhpcy5maWxsQWxwaGEsXG4gICAgICAgIHRoaXMuZmlsbCxcbiAgICAgICAgdGhpcy5zaGFwZVxuICAgICk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBkYXRhLlxuICovXG5HcmFwaGljc0RhdGEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zaGFwZSA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKSxcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKSxcbiAgICBPYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpLFxuICAgIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpLFxuICAgIFdlYkdMR3JhcGhpY3NEYXRhID0gcmVxdWlyZSgnLi9XZWJHTEdyYXBoaWNzRGF0YScpLFxuICAgIGVhcmN1dCA9IHJlcXVpcmUoJ2VhcmN1dCcpO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIG9iamVjdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgUElYSS5PYmplY3RSZW5kZXJlclxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG9iamVjdCByZW5kZXJlciB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIEdyYXBoaWNzUmVuZGVyZXIocmVuZGVyZXIpXG57XG4gICAgT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2wgPSBbXTtcblxuICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbXBsZXhQcmltaXRpdmVTaGFkZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgcG9pbnRzIGEgcG9seSBjYW4gY29udGFpbiBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgYXMgYSBjb21wbGV4IHBvbHlnb24gKHVzaW5nIHRoZSBzdGVuY2lsIGJ1ZmZlcilcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4aW11bVNpbXBsZVBvbHlTaXplID0gMjAwO1xufVxuXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlKTtcbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JhcGhpY3NSZW5kZXJlcjtcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NSZW5kZXJlcjtcblxuV2ViR0xSZW5kZXJlci5yZWdpc3RlclBsdWdpbignZ3JhcGhpY3MnLCBHcmFwaGljc1JlbmRlcmVyKTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGVyZSBpcyBhIFdlYkdMIGNvbnRleHQgY2hhbmdlXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZSA9IGZ1bmN0aW9uKClcbntcblxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHJlbmRlcmVyLlxuICpcbiAqL1xuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3RSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YVBvb2wubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sW2ldLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2wgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgZ3JhcGhpY3Mgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBncmFwaGljcyB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCB0byByZW5kZXIuXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGdyYXBoaWNzKVxue1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICB2YXIgc2hhZGVyID0gcmVuZGVyZXIuc2hhZGVyTWFuYWdlci5wbHVnaW5zLnByaW1pdGl2ZVNoYWRlcixcbiAgICAgICAgd2ViR0xEYXRhO1xuXG4gICAgaWYgKGdyYXBoaWNzLmRpcnR5IHx8ICFncmFwaGljcy5fd2ViR0xbZ2wuaWRdKVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljcyhncmFwaGljcyk7XG4gICAgfVxuXG4gICAgdmFyIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW2dsLmlkXTtcblxuICAgIC8vIFRoaXMgIGNvdWxkIGJlIHNwZWVkZWQgdXAgZm9yIHN1cmUhXG5cbiAgICByZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZSggZ3JhcGhpY3MuYmxlbmRNb2RlICk7XG5cbi8vICAgIHZhciBtYXRyaXggPSAgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0uY2xvbmUoKTtcbi8vICAgIHZhciBtYXRyaXggPSAgcmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldC5wcm9qZWN0aW9uTWF0cml4LmNsb25lKCk7XG4vLyAgICBtYXRyaXguYXBwZW5kKGdyYXBoaWNzLndvcmxkVHJhbnNmb3JtKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gd2ViR0wuZGF0YS5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAge1xuICAgICAgICB3ZWJHTERhdGEgPSB3ZWJHTC5kYXRhW2ldO1xuXG4gICAgICAgIGlmICh3ZWJHTC5kYXRhW2ldLm1vZGUgPT09IDEpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgcmVuZGVyZXIuc3RlbmNpbE1hbmFnZXIucHVzaFN0ZW5jaWwoZ3JhcGhpY3MsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihyZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmNvbXBsZXhQcmltaXRpdmVTaGFkZXIudW5pZm9ybXMuYWxwaGEuX2xvY2F0aW9uLCBncmFwaGljcy53b3JsZEFscGhhICogd2ViR0xEYXRhLmFscGhhKTtcblxuICAgICAgICAgICAgLy8gcmVuZGVyIHF1YWQuLlxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgNCwgZ2wuVU5TSUdORURfU0hPUlQsICggd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoIC0gNCApICogMiApO1xuXG4gICAgICAgICAgICByZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wb3BTdGVuY2lsKGdyYXBoaWNzLCB3ZWJHTERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuXG4gICAgICAgICAgICBzaGFkZXIgPSByZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnByaW1pdGl2ZVNoYWRlcjtcblxuICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoIHNoYWRlciApOy8vYWN0aXZhdGVQcmltaXRpdmVTaGFkZXIoKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgcmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldC5wcm9qZWN0aW9uTWF0cml4LnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci51bmlmb3Jtcy50aW50Ll9sb2NhdGlvbiwgdXRpbHMuaGV4MnJnYihncmFwaGljcy50aW50KSk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybXMuYWxwaGEuX2xvY2F0aW9uLCBncmFwaGljcy53b3JsZEFscGhhKTtcblxuXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAwKTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsNCAqIDYsIDIgKiA0KTtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuaW5kZXhCdWZmZXIpO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX1NUUklQLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuZHJhd0NvdW50Kys7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBncmFwaGljcyBvYmplY3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzIHtQSVhJLkdyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIHVwZGF0ZVxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVHcmFwaGljcyA9IGZ1bmN0aW9uKGdyYXBoaWNzKVxue1xuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgLy8gZ2V0IHRoZSBjb250ZXh0cyBncmFwaGljcyBvYmplY3RcbiAgICB2YXIgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbZ2wuaWRdO1xuXG4gICAgLy8gaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgd2ViR0wgY29udGV4dCB0aW1lIHRvIGNyZWF0ZSBpdCFcbiAgICBpZiAoIXdlYkdMKVxuICAgIHtcbiAgICAgICAgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbZ2wuaWRdID0ge2xhc3RJbmRleDowLCBkYXRhOltdLCBnbDpnbH07XG4gICAgfVxuXG4gICAgLy8gZmxhZyB0aGUgZ3JhcGhpY3MgYXMgbm90IGRpcnR5IGFzIHdlIGFyZSBhYm91dCB0byB1cGRhdGUgaXQuLi5cbiAgICBncmFwaGljcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgdmFyIGk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBjbGVhcmVkIHRoZSBncmFwaGljcyBvYmplY3Qgd2Ugd2lsbCBuZWVkIHRvIGNsZWFyIGV2ZXJ5IG9iamVjdFxuICAgIGlmIChncmFwaGljcy5jbGVhckRpcnR5KVxuICAgIHtcbiAgICAgICAgZ3JhcGhpY3MuY2xlYXJEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbmQgcmV0dXJuIGFsbCB0aGUgd2ViR0xEYXRhcyB0byB0aGUgb2JqZWN0IHBvb2wgc28gdGhhbiBjYW4gYmUgcmV1c2VkIGxhdGVyIG9uXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB3ZWJHTC5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZ3JhcGhpY3NEYXRhID0gd2ViR0wuZGF0YVtpXTtcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sLnB1c2goIGdyYXBoaWNzRGF0YSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGFycmF5IGFuZCByZXNldCB0aGUgaW5kZXguLlxuICAgICAgICB3ZWJHTC5kYXRhID0gW107XG4gICAgICAgIHdlYkdMLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHdlYkdMRGF0YTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgZ3JhcGhpY3MgZGF0YXMgYW5kIGNvbnN0cnVjdCBlYWNoIG9uZS4uXG4gICAgLy8gaWYgdGhlIG9iamVjdCBpcyBhIGNvbXBsZXggZmlsbCB0aGVuIHRoZSBuZXcgc3RlbmNpbCBidWZmZXIgdGVjaG5pcXVlIHdpbGwgYmUgdXNlZFxuICAgIC8vIG90aGVyIHdpc2UgZ3JhcGhpY3Mgb2JqZWN0cyB3aWxsIGJlIHB1c2hlZCBpbnRvIGEgYmF0Y2guLlxuICAgIGZvciAoaSA9IHdlYkdMLmxhc3RJbmRleDsgaSA8IGdyYXBoaWNzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5QT0xZKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGFkZCB0aGUgcG9pbnRzIHRoZSB0aGUgZ3JhcGhpY3Mgb2JqZWN0Li5cbiAgICAgICAgICAgIGRhdGEucG9pbnRzID0gZGF0YS5zaGFwZS5wb2ludHMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlLmNsb3NlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgcG9seSBpZiB0aGUgdmFsdWUgaXMgdHJ1ZSFcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb2ludHNbMF0gIT09IGRhdGEucG9pbnRzW2RhdGEucG9pbnRzLmxlbmd0aC0yXSB8fCBkYXRhLnBvaW50c1sxXSAhPT0gZGF0YS5wb2ludHNbZGF0YS5wb2ludHMubGVuZ3RoLTFdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wb2ludHMucHVzaChkYXRhLnBvaW50c1swXSwgZGF0YS5wb2ludHNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTUFLRSBTVVJFIFdFIEhBVkUgVEhFIENPUlJFQ1QgVFlQRS4uXG4gICAgICAgICAgICBpZiAoZGF0YS5maWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvaW50cy5sZW5ndGggPj0gNilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBvaW50cy5sZW5ndGggPCB0aGlzLm1heGltdW1TaW1wbGVQb2x5U2l6ZSAqIDIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IHRoaXMuc3dpdGNoTW9kZSh3ZWJHTCwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5EcmF3VXNpbmdTaW1wbGUgPSB0aGlzLmJ1aWxkUG9seShkYXRhLCB3ZWJHTERhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbkRyYXdVc2luZ1NpbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLnN3aXRjaE1vZGUod2ViR0wsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRDb21wbGV4UG9seShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLnN3aXRjaE1vZGUod2ViR0wsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZENvbXBsZXhQb2x5KGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5zd2l0Y2hNb2RlKHdlYkdMLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkTGluZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5zd2l0Y2hNb2RlKHdlYkdMLCAwKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJFQ1QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFJlY3RhbmdsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuQ0lSQyB8fCBkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5FTElQKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRDaXJjbGUoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJSRUMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFJvdW5kZWRSZWN0YW5nbGUoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdlYkdMLmxhc3RJbmRleCsrO1xuICAgIH1cblxuICAgIC8vIHVwbG9hZCBhbGwgdGhlIGRpcnR5IGRhdGEuLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbaV07XG5cbiAgICAgICAgaWYgKHdlYkdMRGF0YS5kaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhLnVwbG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gd2ViR0wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKiBAcGFyYW0gdHlwZSB7bnVtYmVyfSBUT0RPIEBBbHZpblxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5zd2l0Y2hNb2RlID0gZnVuY3Rpb24gKHdlYkdMLCB0eXBlKVxue1xuICAgIHZhciB3ZWJHTERhdGE7XG5cbiAgICBpZiAoIXdlYkdMLmRhdGEubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5ncmFwaGljc0RhdGFQb29sLnBvcCgpIHx8IG5ldyBXZWJHTEdyYXBoaWNzRGF0YSh3ZWJHTC5nbCk7XG4gICAgICAgIHdlYkdMRGF0YS5tb2RlID0gdHlwZTtcbiAgICAgICAgd2ViR0wuZGF0YS5wdXNoKHdlYkdMRGF0YSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbd2ViR0wuZGF0YS5sZW5ndGgtMV07XG5cbiAgICAgICAgaWYgKCh3ZWJHTERhdGEucG9pbnRzLmxlbmd0aCA+IDMyMDAwMCkgfHwgd2ViR0xEYXRhLm1vZGUgIT09IHR5cGUgfHwgdHlwZSA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5ncmFwaGljc0RhdGFQb29sLnBvcCgpIHx8IG5ldyBXZWJHTEdyYXBoaWNzRGF0YSh3ZWJHTC5nbCk7XG4gICAgICAgICAgICB3ZWJHTERhdGEubW9kZSA9IHR5cGU7XG4gICAgICAgICAgICB3ZWJHTC5kYXRhLnB1c2god2ViR0xEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdlYkdMRGF0YS5kaXJ0eSA9IHRydWU7XG5cbiAgICByZXR1cm4gd2ViR0xEYXRhO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSByZWN0YW5nbGUgdG8gZHJhd1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtQSVhJLkdyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7b2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIC8vIC0tLSAvL1xuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgIC8vXG4gICAgdmFyIHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgIHZhciB4ID0gcmVjdERhdGEueDtcbiAgICB2YXIgeSA9IHJlY3REYXRhLnk7XG4gICAgdmFyIHdpZHRoID0gcmVjdERhdGEud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlY3REYXRhLmhlaWdodDtcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbClcbiAgICB7XG4gICAgICAgIHZhciBjb2xvciA9IHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgdmVydHMucHVzaCh4LCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHggLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXG4gICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zLCB2ZXJ0UG9zKzEsIHZlcnRQb3MrMiwgdmVydFBvcyszLCB2ZXJ0UG9zKzMpO1xuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoKVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBbeCwgeSxcbiAgICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSxcbiAgICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHgsIHkgKyBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICB4LCB5XTtcblxuXG4gICAgICAgIHRoaXMuYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHRvIGRyYXdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZFJvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgdmFyIHJyZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICB2YXIgeCA9IHJyZWN0RGF0YS54O1xuICAgIHZhciB5ID0gcnJlY3REYXRhLnk7XG4gICAgdmFyIHdpZHRoID0gcnJlY3REYXRhLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBycmVjdERhdGEuaGVpZ2h0O1xuXG4gICAgdmFyIHJhZGl1cyA9IHJyZWN0RGF0YS5yYWRpdXM7XG5cbiAgICB2YXIgcmVjUG9pbnRzID0gW107XG4gICAgcmVjUG9pbnRzLnB1c2goeCwgeSArIHJhZGl1cyk7XG4gICAgdGhpcy5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzLCB4LCB5ICsgaGVpZ2h0LCB4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0LCByZWNQb2ludHMpO1xuICAgIHRoaXMucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cywgcmVjUG9pbnRzKTtcbiAgICB0aGlzLnF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCwgeSArIHJhZGl1cywgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGggLSByYWRpdXMsIHksIHJlY1BvaW50cyk7XG4gICAgdGhpcy5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgcmFkaXVzLCB5LCB4LCB5LCB4LCB5ICsgcmFkaXVzICsgMC4wMDAwMDAwMDAxLCByZWNQb2ludHMpO1xuXG4gICAgLy8gdGhpcyB0aW55IG51bWJlciBkZWFscyB3aXRoIHRoZSBpc3N1ZSB0aGF0IG9jY3VycyB3aGVuIHBvaW50cyBvdmVybGFwIGFuZCBlYXJjdXQgZmFpbHMgdG8gdHJpYW5ndWxhdGUgdGhlIGl0ZW0uXG4gICAgLy8gVE9ETyAtIGZpeCB0aGlzIHByb3Blcmx5LCB0aGlzIGlzIG5vdCB2ZXJ5IGVsZWdhbnQuLiBidXQgaXQgd29ya3MgZm9yIG5vdy5cblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbClcbiAgICB7XG4gICAgICAgIHZhciBjb2xvciA9IHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGgvNjtcblxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gZWFyY3V0KHJlY1BvaW50cywgbnVsbCwgMik7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSs9MylcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsxXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMl0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICsgdmVjUG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZWNQb2ludHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocmVjUG9pbnRzW2ldLCByZWNQb2ludHNbKytpXSwgciwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpXG4gICAge1xuICAgICAgICB2YXIgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHJlY1BvaW50cztcblxuICAgICAgICB0aGlzLmJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLiAoaGVscGVyIGZ1bmN0aW9uLi4pXG4gKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBmcm9tWCB7bnVtYmVyfSBPcmlnaW4gcG9pbnQgeFxuICogQHBhcmFtIGZyb21ZIHtudW1iZXJ9IE9yaWdpbiBwb2ludCB4XG4gKiBAcGFyYW0gY3BYIHtudW1iZXJ9IENvbnRyb2wgcG9pbnQgeFxuICogQHBhcmFtIGNwWSB7bnVtYmVyfSBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSB0b1gge251bWJlcn0gRGVzdGluYXRpb24gcG9pbnQgeFxuICogQHBhcmFtIHRvWSB7bnVtYmVyfSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gKiBAcGFyYW0gW291dF0ge251bWJlcltdfSBUaGUgb3V0cHV0IGFycmF5IHRvIGFkZCBwb2ludHMgaW50by4gSWYgbm90IHBhc3NlZCwgYSBuZXcgYXJyYXkgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSBvZiBwb2ludHNcbiAqL1xuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUucXVhZHJhdGljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1ksIG91dClcbntcbiAgICB2YXIgeGEsXG4gICAgICAgIHlhLFxuICAgICAgICB4YixcbiAgICAgICAgeWIsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIG4gPSAyMCxcbiAgICAgICAgcG9pbnRzID0gb3V0IHx8IFtdO1xuXG4gICAgZnVuY3Rpb24gZ2V0UHQobjEgLCBuMiwgcGVyYykge1xuICAgICAgICB2YXIgZGlmZiA9IG4yIC0gbjE7XG5cbiAgICAgICAgcmV0dXJuIG4xICsgKCBkaWZmICogcGVyYyApO1xuICAgIH1cblxuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpKysgKSB7XG4gICAgICAgIGogPSBpIC8gbjtcblxuICAgICAgICAvLyBUaGUgR3JlZW4gTGluZVxuICAgICAgICB4YSA9IGdldFB0KCBmcm9tWCAsIGNwWCAsIGogKTtcbiAgICAgICAgeWEgPSBnZXRQdCggZnJvbVkgLCBjcFkgLCBqICk7XG4gICAgICAgIHhiID0gZ2V0UHQoIGNwWCAsIHRvWCAsIGogKTtcbiAgICAgICAgeWIgPSBnZXRQdCggY3BZICwgdG9ZICwgaiApO1xuXG4gICAgICAgIC8vIFRoZSBCbGFjayBEb3RcbiAgICAgICAgeCA9IGdldFB0KCB4YSAsIHhiICwgaiApO1xuICAgICAgICB5ID0gZ2V0UHQoIHlhICwgeWIgLCBqICk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50cztcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgY2lyY2xlIHRvIGRyYXdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCB0byBkcmF3XG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtvYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiAqL1xuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRDaXJjbGUgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgLy8gbmVlZCB0byBjb252ZXJ0IHBvaW50cyB0byBhIG5pY2UgcmVndWxhciBkYXRhXG4gICAgdmFyIGNpcmNsZURhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgdmFyIHggPSBjaXJjbGVEYXRhLng7XG4gICAgdmFyIHkgPSBjaXJjbGVEYXRhLnk7XG4gICAgdmFyIHdpZHRoO1xuICAgIHZhciBoZWlnaHQ7XG5cbiAgICAvLyBUT0RPIC0gYml0IGhhY2t5Pz9cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5DSVJDKVxuICAgIHtcbiAgICAgICAgd2lkdGggPSBjaXJjbGVEYXRhLnJhZGl1cztcbiAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5yYWRpdXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsU2VncyA9IE1hdGguZmxvb3IoMzAgKiBNYXRoLnNxcnQoY2lyY2xlRGF0YS5yYWRpdXMpKSB8fCBNYXRoLmZsb29yKDE1ICogTWF0aC5zcXJ0KGNpcmNsZURhdGEud2lkdGggKyBjaXJjbGVEYXRhLmhlaWdodCkpO1xuICAgIHZhciBzZWcgPSAoTWF0aC5QSSAqIDIpIC8gdG90YWxTZWdzIDtcblxuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbClcbiAgICB7XG4gICAgICAgIHZhciBjb2xvciA9IHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGgvNjtcblxuICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxTZWdzICsgMSA7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmVydHMucHVzaCh4LHksIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaCh4ICsgTWF0aC5zaW4oc2VnICogaSkgKiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgeSArIE1hdGguY29zKHNlZyAqIGkpICogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MrKywgdmVjUG9zKyspO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1Bvcy0xKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aClcbiAgICB7XG4gICAgICAgIHZhciB0ZW1wUG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsU2VncyArIDE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cy5wdXNoKHggKyBNYXRoLnNpbihzZWcgKiBpKSAqIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKyBNYXRoLmNvcyhzZWcgKiBpKSAqIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBsaW5lIHRvIGRyYXdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7UElYSS5HcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZExpbmUgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgLy8gVE9ETyBPUFRJTUlTRSFcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgdGhlIGxpbmUgd2lkdGggaXMgYW4gb2RkIG51bWJlciBhZGQgMC41IHRvIGFsaWduIHRvIGEgd2hvbGUgcGl4ZWxcbiAgICAvLyBjb21tZW50aW5nIHRoaXMgb3V0IGZpeGVzICM3MTEgYW5kICMxNjIwXG4gICAgLy8gaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGglMilcbiAgICAvLyB7XG4gICAgLy8gICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAgIHBvaW50c1tpXSArPSAwLjU7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG5cbiAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgdmFyIGZpcnN0UG9pbnQgPSBuZXcgbWF0aC5Qb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgdmFyIGxhc3RQb2ludCA9IG5ldyBtYXRoLlBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXG4gICAgLy8gaWYgdGhlIGZpcnN0IHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IC0gZ29ubmEgaGF2ZSBpc3N1ZXMgOilcbiAgICBpZiAoZmlyc3RQb2ludC54ID09PSBsYXN0UG9pbnQueCAmJiBmaXJzdFBvaW50LnkgPT09IGxhc3RQb2ludC55KVxuICAgIHtcbiAgICAgICAgLy8gbmVlZCB0byBjbG9uZSBhcyB3ZSBhcmUgZ29pbmcgdG8gc2xpZ2h0bHkgbW9kaWZ5IHRoZSBzaGFwZS4uXG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5zbGljZSgpO1xuXG4gICAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgICAgcG9pbnRzLnBvcCgpO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IG5ldyBtYXRoLlBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXG4gICAgICAgIHZhciBtaWRQb2ludFggPSBsYXN0UG9pbnQueCArIChmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgKjAuNTtcbiAgICAgICAgdmFyIG1pZFBvaW50WSA9IGxhc3RQb2ludC55ICsgKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqMC41O1xuXG4gICAgICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICAgICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgdmFyIGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleFN0YXJ0ID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAvLyBEUkFXIHRoZSBMaW5lXG4gICAgdmFyIHdpZHRoID0gZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCAvIDI7XG5cbiAgICAvLyBzb3J0IGNvbG9yXG4gICAgdmFyIGNvbG9yID0gdXRpbHMuaGV4MnJnYihncmFwaGljc0RhdGEubGluZUNvbG9yKTtcbiAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEubGluZUFscGhhO1xuICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgdmFyIHB4LCBweSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeTtcbiAgICB2YXIgcGVycHgsIHBlcnB5LCBwZXJwMngsIHBlcnAyeSwgcGVycDN4LCBwZXJwM3k7XG4gICAgdmFyIGExLCBiMSwgYzEsIGEyLCBiMiwgYzI7XG4gICAgdmFyIGRlbm9tLCBwZGlzdCwgZGlzdDtcblxuICAgIHAxeCA9IHBvaW50c1swXTtcbiAgICBwMXkgPSBwb2ludHNbMV07XG5cbiAgICBwMnggPSBwb2ludHNbMl07XG4gICAgcDJ5ID0gcG9pbnRzWzNdO1xuXG4gICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XG4gICAgcGVycHkgPSAgcDF4IC0gcDJ4O1xuXG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJweCpwZXJweCArIHBlcnB5KnBlcnB5KTtcblxuICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgcGVycHkgLz0gZGlzdDtcbiAgICBwZXJweCAqPSB3aWR0aDtcbiAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgIC8vIHN0YXJ0XG4gICAgdmVydHMucHVzaChwMXggLSBwZXJweCAsIHAxeSAtIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgIHZlcnRzLnB1c2gocDF4ICsgcGVycHggLCBwMXkgKyBwZXJweSxcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoLTE7IGkrKylcbiAgICB7XG4gICAgICAgIHAxeCA9IHBvaW50c1soaS0xKSoyXTtcbiAgICAgICAgcDF5ID0gcG9pbnRzWyhpLTEpKjIgKyAxXTtcblxuICAgICAgICBwMnggPSBwb2ludHNbKGkpKjJdO1xuICAgICAgICBwMnkgPSBwb2ludHNbKGkpKjIgKyAxXTtcblxuICAgICAgICBwM3ggPSBwb2ludHNbKGkrMSkqMl07XG4gICAgICAgIHAzeSA9IHBvaW50c1soaSsxKSoyICsgMV07XG5cbiAgICAgICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XG4gICAgICAgIHBlcnB5ID0gcDF4IC0gcDJ4O1xuXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycHgqcGVycHggKyBwZXJweSpwZXJweSk7XG4gICAgICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgICAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgICAgICBwZXJwMnggPSAtKHAyeSAtIHAzeSk7XG4gICAgICAgIHBlcnAyeSA9IHAyeCAtIHAzeDtcblxuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAyeCpwZXJwMnggKyBwZXJwMnkqcGVycDJ5KTtcbiAgICAgICAgcGVycDJ4IC89IGRpc3Q7XG4gICAgICAgIHBlcnAyeSAvPSBkaXN0O1xuICAgICAgICBwZXJwMnggKj0gd2lkdGg7XG4gICAgICAgIHBlcnAyeSAqPSB3aWR0aDtcblxuICAgICAgICBhMSA9ICgtcGVycHkgKyBwMXkpIC0gKC1wZXJweSArIHAyeSk7XG4gICAgICAgIGIxID0gKC1wZXJweCArIHAyeCkgLSAoLXBlcnB4ICsgcDF4KTtcbiAgICAgICAgYzEgPSAoLXBlcnB4ICsgcDF4KSAqICgtcGVycHkgKyBwMnkpIC0gKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KTtcbiAgICAgICAgYTIgPSAoLXBlcnAyeSArIHAzeSkgLSAoLXBlcnAyeSArIHAyeSk7XG4gICAgICAgIGIyID0gKC1wZXJwMnggKyBwMngpIC0gKC1wZXJwMnggKyBwM3gpO1xuICAgICAgICBjMiA9ICgtcGVycDJ4ICsgcDN4KSAqICgtcGVycDJ5ICsgcDJ5KSAtICgtcGVycDJ4ICsgcDJ4KSAqICgtcGVycDJ5ICsgcDN5KTtcblxuICAgICAgICBkZW5vbSA9IGExKmIyIC0gYTIqYjE7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRlbm9tKSA8IDAuMSApXG4gICAgICAgIHtcblxuICAgICAgICAgICAgZGVub20rPTEwLjE7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4ICwgcDJ5IC0gcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4ICwgcDJ5ICsgcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB4ID0gKGIxKmMyIC0gYjIqYzEpL2Rlbm9tO1xuICAgICAgICBweSA9IChhMipjMSAtIGExKmMyKS9kZW5vbTtcblxuXG4gICAgICAgIHBkaXN0ID0gKHB4IC1wMngpICogKHB4IC1wMngpICsgKHB5IC1wMnkpICogKHB5IC1wMnkpO1xuXG5cbiAgICAgICAgaWYgKHBkaXN0ID4gMTQwICogMTQwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwZXJwM3ggPSBwZXJweCAtIHBlcnAyeDtcbiAgICAgICAgICAgIHBlcnAzeSA9IHBlcnB5IC0gcGVycDJ5O1xuXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAzeCpwZXJwM3ggKyBwZXJwM3kqcGVycDN5KTtcbiAgICAgICAgICAgIHBlcnAzeCAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDN5IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJwM3ggKj0gd2lkdGg7XG4gICAgICAgICAgICBwZXJwM3kgKj0gd2lkdGg7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycDN4LCBwMnkgLXBlcnAzeSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJwM3gsIHAyeSArcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC1wZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIGluZGV4Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdmVydHMucHVzaChweCAsIHB5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChweC1wMngpLCBwMnkgLSAocHkgLSBwMnkpKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcDF4ID0gcG9pbnRzWyhsZW5ndGgtMikqMl07XG4gICAgcDF5ID0gcG9pbnRzWyhsZW5ndGgtMikqMiArIDFdO1xuXG4gICAgcDJ4ID0gcG9pbnRzWyhsZW5ndGgtMSkqMl07XG4gICAgcDJ5ID0gcG9pbnRzWyhsZW5ndGgtMSkqMiArIDFdO1xuXG4gICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XG4gICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xuICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgcGVycHkgLz0gZGlzdDtcbiAgICBwZXJweCAqPSB3aWR0aDtcbiAgICBwZXJweSAqPSB3aWR0aDtcblxuICAgIHZlcnRzLnB1c2gocDJ4IC0gcGVycHggLCBwMnkgLSBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4ICwgcDJ5ICsgcGVycHkpO1xuICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGluZGV4Q291bnQ7IGkrKylcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0KyspO1xuICAgIH1cblxuICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0LTEpO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBjb21wbGV4IHBvbHlnb24gdG8gZHJhd1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtQSVhJLkdyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7b2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkQ29tcGxleFBvbHkgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgLy9UT0RPIC0gbm8gbmVlZCB0byBjb3B5IHRoaXMgYXMgaXQgZ2V0cyB0dXJuZWQgaW50byBhIEZMb2F0MzJBcnJheSBhbnl3YXlzLi5cbiAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cy5zbGljZSgpO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCA2KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdldCBmaXJzdCBhbmQgbGFzdCBwb2ludC4uIGZpZ3VyZSBvdXQgdGhlIG1pZGRsZSFcbiAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuICAgIHdlYkdMRGF0YS5wb2ludHMgPSBwb2ludHM7XG4gICAgd2ViR0xEYXRhLmFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcbiAgICB3ZWJHTERhdGEuY29sb3IgPSB1dGlscy5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuXG4gICAgLy8gY2FsY2xhdGUgdGhlIGJvdW5kcy4uXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcblxuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgeCx5O1xuXG4gICAgLy8gZ2V0IHNpemUuLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSs9MilcbiAgICB7XG4gICAgICAgIHggPSBwb2ludHNbaV07XG4gICAgICAgIHkgPSBwb2ludHNbaSsxXTtcblxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG5cbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHF1YWQgdG8gdGhlIGVuZCBjb3MgdGhlcmUgaXMgbm8gcG9pbnQgbWFraW5nIGFub3RoZXIgYnVmZmVyIVxuICAgIHBvaW50cy5wdXNoKG1pblgsIG1pblksXG4gICAgICAgICAgICAgICAgbWF4WCwgbWluWSxcbiAgICAgICAgICAgICAgICBtYXhYLCBtYXhZLFxuICAgICAgICAgICAgICAgIG1pblgsIG1heFkpO1xuXG4gICAgLy8gcHVzaCBhIHF1YWQgb250byB0aGUgZW5kLi5cblxuICAgIC8vVE9ETyAtIHRoaXMgYWludCBuZWVkZWQhXG4gICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaCggaSApO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBwb2x5Z29uIHRvIGRyYXdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZFBvbHkgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDYpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcblxuICAgIC8vIHNvcnQgY29sb3JcbiAgICB2YXIgY29sb3IgPSB1dGlscy5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG4gICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICB2YXIgdHJpYW5nbGVzID0gZWFyY3V0KHBvaW50cywgbnVsbCwgMik7XG5cbiAgICBpZiAoIXRyaWFuZ2xlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkrPTMpXG4gICAge1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzFdICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArIHZlcnRQb3MpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZlcnRzLnB1c2gocG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sXG4gICAgICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9ncmFwaGljcy93ZWJnbC9HcmFwaGljc1JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIFdlYkdMIHNwZWNpZmljIHByb3BlcnRpZXMgdG8gYmUgdXNlZCBieSB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBXZWJHTEdyYXBoaWNzRGF0YShnbCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLy9UT0RPIGRvZXMgdGhpcyBuZWVkIHRvIGJlIHNwbGl0IGJlZm9yZSB1cGxvZGluZz8/XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY29sb3IgY29tcG9uZW50cyAocixnLGIpXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9IFswLDAsMF07IC8vIGNvbG9yIHNwbGl0IVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgcG9pbnRzIHRvIGRyYXdcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50W119XG4gICAgICovXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGJ1ZmZlclxuICAgICAqIEBtZW1iZXIge1dlYkdMQnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggYnVmZmVyXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLyoqXG4gICAgICogdG9kbyBAYWx2aW5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tb2RlID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbHBoYSBvZiB0aGUgZ3JhcGhpY3NcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbHBoYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZ3JhcGhpY3MgaXMgZGlydHkgb3Igbm90XG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuZ2xQb2ludHMgPSBudWxsO1xuICAgIHRoaXMuZ2xJbmRpY2VzID0gbnVsbDtcbn1cblxuV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xHcmFwaGljc0RhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMR3JhcGhpY3NEYXRhO1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgdmVydGljZXMgYW5kIHRoZSBpbmRpY2VzXG4gKi9cbldlYkdMR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgYnVmZmVycyBhbmQgdXBsb2FkcyB0aGUgZGF0YVxuICovXG5XZWJHTEdyYXBoaWNzRGF0YS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbi8vICAgIHRoaXMubGFzdEluZGV4ID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDtcbiAgICB0aGlzLmdsUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBvaW50cyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmdsUG9pbnRzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICB0aGlzLmdsSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5nbEluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbldlYkdMR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29sb3IgPSBudWxsO1xuICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuXG4gICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgIFxuICAgIHRoaXMuZ2wgPSBudWxsO1xuXG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgdGhpcy5nbFBvaW50cyA9IG51bGw7XG4gICAgdGhpcy5nbEluZGljZXMgPSBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvY29yZS9ncmFwaGljcy93ZWJnbC9XZWJHTEdyYXBoaWNzRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSkgcmV0dXJuIHRyaWFuZ2xlcztcblxuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBzaXplO1xuXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgc2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgc2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChzaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0aWNlIGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZWFyLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgdmFyIHAgPSBlYXIubmV4dC5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IGVhci5wcmV2KSB7XG4gICAgICAgIGlmIChwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIG1pblRYID0gYS54IDwgYi54ID8gKGEueCA8IGMueCA/IGEueCA6IGMueCkgOiAoYi54IDwgYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWluVFkgPSBhLnkgPCBiLnkgPyAoYS55IDwgYy55ID8gYS55IDogYy55KSA6IChiLnkgPCBjLnkgPyBiLnkgOiBjLnkpLFxuICAgICAgICBtYXhUWCA9IGEueCA+IGIueCA/IChhLnggPiBjLnggPyBhLnggOiBjLngpIDogKGIueCA+IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1heFRZID0gYS55ID4gYi55ID8gKGEueSA+IGMueSA/IGEueSA6IGMueSkgOiAoYi55ID4gYy55ID8gYi55IDogYy55KTtcblxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgdmFyIG1pblogPSB6T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBzaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgLy8gZmlyc3QgbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgdmFyIHAgPSBlYXIubmV4dFo7XG5cbiAgICB3aGlsZSAocCAmJiBwLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgcCA9IGVhci5wcmV2WjtcblxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKG91dGVyTm9kZSkge1xuICAgICAgICB2YXIgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpO1xuICAgICAgICBmaWx0ZXJQb2ludHMoYiwgYi5uZXh0KTtcbiAgICB9XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC5uZXh0LnkpIHJldHVybiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChoeCA9PT0gcXgpIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG0ubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBzdG9wKSB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmICgodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiBwLnggPiBtLngpKSAmJiBsb2NhbGx5SW5zaWRlKHAsIGhvbGUpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSBudWxsKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxU2l6ZSA9PT0gMCB8fCAhcSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwLnogPD0gcS56KSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgaW5TaXplICo9IDI7XG5cbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBzaXplIG9mIHRoZSBkYXRhIGJvdW5kaW5nIGJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIHNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9IDMyNzY3ICogKHggLSBtaW5YKSAvIHNpemU7XG4gICAgeSA9IDMyNzY3ICogKHkgLSBtaW5ZKSAvIHNpemU7XG5cbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54KSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSAtIChheCAtIHB4KSAqIChjeSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiZcbiAgICAgICAgICAgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKTtcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICBpZiAoKGVxdWFscyhwMSwgcTEpICYmIGVxdWFscyhwMiwgcTIpKSB8fFxuICAgICAgICAoZXF1YWxzKHAxLCBxMikgJiYgZXF1YWxzKHAyLCBxMSkpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gYXJlYShwMSwgcTEsIHAyKSA+IDAgIT09IGFyZWEocDEsIHExLCBxMikgPiAwICYmXG4gICAgICAgICAgIGFyZWEocDIsIHEyLCBwMSkgPiAwICE9PSBhcmVhKHAyLCBxMiwgcTEpID4gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIHZhciBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgcC5wcmV2ID0gcDtcbiAgICAgICAgcC5uZXh0ID0gcDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgcC5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xuICAgICAgICBsYXN0Lm5leHQgPSBwO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG4gICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cbiAgICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gICAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xufVxuXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcbiAgICAvLyB2ZXJ0aWNlIGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRpY2Ugbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gbnVsbDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2VhcmN1dC9zcmMvZWFyY3V0LmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3lzdGVtUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9TeXN0ZW1SZW5kZXJlcicpLFxuICAgIENhbnZhc01hc2tNYW5hZ2VyID0gcmVxdWlyZSgnLi91dGlscy9DYW52YXNNYXNrTWFuYWdlcicpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKSxcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxuLyoqXG4gKiBUaGUgQ2FudmFzUmVuZGVyZXIgZHJhd3MgdGhlIHNjZW5lIGFuZCBhbGwgaXRzIGNvbnRlbnQgb250byBhIDJkIGNhbnZhcy4gVGhpcyByZW5kZXJlciBzaG91bGQgYmUgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB3ZWJHTC5cbiAqIERvbid0IGZvcmdldCB0byBhZGQgdGhlIENhbnZhc1JlbmRlcmVyLnZpZXcgdG8geW91ciBET00gb3IgeW91IHdpbGwgbm90IHNlZSBhbnl0aGluZyA6KVxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFBJWEkuU3lzdGVtUmVuZGVyZXJcbiAqIEBwYXJhbSBbd2lkdGg9ODAwXSB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gW2hlaWdodD02MDBdIHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9IFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gW29wdGlvbnMudmlld10ge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIHRvIHVzZSBhcyBhIHZpZXcsIG9wdGlvbmFsXG4gKiBAcGFyYW0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcbiAqIEBwYXJhbSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0ge2Jvb2xlYW59IHNldHMgYW50aWFsaWFzIChvbmx5IGFwcGxpY2FibGUgaW4gY2hyb21lIGF0IHRoZSBtb21lbnQpXG4gKiBAcGFyYW0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSB7bnVtYmVyfSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyZXIgcmV0aW5hIHdvdWxkIGJlIDJcbiAqIEBwYXJhbSBbb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcj10cnVlXSB7Ym9vbGVhbn0gVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3JcbiAqICAgICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICogQHBhcmFtIFtvcHRpb25zLnJvdW5kUGl4ZWxzPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdHJ1ZSBQaXhpIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gKi9cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpXG57XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBTeXN0ZW1SZW5kZXJlci5jYWxsKHRoaXMsICdDYW52YXMnLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcblxuICAgIHRoaXMudHlwZSA9IENPTlNULlJFTkRFUkVSX1RZUEUuQ0FOVkFTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCb29sZWFuIGZsYWcgY29udHJvbGxpbmcgY2FudmFzIHJlZnJlc2guXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVmcmVzaCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvZiBhIENhbnZhc01hc2tNYW5hZ2VyLCBoYW5kbGVzIG1hc2tpbmcgd2hlbiB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5DYW52YXNNYXNrTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IENhbnZhc01hc2tNYW5hZ2VyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIHByb3BlcnR5IHVzZWQgdG8gc2V0IHRoZSBjYW52YXMgc21vb3RoaW5nIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc21vb3RoUHJvcGVydHkgPSAnaW1hZ2VTbW9vdGhpbmdFbmFibGVkJztcblxuICAgIGlmICghdGhpcy5jb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNtb290aFByb3BlcnR5ID0gJ3dlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5vSW1hZ2VTbW9vdGhpbmdFbmFibGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNtb290aFByb3BlcnR5ID0gJ29JbWFnZVNtb290aGluZ0VuYWJsZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluaXRQbHVnaW5zKCk7XG5cbiAgICB0aGlzLl9tYXBCbGVuZE1vZGVzKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHRlbXBvcmFyeSBkaXNwbGF5IG9iamVjdCB1c2VkIGFzIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCBpdGVtXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IHtcbiAgICAgICAgd29ybGRUcmFuc2Zvcm06IG5ldyBtYXRoLk1hdHJpeCgpLFxuICAgICAgICB3b3JsZEFscGhhOiAxXG4gICAgfTtcblxuXG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG59XG5cbi8vIGNvbnN0cnVjdG9yXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZSk7XG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZW5kZXJlcjtcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzUmVuZGVyZXI7XG51dGlscy5wbHVnaW5UYXJnZXQubWl4aW4oQ2FudmFzUmVuZGVyZXIpO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB0byB0aGlzIGNhbnZhcyB2aWV3XG4gKlxuICogQHBhcmFtIG9iamVjdCB7UElYSS5EaXNwbGF5T2JqZWN0fSB0aGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkXG4gKi9cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob2JqZWN0KVxue1xuICAgIHRoaXMuZW1pdCgncHJlcmVuZGVyJyk7XG5cbiAgICB2YXIgY2FjaGVQYXJlbnQgPSBvYmplY3QucGFyZW50O1xuXG4gICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gb2JqZWN0O1xuXG4gICAgb2JqZWN0LnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBzY2VuZSBncmFwaFxuICAgIG9iamVjdC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIG9iamVjdC5wYXJlbnQgPSBjYWNoZVBhcmVudDtcblxuICAgIHRoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgdGhpcy5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5OT1JNQUxdO1xuXG4gICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTICYmIHRoaXMudmlldy5zY3JlZW5jYW52YXMpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGggLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckRpc3BsYXlPYmplY3Qob2JqZWN0LCB0aGlzLmNvbnRleHQpO1xuXG4gICAgdGhpcy5lbWl0KCdwb3N0cmVuZGVyJyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciBhbmQgb3B0aW9uYWxseSByZW1vdmVzIHRoZSBDYW52YXMgRE9NIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIFtyZW1vdmVWaWV3PWZhbHNlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICovXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmVWaWV3KVxue1xuICAgIHRoaXMuZGVzdHJveVBsdWdpbnMoKTtcblxuICAgIC8vIGNhbGwgdGhlIGJhc2UgZGVzdHJveVxuICAgIFN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgcmVtb3ZlVmlldyk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgdGhpcy5yZWZyZXNoID0gdHJ1ZTtcblxuICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xuXG4gICAgdGhpcy5zbW9vdGhQcm9wZXJ0eSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBkaXNwbGF5IG9iamVjdFxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5T2JqZWN0IHRvIHJlbmRlclxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckRpc3BsYXlPYmplY3QgPSBmdW5jdGlvbiAoZGlzcGxheU9iamVjdCwgY29udGV4dClcbntcbiAgICB2YXIgdGVtcENvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGRpc3BsYXlPYmplY3QucmVuZGVyQ2FudmFzKHRoaXMpO1xuICAgIHRoaXMuY29udGV4dCA9IHRlbXBDb250ZXh0O1xufTtcblxuLyoqXG4gKiBAZXh0ZW5kcyBQSVhJLlN5c3RlbVJlbmRlcmVyI3Jlc2l6ZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gKiBAcGFyYW0ge251bWJlcn0gaFxuICovXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHcsIGgpXG57XG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHcsIGgpO1xuXG4gICAgLy9yZXNldCB0aGUgc2NhbGUgbW9kZS4uIG9kZGx5IHRoaXMgc2VlbXMgdG8gYmUgcmVzZXQgd2hlbiB0aGUgY2FudmFzIGlzIHJlc2l6ZWQuXG4gICAgLy9zdXJlbHkgYSBicm93c2VyIGJ1Zz8/IExldCBwaXhpIGZpeCB0aGF0IGZvciB5b3UuLlxuICAgIGlmKHRoaXMuc21vb3RoUHJvcGVydHkpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHRbdGhpcy5zbW9vdGhQcm9wZXJ0eV0gPSAoQ09OU1QuU0NBTEVfTU9ERVMuREVGQVVMVCA9PT0gQ09OU1QuU0NBTEVfTU9ERVMuTElORUFSKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogTWFwcyBQaXhpIGJsZW5kIG1vZGVzIHRvIGNhbnZhcyBibGVuZCBtb2Rlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuX21hcEJsZW5kTW9kZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy5ibGVuZE1vZGVzKVxuICAgIHtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0ge307XG5cbiAgICAgICAgaWYgKHV0aWxzLmNhblVzZU5ld0NhbnZhc0JsZW5kTW9kZXMoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk5PUk1BTF0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5BRERdICAgICAgICAgICA9ICdsaWdodGVyJzsgLy9JUyBUSElTIE9LPz8/XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTVVMVElQTFldICAgICAgPSAnbXVsdGlwbHknO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNDUkVFTl0gICAgICAgID0gJ3NjcmVlbic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gICAgICAgPSAnb3ZlcmxheSc7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuREFSS0VOXSAgICAgICAgPSAnZGFya2VuJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5MSUdIVEVOXSAgICAgICA9ICdsaWdodGVuJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl9ET0RHRV0gICA9ICdjb2xvci1kb2RnZSc7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfQlVSTl0gICAgPSAnY29sb3ItYnVybic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuSEFSRF9MSUdIVF0gICAgPSAnaGFyZC1saWdodCc7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gICAgPSAnc29mdC1saWdodCc7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuRElGRkVSRU5DRV0gICAgPSAnZGlmZmVyZW5jZSc7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuRVhDTFVTSU9OXSAgICAgPSAnZXhjbHVzaW9uJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5IVUVdICAgICAgICAgICA9ICdodWUnO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNBVFVSQVRJT05dICAgID0gJ3NhdHVyYXRlJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl0gICAgICAgICA9ICdjb2xvcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gICAgPSAnbHVtaW5vc2l0eSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY29vbCBuZXcgYmxlbmQgbW9kZXMgaW4gY2FudmFzICdjb3VnaCcgaWUgJ2NvdWdoJ1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk5PUk1BTF0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5BRERdICAgICAgICAgICA9ICdsaWdodGVyJzsgLy9JUyBUSElTIE9LPz8/XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTVVMVElQTFldICAgICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNDUkVFTl0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5PVkVSTEFZXSAgICAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuREFSS0VOXSAgICAgICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkxJR0hURU5dICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl9ET0RHRV0gICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfQlVSTl0gICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkhBUkRfTElHSFRdICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5TT0ZUX0xJR0hUXSAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuRElGRkVSRU5DRV0gICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5IVUVdICAgICAgICAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SXSAgICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDYW52YXNHcmFwaGljcyA9IHJlcXVpcmUoJy4vQ2FudmFzR3JhcGhpY3MnKTtcblxuLyoqXG4gKiBBIHNldCBvZiBmdW5jdGlvbnMgdXNlZCB0byBoYW5kbGUgbWFza2luZy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmZ1bmN0aW9uIENhbnZhc01hc2tNYW5hZ2VyKClcbnt9XG5cbkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc01hc2tNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNNYXNrTWFuYWdlcjtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hc2tzLlxuICpcbiAqIEBwYXJhbSBtYXNrRGF0YSB7b2JqZWN0fSB0aGUgbWFza0RhdGEgdGhhdCB3aWxsIGJlIHB1c2hlZFxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ8UElYSS5DYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIGNvbnRleHQgdG8gdXNlLlxuICovXG5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaE1hc2sgPSBmdW5jdGlvbiAobWFza0RhdGEsIHJlbmRlcmVyKVxue1xuXG4gICAgcmVuZGVyZXIuY29udGV4dC5zYXZlKCk7XG5cbiAgICB2YXIgY2FjaGVBbHBoYSA9IG1hc2tEYXRhLmFscGhhO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBtYXNrRGF0YS53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG5cbiAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgdHJhbnNmb3JtLmEgKiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc2Zvcm0uYiAqIHJlc29sdXRpb24sXG4gICAgICAgIHRyYW5zZm9ybS5jICogcmVzb2x1dGlvbixcbiAgICAgICAgdHJhbnNmb3JtLmQgKiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc2Zvcm0udHggKiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc2Zvcm0udHkgKiByZXNvbHV0aW9uXG4gICAgKTtcblxuICAgIC8vVE9ETyBzdXBvcnQgc3ByaXRlIGFscGhhIG1hc2tzPz9cbiAgICAvL2xvdHMgb2YgZWZmb3J0IHJlcXVpcmVkLiBJZiBkZW1hbmQgaXMgZ3JlYXQgZW5vdWdoLi5cbiAgICBpZighbWFza0RhdGEudGV4dHVyZSlcbiAgICB7XG4gICAgICAgIENhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzTWFzayhtYXNrRGF0YSwgcmVuZGVyZXIuY29udGV4dCk7XG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQuY2xpcCgpO1xuICAgIH1cblxuICAgIG1hc2tEYXRhLndvcmxkQWxwaGEgPSBjYWNoZUFscGhhO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlcyB0aGUgY3VycmVudCBkcmF3aW5nIGNvbnRleHQgdG8gdGhlIHN0YXRlIGl0IHdhcyBiZWZvcmUgdGhlIG1hc2sgd2FzIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ8UElYSS5DYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIGNvbnRleHQgdG8gdXNlLlxuICovXG5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wTWFzayA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICByZW5kZXJlci5jb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cbkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNNYXNrTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgZXh0cmFzIGxpYnJhcnlcbiAqIEBhdXRob3IgICAgICBNYXQgR3JvdmVzIDxtYXRAZ29vZGJveWRpZ2l0YWwuY29tPlxuICogQGNvcHlyaWdodCAgIDIwMTMtMjAxNSBHb29kQm95RGlnaXRhbFxuICogQGxpY2Vuc2UgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVQgTGljZW5zZX1cbiAqL1xuXG5yZXF1aXJlKCcuL2NhY2hlQXNCaXRtYXAnKTtcbnJlcXVpcmUoJy4vZ2V0Q2hpbGRCeU5hbWUnKTtcbnJlcXVpcmUoJy4vZ2V0R2xvYmFsUG9zaXRpb24nKTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkuZXh0cmFzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE1vdmllQ2xpcDogICAgICByZXF1aXJlKCcuL01vdmllQ2xpcCcpLFxuICAgIFRpbGluZ1Nwcml0ZTogICByZXF1aXJlKCcuL1RpbGluZ1Nwcml0ZScpLFxuICAgIEJpdG1hcFRleHQ6ICAgICByZXF1aXJlKCcuL0JpdG1hcFRleHQnKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZXh0cmFzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBEaXNwbGF5T2JqZWN0ID0gY29yZS5EaXNwbGF5T2JqZWN0LFxuICAgIF90ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxSZW5kZXJXZWJHTCA9IG51bGw7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxSZW5kZXJDYW52YXMgPSBudWxsO1xuXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSBudWxsO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX29yaWdpbmFsSGl0VGVzdCA9IG51bGw7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxEZXN0cm95ID0gbnVsbDtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZWRTcHJpdGUgPSBudWxsO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGlzIGRpc3BsYXkgb2JqZWN0IHRvIGJlIGNhY2hlZCBhcyBhIGJpdG1hcC5cbiAgICAgKiBUaGlzIGJhc2ljYWxseSB0YWtlcyBhIHNuYXAgc2hvdCBvZiB0aGUgZGlzcGxheSBvYmplY3QgYXMgaXQgaXMgYXQgdGhhdCBtb21lbnQuIEl0IGNhbiBwcm92aWRlIGEgcGVyZm9ybWFuY2UgYmVuZWZpdCBmb3IgY29tcGxleCBzdGF0aWMgZGlzcGxheU9iamVjdHMuXG4gICAgICogVG8gcmVtb3ZlIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byAnZmFsc2UnXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICovXG4gICAgY2FjaGVBc0JpdG1hcDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQXNCaXRtYXAgPT09IHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSZW5kZXJXZWJHTCA9IHRoaXMucmVuZGVyV2ViR0w7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSZW5kZXJDYW52YXMgPSB0aGlzLnJlbmRlckNhbnZhcztcblxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsVXBkYXRlVHJhbnNmb3JtID0gdGhpcy51cGRhdGVUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxHZXRCb3VuZHMgPSB0aGlzLmdldEJvdW5kcztcblxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsRGVzdHJveSA9IHRoaXMuZGVzdHJveTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsQ29udGFpbnNQb2ludCA9IHRoaXMuY29udGFpbnNQb2ludDtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyV2ViR0wgPSB0aGlzLl9yZW5kZXJDYWNoZWRXZWJHTDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX3JlbmRlckNhY2hlZENhbnZhcztcblxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IHRoaXMuX2NhY2hlQXNCaXRtYXBEZXN0cm95O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlZFNwcml0ZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJXZWJHTCA9IHRoaXMuX29yaWdpbmFsUmVuZGVyV2ViR0w7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9vcmlnaW5hbFJlbmRlckNhbnZhcztcbiAgICAgICAgICAgICAgICB0aGlzLmdldEJvdW5kcyA9IHRoaXMuX29yaWdpbmFsR2V0Qm91bmRzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95ID0gdGhpcy5fb3JpZ2luYWxEZXN0cm95O1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLl9vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSB0aGlzLl9vcmlnaW5hbENvbnRhaW5zUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIFdlYkdMXG4qXG4qIEBwYXJhbSByZW5kZXJlciB7UElYSS5XZWJHTFJlbmRlcmVyfSB0aGUgV2ViR0wgcmVuZGVyZXJcbiogQHByaXZhdGVcbiovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FjaGVkV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSlcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdCggcmVuZGVyZXIgKTtcblxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuXG4gICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5zcHJpdGUpO1xuICAgIHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlLnJlbmRlciggdGhpcy5fY2FjaGVkU3ByaXRlICk7XG59O1xuXG4vKipcbiogUHJlcGFyZXMgdGhlIFdlYkdMIHJlbmRlcmVyIHRvIGNhY2hlIHRoZSBzcHJpdGVcbipcbiogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IHRoZSBXZWJHTCByZW5kZXJlclxuKiBAcHJpdmF0ZVxuKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICBpZih0aGlzLl9jYWNoZWRTcHJpdGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZmlyc3Qgd2UgZmx1c2ggYW55dGhpbmcgbGVmdCBpbiB0aGUgcmVuZGVyZXIgKG90aGVyd2lzZSBpdCB3b3VsZCBnZXQgcmVuZGVyZWQgdG8gdGhlIGNhY2hlZCB0ZXh0dXJlKVxuICAgIHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xuICAgIC8vdGhpcy5maWx0ZXJzPSBbXTtcbiAgICAvLyBuZXh0IHdlIGZpbmQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHVudHJhbnNmb3JtZWQgb2JqZWN0XG4gICAgLy8gdGhpcyBmdW5jdGlvbiBhbHNvIGNhbGxzIHVwZGF0ZXRyYW5zZm9ybSBvbiBhbGwgaXRzIGNoaWxkcmVuIGFzIHBhcnQgb2YgdGhlIG1lYXN1cmluZy4gVGhpcyBtZWFucyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgdHJhbnNmb3JtIGFnYWluIGluIHRoaXMgZnVuY3Rpb25cbiAgICAvLyBUT0RPIHBhc3MgYW4gb2JqZWN0IHRvIGNsb25lIHRvbz8gc2F2ZXMgaGF2aW5nIHRvIGNyZWF0ZSBhIG5ldyBvbmUgZWFjaCB0aW1lIVxuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCkuY2xvbmUoKTtcblxuICAgIC8vIGFkZCBzb21lIHBhZGRpbmchXG4gICAgaWYodGhpcy5fZmlsdGVycylcbiAgICB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5fZmlsdGVyc1swXS5wYWRkaW5nO1xuICAgICAgICBib3VuZHMueCAtPSBwYWRkaW5nO1xuICAgICAgICBib3VuZHMueSAtPSBwYWRkaW5nO1xuXG4gICAgICAgIGJvdW5kcy53aWR0aCArPSBwYWRkaW5nICogMjtcbiAgICAgICAgYm91bmRzLmhlaWdodCArPSBwYWRkaW5nICogMjtcbiAgICB9XG5cbiAgICAvLyBmb3Igbm93IHdlIGNhY2hlIHRoZSBjdXJyZW50IHJlbmRlclRhcmdldCB0aGF0IHRoZSB3ZWJHTCByZW5kZXJlciBpcyBjdXJyZW50bHkgdXNpbmcuXG4gICAgLy8gdGhpcyBjb3VsZCBiZSBtb3JlIGVsZWdlbnQuLlxuICAgIHZhciBjYWNoZWRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0O1xuICAgIC8vIFdlIGFsc28gc3RvcmUgdGhlIGZpbHRlciBzdGFjayAtIEkgd2lsbCBkZWZpbml0ZWx5IGxvb2sgdG8gY2hhbmdlIGhvdyB0aGlzIHdvcmtzIGEgbGl0dGxlIGxhdGVyIGRvd24gdGhlIGxpbmUuXG4gICAgdmFyIHN0YWNrID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5maWx0ZXJTdGFjaztcblxuICAgIC8vIHRoaXMgcmVuZGVyVGV4dHVyZSB3aWxsIGJlIHVzZWQgdG8gc3RvcmUgdGhlIGNhY2hlZCBEaXNwbGF5T2JqZWN0XG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgY29yZS5SZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCBib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCk7XG5cbiAgICAvLyBuZWVkIHRvIHNldCAvL1xuICAgIHZhciBtID0gX3RlbXBNYXRyaXg7XG5cbiAgICBtLnR4ID0gLWJvdW5kcy54O1xuICAgIG0udHkgPSAtYm91bmRzLnk7XG5cblxuXG4gICAgLy8gc2V0IGFsbCBwcm9wZXJ0aWVzIHRvIHRoZXJlIG9yaWdpbmFsIHNvIHdlIGNhbiByZW5kZXIgdG8gYSB0ZXh0dXJlXG4gICAgdGhpcy5yZW5kZXJXZWJHTCA9IHRoaXMuX29yaWdpbmFsUmVuZGVyV2ViR0w7XG5cbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLCBtLCB0cnVlLCB0cnVlKTtcblxuICAgIC8vIG5vdyByZXN0b3JlIHRoZSBzdGF0ZSBiZSBzZXR0aW5nIHRoZSBuZXcgcHJvcGVydGllc1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjYWNoZWRSZW5kZXJUYXJnZXQpO1xuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZmlsdGVyU3RhY2sgPSBzdGFjaztcblxuICAgIHRoaXMucmVuZGVyV2ViR0wgICAgID0gdGhpcy5fcmVuZGVyQ2FjaGVkV2ViR0w7XG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XG4gICAgdGhpcy5nZXRCb3VuZHMgICAgICAgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHM7XG5cblxuICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG5ldyBjb3JlLlNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLSggYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0ICk7XG5cbiAgICAvLyByZXN0b3JlIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIGNhY2hlZCBzcHJpdGUgdG8gYXZvaWQgdGhlIG5hc3R5IGZsaWNrZXIuLlxuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvLyBtYXAgdGhlIGhpdCB0ZXN0Li5cbiAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSB0aGlzLl9jYWNoZWRTcHJpdGUuY29udGFpbnNQb2ludC5iaW5kKHRoaXMuX2NhY2hlZFNwcml0ZSk7XG59O1xuXG4vKipcbiogUmVuZGVycyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBzcHJpdGUgd2l0aCBjYW52YXNcbipcbiogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qIEBwcml2YXRlXG4qL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZENhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzKCByZW5kZXJlciApO1xuXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUucmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbn07XG5cbi8vVE9ETyB0aGlzIGNhbiBiZSB0aGUgc2FtZSBhcyB0aGUgd2ViR0wgdmVyaXNvbi4uIHdpbGwgbmVlZCB0byBkbyBhIGxpdHRsZSB0d2Vha2luZyBmaXJzdCB0aG91Z2guLlxuLyoqXG4qIFByZXBhcmVzIHRoZSBDYW52YXMgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxuKlxuKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IHRoZSBDYW52YXMgcmVuZGVyZXJcbiogQHByaXZhdGVcbiovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgaWYodGhpcy5fY2FjaGVkU3ByaXRlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vZ2V0IGJvdW5kcyBhY3R1YWxseSB0cmFuc2Zvcm1zIHRoZSBvYmplY3QgZm9yIHVzIGFscmVhZHkhXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcblxuICAgIHZhciBjYWNoZWRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5jb250ZXh0O1xuXG4gICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgY29yZS5SZW5kZXJUZXh0dXJlKHJlbmRlcmVyLCBib3VuZHMud2lkdGggfCAwLCBib3VuZHMuaGVpZ2h0IHwgMCk7XG5cbiAgICAvLyBuZWVkIHRvIHNldCAvL1xuICAgIHZhciBtID0gX3RlbXBNYXRyaXg7XG5cbiAgICBtLnR4ID0gLWJvdW5kcy54O1xuICAgIG0udHkgPSAtYm91bmRzLnk7XG5cbiAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcbiAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX29yaWdpbmFsUmVuZGVyQ2FudmFzO1xuXG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcywgbSwgdHJ1ZSk7XG5cbiAgICAvLyBub3cgcmVzdG9yZSB0aGUgc3RhdGUgYmUgc2V0dGluZyB0aGUgbmV3IHByb3BlcnRpZXNcbiAgICByZW5kZXJlci5jb250ZXh0ID0gY2FjaGVkUmVuZGVyVGFyZ2V0O1xuXG4gICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XG4gICAgdGhpcy5nZXRCb3VuZHMgID0gdGhpcy5fZ2V0Q2FjaGVkQm91bmRzO1xuXG5cbiAgICAvLyBjcmVhdGUgb3VyIGNhY2hlZCBzcHJpdGVcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBuZXcgY29yZS5TcHJpdGUocmVuZGVyVGV4dHVyZSk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKCBib3VuZHMueCAvIGJvdW5kcy53aWR0aCApO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oIGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCApO1xuXG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIHRoaXMuY29udGFpbnNQb2ludCA9IHRoaXMuX2NhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQodGhpcy5fY2FjaGVkU3ByaXRlKTtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIGNhY2hlZCBzcHJpdGVcbipcbiogQHByaXZhdGVcbiovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZ2V0Q2FjaGVkQm91bmRzID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNwcml0ZS5nZXRCb3VuZHMoKTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGUgY2FjaGVkIHNwcml0ZS5cbipcbiogQHByaXZhdGVcbiovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5fdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbnVsbDtcbn07XG5cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwRGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgdGhpcy5fb3JpZ2luYWxEZXN0cm95KCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9leHRyYXMvY2FjaGVBc0JpdG1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogVGhlIGluc3RhbmNlIG5hbWUgb2YgdGhlIG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICogQG1lbWJlciB7c3RyaW5nfVxuICovXG5jb3JlLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLm5hbWUgPSBudWxsO1xuXG4vKipcbiogUmV0dXJucyB0aGUgZGlzcGxheSBvYmplY3QgaW4gdGhlIGNvbnRhaW5lclxuKlxuKiBAbWVtYmVyb2YgUElYSS5Db250YWluZXIjXG4qIEBwYXJhbSBuYW1lIHtzdHJpbmd9IGluc3RhbmNlIG5hbWVcbiogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fVxuKi9cbmNvcmUuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZXh0cmFzL2dldENoaWxkQnlOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdFxuKlxuKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuKiBAcGFyYW0gcG9pbnQge1BvaW50fSB0aGUgcG9pbnQgdG8gd3JpdGUgdGhlIGdsb2JhbCB2YWx1ZSB0by4gSWYgbnVsbCBhIG5ldyBwb2ludCB3aWxsIGJlIHJldHVybmVkXG4qIEByZXR1cm4ge1BvaW50fVxuKi9cbmNvcmUuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2V0R2xvYmFsUG9zaXRpb24gPSBmdW5jdGlvbiAocG9pbnQpXG57XG4gICAgcG9pbnQgPSBwb2ludCB8fCBuZXcgY29yZS5Qb2ludCgpO1xuXG4gICAgaWYodGhpcy5wYXJlbnQpXG4gICAge1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICBwb2ludC54ID0gdGhpcy53b3JsZFRyYW5zZm9ybS50eDtcbiAgICAgICAgcG9pbnQueSA9IHRoaXMud29ybGRUcmFuc2Zvcm0udHk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHBvaW50LnggPSB0aGlzLnBvc2l0aW9uLng7XG4gICAgICAgIHBvaW50LnkgPSB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZXh0cmFzL2dldEdsb2JhbFBvc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBBIE1vdmllQ2xpcCBpcyBhIHNpbXBsZSB3YXkgdG8gZGlzcGxheSBhbiBhbmltYXRpb24gZGVwaWN0ZWQgYnkgYSBsaXN0IG9mIHRleHR1cmVzLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYWxpZW5JbWFnZXMgPSBbXCJpbWFnZV9zZXF1ZW5jZV8wMS5wbmdcIixcImltYWdlX3NlcXVlbmNlXzAyLnBuZ1wiLFwiaW1hZ2Vfc2VxdWVuY2VfMDMucG5nXCIsXCJpbWFnZV9zZXF1ZW5jZV8wNC5wbmdcIl07XG4gKiB2YXIgdGV4dHVyZUFycmF5ID0gW107XG4gKlxuICogZm9yICh2YXIgaT0wOyBpIDwgNDsgaSsrKVxuICoge1xuICogICAgICB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoYWxpZW5JbWFnZXNbaV0pO1xuICogICAgICB0ZXh0dXJlQXJyYXkucHVzaCh0ZXh0dXJlKTtcbiAqIH07XG4gKlxuICogdmFyIG1jID0gbmV3IFBJWEkuTW92aWVDbGlwKHRleHR1cmVBcnJheSk7XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuU3ByaXRlXG4gKiBAbWVtYmVyb2YgUElYSS5leHRyYXNcbiAqIEBwYXJhbSB0ZXh0dXJlcyB7UElYSS5UZXh0dXJlW118T2JqZWN0W119IGFuIGFycmF5IG9mIHtAbGluayBQSVhJLlRleHR1cmV9IG9yIGZyYW1lIG9iamVjdHMgdGhhdCBtYWtlIHVwIHRoZSBhbmltYXRpb25cbiAqIEBwYXJhbSB0ZXh0dXJlc1tdLnRleHR1cmUge1BJWEkuVGV4dHVyZX0gdGhlIHtAbGluayBQSVhJLlRleHR1cmV9IG9mIHRoZSBmcmFtZVxuICogQHBhcmFtIHRleHR1cmVzW10udGltZSB7bnVtYmVyfSB0aGUgZHVyYXRpb24gb2YgdGhlIGZyYW1lIGluIG1zXG4gKi9cbmZ1bmN0aW9uIE1vdmllQ2xpcCh0ZXh0dXJlcylcbntcbiAgICBjb3JlLlNwcml0ZS5jYWxsKHRoaXMsIHRleHR1cmVzWzBdIGluc3RhbmNlb2YgY29yZS5UZXh0dXJlID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlc1swXS50ZXh0dXJlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGV4dHVyZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwZWVkIHRoYXQgdGhlIE1vdmllQ2xpcCB3aWxsIHBsYXkgYXQuIEhpZ2hlciBpcyBmYXN0ZXIsIGxvd2VyIGlzIHNsb3dlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb3ZpZSBjbGlwIHJlcGVhdHMgYWZ0ZXIgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMubG9vcCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBNb3ZpZUNsaXAgZmluaXNoZXMgcGxheWluZ1xuICAgICAqXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5Nb3ZpZUNsaXAjXG4gICAgICovXG4gICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEVsYXBzZWQgdGltZSBzaW5jZSBhbmltYXRpb24gaGFzIGJlZW4gc3RhcnRlZCwgdXNlZCBpbnRlcm5hbGx5IHRvIGRpc3BsYXkgY3VycmVudCB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIE1vdmllQ2xpcCBpcyBjdXJyZW50bHkgcGxheWluZ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbn1cblxuLy8gY29uc3RydWN0b3Jcbk1vdmllQ2xpcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuU3ByaXRlLnByb3RvdHlwZSk7XG5Nb3ZpZUNsaXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW92aWVDbGlwO1xubW9kdWxlLmV4cG9ydHMgPSBNb3ZpZUNsaXA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1vdmllQ2xpcC5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiB0b3RhbEZyYW1lcyBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgTW92aWVDbGlwLiBUaGlzIGlzIHRoZSBzYW1lIGFzIG51bWJlciBvZiB0ZXh0dXJlc1xuICAgICAqIGFzc2lnbmVkIHRvIHRoZSBNb3ZpZUNsaXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLk1vdmllQ2xpcCNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdG90YWxGcmFtZXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IG9mIHRleHR1cmVzIHVzZWQgZm9yIHRoaXMgTW92aWVDbGlwXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVbXX1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5leHRyYXMuTW92aWVDbGlwI1xuICAgICAqXG4gICAgICovXG4gICAgdGV4dHVyZXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih2YWx1ZVswXSBpbnN0YW5jZW9mIGNvcmUuVGV4dHVyZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKHZhbHVlW2ldLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMucHVzaCh2YWx1ZVtpXS50aW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBUaGUgTW92aWVDbGlwcyBjdXJyZW50IGZyYW1lIGluZGV4XG4gICAgKlxuICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLk1vdmllQ2xpcCNcbiAgICAqIEByZWFkb25seVxuICAgICovXG4gICAgY3VycmVudEZyYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpICUgdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZyYW1lICs9IHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RnJhbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG4vKipcbiAqIFN0b3BzIHRoZSBNb3ZpZUNsaXBcbiAqXG4gKi9cbk1vdmllQ2xpcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYoIXRoaXMucGxheWluZylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBjb3JlLnRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbn07XG5cbi8qKlxuICogUGxheXMgdGhlIE1vdmllQ2xpcFxuICpcbiAqL1xuTW92aWVDbGlwLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZih0aGlzLnBsYXlpbmcpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICBjb3JlLnRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzKTtcbn07XG5cbi8qKlxuICogU3RvcHMgdGhlIE1vdmllQ2xpcCBhbmQgZ29lcyB0byBhIHNwZWNpZmljIGZyYW1lXG4gKlxuICogQHBhcmFtIGZyYW1lTnVtYmVyIHtudW1iZXJ9IGZyYW1lIGluZGV4IHRvIHN0b3AgYXRcbiAqL1xuTW92aWVDbGlwLnByb3RvdHlwZS5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uIChmcmFtZU51bWJlcilcbntcbiAgICB0aGlzLnN0b3AoKTtcblxuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gZnJhbWVOdW1iZXI7XG5cbiAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbdGhpcy5jdXJyZW50RnJhbWVdO1xufTtcblxuLyoqXG4gKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBNb3ZpZUNsaXBcbiAqXG4gKiBAcGFyYW0gZnJhbWVOdW1iZXIge251bWJlcn0gZnJhbWUgaW5kZXggdG8gc3RhcnQgYXRcbiAqL1xuTW92aWVDbGlwLnByb3RvdHlwZS5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uIChmcmFtZU51bWJlcilcbntcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IGZyYW1lTnVtYmVyO1xuXG4gICAgdGhpcy5wbGF5KCk7XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3ZpZUNsaXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YVRpbWUpXG57XG4gICAgdmFyIGVsYXBzZWQgPSB0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lO1xuXG4gICAgaWYgKHRoaXMuX2R1cmF0aW9ucyAhPT0gbnVsbClcbiAgICB7XG4gICAgICAgIHZhciBsYWcgPSB0aGlzLl9jdXJyZW50VGltZSAlIDEgKiB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuXG4gICAgICAgIGxhZyArPSBlbGFwc2VkIC8gNjAgKiAxMDAwO1xuXG4gICAgICAgIHdoaWxlIChsYWcgPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZS0tO1xuICAgICAgICAgICAgbGFnICs9IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbih0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBNYXRoLmZsb29yKHRoaXMuX2N1cnJlbnRUaW1lKTtcblxuICAgICAgICB3aGlsZSAobGFnID49IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhZyAtPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdICogc2lnbjtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IHNpZ247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBsYWcgLyB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBlbGFwc2VkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50VGltZSA8IDAgJiYgIXRoaXMubG9vcClcbiAgICB7XG4gICAgICAgIHRoaXMuZ290b0FuZFN0b3AoMCk7XG5cbiAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fY3VycmVudFRpbWUgPj0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoICYmICF0aGlzLmxvb3ApXG4gICAge1xuICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIGlmICh0aGlzLm9uQ29tcGxldGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgfVxuXG59O1xuXG4vKlxuICogU3RvcHMgdGhlIE1vdmllQ2xpcCBhbmQgZGVzdHJveXMgaXRcbiAqXG4gKi9cbk1vdmllQ2xpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICggKVxue1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGNvcmUuU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSBtb3ZpZWNsaXAgZnJvbSBhbiBhcnJheSBvZiBmcmFtZSBpZHNcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZnJhbWVzIHtzdHJpbmdbXX0gdGhlIGFycmF5IG9mIGZyYW1lcyBpZHMgdGhlIG1vdmllY2xpcCB3aWxsIHVzZSBhcyBpdHMgdGV4dHVyZSBmcmFtZXNcbiAqL1xuTW92aWVDbGlwLmZyb21GcmFtZXMgPSBmdW5jdGlvbiAoZnJhbWVzKVxue1xuICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyArK2kpXG4gICAge1xuICAgICAgICB0ZXh0dXJlcy5wdXNoKG5ldyBjb3JlLlRleHR1cmUuZnJvbUZyYW1lKGZyYW1lc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTW92aWVDbGlwKHRleHR1cmVzKTtcbn07XG5cbi8qKlxuICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIG1vdmllY2xpcCBmcm9tIGFuIGFycmF5IG9mIGltYWdlIGlkc1xuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBpbWFnZXMge3N0cmluZ1tdfSB0aGUgYXJyYXkgb2YgaW1hZ2UgdXJscyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lc1xuICovXG5Nb3ZpZUNsaXAuZnJvbUltYWdlcyA9IGZ1bmN0aW9uIChpbWFnZXMpXG57XG4gICAgdmFyIHRleHR1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIHRleHR1cmVzLnB1c2gobmV3IGNvcmUuVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNb3ZpZUNsaXAodGV4dHVyZXMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2V4dHJhcy9Nb3ZpZUNsaXAuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpLFxuICAgIC8vIGEgc3ByaXRlIHVzZSBkZm9yIHJlbmRlcmluZyB0ZXh0dXJlcy4uXG4gICAgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKSxcbiAgICBDYW52YXNUaW50ZXIgPSByZXF1aXJlKCcuLi9jb3JlL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzVGludGVyJyk7XG5cbi8qKlxuICogQSB0aWxpbmcgc3ByaXRlIGlzIGEgZmFzdCB3YXkgb2YgcmVuZGVyaW5nIGEgdGlsaW5nIGltYWdlXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLlNwcml0ZVxuICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSAgdGhlIHdpZHRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAqL1xuZnVuY3Rpb24gVGlsaW5nU3ByaXRlKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgY29yZS5TcHJpdGUuY2FsbCh0aGlzLCB0ZXh0dXJlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsaW5nIG9mIHRoZSBpbWFnZSB0aGF0IGlzIGJlaW5nIHRpbGVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqL1xuICAgIHRoaXMudGlsZVNjYWxlID0gbmV3IGNvcmUuUG9pbnQoMSwxKTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVQb3NpdGlvbiA9IG5ldyBjb3JlLlBvaW50KDAsMCk7XG5cbiAgICAvLy8vLyBwcml2YXRlXG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2l0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aCB8fCAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgMTAwO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVVdnN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl91dnMgPSBuZXcgY29yZS5UZXh0dXJlVXZzKCk7XG5cbiAgICB0aGlzLl9jYW52YXNQYXR0ZXJuID0gbnVsbDtcblxuICAgIC8vVE9ETyBtb3ZlLi5cbiAgICB0aGlzLnNoYWRlciA9IG5ldyBjb3JlLkFic3RyYWN0RmlsdGVyKFxuXG4gICAgICBbXG4gICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7JyxcblxuICAgICAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcblxuICAgICAgICAndW5pZm9ybSB2ZWM0IHVGcmFtZTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IHVUcmFuc2Zvcm07JyxcblxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsnLFxuXG4gICAgICAgICcgICB2ZWMyIGNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxuICAgICAgICAnICAgY29vcmQgLT0gdVRyYW5zZm9ybS54eTsnLFxuICAgICAgICAnICAgY29vcmQgLz0gdVRyYW5zZm9ybS56dzsnLFxuICAgICAgICAnICAgdlRleHR1cmVDb29yZCA9IGNvb3JkOycsXG5cbiAgICAgICAgJyAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7JyxcbiAgICAgICAgJ30nXG4gICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgW1xuICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcblxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1RnJhbWU7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiB1UGl4ZWxTaXplOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuXG4gICAgICAgICcgICB2ZWMyIGNvb3JkID0gbW9kKHZUZXh0dXJlQ29vcmQsIHVGcmFtZS56dyk7JyxcbiAgICAgICAgJyAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVQaXhlbFNpemUsIHVGcmFtZS56dyAtIHVQaXhlbFNpemUpOycsXG4gICAgICAgICcgICBjb29yZCArPSB1RnJhbWUueHk7JyxcblxuICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gIHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpICogdkNvbG9yIDsnLFxuICAgICAgICAnfSdcbiAgICAgIF0uam9pbignXFxuJyksXG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1RnJhbWU6IHsgdHlwZTogJzRmdicsIHZhbHVlOiBbMCwwLDEsMV0gfSxcbiAgICAgICAgICAgICAgICB1VHJhbnNmb3JtOiB7IHR5cGU6ICc0ZnYnLCB2YWx1ZTogWzAsMCwxLDFdIH0sXG4gICAgICAgICAgICAgICAgdVBpeGVsU2l6ZSA6IHsgdHlwZSA6ICcyZnYnLCB2YWx1ZTogWzEsIDFdfVxuICAgICAgICAgICAgfVxuICAgICAgKTtcbn1cblxuVGlsaW5nU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5TcHJpdGUucHJvdG90eXBlKTtcblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxpbmdTcHJpdGU7XG5tb2R1bGUuZXhwb3J0cyA9IFRpbGluZ1Nwcml0ZTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWxpbmdTcHJpdGUucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZSNcbiAgICAgKi9cbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGlsaW5nU3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGUjXG4gICAgICovXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuO1xufTtcblxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIC8vIHR3ZWFrIG91ciB0ZXh0dXJlIHRlbXBvcmFyaWx5Li5cbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG5cbiAgICBpZighdGV4dHVyZSB8fCAhdGV4dHVyZS5fdXZzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZW1wVXZzID0gdGV4dHVyZS5fdXZzLFxuICAgICAgICB0ZW1wV2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aCxcbiAgICAgICAgdGVtcEhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCxcbiAgICAgICAgdHcgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoLFxuICAgICAgICB0aCA9IHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgdGV4dHVyZS5fdXZzID0gdGhpcy5fdXZzO1xuICAgIHRleHR1cmUuX2ZyYW1lLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVQaXhlbFNpemUudmFsdWVbMF0gPSAxLjAvdHc7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudVBpeGVsU2l6ZS52YWx1ZVsxXSA9IDEuMC90aDtcblxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVGcmFtZS52YWx1ZVswXSA9IHRlbXBVdnMueDA7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudUZyYW1lLnZhbHVlWzFdID0gdGVtcFV2cy55MDtcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51RnJhbWUudmFsdWVbMl0gPSB0ZW1wVXZzLngxIC0gdGVtcFV2cy54MDtcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51RnJhbWUudmFsdWVbM10gPSB0ZW1wVXZzLnkyIC0gdGVtcFV2cy55MDtcblxuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVUcmFuc2Zvcm0udmFsdWVbMF0gPSAodGhpcy50aWxlUG9zaXRpb24ueCAlICh0ZW1wV2lkdGggKiB0aGlzLnRpbGVTY2FsZS54KSkgLyB0aGlzLl93aWR0aDtcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51VHJhbnNmb3JtLnZhbHVlWzFdID0gKHRoaXMudGlsZVBvc2l0aW9uLnkgJSAodGVtcEhlaWdodCAqIHRoaXMudGlsZVNjYWxlLnkpKSAvIHRoaXMuX2hlaWdodDtcbiAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51VHJhbnNmb3JtLnZhbHVlWzJdID0gKCB0dyAvIHRoaXMuX3dpZHRoICkgKiB0aGlzLnRpbGVTY2FsZS54O1xuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVUcmFuc2Zvcm0udmFsdWVbM10gPSAoIHRoIC8gdGhpcy5faGVpZ2h0ICkgKiB0aGlzLnRpbGVTY2FsZS55O1xuXG4gICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5zcHJpdGUpO1xuICAgIHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlLnJlbmRlcih0aGlzKTtcblxuICAgIHRleHR1cmUuX3V2cyA9IHRlbXBVdnM7XG4gICAgdGV4dHVyZS5fZnJhbWUud2lkdGggPSB0ZW1wV2lkdGg7XG4gICAgdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gdGVtcEhlaWdodDtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9IGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgcmVuZGVyZXJcbiAqIEBwcml2YXRlXG4gKi9cblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG5cbiAgICBpZiAoIXRleHR1cmUuYmFzZVRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQsXG4gICAgICAgIHRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm0sXG4gICAgICAgIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUsXG4gICAgICAgIG1vZFggPSAodGhpcy50aWxlUG9zaXRpb24ueCAvIHRoaXMudGlsZVNjYWxlLngpICUgdGV4dHVyZS5fZnJhbWUud2lkdGgsXG4gICAgICAgIG1vZFkgPSAodGhpcy50aWxlUG9zaXRpb24ueSAvIHRoaXMudGlsZVNjYWxlLnkpICUgdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xuXG4gICAgLy8gY3JlYXRlIGEgbmljZSBzaGlueSBwYXR0ZXJuIVxuICAgIC8vIFRPRE8gdGhpcyBuZWVkcyB0byBiZSByZWZyZXNoZWQgaWYgdGV4dHVyZSBjaGFuZ2VzLi5cbiAgICBpZighdGhpcy5fY2FudmFzUGF0dGVybilcbiAgICB7XG4gICAgICAgIC8vIGN1dCBhbiBvYmplY3QgZnJvbSBhIHNwcml0ZXNoZWV0Li5cbiAgICAgICAgdmFyIHRlbXBDYW52YXMgPSBuZXcgY29yZS5DYW52YXNCdWZmZXIodGV4dHVyZS5fZnJhbWUud2lkdGggKiByZXNvbHV0aW9uLCB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uKTtcblxuICAgICAgICAvLyBUaW50IHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICAgIGlmICh0aGlzLnRpbnQgIT09IDB4RkZGRkZGKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZWRUaW50ICE9PSB0aGlzLnRpbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gdGhpcy50aW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy50aW50ZWRUZXh0dXJlID0gQ2FudmFzVGludGVyLmdldFRpbnRlZFRleHR1cmUodGhpcywgdGhpcy50aW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDYW52YXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy50aW50ZWRUZXh0dXJlLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRlbXBDYW52YXMuY29udGV4dC5kcmF3SW1hZ2UoYmFzZVRleHR1cmUuc291cmNlLCAtdGV4dHVyZS5fZnJhbWUueCAqIHJlc29sdXRpb24sIC10ZXh0dXJlLl9mcmFtZS55ICogcmVzb2x1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FudmFzUGF0dGVybiA9IHRlbXBDYW52YXMuY29udGV4dC5jcmVhdGVQYXR0ZXJuKCB0ZW1wQ2FudmFzLmNhbnZhcywgJ3JlcGVhdCcgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgY29udGV4dCBzdGF0ZS4uXG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSAqIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5iICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmMgKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZCAqIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50eCAqIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50eSAqIHJlc29sdXRpb24pO1xuXG4gICAgLy8gVE9ETyAtIHRoaXMgc2hvdWxkIGJlIHJvbGxlZCBpbnRvIHRoZSBzZXRUcmFuc2Zvcm0gYWJvdmUuLlxuICAgIGNvbnRleHQuc2NhbGUodGhpcy50aWxlU2NhbGUueCAvIHJlc29sdXRpb24sIHRoaXMudGlsZVNjYWxlLnkgLyByZXNvbHV0aW9uKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKG1vZFggKyAodGhpcy5hbmNob3IueCAqIC10aGlzLl93aWR0aCApLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZFkgKyAodGhpcy5hbmNob3IueSAqIC10aGlzLl9oZWlnaHQpKTtcblxuICAgIC8vIGNoZWNrIGJsZW5kIG1vZGVcbiAgICB2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gcmVuZGVyZXIuYmxlbmRNb2Rlc1t0aGlzLmJsZW5kTW9kZV07XG4gICAgaWYgKGNvbXBvc2l0ZU9wZXJhdGlvbiAhPT0gcmVuZGVyZXIuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pXG4gICAge1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBmaWxsIHRoZSBwYXR0ZXJuIVxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fY2FudmFzUGF0dGVybjtcbiAgICBjb250ZXh0LmZpbGxSZWN0KC1tb2RYLFxuICAgICAgICAgICAgICAgICAgICAgLW1vZFksXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCAqIHJlc29sdXRpb24gLyB0aGlzLnRpbGVTY2FsZS54LFxuICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0ICogcmVzb2x1dGlvbiAvIHRoaXMudGlsZVNjYWxlLnkpO1xuXG5cbiAgICAvL1RPRE8gLSBwcmV0dHkgc3VyZSB0aGlzIGNhbiBiZSBkZWxldGVkLi4uXG4gICAgLy9jb250ZXh0LnRyYW5zbGF0ZSgtdGhpcy50aWxlUG9zaXRpb24ueCArICh0aGlzLmFuY2hvci54ICogdGhpcy5fd2lkdGgpLCAtdGhpcy50aWxlUG9zaXRpb24ueSArICh0aGlzLmFuY2hvci55ICogdGhpcy5faGVpZ2h0KSk7XG4gICAgLy9jb250ZXh0LnNjYWxlKDEgLyB0aGlzLnRpbGVTY2FsZS54LCAxIC8gdGhpcy50aWxlU2NhbGUueSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHNwcml0ZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbipcbiAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiAqL1xuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICB2YXIgdzAgPSB3aWR0aCAqICgxLXRoaXMuYW5jaG9yLngpO1xuICAgIHZhciB3MSA9IHdpZHRoICogLXRoaXMuYW5jaG9yLng7XG5cbiAgICB2YXIgaDAgPSBoZWlnaHQgKiAoMS10aGlzLmFuY2hvci55KTtcbiAgICB2YXIgaDEgPSBoZWlnaHQgKiAtdGhpcy5hbmNob3IueTtcblxuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5iO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYztcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7XG5cbiAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2YXIgeTEgPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgIHZhciB4MiA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgdmFyIHgzID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHkzID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG5cbiAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgdmFyIHk0ID0gIGQgKiBoMCArIGIgKiB3MSArIHR5O1xuXG4gICAgdmFyIG1pblgsXG4gICAgICAgIG1heFgsXG4gICAgICAgIG1pblksXG4gICAgICAgIG1heFk7XG5cbiAgICBtaW5YID0geDE7XG4gICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgIG1pblggPSB4NCA8IG1pblggPyB4NCA6IG1pblg7XG5cbiAgICBtaW5ZID0geTE7XG4gICAgbWluWSA9IHkyIDwgbWluWSA/IHkyIDogbWluWTtcbiAgICBtaW5ZID0geTMgPCBtaW5ZID8geTMgOiBtaW5ZO1xuICAgIG1pblkgPSB5NCA8IG1pblkgPyB5NCA6IG1pblk7XG5cbiAgICBtYXhYID0geDE7XG4gICAgbWF4WCA9IHgyID4gbWF4WCA/IHgyIDogbWF4WDtcbiAgICBtYXhYID0geDMgPiBtYXhYID8geDMgOiBtYXhYO1xuICAgIG1heFggPSB4NCA+IG1heFggPyB4NCA6IG1heFg7XG5cbiAgICBtYXhZID0geTE7XG4gICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgIG1heFkgPSB5NCA+IG1heFkgPyB5NCA6IG1heFk7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgYm91bmRzLnggPSBtaW5YO1xuICAgIGJvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHNvIHRoYXQgaWYgdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBhZ2FpbiBpbiB0aGUgcmVuZGVyIGN5Y2xlIHdlIGRvIG5vdCBoYXZlIHRvIHJlY2FsY3VsYXRlXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcblxuICAgIHJldHVybiBib3VuZHM7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHRpbGluZyBzcHJpdGVcbiAqIEBwYXJhbSBwb2ludCB7UElYSS5Qb2ludH0gdGhlIHBvaW50IHRvIGNoZWNrXG4gKi9cblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKCBwb2ludCApXG57XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsICB0ZW1wUG9pbnQpO1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICB2YXIgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgIHZhciB5MTtcblxuICAgIGlmICggdGVtcFBvaW50LnggPiB4MSAmJiB0ZW1wUG9pbnQueCA8IHgxICsgd2lkdGggKVxuICAgIHtcbiAgICAgICAgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcblxuICAgICAgICBpZiAoIHRlbXBQb2ludC55ID4geTEgJiYgdGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHRpbGluZyBzcHJpdGVcbiAqXG4gKi9cblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3JlLlNwcml0ZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50aWxlU2NhbGUgPSBudWxsO1xuICAgIHRoaXMuX3RpbGVTY2FsZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy50aWxlUG9zaXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy5fdXZzID0gbnVsbDtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHRpbGluZyBzcHJpdGUgdGhhdCB3aWxsIHVzZSBhIHRleHR1cmUgZnJvbSB0aGUgVGV4dHVyZUNhY2hlIGJhc2VkIG9uIHRoZSBmcmFtZUlkXG4gKiBUaGUgZnJhbWUgaWRzIGFyZSBjcmVhdGVkIHdoZW4gYSBUZXh0dXJlIHBhY2tlciBmaWxlIGhhcyBiZWVuIGxvYWRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBmcmFtZUlkIHtzdHJpbmd9IFRoZSBmcmFtZSBJZCBvZiB0aGUgdGV4dHVyZSBpbiB0aGUgY2FjaGVcbiAqIEByZXR1cm4ge1BJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gQSBuZXcgVGlsaW5nU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBmcmFtZUlkXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKi9cblRpbGluZ1Nwcml0ZS5mcm9tRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWVJZCx3aWR0aCxoZWlnaHQpXG57XG4gICAgdmFyIHRleHR1cmUgPSBjb3JlLnV0aWxzLlRleHR1cmVDYWNoZVtmcmFtZUlkXTtcblxuICAgIGlmICghdGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZyYW1lSWQgXCInICsgZnJhbWVJZCArICdcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSAnICsgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUaWxpbmdTcHJpdGUodGV4dHVyZSx3aWR0aCxoZWlnaHQpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBiYXNlZCBvbiBhbiBpbWFnZSB1cmxcbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBsb2FkZWRcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gaW1hZ2VJZCB7c3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gW2Nyb3Nzb3JpZ2luPShhdXRvKV0ge2Jvb2xlYW59IGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIGNyb3NzLW9yaWdpbiBwYXJhbWV0ZXJcbiAqIEBwYXJhbSBbc2NhbGVNb2RlPVBJWEkuU0NBTEVfTU9ERVMuREVGQVVMVF0ge251bWJlcn0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgc2NhbGUgbW9kZSwgc2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IEEgbmV3IFRpbGluZ1Nwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgaW1hZ2UgaWRcbiAqL1xuVGlsaW5nU3ByaXRlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIChpbWFnZUlkLCB3aWR0aCwgaGVpZ2h0LCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxue1xuICAgIHJldHVybiBuZXcgVGlsaW5nU3ByaXRlKGNvcmUuVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSksd2lkdGgsaGVpZ2h0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2V4dHJhcy9UaWxpbmdTcHJpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIEEgQml0bWFwVGV4dCBvYmplY3Qgd2lsbCBjcmVhdGUgYSBsaW5lIG9yIG11bHRpcGxlIGxpbmVzIG9mIHRleHQgdXNpbmcgYml0bWFwIGZvbnQuIFRvXG4gKiBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicsICdcXHInIG9yICdcXHJcXG4nIGluIHlvdXIgc3RyaW5nLiBZb3UgY2FuIGdlbmVyYXRlIHRoZSBmbnQgZmlsZXMgdXNpbmc6XG4gKlxuICogQSBCaXRtYXBUZXh0IGNhbiBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgZm9udCBpcyBsb2FkZWRcbiAqXG4gKiBgYGBqc1xuICogLy8gaW4gdGhpcyBjYXNlIHRoZSBmb250IGlzIGluIGEgZmlsZSBjYWxsZWQgJ2Rlc3lyZWwuZm50J1xuICogdmFyIGJpdG1hcFRleHQgPSBuZXcgUElYSS5leHRyYXMuQml0bWFwVGV4dChcInRleHQgdXNpbmcgYSBmYW5jeSBmb250IVwiLCB7Zm9udDogXCIzNXB4IERlc3lyZWxcIiwgYWxpZ246IFwicmlnaHRcIn0pO1xuICogYGBgXG4gKlxuICpcbiAqIGh0dHA6Ly93d3cuYW5nZWxjb2RlLmNvbS9wcm9kdWN0cy9ibWZvbnQvIGZvciB3aW5kb3dzIG9yXG4gKiBodHRwOi8vd3d3LmJtZ2x5cGguY29tLyBmb3IgbWFjLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5Db250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xuICogQHBhcmFtIHRleHQge3N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKiBAcGFyYW0gc3R5bGUge29iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBzdHlsZS5mb250IHtzdHJpbmd8b2JqZWN0fSBUaGUgZm9udCBkZXNjcmlwdG9yIGZvciB0aGUgb2JqZWN0LCBjYW4gYmUgcGFzc2VkIGFzIGEgc3RyaW5nIG9mIGZvcm1cbiAqICAgICAgXCIyNHB4IEZvbnROYW1lXCIgb3IgXCJGb250TmFtZVwiIG9yIGFzIGFuIG9iamVjdCB3aXRoIGV4cGxpY2l0IG5hbWUvc2l6ZSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIFtzdHlsZS5mb250Lm5hbWVdIHtzdHJpbmd9IFRoZSBiaXRtYXAgZm9udCBpZFxuICogQHBhcmFtIFtzdHlsZS5mb250LnNpemVdIHtudW1iZXJ9IFRoZSBzaXplIG9mIHRoZSBmb250IGluIHBpeGVscywgZS5nLiAyNFxuICogQHBhcmFtIFtzdHlsZS5hbGlnbj0nbGVmdCddIHtzdHJpbmd9IEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0JyksIGRvZXMgbm90IGFmZmVjdFxuICogICAgICBzaW5nbGUgbGluZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLnRpbnQ9MHhGRkZGRkZdIHtudW1iZXJ9IFRoZSB0aW50IGNvbG9yXG4gKi9cbmZ1bmN0aW9uIEJpdG1hcFRleHQodGV4dCwgc3R5bGUpXG57XG4gICAgY29yZS5Db250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIHN0eWxlID0gc3R5bGUgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIG92ZXJhbGwgdGV4dCwgZGlmZmVyZW50IGZyb20gZm9udFNpemUsXG4gICAgICogd2hpY2ggaXMgZGVmaW5lZCBpbiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy50ZXh0V2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgb3ZlcmFsbCB0ZXh0LCBkaWZmZXJlbnQgZnJvbSBmb250U2l6ZSxcbiAgICAgKiB3aGljaCBpcyBkZWZpbmVkIGluIHRoZSBzdHlsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnRleHRIZWlnaHQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgbGV0dGVyIHNwcml0ZSBwb29sLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5TcHJpdGVbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dseXBocyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZvbnQgPSB7XG4gICAgICAgIHRpbnQ6IHN0eWxlLnRpbnQgIT09IHVuZGVmaW5lZCA/IHN0eWxlLnRpbnQgOiAweEZGRkZGRixcbiAgICAgICAgYWxpZ246IHN0eWxlLmFsaWduIHx8ICdsZWZ0JyxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgc2l6ZTogMFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IGZvbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZvbnQgPSBzdHlsZS5mb250OyAvLyBydW4gZm9udCBzZXR0ZXJcblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCB3aWR0aCBvZiB0aGlzIGJpdG1hcCB0ZXh0IGluIHBpeGVscy4gSWYgdGhlIHRleHQgcHJvdmlkZWQgaXMgbG9uZ2VyIHRoYW4gdGhlIHZhbHVlIHByb3ZpZGVkLCBsaW5lIGJyZWFrcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgaW4gdGhlIGxhc3Qgd2hpdGVzcGFjZS5cbiAgICAgKiBEaXNhYmxlIGJ5IHNldHRpbmcgdmFsdWUgdG8gMFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4V2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCBsaW5lIGhlaWdodC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0cnlpbmcgdG8gdXNlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIFRleHQsIGllOiB3aGVuIHRyeWluZyB0byB2ZXJ0aWNhbGx5IGFsaWduLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4TGluZUhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlydHkgc3RhdGUgb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICAgIHRoaXMudXBkYXRlVGV4dCgpO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuQml0bWFwVGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQ29udGFpbmVyLnByb3RvdHlwZSk7XG5CaXRtYXBUZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpdG1hcFRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IEJpdG1hcFRleHQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJpdG1hcFRleHQucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHRpbnQgb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLkJpdG1hcFRleHQjXG4gICAgICovXG4gICAgdGludDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb250LnRpbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9mb250LnRpbnQgPSAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+PSAwKSA/IHZhbHVlIDogMHhGRkZGRkY7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbGlnbm1lbnQgb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2xlZnQnXG4gICAgICogQG1lbWJlcm9mIFBJWEkuZXh0cmFzLkJpdG1hcFRleHQjXG4gICAgICovXG4gICAgYWxpZ246IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udC5hbGlnbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnQuYWxpZ24gPSB2YWx1ZSB8fCAnbGVmdCc7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IGRlc2NyaXB0b3Igb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGb250fVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I1xuICAgICAqL1xuICAgIGZvbnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udC5uYW1lID0gdmFsdWUubGVuZ3RoID09PSAxID8gdmFsdWVbMF0gOiB2YWx1ZS5zbGljZSgxKS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udC5zaXplID0gdmFsdWUubGVuZ3RoID49IDIgPyBwYXJzZUludCh2YWx1ZVswXSwgMTApIDogQml0bWFwVGV4dC5mb250c1t0aGlzLl9mb250Lm5hbWVdLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250Lm5hbWUgPSB2YWx1ZS5uYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnQuc2l6ZSA9IHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJyA/IHZhbHVlLnNpemUgOiBwYXJzZUludCh2YWx1ZS5zaXplLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I1xuICAgICAqL1xuICAgIHRleHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKSB8fCAnICc7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dCA9PT0gdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5CaXRtYXBUZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZGF0YSA9IEJpdG1hcFRleHQuZm9udHNbdGhpcy5fZm9udC5uYW1lXTtcbiAgICB2YXIgcG9zID0gbmV3IGNvcmUuUG9pbnQoKTtcbiAgICB2YXIgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICB2YXIgbGFzdExpbmVXaWR0aCA9IDA7XG4gICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICB2YXIgbGluZSA9IDA7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5fZm9udC5zaXplIC8gZGF0YS5zaXplO1xuICAgIHZhciBsYXN0U3BhY2UgPSAtMTtcbiAgICB2YXIgbWF4TGluZUhlaWdodCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHRoaXMudGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBsYXN0U3BhY2UgPSAvKFxccykvLnRlc3QodGhpcy50ZXh0LmNoYXJBdChpKSkgPyBpIDogbGFzdFNwYWNlO1xuXG4gICAgICAgIGlmICgvKD86XFxyXFxufFxccnxcXG4pLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaSkpKVxuICAgICAgICB7XG4gICAgICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgbGluZSsrO1xuXG4gICAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgICBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdFNwYWNlICE9PSAtMSAmJiB0aGlzLm1heFdpZHRoID4gMCAmJiBwb3MueCAqIHNjYWxlID4gdGhpcy5tYXhXaWR0aClcbiAgICAgICAge1xuICAgICAgICAgICAgY29yZS51dGlscy5yZW1vdmVJdGVtcyhjaGFycywgbGFzdFNwYWNlLCBpIC0gbGFzdFNwYWNlKTtcbiAgICAgICAgICAgIGkgPSBsYXN0U3BhY2U7XG4gICAgICAgICAgICBsYXN0U3BhY2UgPSAtMTtcblxuICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcbiAgICAgICAgICAgIGxpbmUrKztcblxuICAgICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgICAgcG9zLnkgKz0gZGF0YS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJEYXRhID0gZGF0YS5jaGFyc1tjaGFyQ29kZV07XG5cbiAgICAgICAgaWYgKCFjaGFyRGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldkNoYXJDb2RlICYmIGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXSlcbiAgICAgICAge1xuICAgICAgICAgICAgcG9zLnggKz0gY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnMucHVzaCh7dGV4dHVyZTpjaGFyRGF0YS50ZXh0dXJlLCBsaW5lOiBsaW5lLCBjaGFyQ29kZTogY2hhckNvZGUsIHBvc2l0aW9uOiBuZXcgY29yZS5Qb2ludChwb3MueCArIGNoYXJEYXRhLnhPZmZzZXQsIHBvcy55ICsgY2hhckRhdGEueU9mZnNldCl9KTtcbiAgICAgICAgbGFzdExpbmVXaWR0aCA9IHBvcy54ICsgKGNoYXJEYXRhLnRleHR1cmUud2lkdGggKyBjaGFyRGF0YS54T2Zmc2V0KTtcbiAgICAgICAgcG9zLnggKz0gY2hhckRhdGEueEFkdmFuY2U7XG4gICAgICAgIG1heExpbmVIZWlnaHQgPSBNYXRoLm1heChtYXhMaW5lSGVpZ2h0LCAoY2hhckRhdGEueU9mZnNldCArIGNoYXJEYXRhLnRleHR1cmUuaGVpZ2h0KSk7XG4gICAgICAgIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgIH1cblxuICAgIGxpbmVXaWR0aHMucHVzaChsYXN0TGluZVdpZHRoKTtcbiAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpO1xuXG4gICAgdmFyIGxpbmVBbGlnbk9mZnNldHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbGluZTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGFsaWduT2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5fZm9udC5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAge1xuICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ZvbnQuYWxpZ24gPT09ICdjZW50ZXInKVxuICAgICAgICB7XG4gICAgICAgICAgICBhbGlnbk9mZnNldCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lQWxpZ25PZmZzZXRzLnB1c2goYWxpZ25PZmZzZXQpO1xuICAgIH1cblxuICAgIHZhciBsZW5DaGFycyA9IGNoYXJzLmxlbmd0aDtcbiAgICB2YXIgdGludCA9IHRoaXMudGludDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5DaGFyczsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLl9nbHlwaHNbaV07IC8vIGdldCB0aGUgbmV4dCBnbHlwaCBzcHJpdGVcblxuICAgICAgICBpZiAoYylcbiAgICAgICAge1xuICAgICAgICAgICAgYy50ZXh0dXJlID0gY2hhcnNbaV0udGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGMgPSBuZXcgY29yZS5TcHJpdGUoY2hhcnNbaV0udGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLl9nbHlwaHMucHVzaChjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMucG9zaXRpb24ueCA9IChjaGFyc1tpXS5wb3NpdGlvbi54ICsgbGluZUFsaWduT2Zmc2V0c1tjaGFyc1tpXS5saW5lXSkgKiBzY2FsZTtcbiAgICAgICAgYy5wb3NpdGlvbi55ID0gY2hhcnNbaV0ucG9zaXRpb24ueSAqIHNjYWxlO1xuICAgICAgICBjLnNjYWxlLnggPSBjLnNjYWxlLnkgPSBzY2FsZTtcbiAgICAgICAgYy50aW50ID0gdGludDtcblxuICAgICAgICBpZiAoIWMucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKGMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IGNoaWxkcmVuLlxuICAgIGZvciAoaSA9IGxlbkNoYXJzOyBpIDwgdGhpcy5fZ2x5cGhzLmxlbmd0aDsgKytpKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLl9nbHlwaHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMudGV4dFdpZHRoID0gbWF4TGluZVdpZHRoICogc2NhbGU7XG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gKHBvcy55ICsgZGF0YS5saW5lSGVpZ2h0KSAqIHNjYWxlO1xuICAgIHRoaXMubWF4TGluZUhlaWdodCA9IG1heExpbmVIZWlnaHQgKiBzY2FsZTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9mIHRoaXMgb2JqZWN0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuQml0bWFwVGV4dC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgdGhpcy5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0oKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRleHQgYmVmb3JlIGNhbGxpbmcgcGFyZW50J3MgZ2V0TG9jYWxCb3VuZHNcbiAqXG4gKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuXG5CaXRtYXBUZXh0LnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIGNvcmUuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRleHQgd2hlbiBuZWVkZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5CaXRtYXBUZXh0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxufTtcblxuQml0bWFwVGV4dC5mb250cyA9IHt9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9leHRyYXMvQml0bWFwVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgZmlsdGVycyBsaWJyYXJ5XG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkuZmlsdGVyc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBc2NpaUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vYXNjaWkvQXNjaWlGaWx0ZXInKSxcbiAgICBCbG9vbUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vYmxvb20vQmxvb21GaWx0ZXInKSxcbiAgICBCbHVyRmlsdGVyOiAgICAgICAgIHJlcXVpcmUoJy4vYmx1ci9CbHVyRmlsdGVyJyksXG4gICAgQmx1clhGaWx0ZXI6ICAgICAgICByZXF1aXJlKCcuL2JsdXIvQmx1clhGaWx0ZXInKSxcbiAgICBCbHVyWUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vYmx1ci9CbHVyWUZpbHRlcicpLFxuICAgIEJsdXJEaXJGaWx0ZXI6ICAgICAgcmVxdWlyZSgnLi9ibHVyL0JsdXJEaXJGaWx0ZXInKSxcbiAgICBDb2xvck1hdHJpeEZpbHRlcjogIHJlcXVpcmUoJy4vY29sb3IvQ29sb3JNYXRyaXhGaWx0ZXInKSxcbiAgICBDb2xvclN0ZXBGaWx0ZXI6ICAgIHJlcXVpcmUoJy4vY29sb3IvQ29sb3JTdGVwRmlsdGVyJyksXG4gICAgQ29udm9sdXRpb25GaWx0ZXI6ICByZXF1aXJlKCcuL2NvbnZvbHV0aW9uL0NvbnZvbHV0aW9uRmlsdGVyJyksXG4gICAgQ3Jvc3NIYXRjaEZpbHRlcjogICByZXF1aXJlKCcuL2Nyb3NzaGF0Y2gvQ3Jvc3NIYXRjaEZpbHRlcicpLFxuICAgIERpc3BsYWNlbWVudEZpbHRlcjogcmVxdWlyZSgnLi9kaXNwbGFjZW1lbnQvRGlzcGxhY2VtZW50RmlsdGVyJyksXG4gICAgRG90U2NyZWVuRmlsdGVyOiAgICByZXF1aXJlKCcuL2RvdC9Eb3RTY3JlZW5GaWx0ZXInKSxcbiAgICBHcmF5RmlsdGVyOiAgICAgICAgIHJlcXVpcmUoJy4vZ3JheS9HcmF5RmlsdGVyJyksXG4gICAgRHJvcFNoYWRvd0ZpbHRlcjogICByZXF1aXJlKCcuL2Ryb3BzaGFkb3cvRHJvcFNoYWRvd0ZpbHRlcicpLFxuICAgIEludmVydEZpbHRlcjogICAgICAgcmVxdWlyZSgnLi9pbnZlcnQvSW52ZXJ0RmlsdGVyJyksXG4gICAgTm9pc2VGaWx0ZXI6ICAgICAgICByZXF1aXJlKCcuL25vaXNlL05vaXNlRmlsdGVyJyksXG4gICAgUGl4ZWxhdGVGaWx0ZXI6ICAgICByZXF1aXJlKCcuL3BpeGVsYXRlL1BpeGVsYXRlRmlsdGVyJyksXG4gICAgUkdCU3BsaXRGaWx0ZXI6ICAgICByZXF1aXJlKCcuL3JnYi9SR0JTcGxpdEZpbHRlcicpLFxuICAgIFNob2Nrd2F2ZUZpbHRlcjogICAgcmVxdWlyZSgnLi9zaG9ja3dhdmUvU2hvY2t3YXZlRmlsdGVyJyksXG4gICAgU2VwaWFGaWx0ZXI6ICAgICAgICByZXF1aXJlKCcuL3NlcGlhL1NlcGlhRmlsdGVyJyksXG4gICAgU21hcnRCbHVyRmlsdGVyOiAgICByZXF1aXJlKCcuL2JsdXIvU21hcnRCbHVyRmlsdGVyJyksXG4gICAgVGlsdFNoaWZ0RmlsdGVyOiAgICByZXF1aXJlKCcuL3RpbHRzaGlmdC9UaWx0U2hpZnRGaWx0ZXInKSxcbiAgICBUaWx0U2hpZnRYRmlsdGVyOiAgIHJlcXVpcmUoJy4vdGlsdHNoaWZ0L1RpbHRTaGlmdFhGaWx0ZXInKSxcbiAgICBUaWx0U2hpZnRZRmlsdGVyOiAgIHJlcXVpcmUoJy4vdGlsdHNoaWZ0L1RpbHRTaGlmdFlGaWx0ZXInKSxcbiAgICBUd2lzdEZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vdHdpc3QvVHdpc3RGaWx0ZXInKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8vIFRPRE8gKGNlbmdsZXIpIC0gVGhlIFkgaXMgZmxpcHBlZCBpbiB0aGlzIHNoYWRlciBmb3Igc29tZSByZWFzb24uXG5cbi8qKlxuICogQGF1dGhvciBWaWNvIEB2aWNvY290ZWFcbiAqIG9yaWdpbmFsIHNoYWRlciA6IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sc3NHRGogYnkgQG1vdkFYMTNoXG4gKi9cblxuLyoqXG4gKiBBbiBBU0NJSSBmaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIEFzY2lpRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzQgZGltZW5zaW9ucztcXG51bmlmb3JtIGZsb2F0IHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG5mbG9hdCBjaGFyYWN0ZXIoZmxvYXQgbiwgdmVjMiBwKVxcbntcXG4gICAgcCA9IGZsb29yKHAqdmVjMig0LjAsIC00LjApICsgMi41KTtcXG4gICAgaWYgKGNsYW1wKHAueCwgMC4wLCA0LjApID09IHAueCAmJiBjbGFtcChwLnksIDAuMCwgNC4wKSA9PSBwLnkpXFxuICAgIHtcXG4gICAgICAgIGlmIChpbnQobW9kKG4vZXhwMihwLnggKyA1LjAqcC55KSwgMi4wKSkgPT0gMSkgcmV0dXJuIDEuMDtcXG4gICAgfVxcbiAgICByZXR1cm4gMC4wO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eTtcXG5cXG4gICAgdmVjMyBjb2wgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGZsb29yKCB1diAvIHBpeGVsU2l6ZSApICogcGl4ZWxTaXplIC8gZGltZW5zaW9ucy54eSkucmdiO1xcblxcbiAgICBmbG9hdCBncmF5ID0gKGNvbC5yICsgY29sLmcgKyBjb2wuYikgLyAzLjA7XFxuXFxuICAgIGZsb2F0IG4gPSAgNjU1MzYuMDsgICAgICAgICAgICAgLy8gLlxcbiAgICBpZiAoZ3JheSA+IDAuMikgbiA9IDY1NjAwLjA7ICAgIC8vIDpcXG4gICAgaWYgKGdyYXkgPiAwLjMpIG4gPSAzMzI3NzIuMDsgICAvLyAqXFxuICAgIGlmIChncmF5ID4gMC40KSBuID0gMTUyNTUwODYuMDsgLy8gb1xcbiAgICBpZiAoZ3JheSA+IDAuNSkgbiA9IDIzMzg1MTY0LjA7IC8vICZcXG4gICAgaWYgKGdyYXkgPiAwLjYpIG4gPSAxNTI1MjAxNC4wOyAvLyA4XFxuICAgIGlmIChncmF5ID4gMC43KSBuID0gMTMxOTk0NTIuMDsgLy8gQFxcbiAgICBpZiAoZ3JheSA+IDAuOCkgbiA9IDExNTEyODEwLjA7IC8vICNcXG5cXG4gICAgdmVjMiBwID0gbW9kKCB1diAvICggcGl4ZWxTaXplICogMC41ICksIDIuMCkgLSB2ZWMyKDEuMCk7XFxuICAgIGNvbCA9IGNvbCAqIGNoYXJhY3RlcihuLCBwKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2wsIDEuMCk7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgZGltZW5zaW9uczogeyB0eXBlOiAnNGZ2JywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDBdKSB9LFxuICAgICAgICAgICAgcGl4ZWxTaXplOiAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogOCB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5Bc2NpaUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkFzY2lpRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzY2lpRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBBc2NpaUZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXNjaWlGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIHNpemUgdXNlZCBieSB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQXNjaWlGaWx0ZXIjXG4gICAgICovXG4gICAgc2l6ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnBpeGVsU2l6ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucGl4ZWxTaXplLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9hc2NpaS9Bc2NpaUZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyksXG4gICAgQmx1clhGaWx0ZXIgPSByZXF1aXJlKCcuLi9ibHVyL0JsdXJYRmlsdGVyJyksXG4gICAgQmx1cllGaWx0ZXIgPSByZXF1aXJlKCcuLi9ibHVyL0JsdXJZRmlsdGVyJyk7XG5cbi8qKlxuICogVGhlIEJsb29tRmlsdGVyIGFwcGxpZXMgYSBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cbiAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBjYW4gYmUgc2V0IGZvciB4LSBhbmQgeS1heGlzIHNlcGFyYXRlbHkuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIEJsb29tRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IEJsdXJYRmlsdGVyKCk7XG4gICAgdGhpcy5ibHVyWUZpbHRlciA9IG5ldyBCbHVyWUZpbHRlcigpO1xuXG4gICAgdGhpcy5kZWZhdWx0RmlsdGVyID0gbmV3IGNvcmUuQWJzdHJhY3RGaWx0ZXIoKTtcbn1cblxuQmxvb21GaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5CbG9vbUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbG9vbUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQmxvb21GaWx0ZXI7XG5cbkJsb29tRmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dClcbntcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG5cbiAgICAvL1RPRE8gLSBjb3B5VGV4U3ViSW1hZ2UyRCBjb3VsZCBiZSB1c2VkIGhlcmU/XG4gICAgdGhpcy5kZWZhdWx0RmlsdGVyLmFwcGx5RmlsdGVyKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KTtcblxuICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIGlucHV0LCByZW5kZXJUYXJnZXQpO1xuXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoY29yZS5CTEVORF9NT0RFUy5TQ1JFRU4pO1xuXG4gICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQpO1xuXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoY29yZS5CTEVORF9NT0RFUy5OT1JNQUwpO1xuXG4gICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJsb29tRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5CbG9vbUZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG4gICAgYmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkJsb29tRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyWDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkJsb29tRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyWToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2Jsb29tL0Jsb29tRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGUgQmx1clhGaWx0ZXIgYXBwbGllcyBhIGhvcml6b250YWwgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIEJsdXJYRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5cXG51bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzZdO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMygoYVZlcnRleFBvc2l0aW9uKSwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFxuICAgIHZCbHVyVGV4Q29vcmRzWyAwXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKC0wLjAxMiAqIHN0cmVuZ3RoLCAwLjApO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgMV0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigtMC4wMDggKiBzdHJlbmd0aCwgMC4wKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDJdID0gYVRleHR1cmVDb29yZCArIHZlYzIoLTAuMDA0ICogc3RyZW5ndGgsIDAuMCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyAzXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKCAwLjAwNCAqIHN0cmVuZ3RoLCAwLjApO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgNF0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMiggMC4wMDggKiBzdHJlbmd0aCwgMC4wKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDVdID0gYVRleHR1cmVDb29yZCArIHZlYzIoIDAuMDEyICogc3RyZW5ndGgsIDAuMCk7XFxuXFxuICAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxufVxcblwiLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbNl07XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDBdKSowLjAwNDQzMTg0ODQxMTkzODM0MTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDFdKSowLjA1Mzk5MDk2NjUxMzE4OTg1O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMl0pKjAuMjQxOTcwNzI0NTE5MTQ1NDtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCAgICAgKSowLjM5ODk0MjI4MDQwMTQzMjc7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAzXSkqMC4yNDE5NzA3MjQ1MTkxNDU0O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgNF0pKjAuMDUzOTkwOTY2NTEzMTg5ODU7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyA1XSkqMC4wMDQ0MzE4NDg0MTE5MzgzNDE7XFxufVxcblwiLFxuICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0cmVuZ3RoOiB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGFzc2VzIGZvciBibHVyLiBNb3JlIHBhc3NlcyBtZWFucyBoaWdoZXIgcXVhaWxpdHkgYmx1cmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5wYXNzZXMgPSAxO1xuXG4gICAgdGhpcy5zdHJlbmd0aCA9IDQ7XG59XG5cbkJsdXJYRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuQmx1clhGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmx1clhGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJYRmlsdGVyO1xuXG5CbHVyWEZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKVxue1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XG5cbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdGhpcy5zdHJlbmd0aCAvIDQgLyB0aGlzLnBhc3NlcyAqIChpbnB1dC5mcmFtZS53aWR0aCAvIGlucHV0LnNpemUud2lkdGgpO1xuXG4gICAgaWYodGhpcy5wYXNzZXMgPT09IDEpXG4gICAge1xuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG4gICAgICAgIHZhciBmbGlwID0gaW5wdXQ7XG4gICAgICAgIHZhciBmbG9wID0gcmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3Nlcy0xOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBmbGlwLCBmbG9wLCB0cnVlKTtcblxuICAgICAgICAgICB2YXIgdGVtcCA9IGZsb3A7XG4gICAgICAgICAgIGZsb3AgPSBmbGlwO1xuICAgICAgICAgICBmbGlwID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBmbGlwLCBvdXRwdXQsIGNsZWFyKTtcblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnJldHVyblJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIH1cbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmx1clhGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1ci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkJsdXJYRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnN0cmVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gIE1hdGguYWJzKHZhbHVlKSAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2JsdXIvQmx1clhGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoZSBCbHVyWUZpbHRlciBhcHBsaWVzIGEgaG9yaXpvbnRhbCBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gQmx1cllGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbnVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbNl07XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKChhVmVydGV4UG9zaXRpb24pLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXG4gICAgdkJsdXJUZXhDb29yZHNbIDBdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAtMC4wMTIgKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyAxXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgLTAuMDA4ICogc3RyZW5ndGgpO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgMl0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsIC0wLjAwNCAqIHN0cmVuZ3RoKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDNdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAgMC4wMDQgKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyA0XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgIDAuMDA4ICogc3RyZW5ndGgpO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgNV0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICAwLjAxMiAqIHN0cmVuZ3RoKTtcXG5cXG4gICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcbn1cXG5cIixcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzZdO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAwXSkqMC4wMDQ0MzE4NDg0MTE5MzgzNDE7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAxXSkqMC4wNTM5OTA5NjY1MTMxODk4NTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDJdKSowLjI0MTk3MDcyNDUxOTE0NTQ7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgICAgICkqMC4zOTg5NDIyODA0MDE0MzI3O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgM10pKjAuMjQxOTcwNzI0NTE5MTQ1NDtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDRdKSowLjA1Mzk5MDk2NjUxMzE4OTg1O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgNV0pKjAuMDA0NDMxODQ4NDExOTM4MzQxO1xcbn1cXG5cIixcbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBzdHJlbmd0aDogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMSB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSAxO1xuICAgIHRoaXMuc3RyZW5ndGggPSA0O1xufVxuXG5CbHVyWUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkJsdXJZRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsdXJZRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBCbHVyWUZpbHRlcjtcblxuQmx1cllGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcilcbntcbiAgICB2YXIgc2hhZGVyID0gdGhpcy5nZXRTaGFkZXIocmVuZGVyZXIpO1xuXG4gICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZSA9IE1hdGguYWJzKHRoaXMuc3RyZW5ndGgpIC8gNCAvIHRoaXMucGFzc2VzICogKGlucHV0LmZyYW1lLmhlaWdodCAvIGlucHV0LnNpemUuaGVpZ2h0KTtcblxuICAgIGlmKHRoaXMucGFzc2VzID09PSAxKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xuICAgICAgICB2YXIgZmxpcCA9IGlucHV0O1xuICAgICAgICB2YXIgZmxvcCA9IHJlbmRlclRhcmdldDtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXNzZXMtMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgZmxvcCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgdmFyIHRlbXAgPSBmbG9wO1xuICAgICAgICAgICBmbG9wID0gZmxpcDtcbiAgICAgICAgICAgZmxpcCA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgb3V0cHV0LCBjbGVhcik7XG5cbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICB9XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJsdXJZRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5CbHVyWUZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG4gICAgYmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5zdHJlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGguYWJzKHZhbHVlKSAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2JsdXIvQmx1cllGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpLFxuICAgIEJsdXJYRmlsdGVyID0gcmVxdWlyZSgnLi9CbHVyWEZpbHRlcicpLFxuICAgIEJsdXJZRmlsdGVyID0gcmVxdWlyZSgnLi9CbHVyWUZpbHRlcicpO1xuXG4vKipcbiAqIFRoZSBCbHVyRmlsdGVyIGFwcGxpZXMgYSBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cbiAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBjYW4gYmUgc2V0IGZvciB4LSBhbmQgeS1heGlzIHNlcGFyYXRlbHkuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIEJsdXJGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1clhGaWx0ZXIoKTtcbiAgICB0aGlzLmJsdXJZRmlsdGVyID0gbmV3IEJsdXJZRmlsdGVyKCk7XG59XG5cbkJsdXJGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5CbHVyRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsdXJGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJGaWx0ZXI7XG5cbkJsdXJGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxue1xuICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcblxuICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIGlucHV0LCByZW5kZXJUYXJnZXQpO1xuICAgIHRoaXMuYmx1cllGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgb3V0cHV0KTtcblxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbHVyRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5CbHVyRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGguYWJzKHZhbHVlKSAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwYXNzZXMgZm9yIGJsdXIuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlciBxdWFpbGl0eSBibHVyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1cllGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHBhc3Nlczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5ibHVyWEZpbHRlci5wYXNzZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLnBhc3NlcyA9IHRoaXMuYmx1cllGaWx0ZXIucGFzc2VzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5CbHVyRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyWDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkJsdXJGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXJZOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvYmx1ci9CbHVyRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcblxuXG4vKipcbiAqIFRoZSBCbHVyRGlyRmlsdGVyIGFwcGxpZXMgYSBHYXVzc2lhbiBibHVyIHRvd2FyZCBhIGRpcmVjdGlvbiB0byBhbiBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyWFxuICogQHBhcmFtIHtudW1iZXJ9IGRpcllcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gQmx1ckRpckZpbHRlcihkaXJYLCBkaXJZKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbnVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XFxudW5pZm9ybSBmbG9hdCBkaXJYO1xcbnVuaWZvcm0gZmxvYXQgZGlyWTtcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1szXTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoKGFWZXJ0ZXhQb3NpdGlvbiksIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcblxcbiAgICB2Qmx1clRleENvb3Jkc1swXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKCAoMC4wMDQgKiBzdHJlbmd0aCkgKiBkaXJYLCAoMC4wMDQgKiBzdHJlbmd0aCkgKiBkaXJZICk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWzFdID0gYVRleHR1cmVDb29yZCArIHZlYzIoICgwLjAwOCAqIHN0cmVuZ3RoKSAqIGRpclgsICgwLjAwOCAqIHN0cmVuZ3RoKSAqIGRpclkgKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbMl0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMiggKDAuMDEyICogc3RyZW5ndGgpICogZGlyWCwgKDAuMDEyICogc3RyZW5ndGgpICogZGlyWSApO1xcblxcbiAgICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcbn1cXG5cIixcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzNdO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgICAgICkgKiAwLjM5ODk0MjI4MDQwMTQzMjc7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAwXSkgKiAwLjI0MTk3MDcyNDUxOTE0NTQ7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAxXSkgKiAwLjA1Mzk5MDk2NjUxMzE4OTg1O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMl0pICogMC4wMDQ0MzE4NDg0MTE5MzgzNDE7XFxufVxcblwiLFxuICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0cmVuZ3RoOiB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgICBkaXJYOiB7IHR5cGU6ICcxZicsIHZhbHVlOiBkaXJYIHx8IDAgfSxcbiAgICAgICAgICAgIGRpclk6IHsgdHlwZTogJzFmJywgdmFsdWU6IGRpclkgfHwgMCB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5kZWZhdWx0RmlsdGVyID0gbmV3IGNvcmUuQWJzdHJhY3RGaWx0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwYXNzZXMgZm9yIGJsdXIuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlciBxdWFpbGl0eSBibHVyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLnBhc3NlcyA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBYIGRpcmVjdGlvbiBvZiB0aGUgYmx1clxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmRpclggPSBkaXJYIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBZIGRpcmVjdGlvbiBvZiB0aGUgYmx1clxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmRpclkgPSBkaXJZIHx8IDA7XG5cbiAgICB0aGlzLnN0cmVuZ3RoID0gNDtcbn1cblxuQmx1ckRpckZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkJsdXJEaXJGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmx1ckRpckZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQmx1ckRpckZpbHRlcjtcblxuQmx1ckRpckZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XG5cbiAgICB2YXIgc2hhZGVyID0gdGhpcy5nZXRTaGFkZXIocmVuZGVyZXIpO1xuXG4gICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZSA9IHRoaXMuc3RyZW5ndGggLyA0IC8gdGhpcy5wYXNzZXMgKiAoaW5wdXQuZnJhbWUud2lkdGggLyBpbnB1dC5zaXplLndpZHRoKTtcblxuICAgIGlmICh0aGlzLnBhc3NlcyA9PT0gMSkge1xuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIHJlbmRlclRhcmdldCwgY2xlYXIpO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3Nlcy0yOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vdGhpcy51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZSA9IHRoaXMuc3RyZW5ndGggLyA0IC8gKHRoaXMucGFzc2VzKyhpKjIpKSAqIChpbnB1dC5mcmFtZS53aWR0aCAvIGlucHV0LnNpemUud2lkdGgpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0LCBjbGVhcik7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQsIGNsZWFyKTtcblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnJldHVyblJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIH1cbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmx1ckRpckZpbHRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1ckRpckZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG4gICAgYmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gdmFsdWUgKiAwLjU7XG4gICAgICAgICAgICB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFggZGlyZWN0aW9uIG9mIHRoZSBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1cllGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGRpclg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJYO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5kaXJYLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFkgZGlyZWN0aW9uIG9mIHRoZSBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQmx1ckRpckZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgZGlyWToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpclk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmRpclkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2JsdXIvQmx1ckRpckZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhlIENvbG9yTWF0cml4RmlsdGVyIGNsYXNzIGxldHMgeW91IGFwcGx5IGEgNXg0IG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgUkdCQVxuICogY29sb3IgYW5kIGFscGhhIHZhbHVlcyBvZiBldmVyeSBwaXhlbCBvbiB5b3VyIGRpc3BsYXlPYmplY3QgdG8gcHJvZHVjZSBhIHJlc3VsdFxuICogd2l0aCBhIG5ldyBzZXQgb2YgUkdCQSBjb2xvciBhbmQgYWxwaGEgdmFsdWVzLiBJdCdzIHByZXR0eSBwb3dlcmZ1bCFcbiAqXG4gKiBgYGBqc1xuICogIHZhciBjb2xvck1hdHJpeCA9IG5ldyBQSVhJLkNvbG9yTWF0cml4RmlsdGVyKCk7XG4gKiAgY29udGFpbmVyLmZpbHRlcnMgPSBbY29sb3JNYXRyaXhdO1xuICogIGNvbG9yTWF0cml4LmNvbnRyYXN0KDIpO1xuICogYGBgXG4gKiBAYXV0aG9yIENsw6ltZW50IENoZW5lYmF1bHQgPGNsZW1lbnRAZ29vZGJveWRpZ2l0YWwuY29tPlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIENvbG9yTWF0cml4RmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IG1bMjVdO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG5cXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yLnIgPSAobVswXSAqIGMucik7XFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAobVsxXSAqIGMuZyk7XFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAobVsyXSAqIGMuYik7XFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAobVszXSAqIGMuYSk7XFxuICAgICAgICBnbF9GcmFnQ29sb3IuciArPSBtWzRdICogYy5hO1xcblxcbiAgICBnbF9GcmFnQ29sb3IuZyA9IChtWzVdICogYy5yKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IChtWzZdICogYy5nKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IChtWzddICogYy5iKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IChtWzhdICogYy5hKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IG1bOV0gKiBjLmE7XFxuXFxuICAgICBnbF9GcmFnQ29sb3IuYiA9IChtWzEwXSAqIGMucik7XFxuICAgICAgICBnbF9GcmFnQ29sb3IuYiArPSAobVsxMV0gKiBjLmcpO1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLmIgKz0gKG1bMTJdICogYy5iKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5iICs9IChtWzEzXSAqIGMuYSk7XFxuICAgICAgICBnbF9GcmFnQ29sb3IuYiArPSBtWzE0XSAqIGMuYTtcXG5cXG4gICAgIGdsX0ZyYWdDb2xvci5hID0gKG1bMTVdICogYy5yKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5hICs9IChtWzE2XSAqIGMuZyk7XFxuICAgICAgICBnbF9GcmFnQ29sb3IuYSArPSAobVsxN10gKiBjLmIpO1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLmEgKz0gKG1bMThdICogYy5hKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5hICs9IG1bMTldICogYy5hO1xcblxcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIG06IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnMWZ2JywgdmFsdWU6IFtcbiAgICAgICAgICAgICAgICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sb3JNYXRyaXhGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yTWF0cml4RmlsdGVyO1xuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBjdXJyZW50IG1hdHJpeCBhbmQgc2V0IHRoZSBuZXcgb25lXG4gKlxuICogQHBhcmFtIG1hdHJpeCB7bnVtYmVyW119IChtYXQgNXg0KVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSwganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuX2xvYWRNYXRyaXggPSBmdW5jdGlvbiAobWF0cml4LCBtdWx0aXBseSlcbntcbiAgICBtdWx0aXBseSA9ICEhbXVsdGlwbHk7XG5cbiAgICB2YXIgbmV3TWF0cml4ID0gbWF0cml4O1xuXG4gICAgaWYgKG11bHRpcGx5KSB7XG4gICAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLnZhbHVlLCBtYXRyaXgpO1xuICAgICAgICBuZXdNYXRyaXggPSB0aGlzLl9jb2xvck1hdHJpeChuZXdNYXRyaXgpO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbmV3IG1hdHJpeFxuICAgIHRoaXMudW5pZm9ybXMubS52YWx1ZSA9IG5ld01hdHJpeDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NSdzXG4gKlxuICogQHBhcmFtIG91dCB7bnVtYmVyW119IChtYXQgNXg0KSB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIGEge251bWJlcltdfSAobWF0IDV4NCkgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSBiIHtudW1iZXJbXX0gKG1hdCA1eDQpIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMgb3V0IHtudW1iZXJbXX0gKG1hdCA1eDQpXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5fbXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKVxue1xuXG4gICAgLy8gUmVkIENoYW5uZWxcbiAgICBvdXRbMF0gPSAoYVswXSAqIGJbMF0pICsgKGFbMV0gKiBiWzVdKSArIChhWzJdICogYlsxMF0pICsgKGFbM10gKiBiWzE1XSk7XG4gICAgb3V0WzFdID0gKGFbMF0gKiBiWzFdKSArIChhWzFdICogYls2XSkgKyAoYVsyXSAqIGJbMTFdKSArIChhWzNdICogYlsxNl0pO1xuICAgIG91dFsyXSA9IChhWzBdICogYlsyXSkgKyAoYVsxXSAqIGJbN10pICsgKGFbMl0gKiBiWzEyXSkgKyAoYVszXSAqIGJbMTddKTtcbiAgICBvdXRbM10gPSAoYVswXSAqIGJbM10pICsgKGFbMV0gKiBiWzhdKSArIChhWzJdICogYlsxM10pICsgKGFbM10gKiBiWzE4XSk7XG4gICAgb3V0WzRdID0gKGFbMF0gKiBiWzRdKSArIChhWzFdICogYls5XSkgKyAoYVsyXSAqIGJbMTRdKSArIChhWzNdICogYlsxOV0pO1xuXG4gICAgLy8gR3JlZW4gQ2hhbm5lbFxuICAgIG91dFs1XSA9IChhWzVdICogYlswXSkgKyAoYVs2XSAqIGJbNV0pICsgKGFbN10gKiBiWzEwXSkgKyAoYVs4XSAqIGJbMTVdKTtcbiAgICBvdXRbNl0gPSAoYVs1XSAqIGJbMV0pICsgKGFbNl0gKiBiWzZdKSArIChhWzddICogYlsxMV0pICsgKGFbOF0gKiBiWzE2XSk7XG4gICAgb3V0WzddID0gKGFbNV0gKiBiWzJdKSArIChhWzZdICogYls3XSkgKyAoYVs3XSAqIGJbMTJdKSArIChhWzhdICogYlsxN10pO1xuICAgIG91dFs4XSA9IChhWzVdICogYlszXSkgKyAoYVs2XSAqIGJbOF0pICsgKGFbN10gKiBiWzEzXSkgKyAoYVs4XSAqIGJbMThdKTtcbiAgICBvdXRbOV0gPSAoYVs1XSAqIGJbNF0pICsgKGFbNl0gKiBiWzldKSArIChhWzddICogYlsxNF0pICsgKGFbOF0gKiBiWzE5XSk7XG5cbiAgICAvLyBCbHVlIENoYW5uZWxcbiAgICBvdXRbMTBdID0gKGFbMTBdICogYlswXSkgKyAoYVsxMV0gKiBiWzVdKSArIChhWzEyXSAqIGJbMTBdKSArIChhWzEzXSAqIGJbMTVdKTtcbiAgICBvdXRbMTFdID0gKGFbMTBdICogYlsxXSkgKyAoYVsxMV0gKiBiWzZdKSArIChhWzEyXSAqIGJbMTFdKSArIChhWzEzXSAqIGJbMTZdKTtcbiAgICBvdXRbMTJdID0gKGFbMTBdICogYlsyXSkgKyAoYVsxMV0gKiBiWzddKSArIChhWzEyXSAqIGJbMTJdKSArIChhWzEzXSAqIGJbMTddKTtcbiAgICBvdXRbMTNdID0gKGFbMTBdICogYlszXSkgKyAoYVsxMV0gKiBiWzhdKSArIChhWzEyXSAqIGJbMTNdKSArIChhWzEzXSAqIGJbMThdKTtcbiAgICBvdXRbMTRdID0gKGFbMTBdICogYls0XSkgKyAoYVsxMV0gKiBiWzldKSArIChhWzEyXSAqIGJbMTRdKSArIChhWzEzXSAqIGJbMTldKTtcblxuICAgIC8vIEFscGhhIENoYW5uZWxcbiAgICBvdXRbMTVdID0gKGFbMTVdICogYlswXSkgKyAoYVsxNl0gKiBiWzVdKSArIChhWzE3XSAqIGJbMTBdKSArIChhWzE4XSAqIGJbMTVdKTtcbiAgICBvdXRbMTZdID0gKGFbMTVdICogYlsxXSkgKyAoYVsxNl0gKiBiWzZdKSArIChhWzE3XSAqIGJbMTFdKSArIChhWzE4XSAqIGJbMTZdKTtcbiAgICBvdXRbMTddID0gKGFbMTVdICogYlsyXSkgKyAoYVsxNl0gKiBiWzddKSArIChhWzE3XSAqIGJbMTJdKSArIChhWzE4XSAqIGJbMTddKTtcbiAgICBvdXRbMThdID0gKGFbMTVdICogYlszXSkgKyAoYVsxNl0gKiBiWzhdKSArIChhWzE3XSAqIGJbMTNdKSArIChhWzE4XSAqIGJbMThdKTtcbiAgICBvdXRbMTldID0gKGFbMTVdICogYls0XSkgKyAoYVsxNl0gKiBiWzldKSArIChhWzE3XSAqIGJbMTRdKSArIChhWzE4XSAqIGJbMTldKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEZsb2F0MzIgQXJyYXkgYW5kIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IGNvbXBvbmVudCB0byAwLTFcbiAqXG4gKiBAcGFyYW0gbWF0cml4IHtudW1iZXJbXX0gKG1hdCA1eDQpXG4gKiBAcmV0dXJuIG0ge251bWJlcltdfSAobWF0IDV4NCkgd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5fY29sb3JNYXRyaXggPSBmdW5jdGlvbiAobWF0cml4KVxue1xuICAgIC8vIENyZWF0ZSBhIEZsb2F0MzIgQXJyYXkgYW5kIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IGNvbXBvbmVudCB0byAwLTFcbiAgICB2YXIgbSA9IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4KTtcbiAgICBtWzRdIC89IDI1NTtcbiAgICBtWzldIC89IDI1NTtcbiAgICBtWzE0XSAvPSAyNTU7XG4gICAgbVsxOV0gLz0gMjU1O1xuXG4gICAgcmV0dXJuIG07XG59O1xuXG4vKipcbiAqIEFkanVzdHMgYnJpZ2h0bmVzc1xuICpcbiAqIEBwYXJhbSBiIHtudW1iZXJ9IHZhbHVlIG9mIHRoZSBicmlndGhuZXNzICgwIGlzIGJsYWNrKVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmJyaWdodG5lc3MgPSBmdW5jdGlvbiAoYiwgbXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgYiwgMCwgMCwgMCwgMCxcbiAgICAgICAgMCwgYiwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgYiwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1hdHJpY2VzIGluIGdyZXkgc2NhbGVzXG4gKlxuICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IHZhbHVlIG9mIHRoZSBncmV5ICgwIGlzIGJsYWNrKVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyZXlzY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSwgbXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcbiAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcbiAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcbi8vQW1lcmljYW5pemVkIGFsaWFzXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuZ3JheXNjYWxlID0gQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyZXlzY2FsZTtcblxuLyoqXG4gKiBTZXQgdGhlIGJsYWNrIGFuZCB3aGl0ZSBtYXRyaWNlXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuYmxhY2tBbmRXaGl0ZSA9IGZ1bmN0aW9uIChtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAwLjMsIDAuNiwgMC4xLCAwLCAwLFxuICAgICAgICAwLjMsIDAuNiwgMC4xLCAwLCAwLFxuICAgICAgICAwLjMsIDAuNiwgMC4xLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaHVlIHByb3BlcnR5IG9mIHRoZSBjb2xvclxuICpcbiAqIEBwYXJhbSByb3RhdGlvbiB7bnVtYmVyfSBpbiBkZWdyZWVzXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuaHVlID0gZnVuY3Rpb24gKHJvdGF0aW9uLCBtdWx0aXBseSlcbntcbiAgICByb3RhdGlvbiA9IChyb3RhdGlvbiB8fCAwKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4ocm90YXRpb24pO1xuXG4gICAgLy8gbHVtaW5hbmNlUmVkLCBsdW1pbmFuY2VHcmVlbiwgbHVtaW5hbmNlQmx1ZVxuICAgIHZhciBsdW1SID0gMC4yMTMsIC8vIG9yIDAuMzA4NlxuICAgICAgICBsdW1HID0gMC43MTUsIC8vIG9yIDAuNjA5NFxuICAgICAgICBsdW1CID0gMC4wNzI7IC8vIG9yIDAuMDgyMFxuXG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgbHVtUiArIGNvcyAqICgxIC0gbHVtUikgKyBzaW4gKiAoLWx1bVIpLCBsdW1HICsgY29zICogKC1sdW1HKSArIHNpbiAqICgtbHVtRyksIGx1bUIgKyBjb3MgKiAoLWx1bUIpICsgc2luICogKDEgLSBsdW1CKSwgMCwgMCxcbiAgICAgICAgbHVtUiArIGNvcyAqICgtbHVtUikgKyBzaW4gKiAoMC4xNDMpLCBsdW1HICsgY29zICogKDEgLSBsdW1HKSArIHNpbiAqICgwLjE0MCksIGx1bUIgKyBjb3MgKiAoLWx1bUIpICsgc2luICogKC0wLjI4MyksIDAsIDAsXG4gICAgICAgIGx1bVIgKyBjb3MgKiAoLWx1bVIpICsgc2luICogKC0oMSAtIGx1bVIpKSwgbHVtRyArIGNvcyAqICgtbHVtRykgKyBzaW4gKiAobHVtRyksIGx1bUIgKyBjb3MgKiAoMSAtIGx1bUIpICsgc2luICogKGx1bUIpLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBjb250cmFzdCBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gZGFyayBhbmQgYnJpZ2h0XG4gKiBJbmNyZWFzZSBjb250cmFzdCA6IHNoYWRvd3MgZGFya2VyIGFuZCBoaWdobGlnaHRzIGJyaWdodGVyXG4gKiBEZWNyZWFzZSBjb250cmFzdCA6IGJyaW5nIHRoZSBzaGFkb3dzIHVwIGFuZCB0aGUgaGlnaGxpZ2h0cyBkb3duXG4gKlxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSB2YWx1ZSBvZiB0aGUgY29udHJhc3RcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5jb250cmFzdCA9IGZ1bmN0aW9uIChhbW91bnQsIG11bHRpcGx5KVxue1xuICAgIHZhciB2ID0gKGFtb3VudCB8fCAwKSArIDE7XG4gICAgdmFyIG8gPSAtMTI4ICogKHYgLSAxKTtcblxuICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgIHYsIDAsIDAsIDAsIG8sXG4gICAgICAgIDAsIHYsIDAsIDAsIG8sXG4gICAgICAgIDAsIDAsIHYsIDAsIG8sXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzYXR1cmF0aW9uIG1hdHJpeCwgaW5jcmVhc2UgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBjb2xvcnNcbiAqIEluY3JlYXNlIHNhdHVyYXRpb24gOiBpbmNyZWFzZSBjb250cmFzdCwgYnJpZ2h0bmVzcywgYW5kIHNoYXJwbmVzc1xuICpcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn1cbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQsIG11bHRpcGx5KVxue1xuICAgIHZhciB4ID0gKGFtb3VudCB8fCAwKSAqIDIgLyAzICsgMTtcbiAgICB2YXIgeSA9ICgoeCAtIDEpICogLTAuNSk7XG5cbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICB4LCB5LCB5LCAwLCAwLFxuICAgICAgICB5LCB4LCB5LCAwLCAwLFxuICAgICAgICB5LCB5LCB4LCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKipcbiAqIERlc2F0dXJhdGUgaW1hZ2UgKHJlbW92ZSBjb2xvcilcbiAqXG4gKiBDYWxsIHRoZSBzYXR1cmF0ZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24gKG11bHRpcGx5KSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG57XG4gICAgdGhpcy5zYXR1cmF0ZSgtMSk7XG59O1xuXG4vKipcbiAqIE5lZ2F0aXZlIGltYWdlIChpbnZlcnNlIG9mIGNsYXNzaWMgcmdiIG1hdHJpeClcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUubmVnYXRpdmUgPSBmdW5jdGlvbiAobXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMCwgMSwgMSwgMCwgMCxcbiAgICAgICAgMSwgMCwgMSwgMCwgMCxcbiAgICAgICAgMSwgMSwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBTZXBpYSBpbWFnZVxuICpcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5zZXBpYSA9IGZ1bmN0aW9uIChtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAwLjM5MywgMC43Njg5OTk5LCAwLjE4ODk5OTk5LCAwLCAwLFxuICAgICAgICAwLjM0OSwgMC42ODU5OTk5LCAwLjE2Nzk5OTk5LCAwLCAwLFxuICAgICAgICAwLjI3MiwgMC41MzM5OTk5LCAwLjEzMDk5OTk5LCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKipcbiAqIENvbG9yIG1vdGlvbiBwaWN0dXJlIHByb2Nlc3MgaW52ZW50ZWQgaW4gMTkxNiAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUudGVjaG5pY29sb3IgPSBmdW5jdGlvbiAobXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMS45MTI1Mjc3ODkxNDU2MDgzLCAtMC44NTQ1MzQ0OTc2OTUxNjQ1LCAtMC4wOTE1NTUwODQ4Mjc1NTU4NSwgMCwgMTEuNzkzNjAzNDM0Mzc3MzM3LFxuICAgICAgICAtMC4zMDg3ODMzMzg1OTI4MDk3LCAxLjc2NTg5MDg1NTU0NTg0MjgsIC0wLjEwNjAxNzQzMDc0NzIyMjQ1LCAwLCAtNzAuMzUyMDUxNjE0NjEzOTgsXG4gICAgICAgIC0wLjIzMTEwMzM3NzU0ODYxNiwgLTAuNzUwMTg5OTE5NzQ0MDIxMiwgMS44NDc1OTc4MTYxMDgxODksIDAsIDMwLjk1MDk0MDg2OTQ5MTEzOCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBQb2xhcm9pZCBmaWx0ZXJcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUucG9sYXJvaWQgPSBmdW5jdGlvbiAobXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMS40MzgsIC0wLjA2MiwgLTAuMDYyLCAwLCAwLFxuICAgICAgICAtMC4xMjIsIDEuMzc4LCAtMC4xMjIsIDAsIDAsXG4gICAgICAgIC0wLjAxNiwgLTAuMDE2LCAxLjQ4MywgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgd2hvIHRyYW5zZm9ybXMgOiBSZWQgLT4gQmx1ZSBhbmQgQmx1ZSAtPiBSZWRcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUudG9CR1IgPSBmdW5jdGlvbiAobXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBDb2xvciByZXZlcnNhbCBmaWxtIGludHJvZHVjZWQgYnkgRWFzdG1hbiBLb2RhayBpbiAxOTM1LiAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUua29kYWNocm9tZSA9IGZ1bmN0aW9uIChtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAxLjEyODU1ODIzOTY1OTM1MjUsIC0wLjM5NjczODIyODM2MDEzNDgsIC0wLjAzOTkyNTU5MTcyOTIxNzkzLCAwLCA2My43Mjk1ODc2MjE5NjUwMixcbiAgICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qKlxuICogQnJvd24gZGVsaWNpb3VzIGJyb3duaSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gKlxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmJyb3duaSA9IGZ1bmN0aW9uIChtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAwLjU5OTcwMjM0OTgxNTk3MTUsIDAuMzQ1NTMyNDMwNDgzOTEyNjMsIC0wLjI3MDgyOTg2NzQ1MzgwNDIsIDAsIDQ3LjQzMTkyODU1NjAwODczLFxuICAgICAgICAtMC4wMzc3MDMyNDk4Mzc3ODMxNTcsIDAuODYwOTU3NzU4Nzk5MjY0MSwgMC4xNTA1OTU1MjM4ODQ1OTkxMywgMCwgLTM2Ljk2ODQxNDk4MzE5MTI3LFxuICAgICAgICAwLjI0MTEzNjM1MTI4MTUzMzM1LCAtMC4wNzQ0MTAzNzkwODQyMjQ5MiwgMC40NDk3MjE4MjA2NDg3NzE1MywgMCwgLTcuNTYyMDc1Mjc3NTkxMjgzLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKlxuICogVmludGFnZSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gKlxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnZpbnRhZ2UgPSBmdW5jdGlvbiAobXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMC42Mjc5MzQ1NjM1NjA1OTk0LCAwLjMyMDIxODM0MjA4MTkzNjcsIC0wLjAzOTY1NDA4MjExMzEyNDUzLCAwLCA5LjY1MTI4NTgzNTI5NDEyMyxcbiAgICAgICAgMC4wMjU3ODM5NzcwNDgwODg2OCwgMC42NDQxMTg4NjQ0Mzc0NzcxLCAwLjAzMjU5MTI3NjE2MTQ5Mjk0LCAwLCA3LjQ2MjgyOTE3NjQ3MDU5MSxcbiAgICAgICAgMC4wNDY2MDU1NTU2NzgyNzE5LCAtMC4wODUxMjMyOTg3MjQ3ODkxLCAwLjUyNDE2NDgwMTg3MDA0NjUsIDAsIDUuMTU5MTkwNTg4MjM1Mjk2LFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKlxuICogV2UgZG9uJ3Qga25vdyBleGFjdGx5IHdoYXQgaXQgZG9lcywga2luZCBvZiBncmFkaWVudCBtYXAsIGJ1dCBmdW5ueSB0byBwbGF5IHdpdGghXG4gKlxuICogQHBhcmFtIGRlc2F0dXJhdGlvbiB7bnVtYmVyfVxuICogQHBhcmFtIHRvbmVkIHtudW1iZXJ9XG4gKiBAcGFyYW0gbGlnaHRDb2xvciB7c3RyaW5nfSAoZXhhbXBsZSA6IFwiMHhGRkU1ODBcIilcbiAqIEBwYXJhbSBkYXJrQ29sb3Ige3N0cmluZ30gIChleGFtcGxlIDogXCIweEZGRTU4MFwiKVxuICpcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5jb2xvclRvbmUgPSBmdW5jdGlvbiAoZGVzYXR1cmF0aW9uLCB0b25lZCwgbGlnaHRDb2xvciwgZGFya0NvbG9yLCBtdWx0aXBseSlcbntcbiAgICBkZXNhdHVyYXRpb24gPSBkZXNhdHVyYXRpb24gfHwgMC4yO1xuICAgIHRvbmVkID0gdG9uZWQgfHwgMC4xNTtcbiAgICBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAweEZGRTU4MDtcbiAgICBkYXJrQ29sb3IgPSBkYXJrQ29sb3IgfHwgMHgzMzgwMDA7XG5cbiAgICB2YXIgbFIgPSAoKGxpZ2h0Q29sb3IgPj4gMTYpICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIGxHID0gKChsaWdodENvbG9yID4+IDgpICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIGxCID0gKGxpZ2h0Q29sb3IgJiAweEZGKSAvIDI1NTtcblxuICAgIHZhciBkUiA9ICgoZGFya0NvbG9yID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xuICAgIHZhciBkRyA9ICgoZGFya0NvbG9yID4+IDgpICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIGRCID0gKGRhcmtDb2xvciAmIDB4RkYpIC8gMjU1O1xuXG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMC4zLCAwLjU5LCAwLjExLCAwLCAwLFxuICAgICAgICBsUiwgbEcsIGxCLCBkZXNhdHVyYXRpb24sIDAsXG4gICAgICAgIGRSLCBkRywgZEIsIHRvbmVkLCAwLFxuICAgICAgICBsUiAtIGRSLCBsRyAtIGRHLCBsQiAtIGRCLCAwLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKlxuICogTmlnaHQgZWZmZWN0XG4gKlxuICogQHBhcmFtIGludGVuc2l0eSB7bnVtYmVyfVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLm5pZ2h0ID0gZnVuY3Rpb24gKGludGVuc2l0eSwgbXVsdGlwbHkpXG57XG4gICAgaW50ZW5zaXR5ID0gaW50ZW5zaXR5IHx8IDAuMTtcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICBpbnRlbnNpdHkgKiAoIC0yLjApLCAtaW50ZW5zaXR5LCAwLCAwLCAwLFxuICAgICAgICAtaW50ZW5zaXR5LCAwLCBpbnRlbnNpdHksIDAsIDAsXG4gICAgICAgIDAsIGludGVuc2l0eSwgaW50ZW5zaXR5ICogMi4wLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG5cbi8qXG4gKiBQcmVkYXRvciBlZmZlY3RcbiAqXG4gKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyBhIG5ldyBpbmRlcGVudCBvbmVcbiAqXG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IGhvdyBtdWNoIHRoZSBwcmVkYXRvciBmZWVscyBoaXMgZnV0dXJlIHZpY3RpbVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnByZWRhdG9yID0gZnVuY3Rpb24gKGFtb3VudCwgbXVsdGlwbHkpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMTEuMjI0MTMwNjMwNDkzMTY0ICogYW1vdW50LCAtNC43OTQ0ODY5OTk1MTE3MTkgKiBhbW91bnQsIC0yLjg3NDYxMTg1NDU1MzIyMjcgKiBhbW91bnQsIDAgKiBhbW91bnQsIDAuNDAzNDI0MzgyMjA5Nzc3ODMgKiBhbW91bnQsXG4gICAgICAgIC0zLjYzMzA2OTc1MzY0Njg1MDYgKiBhbW91bnQsIDkuMTkzMTU3MTk2MDQ0OTIyICogYW1vdW50LCAtMi45NTE4MTA4MzY3OTE5OTIgKiBhbW91bnQsIDAgKiBhbW91bnQsIC0xLjMxNjEzNTA0ODg2NjI3MiAqIGFtb3VudCxcbiAgICAgICAgLTMuMjE4NDE5NzkwMjY3OTQ0MyAqIGFtb3VudCwgLTQuMjM3NTAzMDUxNzU3ODEyNSAqIGFtb3VudCwgNy40NzY0NDgwNTkwODIwMzEgKiBhbW91bnQsIDAgKiBhbW91bnQsIDAuODA0NDQ1OTIyMzc0NzI1MyAqIGFtb3VudCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLypcbiAqIExTRCBlZmZlY3RcbiAqXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gYW1vdW50IHtudW1iZXJ9IEhvdyBjcmF6eSBpcyB5b3VyIGVmZmVjdFxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmxzZCA9IGZ1bmN0aW9uIChtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAyLCAtMC40LCAwLjUsIDAsIDAsXG4gICAgICAgIC0wLjUsIDIsIC0wLjQsIDAsIDAsXG4gICAgICAgIC0wLjQsIC0wLjUsIDMsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qXG4gKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmVcbiAqXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgZmFsc2UpO1xufTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXRyaXggb2YgdGhlIGNvbG9yIG1hdHJpeCBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQ29sb3JNYXRyaXhGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdXG4gICAgICovXG4gICAgbWF0cml4OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvY29sb3IvQ29sb3JNYXRyaXhGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoaXMgbG93ZXJzIHRoZSBjb2xvciBkZXB0aCBvZiB5b3VyIGltYWdlIGJ5IHRoZSBnaXZlbiBhbW91bnQsIHByb2R1Y2luZyBhbiBpbWFnZSB3aXRoIGEgc21hbGxlciBwYWxldHRlLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBDb2xvclN0ZXBGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgc3RlcDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcblxcbiAgICBjb2xvciA9IGZsb29yKGNvbG9yICogc3RlcCkgLyBzdGVwO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBzdGVwOiB7IHR5cGU6ICcxZicsIHZhbHVlOiA1IH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbkNvbG9yU3RlcEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkNvbG9yU3RlcEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xvclN0ZXBGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yU3RlcEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29sb3JTdGVwRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2Ygc3RlcHMgdG8gcmVkdWNlIHRoZSBwYWxldHRlIGJ5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQ29sb3JTdGVwRmlsdGVyI1xuICAgICAqL1xuICAgIHN0ZXA6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zdGVwLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zdGVwLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9jb2xvci9Db2xvclN0ZXBGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoZSBDb252b2x1dGlvbkZpbHRlciBjbGFzcyBhcHBsaWVzIGEgbWF0cml4IGNvbnZvbHV0aW9uIGZpbHRlciBlZmZlY3QuXG4gKiBBIGNvbnZvbHV0aW9uIGNvbWJpbmVzIHBpeGVscyBpbiB0aGUgaW5wdXQgaW1hZ2Ugd2l0aCBuZWlnaGJvcmluZyBwaXhlbHMgdG8gcHJvZHVjZSBhIG5ldyBpbWFnZS5cbiAqIEEgd2lkZSB2YXJpZXR5IG9mIGltYWdlIGVmZmVjdHMgY2FuIGJlIGFjaGlldmVkIHRocm91Z2ggY29udm9sdXRpb25zLCBpbmNsdWRpbmcgYmx1cnJpbmcsIGVkZ2VcbiAqIGRldGVjdGlvbiwgc2hhcnBlbmluZywgZW1ib3NzaW5nLCBhbmQgYmV2ZWxpbmcuIFRoZSBtYXRyaXggc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBhIDkgcG9pbnQgQXJyYXkuXG4gKiBTZWUgaHR0cDovL2RvY3MuZ2ltcC5vcmcvZW4vcGx1Zy1pbi1jb252bWF0cml4Lmh0bWwgZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqIEBwYXJhbSBtYXRyaXgge251bWJlcltdfSBBbiBhcnJheSBvZiB2YWx1ZXMgdXNlZCBmb3IgbWF0cml4IHRyYW5zZm9ybWF0aW9uLiBTcGVjaWZpZWQgYXMgYSA5IHBvaW50IEFycmF5LlxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSBvYmplY3QgeW91IGFyZSB0cmFuc2Zvcm1pbmdcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gSGVpZ2h0IG9mIHRoZSBvYmplY3QgeW91IGFyZSB0cmFuc2Zvcm1pbmdcbiAqL1xuZnVuY3Rpb24gQ29udm9sdXRpb25GaWx0ZXIobWF0cml4LCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgbWVkaXVtcCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXG51bmlmb3JtIGZsb2F0IG1hdHJpeFs5XTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgdmVjNCBjMTEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgLSB0ZXhlbFNpemUpOyAvLyB0b3AgbGVmdFxcbiAgIHZlYzQgYzEyID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55IC0gdGV4ZWxTaXplLnkpKTsgLy8gdG9wIGNlbnRlclxcbiAgIHZlYzQgYzEzID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIHRleGVsU2l6ZS54LCB2VGV4dHVyZUNvb3JkLnkgLSB0ZXhlbFNpemUueSkpOyAvLyB0b3AgcmlnaHRcXG5cXG4gICB2ZWM0IGMyMSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSB0ZXhlbFNpemUueCwgdlRleHR1cmVDb29yZC55KSk7IC8vIG1pZCBsZWZ0XFxuICAgdmVjNCBjMjIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOyAvLyBtaWQgY2VudGVyXFxuICAgdmVjNCBjMjMgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgdGV4ZWxTaXplLngsIHZUZXh0dXJlQ29vcmQueSkpOyAvLyBtaWQgcmlnaHRcXG5cXG4gICB2ZWM0IGMzMSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSB0ZXhlbFNpemUueCwgdlRleHR1cmVDb29yZC55ICsgdGV4ZWxTaXplLnkpKTsgLy8gYm90dG9tIGxlZnRcXG4gICB2ZWM0IGMzMiA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSArIHRleGVsU2l6ZS55KSk7IC8vIGJvdHRvbSBjZW50ZXJcXG4gICB2ZWM0IGMzMyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIHRleGVsU2l6ZSk7IC8vIGJvdHRvbSByaWdodFxcblxcbiAgIGdsX0ZyYWdDb2xvciA9XFxuICAgICAgIGMxMSAqIG1hdHJpeFswXSArIGMxMiAqIG1hdHJpeFsxXSArIGMxMyAqIG1hdHJpeFsyXSArXFxuICAgICAgIGMyMSAqIG1hdHJpeFszXSArIGMyMiAqIG1hdHJpeFs0XSArIGMyMyAqIG1hdHJpeFs1XSArXFxuICAgICAgIGMzMSAqIG1hdHJpeFs2XSArIGMzMiAqIG1hdHJpeFs3XSArIGMzMyAqIG1hdHJpeFs4XTtcXG5cXG4gICBnbF9GcmFnQ29sb3IuYSA9IGMyMi5hO1xcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1hdHJpeDogICAgIHsgdHlwZTogJzFmdicsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCkgfSxcbiAgICAgICAgICAgIHRleGVsU2l6ZTogIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMSAvIHdpZHRoLCB5OiAxIC8gaGVpZ2h0IH0gfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuQ29udm9sdXRpb25GaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5Db252b2x1dGlvbkZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252b2x1dGlvbkZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQ29udm9sdXRpb25GaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnZvbHV0aW9uRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHZhbHVlcyB1c2VkIGZvciBtYXRyaXggdHJhbnNmb3JtYXRpb24uIFNwZWNpZmllZCBhcyBhIDkgcG9pbnQgQXJyYXkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkNvbnZvbHV0aW9uRmlsdGVyI1xuICAgICAqL1xuICAgIG1hdHJpeDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hdHJpeC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubWF0cml4LnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIG9iamVjdCB5b3UgYXJlIHRyYW5zZm9ybWluZ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuQ29udm9sdXRpb25GaWx0ZXIjXG4gICAgICovXG4gICAgd2lkdGg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gMS90aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS54O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUueCA9IDEvdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IG9mIHRoZSBvYmplY3QgeW91IGFyZSB0cmFuc2Zvcm1pbmdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkNvbnZvbHV0aW9uRmlsdGVyI1xuICAgICAqL1xuICAgIGhlaWdodDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAxL3RoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS55ID0gMS92YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2NvbnZvbHV0aW9uL0NvbnZvbHV0aW9uRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBBIENyb3NzIEhhdGNoIGVmZmVjdCBmaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIENyb3NzSGF0Y2hGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZmxvYXQgbHVtID0gbGVuZ3RoKHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZC54eSkucmdiKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICBpZiAobHVtIDwgMS4wMClcXG4gICAge1xcbiAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCArIGdsX0ZyYWdDb29yZC55LCAxMC4wKSA9PSAwLjApXFxuICAgICAgICB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChsdW0gPCAwLjc1KVxcbiAgICB7XFxuICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54IC0gZ2xfRnJhZ0Nvb3JkLnksIDEwLjApID09IDAuMClcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGx1bSA8IDAuNTApXFxuICAgIHtcXG4gICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggKyBnbF9GcmFnQ29vcmQueSAtIDUuMCwgMTAuMCkgPT0gMC4wKVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAobHVtIDwgMC4zKVxcbiAgICB7XFxuICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54IC0gZ2xfRnJhZ0Nvb3JkLnkgLSA1LjAsIDEwLjApID09IDAuMClcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXCJcbiAgICApO1xufVxuXG5Dcm9zc0hhdGNoRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuQ3Jvc3NIYXRjaEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDcm9zc0hhdGNoRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBDcm9zc0hhdGNoRmlsdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2Nyb3NzaGF0Y2gvQ3Jvc3NIYXRjaEZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhlIERpc3BsYWNlbWVudEZpbHRlciBjbGFzcyB1c2VzIHRoZSBwaXhlbCB2YWx1ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRleHR1cmUgKGNhbGxlZCB0aGUgZGlzcGxhY2VtZW50IG1hcCkgdG8gcGVyZm9ybSBhIGRpc3BsYWNlbWVudCBvZiBhbiBvYmplY3QuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGZpbHRlciB0byBhcHBseSBhbGwgbWFub3Igb2YgY3Jhenkgd2FycGluZyBlZmZlY3RzXG4gKiBDdXJyZW50bHkgdGhlIHIgcHJvcGVydHkgb2YgdGhlIHRleHR1cmUgaXMgdXNlZCB0byBvZmZzZXQgdGhlIHggYW5kIHRoZSBnIHByb3BlcnR5IG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB5LlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICogQHBhcmFtIHNwcml0ZSB7UElYSS5TcHJpdGV9IHRoZSBzcHJpdGUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbWVudCBtYXAuIChtYWtlIHN1cmUgaXRzIGFkZGVkIHRvIHRoZSBzY2VuZSEpXG4gKi9cbmZ1bmN0aW9uIERpc3BsYWNlbWVudEZpbHRlcihzcHJpdGUsIHNjYWxlKVxue1xuICAgIHZhciBtYXNrTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG4gICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcblxuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyBvdGhlck1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hcENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgIHZNYXBDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcbiAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxufVxcblwiLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hcENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudW5pZm9ybSB2ZWMyIHNjYWxlO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcFNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIHZlYzQgbWFwID0gIHRleHR1cmUyRChtYXBTYW1wbGVyLCB2TWFwQ29vcmQpO1xcblxcbiAgIG1hcCAtPSAwLjU7XFxuICAgbWFwLnh5ICo9IHNjYWxlO1xcblxcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyBtYXAueCwgdlRleHR1cmVDb29yZC55ICsgbWFwLnkpKTtcXG59XFxuXCIsXG4gICAgICAgIC8vIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1hcFNhbXBsZXI6ICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogc3ByaXRlLnRleHR1cmUgfSxcbiAgICAgICAgICAgIG90aGVyTWF0cml4OiAgICB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG1hc2tNYXRyaXgudG9BcnJheSh0cnVlKSB9LFxuICAgICAgICAgICAgc2NhbGU6ICAgICAgICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMSwgeTogMSB9IH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLm1hc2tTcHJpdGUgPSBzcHJpdGU7XG4gICAgdGhpcy5tYXNrTWF0cml4ID0gbWFza01hdHJpeDtcblxuICAgIGlmIChzY2FsZSA9PT0gbnVsbCB8fCBzY2FsZSA9PT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgc2NhbGUgPSAyMDtcbiAgICB9XG5cbiAgICB0aGlzLnNjYWxlID0gbmV3IGNvcmUuUG9pbnQoc2NhbGUsIHNjYWxlKTtcbn1cblxuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpc3BsYWNlbWVudEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gRGlzcGxhY2VtZW50RmlsdGVyO1xuXG5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxue1xuICAgIHZhciBmaWx0ZXJNYW5hZ2VyID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlcjtcblxuICAgIGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlTWFwcGVkTWF0cml4KGlucHV0LmZyYW1lLCB0aGlzLm1hc2tTcHJpdGUsIHRoaXMubWFza01hdHJpeCk7XG5cbiAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4LnZhbHVlID0gdGhpcy5tYXNrTWF0cml4LnRvQXJyYXkodHJ1ZSk7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZS54ID0gdGhpcy5zY2FsZS54ICogKDEvaW5wdXQuZnJhbWUud2lkdGgpO1xuICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUueSA9IHRoaXMuc2NhbGUueSAqICgxL2lucHV0LmZyYW1lLmhlaWdodCk7XG5cbiAgICB2YXIgc2hhZGVyID0gdGhpcy5nZXRTaGFkZXIocmVuZGVyZXIpO1xuICAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCk7XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKERpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcC4gTXVzdCBiZSBwb3dlciBvZiAyIHNpemVkIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5EaXNwbGFjZW1lbnRGaWx0ZXIjXG4gICAgICovXG4gICAgbWFwOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlci52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlci52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9kaXNwbGFjZW1lbnQvRGlzcGxhY2VtZW50RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqIG9yaWdpbmFsIGZpbHRlcjogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvZnVuL2RvdHNjcmVlbi5qc1xuICovXG5cbi8qKlxuICogVGhpcyBmaWx0ZXIgYXBwbGllcyBhIGRvdHNjcmVlbiBlZmZlY3QgbWFraW5nIGRpc3BsYXkgb2JqZWN0cyBhcHBlYXIgdG8gYmUgbWFkZSBvdXQgb2ZcbiAqIGJsYWNrIGFuZCB3aGl0ZSBoYWxmdG9uZSBkb3RzIGxpa2UgYW4gb2xkIHByaW50ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIERvdFNjcmVlbkZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHZlYzQgZGltZW5zaW9ucztcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG51bmlmb3JtIGZsb2F0IGFuZ2xlO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuXFxuZmxvYXQgcGF0dGVybigpXFxue1xcbiAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpLCBjID0gY29zKGFuZ2xlKTtcXG4gICB2ZWMyIHRleCA9IHZUZXh0dXJlQ29vcmQgKiBkaW1lbnNpb25zLnh5O1xcbiAgIHZlYzIgcG9pbnQgPSB2ZWMyKFxcbiAgICAgICBjICogdGV4LnggLSBzICogdGV4LnksXFxuICAgICAgIHMgKiB0ZXgueCArIGMgKiB0ZXgueVxcbiAgICkgKiBzY2FsZTtcXG4gICByZXR1cm4gKHNpbihwb2ludC54KSAqIHNpbihwb2ludC55KSkgKiA0LjA7XFxufVxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgIGZsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcXG4gICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoYXZlcmFnZSAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKCkpLCBjb2xvci5hKTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBzY2FsZTogICAgICB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgICBhbmdsZTogICAgICB7IHR5cGU6ICcxZicsIHZhbHVlOiA1IH0sXG4gICAgICAgICAgICBkaW1lbnNpb25zOiB7IHR5cGU6ICc0ZnYnLCB2YWx1ZTogWzAsIDAsIDAsIDBdIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbkRvdFNjcmVlbkZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkRvdFNjcmVlbkZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb3RTY3JlZW5GaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IERvdFNjcmVlbkZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBvZiB0aGUgZWZmZWN0LlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkRvdFNjcmVlbkZpbHRlciNcbiAgICAgKi9cbiAgICBzY2FsZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIGVmZmVjdC5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Eb3RTY3JlZW5GaWx0ZXIjXG4gICAgICovXG4gICAgYW5nbGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2RvdC9Eb3RTY3JlZW5GaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoaXMgZ3JleXNjYWxlcyB0aGUgcGFsZXR0ZSBvZiB5b3VyIERpc3BsYXkgT2JqZWN0cy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gR3JheUZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IGdyYXk7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peChnbF9GcmFnQ29sb3IucmdiLCB2ZWMzKDAuMjEyNipnbF9GcmFnQ29sb3IuciArIDAuNzE1MipnbF9GcmFnQ29sb3IuZyArIDAuMDcyMipnbF9GcmFnQ29sb3IuYiksIGdyYXkpO1xcbn1cXG5cIixcbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBncmF5OiB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbkdyYXlGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5HcmF5RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyYXlGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEdyYXlGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEdyYXlGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBncmF5LiAxIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGJsYWNrIGFuZCB3aGl0ZSwgMCB3aWxsIG1ha2UgdGhlIG9iamVjdCBpdHMgbm9ybWFsIGNvbG9yLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuR3JheUZpbHRlciNcbiAgICAgKi9cbiAgICBncmF5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ3JheS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuZ3JheS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvZ3JheS9HcmF5RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKSxcbiAgICBCbHVyWEZpbHRlciA9IHJlcXVpcmUoJy4uL2JsdXIvQmx1clhGaWx0ZXInKSxcbiAgICBCbHVyWVRpbnRGaWx0ZXIgPSByZXF1aXJlKCcuL0JsdXJZVGludEZpbHRlcicpO1xuXG4vKipcbiAqIFRoZSBEcm9wU2hhZG93RmlsdGVyIGFwcGxpZXMgYSBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cbiAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ciBjYW4gYmUgc2V0IGZvciB4LSBhbmQgeS1heGlzIHNlcGFyYXRlbHkuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIERyb3BTaGFkb3dGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1clhGaWx0ZXIoKTtcbiAgICB0aGlzLmJsdXJZVGludEZpbHRlciA9IG5ldyBCbHVyWVRpbnRGaWx0ZXIoKTtcblxuICAgIHRoaXMuZGVmYXVsdEZpbHRlciA9IG5ldyBjb3JlLkFic3RyYWN0RmlsdGVyKCk7XG5cbiAgICB0aGlzLnBhZGRpbmcgPSAzMDtcblxuICAgIHRoaXMuX2RpcnR5UG9zaXRpb24gPSB0cnVlO1xuICAgIHRoaXMuX2FuZ2xlID0gNDUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gMTA7XG4gICAgdGhpcy5hbHBoYSA9IDAuNzU7XG4gICAgdGhpcy5oaWRlT2JqZWN0ID0gZmFsc2U7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBjb3JlLkJMRU5EX01PREVTLk1VTFRJUExZO1xufVxuXG5Ecm9wU2hhZG93RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuRHJvcFNoYWRvd0ZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcm9wU2hhZG93RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBEcm9wU2hhZG93RmlsdGVyO1xuXG5Ecm9wU2hhZG93RmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dClcbntcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG5cbiAgICAvL1RPRE8gLSBjb3B5VGV4U3ViSW1hZ2UyRCBjb3VsZCBiZSB1c2VkIGhlcmU/XG4gICAgaWYodGhpcy5fZGlydHlQb3NpdGlvbilcbiAgICB7XG4gICAgICAgIHRoaXMuX2RpcnR5UG9zaXRpb24gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5vZmZzZXQudmFsdWVbMF0gPSBNYXRoLnNpbih0aGlzLl9hbmdsZSkgKiB0aGlzLl9kaXN0YW5jZTtcbiAgICAgICAgdGhpcy5ibHVyWVRpbnRGaWx0ZXIudW5pZm9ybXMub2Zmc2V0LnZhbHVlWzFdID0gTWF0aC5jb3ModGhpcy5fYW5nbGUpICogdGhpcy5fZGlzdGFuY2U7XG4gICAgfVxuXG4gICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgaW5wdXQsIHJlbmRlclRhcmdldCk7XG5cbiAgICByZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XG5cbiAgICB0aGlzLmJsdXJZVGludEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQpO1xuXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoY29yZS5CTEVORF9NT0RFUy5OT1JNQUwpO1xuXG4gICAgaWYoIXRoaXMuaGlkZU9iamVjdClcbiAgICB7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0RmlsdGVyLmFwcGx5RmlsdGVyKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KTtcbiAgICB9XG5cblxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEcm9wU2hhZG93RmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5Ecm9wU2hhZG93RmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllUaW50RmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkRyb3BTaGFkb3dGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXJYOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWSBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuRHJvcFNoYWRvd0ZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG4gICAgYmx1clk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibHVyWVRpbnRGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cllUaW50RmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIFBJWEkuZmlsdGVycy5Ecm9wU2hhZG93RmlsdGVyI1xuICAgICAqL1xuICAgIGNvbG9yOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICBjb3JlLnV0aWxzLnJnYjJoZXgoIHRoaXMuYmx1cllUaW50RmlsdGVyLnVuaWZvcm1zLmNvbG9yLnZhbHVlICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5jb2xvci52YWx1ZSA9IGNvcmUudXRpbHMuaGV4MnJnYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWxwaGEgb2YgdGhlIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBQSVhJLmZpbHRlcnMuRHJvcFNoYWRvd0ZpbHRlciNcbiAgICAgKi9cbiAgICBhbHBoYToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5ibHVyWVRpbnRGaWx0ZXIudW5pZm9ybXMuYWxwaGEudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5hbHBoYS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRpc3RhbmNlIG9mIHRoZSBzaGFkb3dcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkRyb3BTaGFkb3dGaWx0ZXIjXG4gICAgICovXG4gICAgZGlzdGFuY2U6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuX2Rpc3RhbmNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGlydHlQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFuZ2xlIG9mIHRoZSBzaGFkb3dcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgUElYSS5maWx0ZXJzLkRyb3BTaGFkb3dGaWx0ZXIjXG4gICAgICovXG4gICAgYW5nbGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuX2FuZ2xlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGlydHlQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9hbmdsZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvZHJvcHNoYWRvdy9Ecm9wU2hhZG93RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcblxuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoZSBCbHVyWVRpbnRGaWx0ZXIgYXBwbGllcyBhIHZlcnRpY2FsIEdhdXNzaWFuIGJsdXIgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBCbHVyWVRpbnRGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbnVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XFxudW5pZm9ybSB2ZWMyIG9mZnNldDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1s2XTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoKGFWZXJ0ZXhQb3NpdGlvbitvZmZzZXQpLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXG4gICAgdkJsdXJUZXhDb29yZHNbIDBdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAtMC4wMTIgKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyAxXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgLTAuMDA4ICogc3RyZW5ndGgpO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgMl0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsIC0wLjAwNCAqIHN0cmVuZ3RoKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDNdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAgMC4wMDQgKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyA0XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgIDAuMDA4ICogc3RyZW5ndGgpO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgNV0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICAwLjAxMiAqIHN0cmVuZ3RoKTtcXG5cXG4gICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcbn1cXG5cIixcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzZdO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcXG5cXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDBdKSowLjAwNDQzMTg0ODQxMTkzODM0MTtcXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDFdKSowLjA1Mzk5MDk2NjUxMzE4OTg1O1xcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMl0pKjAuMjQxOTcwNzI0NTE5MTQ1NDtcXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCAgICAgKSowLjM5ODk0MjI4MDQwMTQzMjc7XFxuICAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAzXSkqMC4yNDE5NzA3MjQ1MTkxNDU0O1xcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgNF0pKjAuMDUzOTkwOTY2NTEzMTg5ODU7XFxuICAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyA1XSkqMC4wMDQ0MzE4NDg0MTE5MzgzNDE7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLnJnYiAqIHN1bS5hICogYWxwaGEsIHN1bS5hICogYWxwaGEgKTtcXG59XFxuXCIsXG4gICAgICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgYmx1cjogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMSAvIDUxMiB9LFxuICAgICAgICAgICAgY29sb3I6IHsgdHlwZTogJ2MnLCB2YWx1ZTogWzAsMCwwXX0sXG4gICAgICAgICAgICBhbHBoYTogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMC43IH0sXG4gICAgICAgICAgICBvZmZzZXQ6IHsgdHlwZTogJzJmJywgdmFsdWU6WzUsIDVdfSxcbiAgICAgICAgICAgIHN0cmVuZ3RoOiB7IHR5cGU6ICcxZicsIHZhbHVlOjF9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5wYXNzZXMgPSAxO1xuICAgIHRoaXMuc3RyZW5ndGggPSA0O1xufVxuXG5CbHVyWVRpbnRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5CbHVyWVRpbnRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmx1cllUaW50RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBCbHVyWVRpbnRGaWx0ZXI7XG5cbkJsdXJZVGludEZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKVxue1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XG5cbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdGhpcy5zdHJlbmd0aCAvIDQgLyB0aGlzLnBhc3NlcyAqIChpbnB1dC5mcmFtZS5oZWlnaHQgLyBpbnB1dC5zaXplLmhlaWdodCk7XG5cbiAgICBpZih0aGlzLnBhc3NlcyA9PT0gMSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcbiAgICAgICAgdmFyIGZsaXAgPSBpbnB1dDtcbiAgICAgICAgdmFyIGZsb3AgPSByZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMucGFzc2VzLTE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIGZsaXAsIGZsb3AsIGNsZWFyKTtcblxuICAgICAgICAgICB2YXIgdGVtcCA9IGZsb3A7XG4gICAgICAgICAgIGZsb3AgPSBmbGlwO1xuICAgICAgICAgICBmbGlwID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBmbGlwLCBvdXRwdXQsIGNsZWFyKTtcblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnJldHVyblJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIH1cbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmx1cllUaW50RmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5CbHVyWVRpbnRGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuc3RyZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSB2YWx1ZSAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL2Ryb3BzaGFkb3cvQmx1cllUaW50RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGlzIGludmVydHMgeW91ciBEaXNwbGF5IE9iamVjdHMgY29sb3JzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBJbnZlcnRGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gZmxvYXQgaW52ZXJ0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggKHZlYzMoMSktZ2xfRnJhZ0NvbG9yLnJnYikgKiBnbF9GcmFnQ29sb3IuYSwgZ2xfRnJhZ0NvbG9yLnJnYiwgMS4wIC0gaW52ZXJ0KTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBpbnZlcnQ6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuSW52ZXJ0RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuSW52ZXJ0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludmVydEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gSW52ZXJ0RmlsdGVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbnZlcnRGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBpbnZlcnQuIGAxYCB3aWxsIGZ1bGx5IGludmVydCB0aGUgY29sb3JzLCBhbmRcbiAgICAgKiBgMGAgd2lsbCBtYWtlIHRoZSBvYmplY3QgaXRzIG5vcm1hbCBjb2xvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLkludmVydEZpbHRlciNcbiAgICAgKi9cbiAgICBpbnZlcnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5pbnZlcnQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmludmVydC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvaW52ZXJ0L0ludmVydEZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogQGF1dGhvciBWaWNvIEB2aWNvY290ZWFcbiAqIG9yaWdpbmFsIGZpbHRlcjogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYWRqdXN0L25vaXNlLmpzXG4gKi9cblxuLyoqXG4gKiBBIE5vaXNlIGVmZmVjdCBmaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIE5vaXNlRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIGZsb2F0IG5vaXNlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbmZsb2F0IHJhbmQodmVjMiBjbylcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGZsb2F0IGRpZmYgPSAocmFuZCh2VGV4dHVyZUNvb3JkKSAtIDAuNSkgKiBub2lzZTtcXG5cXG4gICAgY29sb3IuciArPSBkaWZmO1xcbiAgICBjb2xvci5nICs9IGRpZmY7XFxuICAgIGNvbG9yLmIgKz0gZGlmZjtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgbm9pc2U6IHsgdHlwZTogJzFmJywgdmFsdWU6IDAuNSB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5Ob2lzZUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbk5vaXNlRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vaXNlRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBOb2lzZUZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTm9pc2VGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBub2lzZSB0byBhcHBseS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLk5vaXNlRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDAuNVxuICAgICAqL1xuICAgIG5vaXNlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubm9pc2UudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLm5vaXNlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy9ub2lzZS9Ob2lzZUZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoaXMgZmlsdGVyIGFwcGxpZXMgYSBwaXhlbGF0ZSBlZmZlY3QgbWFraW5nIGRpc3BsYXkgb2JqZWN0cyBhcHBlYXIgJ2Jsb2NreScuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIFBpeGVsYXRlRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHZlYzQgZGltZW5zaW9ucztcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQ7XFxuXFxuICAgIHZlYzIgc2l6ZSA9IGRpbWVuc2lvbnMueHkgLyBwaXhlbFNpemU7XFxuXFxuICAgIHZlYzIgY29sb3IgPSBmbG9vciggKCB2VGV4dHVyZUNvb3JkICogc2l6ZSApICkgLyBzaXplICsgcGl4ZWxTaXplL2RpbWVuc2lvbnMueHkgKiAwLjU7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29sb3IpO1xcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHsgdHlwZTogJzRmdicsICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMF0pIH0sXG4gICAgICAgICAgICBwaXhlbFNpemU6ICB7IHR5cGU6ICd2MicsICAgdmFsdWU6IHsgeDogMTAsIHk6IDEwIH0gfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuUGl4ZWxhdGVGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5QaXhlbGF0ZUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaXhlbGF0ZUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gUGl4ZWxhdGVGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFBpeGVsYXRlRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoaXMgYSBwb2ludCB0aGF0IGRlc2NyaWJlcyB0aGUgc2l6ZSBvZiB0aGUgYmxvY2tzLlxuICAgICAqIHggaXMgdGhlIHdpZHRoIG9mIHRoZSBibG9jayBhbmQgeSBpcyB0aGUgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlBpeGVsYXRlRmlsdGVyI1xuICAgICAqL1xuICAgIHNpemU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5waXhlbFNpemUudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnBpeGVsU2l6ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvcGl4ZWxhdGUvUGl4ZWxhdGVGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBBbiBSR0IgU3BsaXQgRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBSR0JTcGxpdEZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7XFxudW5pZm9ybSB2ZWMyIHJlZDtcXG51bmlmb3JtIHZlYzIgZ3JlZW47XFxudW5pZm9ybSB2ZWMyIGJsdWU7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX0ZyYWdDb2xvci5yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgcmVkL2RpbWVuc2lvbnMueHkpLnI7XFxuICAgZ2xfRnJhZ0NvbG9yLmcgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBncmVlbi9kaW1lbnNpb25zLnh5KS5nO1xcbiAgIGdsX0ZyYWdDb2xvci5iID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgYmx1ZS9kaW1lbnNpb25zLnh5KS5iO1xcbiAgIGdsX0ZyYWdDb2xvci5hID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKS5hO1xcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlZDogICAgICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMjAsIHk6IDIwIH0gfSxcbiAgICAgICAgICAgIGdyZWVuOiAgICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogLTIwLCB5OiAyMCB9IH0sXG4gICAgICAgICAgICBibHVlOiAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDIwLCB5OiAtMjAgfSB9LFxuICAgICAgICAgICAgZGltZW5zaW9uczogeyB0eXBlOiAnNGZ2JywgdmFsdWU6IFswLCAwLCAwLCAwXSB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5SR0JTcGxpdEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcblJHQlNwbGl0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJHQlNwbGl0RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBSR0JTcGxpdEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogUmVkIGNoYW5uZWwgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlJHQlNwbGl0RmlsdGVyI1xuICAgICAqL1xuICAgIHJlZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnJlZC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucmVkLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JlZW4gY2hhbm5lbCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuUkdCU3BsaXRGaWx0ZXIjXG4gICAgICovXG4gICAgZ3JlZW46IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ncmVlbi52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuZ3JlZW4udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCbHVlIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5SR0JTcGxpdEZpbHRlciNcbiAgICAgKi9cbiAgICBibHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuYmx1ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuYmx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvcmdiL1JHQlNwbGl0RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhlIENvbG9yTWF0cml4RmlsdGVyIGNsYXNzIGxldHMgeW91IGFwcGx5IGEgNHg0IG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgUkdCQVxuICogY29sb3IgYW5kIGFscGhhIHZhbHVlcyBvZiBldmVyeSBwaXhlbCBvbiB5b3VyIGRpc3BsYXlPYmplY3QgdG8gcHJvZHVjZSBhIHJlc3VsdFxuICogd2l0aCBhIG5ldyBzZXQgb2YgUkdCQSBjb2xvciBhbmQgYWxwaGEgdmFsdWVzLiBJdCdzIHByZXR0eSBwb3dlcmZ1bCFcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gU2hvY2t3YXZlRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcbnVuaWZvcm0gdmVjMyBwYXJhbXM7IC8vIDEwLjAsIDAuOCwgMC4xXFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICB2ZWMyIHV2ID0gdlRleHR1cmVDb29yZDtcXG4gICAgdmVjMiB0ZXhDb29yZCA9IHV2O1xcblxcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UodXYsIGNlbnRlcik7XFxuXFxuICAgIGlmICggKGRpc3QgPD0gKHRpbWUgKyBwYXJhbXMueikpICYmIChkaXN0ID49ICh0aW1lIC0gcGFyYW1zLnopKSApXFxuICAgIHtcXG4gICAgICAgIGZsb2F0IGRpZmYgPSAoZGlzdCAtIHRpbWUpO1xcbiAgICAgICAgZmxvYXQgcG93RGlmZiA9IDEuMCAtIHBvdyhhYnMoZGlmZipwYXJhbXMueCksIHBhcmFtcy55KTtcXG5cXG4gICAgICAgIGZsb2F0IGRpZmZUaW1lID0gZGlmZiAgKiBwb3dEaWZmO1xcbiAgICAgICAgdmVjMiBkaWZmVVYgPSBub3JtYWxpemUodXYgLSBjZW50ZXIpO1xcbiAgICAgICAgdGV4Q29vcmQgPSB1diArIChkaWZmVVYgKiBkaWZmVGltZSk7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB0ZXhDb29yZCk7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgY2VudGVyOiB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDAuNSwgeTogMC41IH0gfSxcbiAgICAgICAgICAgIHBhcmFtczogeyB0eXBlOiAndjMnLCB2YWx1ZTogeyB4OiAxMCwgeTogMC44LCB6OiAwLjEgfSB9LFxuICAgICAgICAgICAgdGltZTogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMCB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5TaG9ja3dhdmVGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5TaG9ja3dhdmVGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hvY2t3YXZlRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBTaG9ja3dhdmVGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNob2Nrd2F2ZUZpbHRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjZW50ZXIgb2YgdGhlIHNob2Nrd2F2ZSBpbiBub3JtYWxpemVkIHNjcmVlbiBjb29yZHMuIFRoYXQgaXNcbiAgICAgKiAoMCwwKSBpcyB0aGUgdG9wLWxlZnQgYW5kICgxLDEpIGlzIHRoZSBib3R0b20gcmlnaHQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuU2hvY2t3YXZlRmlsdGVyI1xuICAgICAqL1xuICAgIGNlbnRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmNlbnRlci52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuY2VudGVyLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhcmFtcyBvZiB0aGUgc2hvY2t3YXZlLiBUaGVzZSBtb2RpZnkgdGhlIGxvb2sgYW5kIGJlaGF2aW9yIG9mXG4gICAgICogdGhlIHNob2Nrd2F2ZSBhcyBpdCByaXBwbGVzIG91dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5TaG9ja3dhdmVGaWx0ZXIjXG4gICAgICovXG4gICAgcGFyYW1zOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucGFyYW1zLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5wYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxhcHNlZCB0aW1lIG9mIHRoZSBzaG9ja3dhdmUuIFRoaXMgY29udHJvbHMgdGhlIHNwZWVkIGF0IHdoaWNoXG4gICAgICogdGhlIHNob2Nrd2F2ZSByaXBwbGVzIG91dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlNob2Nrd2F2ZUZpbHRlciNcbiAgICAgKi9cbiAgICB0aW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudGltZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvc2hvY2t3YXZlL1Nob2Nrd2F2ZUZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoaXMgYXBwbGllcyBhIHNlcGlhIGVmZmVjdCB0byB5b3VyIERpc3BsYXkgT2JqZWN0cy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gU2VwaWFGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgc2VwaWE7XFxuXFxuY29uc3QgbWF0MyBzZXBpYU1hdHJpeCA9IG1hdDMoMC4zNTg4LCAwLjcwNDQsIDAuMTM2OCwgMC4yOTkwLCAwLjU4NzAsIDAuMTE0MCwgMC4yMzkyLCAwLjQ2OTYsIDAuMDkxMik7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZ2xfRnJhZ0NvbG9yLnJnYiAqIHNlcGlhTWF0cml4LCBzZXBpYSk7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgc2VwaWE6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuU2VwaWFGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5TZXBpYUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXBpYUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gU2VwaWFGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNlcGlhRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgc2VwaWEuIGAxYCB3aWxsIGFwcGx5IHRoZSBmdWxsIHNlcGlhIGVmZmVjdCwgYW5kXG4gICAgICogYDBgIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGl0cyBub3JtYWwgY29sb3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5TZXBpYUZpbHRlciNcbiAgICAgKi9cbiAgICBzZXBpYToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnNlcGlhLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zZXBpYS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvc2VwaWEvU2VwaWFGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBBIFNtYXJ0IEJsdXIgRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBTbWFydEJsdXJGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiBkZWx0YTtcXG5cXG5mbG9hdCByYW5kb20odmVjMyBzY2FsZSwgZmxvYXQgc2VlZClcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXogKyBzZWVkLCBzY2FsZSkpICogNDM3NTguNTQ1MyArIHNlZWQpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuICAgIGZsb2F0IHRvdGFsID0gMC4wO1xcblxcbiAgICBmbG9hdCBvZmZzZXQgPSByYW5kb20odmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKSwgMC4wKTtcXG5cXG4gICAgZm9yIChmbG9hdCB0ID0gLTMwLjA7IHQgPD0gMzAuMDsgdCsrKVxcbiAgICB7XFxuICAgICAgICBmbG9hdCBwZXJjZW50ID0gKHQgKyBvZmZzZXQgLSAwLjUpIC8gMzAuMDtcXG4gICAgICAgIGZsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcXG4gICAgICAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgZGVsdGEgKiBwZXJjZW50KTtcXG4gICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XFxuICAgICAgICBjb2xvciArPSBzYW1wbGUgKiB3ZWlnaHQ7XFxuICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiAvPSBnbF9GcmFnQ29sb3IuYSArIDAuMDAwMDE7XFxufVxcblwiLFxuICAgICAgICAvLyB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgZGVsdGE6IHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMC4xLCB5OiAwLjAgfSB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5TbWFydEJsdXJGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5TbWFydEJsdXJGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU21hcnRCbHVyRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBTbWFydEJsdXJGaWx0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvYmx1ci9TbWFydEJsdXJGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKSxcbiAgICBUaWx0U2hpZnRYRmlsdGVyID0gcmVxdWlyZSgnLi9UaWx0U2hpZnRYRmlsdGVyJyksXG4gICAgVGlsdFNoaWZ0WUZpbHRlciA9IHJlcXVpcmUoJy4vVGlsdFNoaWZ0WUZpbHRlcicpO1xuXG4vKipcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xuICovXG5cbi8qKlxuICogQSBUaWx0U2hpZnQgRmlsdGVyLiBNYW5hZ2VzIHRoZSBwYXNzIG9mIGJvdGggYSBUaWx0U2hpZnRYRmlsdGVyIGFuZCBUaWx0U2hpZnRZRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBUaWx0U2hpZnRGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlciA9IG5ldyBUaWx0U2hpZnRYRmlsdGVyKCk7XG4gICAgdGhpcy50aWx0U2hpZnRZRmlsdGVyID0gbmV3IFRpbHRTaGlmdFlGaWx0ZXIoKTtcbn1cblxuVGlsdFNoaWZ0RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuVGlsdFNoaWZ0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbHRTaGlmdEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gVGlsdFNoaWZ0RmlsdGVyO1xuXG5UaWx0U2hpZnRGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxue1xuICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcblxuICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgaW5wdXQsIHJlbmRlclRhcmdldCk7XG5cbiAgICB0aGlzLnRpbHRTaGlmdFlGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgb3V0cHV0KTtcblxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWx0U2hpZnRGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuVGlsdFNoaWZ0RmlsdGVyI1xuICAgICAqL1xuICAgIGJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWx0U2hpZnRYRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuYmx1ciA9IHRoaXMudGlsdFNoaWZ0WUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBncmFkaWVudCBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuVGlsdFNoaWZ0RmlsdGVyI1xuICAgICAqL1xuICAgIGdyYWRpZW50Qmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuZ3JhZGllbnRCbHVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50aWx0U2hpZnRYRmlsdGVyLmdyYWRpZW50Qmx1ciA9IHRoaXMudGlsdFNoaWZ0WUZpbHRlci5ncmFkaWVudEJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgWSB2YWx1ZSB0byBzdGFydCB0aGUgZWZmZWN0IGF0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuVGlsdFNoaWZ0RmlsdGVyI1xuICAgICAqL1xuICAgIHN0YXJ0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5zdGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5zdGFydCA9IHRoaXMudGlsdFNoaWZ0WUZpbHRlci5zdGFydCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBZIHZhbHVlIHRvIGVuZCB0aGUgZWZmZWN0IGF0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuVGlsdFNoaWZ0RmlsdGVyI1xuICAgICAqL1xuICAgIGVuZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuZW5kO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50aWx0U2hpZnRYRmlsdGVyLmVuZCA9IHRoaXMudGlsdFNoaWZ0WUZpbHRlci5lbmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9maWx0ZXJzL3RpbHRzaGlmdC9UaWx0U2hpZnRGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGlsdFNoaWZ0QXhpc0ZpbHRlciA9IHJlcXVpcmUoJy4vVGlsdFNoaWZ0QXhpc0ZpbHRlcicpO1xuXG4vKipcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xuICovXG5cbi8qKlxuICogQSBUaWx0U2hpZnRYRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5UaWx0U2hpZnRBeGlzRmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIFRpbHRTaGlmdFhGaWx0ZXIoKVxue1xuICAgIFRpbHRTaGlmdEF4aXNGaWx0ZXIuY2FsbCh0aGlzKTtcbn1cblxuVGlsdFNoaWZ0WEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRpbHRTaGlmdEF4aXNGaWx0ZXIucHJvdG90eXBlKTtcblRpbHRTaGlmdFhGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsdFNoaWZ0WEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gVGlsdFNoaWZ0WEZpbHRlcjtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBmaWx0ZXIgZGVsdGEgdmFsdWVzLlxuICpcbiAqL1xuVGlsdFNoaWZ0WEZpbHRlci5wcm90b3R5cGUudXBkYXRlRGVsdGEgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBkeCA9IHRoaXMudW5pZm9ybXMuZW5kLnZhbHVlLnggLSB0aGlzLnVuaWZvcm1zLnN0YXJ0LnZhbHVlLng7XG4gICAgdmFyIGR5ID0gdGhpcy51bmlmb3Jtcy5lbmQudmFsdWUueSAtIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWUueTtcbiAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhLnZhbHVlLnggPSBkeCAvIGQ7XG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS55ID0gZHkgLyBkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZmlsdGVycy90aWx0c2hpZnQvVGlsdFNoaWZ0WEZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xuICovXG5cbi8qKlxuICogQSBUaWx0U2hpZnRBeGlzRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5BYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBUaWx0U2hpZnRBeGlzRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IGJsdXI7XFxudW5pZm9ybSBmbG9hdCBncmFkaWVudEJsdXI7XFxudW5pZm9ybSB2ZWMyIHN0YXJ0O1xcbnVuaWZvcm0gdmVjMiBlbmQ7XFxudW5pZm9ybSB2ZWMyIGRlbHRhO1xcbnVuaWZvcm0gdmVjMiB0ZXhTaXplO1xcblxcbmZsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlLCBmbG9hdCBzZWVkKVxcbntcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiArIHNlZWQsIHNjYWxlKSkgKiA0Mzc1OC41NDUzICsgc2VlZCk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgZmxvYXQgdG90YWwgPSAwLjA7XFxuXFxuICAgIGZsb2F0IG9mZnNldCA9IHJhbmRvbSh2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpLCAwLjApO1xcbiAgICB2ZWMyIG5vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMyKHN0YXJ0LnkgLSBlbmQueSwgZW5kLnggLSBzdGFydC54KSk7XFxuICAgIGZsb2F0IHJhZGl1cyA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGFicyhkb3QodlRleHR1cmVDb29yZCAqIHRleFNpemUgLSBzdGFydCwgbm9ybWFsKSkgLyBncmFkaWVudEJsdXIpICogYmx1cjtcXG5cXG4gICAgZm9yIChmbG9hdCB0ID0gLTMwLjA7IHQgPD0gMzAuMDsgdCsrKVxcbiAgICB7XFxuICAgICAgICBmbG9hdCBwZXJjZW50ID0gKHQgKyBvZmZzZXQgLSAwLjUpIC8gMzAuMDtcXG4gICAgICAgIGZsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcXG4gICAgICAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgZGVsdGEgLyB0ZXhTaXplICogcGVyY2VudCAqIHJhZGl1cyk7XFxuICAgICAgICBzYW1wbGUucmdiICo9IHNhbXBsZS5hO1xcbiAgICAgICAgY29sb3IgKz0gc2FtcGxlICogd2VpZ2h0O1xcbiAgICAgICAgdG90YWwgKz0gd2VpZ2h0O1xcbiAgICB9XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yIC8gdG90YWw7XFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgLz0gZ2xfRnJhZ0NvbG9yLmEgKyAwLjAwMDAxO1xcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJsdXI6ICAgICAgICAgICB7IHR5cGU6ICcxZicsIHZhbHVlOiAxMDAgfSxcbiAgICAgICAgICAgIGdyYWRpZW50Qmx1cjogICB7IHR5cGU6ICcxZicsIHZhbHVlOiA2MDAgfSxcbiAgICAgICAgICAgIHN0YXJ0OiAgICAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDAsICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodCAvIDIgfSB9LFxuICAgICAgICAgICAgZW5kOiAgICAgICAgICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogNjAwLCAgeTogd2luZG93LmlubmVySGVpZ2h0IC8gMiB9IH0sXG4gICAgICAgICAgICBkZWx0YTogICAgICAgICAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiAzMCwgICB5OiAzMCB9IH0sXG4gICAgICAgICAgICB0ZXhTaXplOiAgICAgICAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiB3aW5kb3cuaW5uZXJXaWR0aCwgeTogd2luZG93LmlubmVySGVpZ2h0IH0gfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMudXBkYXRlRGVsdGEoKTtcbn1cblxuVGlsdFNoaWZ0QXhpc0ZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcblRpbHRTaGlmdEF4aXNGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsdFNoaWZ0QXhpc0ZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gVGlsdFNoaWZ0QXhpc0ZpbHRlcjtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBmaWx0ZXIgZGVsdGEgdmFsdWVzLlxuICogVGhpcyBpcyBvdmVycmlkZGVuIGluIHRoZSBYIGFuZCBZIGZpbHRlcnMsIGRvZXMgbm90aGluZyBmb3IgdGhpcyBjbGFzcy5cbiAqXG4gKi9cblRpbHRTaGlmdEF4aXNGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZURlbHRhID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhLnZhbHVlLnggPSAwO1xuICAgIHRoaXMudW5pZm9ybXMuZGVsdGEudmFsdWUueSA9IDA7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWx0U2hpZnRBeGlzRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1ci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlRpbHRTaGlmdEF4aXNGaWx0ZXIjXG4gICAgICovXG4gICAgYmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIGdyYWRpZW50IGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5UaWx0U2hpZnRBeGlzRmlsdGVyI1xuICAgICAqL1xuICAgIGdyYWRpZW50Qmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmdyYWRpZW50Qmx1ci52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuZ3JhZGllbnRCbHVyLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFggdmFsdWUgdG8gc3RhcnQgdGhlIGVmZmVjdCBhdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5UaWx0U2hpZnRBeGlzRmlsdGVyI1xuICAgICAqL1xuICAgIHN0YXJ0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnN0YXJ0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURlbHRhKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFggdmFsdWUgdG8gZW5kIHRoZSBlZmZlY3QgYXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnMuVGlsdFNoaWZ0QXhpc0ZpbHRlciNcbiAgICAgKi9cbiAgICBlbmQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5lbmQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmVuZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWx0YSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvdGlsdHNoaWZ0L1RpbHRTaGlmdEF4aXNGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVGlsdFNoaWZ0QXhpc0ZpbHRlciA9IHJlcXVpcmUoJy4vVGlsdFNoaWZ0QXhpc0ZpbHRlcicpO1xuXG4vKipcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xuICovXG5cbi8qKlxuICogQSBUaWx0U2hpZnRZRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUElYSS5UaWx0U2hpZnRBeGlzRmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIFRpbHRTaGlmdFlGaWx0ZXIoKVxue1xuICAgIFRpbHRTaGlmdEF4aXNGaWx0ZXIuY2FsbCh0aGlzKTtcbn1cblxuVGlsdFNoaWZ0WUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRpbHRTaGlmdEF4aXNGaWx0ZXIucHJvdG90eXBlKTtcblRpbHRTaGlmdFlGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsdFNoaWZ0WUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gVGlsdFNoaWZ0WUZpbHRlcjtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBmaWx0ZXIgZGVsdGEgdmFsdWVzLlxuICpcbiAqL1xuVGlsdFNoaWZ0WUZpbHRlci5wcm90b3R5cGUudXBkYXRlRGVsdGEgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBkeCA9IHRoaXMudW5pZm9ybXMuZW5kLnZhbHVlLnggLSB0aGlzLnVuaWZvcm1zLnN0YXJ0LnZhbHVlLng7XG4gICAgdmFyIGR5ID0gdGhpcy51bmlmb3Jtcy5lbmQudmFsdWUueSAtIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWUueTtcbiAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhLnZhbHVlLnggPSAtZHkgLyBkO1xuICAgIHRoaXMudW5pZm9ybXMuZGVsdGEudmFsdWUueSA9IGR4IC8gZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvdGlsdHNoaWZ0L1RpbHRTaGlmdFlGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGlzIGZpbHRlciBhcHBsaWVzIGEgdHdpc3QgZWZmZWN0IG1ha2luZyBkaXNwbGF5IG9iamVjdHMgYXBwZWFyIHR3aXN0ZWQgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gVHdpc3RGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xcbnVuaWZvcm0gZmxvYXQgYW5nbGU7XFxudW5pZm9ybSB2ZWMyIG9mZnNldDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgLSBvZmZzZXQ7XFxuICAgZmxvYXQgZGlzdCA9IGxlbmd0aChjb29yZCk7XFxuXFxuICAgaWYgKGRpc3QgPCByYWRpdXMpXFxuICAge1xcbiAgICAgICBmbG9hdCByYXRpbyA9IChyYWRpdXMgLSBkaXN0KSAvIHJhZGl1cztcXG4gICAgICAgZmxvYXQgYW5nbGVNb2QgPSByYXRpbyAqIHJhdGlvICogYW5nbGU7XFxuICAgICAgIGZsb2F0IHMgPSBzaW4oYW5nbGVNb2QpO1xcbiAgICAgICBmbG9hdCBjID0gY29zKGFuZ2xlTW9kKTtcXG4gICAgICAgY29vcmQgPSB2ZWMyKGNvb3JkLnggKiBjIC0gY29vcmQueSAqIHMsIGNvb3JkLnggKiBzICsgY29vcmQueSAqIGMpO1xcbiAgIH1cXG5cXG4gICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkK29mZnNldCk7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgcmFkaXVzOiAgICAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogMC41IH0sXG4gICAgICAgICAgICBhbmdsZTogICAgICB7IHR5cGU6ICcxZicsIHZhbHVlOiA1IH0sXG4gICAgICAgICAgICBvZmZzZXQ6ICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDAuNSwgeTogMC41IH0gfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuVHdpc3RGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5Ud2lzdEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUd2lzdEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gVHdpc3RGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFR3aXN0RmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoaXMgcG9pbnQgZGVzY3JpYmVzIHRoZSB0aGUgb2Zmc2V0IG9mIHRoZSB0d2lzdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Ud2lzdEZpbHRlciNcbiAgICAgKi9cbiAgICBvZmZzZXQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgcmFkaXVzIG9mIHRoZSB0d2lzdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzLlR3aXN0RmlsdGVyI1xuICAgICAqL1xuICAgIHJhZGl1czoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBhbmdsZSBvZiB0aGUgdHdpc3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFBJWEkuZmlsdGVycy5Ud2lzdEZpbHRlciNcbiAgICAgKi9cbiAgICBhbmdsZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFuZ2xlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ZpbHRlcnMvdHdpc3QvVHdpc3RGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBmaWxlICAgICAgICBNYWluIGV4cG9ydCBvZiB0aGUgUElYSSBpbnRlcmFjdGlvbnMgbGlicmFyeVxuICogQGF1dGhvciAgICAgIE1hdCBHcm92ZXMgPG1hdEBnb29kYm95ZGlnaXRhbC5jb20+XG4gKiBAY29weXJpZ2h0ICAgMjAxMy0yMDE1IEdvb2RCb3lEaWdpdGFsXG4gKiBAbGljZW5zZSAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLmludGVyYWN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEludGVyYWN0aW9uRGF0YTogICAgcmVxdWlyZSgnLi9JbnRlcmFjdGlvbkRhdGEnKSxcbiAgICBJbnRlcmFjdGlvbk1hbmFnZXI6IHJlcXVpcmUoJy4vSW50ZXJhY3Rpb25NYW5hZ2VyJyksXG4gICAgaW50ZXJhY3RpdmVUYXJnZXQ6ICByZXF1aXJlKCcuL2ludGVyYWN0aXZlVGFyZ2V0Jylcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ludGVyYWN0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogSG9sZHMgYWxsIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gYW4gSW50ZXJhY3Rpb24gZXZlbnRcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIEludGVyYWN0aW9uRGF0YSgpXG57XG4gICAgLyoqXG4gICAgICogVGhpcyBwb2ludCBzdG9yZXMgdGhlIGdsb2JhbCBjb29yZHMgb2Ygd2hlcmUgdGhlIHRvdWNoL21vdXNlIGV2ZW50IGhhcHBlbmVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsID0gbmV3IGNvcmUuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgU3ByaXRlIHRoYXQgd2FzIGludGVyYWN0ZWQgd2l0aFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5TcHJpdGV9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwYXNzZWQgdG8gYW4gZXZlbnQgaGFuZGxlciwgdGhpcyB3aWxsIGJlIHRoZSBvcmlnaW5hbCBET00gRXZlbnQgdGhhdCB3YXMgY2FwdHVyZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0V2ZW50fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG51bGw7XG59XG5cbkludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcmFjdGlvbkRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aW9uRGF0YTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXlPYmplY3QgZm9yIHRoaXMgSW50ZXJhY3Rpb25EYXRhXG4gKlxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgbG9jYWwgY29vcmRzIG9mZlxuICogQHBhcmFtIFtwb2ludF0ge1BJWEkuUG9pbnR9IEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWwgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBwb2ludClcbiAqIEBwYXJhbSBbZ2xvYmFsUG9zXSB7UElYSS5Qb2ludH0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB5b3VyIGN1c3RvbSBnbG9iYWwgY29vcmRzLCBvcHRpb25hbCAob3RoZXJ3aXNlIHdpbGwgdXNlIHRoZSBjdXJyZW50IGdsb2JhbCBjb29yZHMpXG4gKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBBIHBvaW50IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBJbnRlcmFjdGlvbkRhdGEgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIERpc3BsYXlPYmplY3RcbiAqL1xuSW50ZXJhY3Rpb25EYXRhLnByb3RvdHlwZS5nZXRMb2NhbFBvc2l0aW9uID0gZnVuY3Rpb24gKGRpc3BsYXlPYmplY3QsIHBvaW50LCBnbG9iYWxQb3MpXG57XG4gICAgcmV0dXJuIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGdsb2JhbFBvcyB8fCB0aGlzLmdsb2JhbCwgcG9pbnQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgSW50ZXJhY3Rpb25EYXRhID0gcmVxdWlyZSgnLi9JbnRlcmFjdGlvbkRhdGEnKTtcblxuLy8gTWl4IGludGVyYWN0aXZlVGFyZ2V0IGludG8gY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZVxuT2JqZWN0LmFzc2lnbihcbiAgICBjb3JlLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLFxuICAgIHJlcXVpcmUoJy4vaW50ZXJhY3RpdmVUYXJnZXQnKVxuKTtcblxuLyoqXG4gKiBUaGUgaW50ZXJhY3Rpb24gbWFuYWdlciBkZWFscyB3aXRoIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuIEFueSBEaXNwbGF5T2JqZWN0IGNhbiBiZSBpbnRlcmFjdGl2ZVxuICogaWYgaXRzIGludGVyYWN0aXZlIHBhcmFtZXRlciBpcyBzZXQgdG8gdHJ1ZVxuICogVGhpcyBtYW5hZ2VyIGFsc28gc3VwcG9ydHMgbXVsdGl0b3VjaC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ8UElYSS5XZWJHTFJlbmRlcmVyfSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICogQHBhcmFtIFtvcHRpb25zXSB7b2JqZWN0fVxuICogQHBhcmFtIFtvcHRpb25zLmF1dG9QcmV2ZW50RGVmYXVsdD10cnVlXSB7Ym9vbGVhbn0gU2hvdWxkIHRoZSBtYW5hZ2VyIGF1dG9tYXRpY2FsbHkgcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYWN0aW9ucy5cbiAqIEBwYXJhbSBbb3B0aW9ucy5pbnRlcmFjdGlvbkZyZXF1ZW5jeT0xMF0ge251bWJlcn0gRnJlcXVlbmN5IGluY3JlYXNlcyB0aGUgaW50ZXJhY3Rpb24gZXZlbnRzIHdpbGwgYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gSW50ZXJhY3Rpb25NYW5hZ2VyKHJlbmRlcmVyLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlcmVyIHRoaXMgaW50ZXJhY3Rpb24gbWFuYWdlciB3b3JrcyBmb3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlN5c3RlbVJlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBkZWZhdWx0IGJyb3dzZXIgYWN0aW9ucyBhdXRvbWF0aWNhbGx5IGJlIHByZXZlbnRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ID0gb3B0aW9ucy5hdXRvUHJldmVudERlZmF1bHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0b1ByZXZlbnREZWZhdWx0IDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEFzIHRoaXMgZnJlcXVlbmN5IGluY3JlYXNlcyB0aGUgaW50ZXJhY3Rpb24gZXZlbnRzIHdpbGwgYmUgY2hlY2tlZCBtb3JlIG9mdGVuLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IG9wdGlvbnMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgfHwgMTA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW91c2UgZGF0YVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkRhdGF9XG4gICAgICovXG4gICAgdGhpcy5tb3VzZSA9IG5ldyBJbnRlcmFjdGlvbkRhdGEoKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGRhdGEgb2JqZWN0IHRvIGhhbmRsZSBhbGwgdGhlIGV2ZW50IHRyYWNraW5nL2Rpc3BhdGNoaW5nXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5ldmVudERhdGEgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGRhdGE6IHRoaXMubW91c2UsXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaW55IGxpdHRsZSBpbnRlcmFjdGl2ZURhdGEgcG9vbCAhXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uRGF0YVtdfVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIERPTSBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgZGV0ZXJtaW5zIGlmIG1vdXNlbW92ZSBhbmQgdG91Y2htb3ZlIGV2ZW50cyBhcmUgZmlyZWQgb25seSB3aGVuIHRoZSBjdXJzcm9yIGlzIG92ZXIgdGhlIG9iamVjdFxuICAgICAqIFNldHRpbmcgdG8gdHJ1ZSB3aWxsIG1ha2UgdGhpbmdzIHdvcmsgbW9yZSBpbiBsaW5lIHdpdGggaG93IHRoZSBET00gdmVyaXNvbiB3b3Jrcy5cbiAgICAgKiBTZXR0aW5nIHRvIGZhbHNlIGNhbiBtYWtlIHRoaW5ncyBlYXNpZXIgZm9yIHRoaW5ncyBsaWtlIGRyYWdnaW5nXG4gICAgICogSXQgaXMgY3VycmVudGx5IHNldCB0byBmYWxzZSBhcyB0aGlzIGlzIGhvdyBwaXhpIHVzZWQgdG8gd29yay4gVGhpcyB3aWxsIGJlIHNldCB0byB0cnVlIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBwaXhpLlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1vdmVXaGVuSW5zaWRlID0gZmFsc2U7XG4gICAgXG4gICAgLyoqXG4gICAgICogSGF2ZSBldmVudHMgYmVlbiBhdHRhY2hlZCB0byB0aGUgZG9tIGVsZW1lbnQ/XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xuXG4gICAgLy90aGlzIHdpbGwgbWFrZSBpdCBzbyB0aGF0IHlvdSBkb24ndCBoYXZlIHRvIGNhbGwgYmluZCBhbGwgdGhlIHRpbWVcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2Nlc3NNb3VzZVVwID0gdGhpcy5wcm9jZXNzTW91c2VVcC5iaW5kKCB0aGlzICk7XG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9jZXNzTW91c2VEb3duID0gdGhpcy5wcm9jZXNzTW91c2VEb3duLmJpbmQoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQoIHRoaXMgKTtcbiAgICB0aGlzLnByb2Nlc3NNb3VzZU1vdmUgPSB0aGlzLnByb2Nlc3NNb3VzZU1vdmUuYmluZCggdGhpcyApO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vbk1vdXNlT3V0ID0gdGhpcy5vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9jZXNzTW91c2VPdmVyT3V0ID0gdGhpcy5wcm9jZXNzTW91c2VPdmVyT3V0LmJpbmQoIHRoaXMgKTtcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vblRvdWNoU3RhcnQgPSB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvY2Vzc1RvdWNoU3RhcnQgPSB0aGlzLnByb2Nlc3NUb3VjaFN0YXJ0LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uVG91Y2hFbmQgPSB0aGlzLm9uVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2Nlc3NUb3VjaEVuZCA9IHRoaXMucHJvY2Vzc1RvdWNoRW5kLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uVG91Y2hNb3ZlID0gdGhpcy5vblRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvY2Vzc1RvdWNoTW92ZSA9IHRoaXMucHJvY2Vzc1RvdWNoTW92ZS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3NzIHN0eWxlIG9mIHRoZSBjdXJzb3IgdGhhdCBpcyBiZWluZyB1c2VkXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEN1cnNvclN0eWxlID0gJ2luaGVyaXQnO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2FjaGVkIHZhclxuICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wUG9pbnQgPSBuZXcgY29yZS5Qb2ludCgpO1xuICAgIFxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcmVzb2x1dGlvblxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xuXG4gICAgdGhpcy5zZXRUYXJnZXRFbGVtZW50KHRoaXMucmVuZGVyZXIudmlldywgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uKTtcbn1cblxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVyYWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb25NYW5hZ2VyO1xuXG4vKipcbiAqIFNldHMgdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZS90b3VjaCBldmVudHMuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHlvdSBoYXZlXG4gKiBvdGhlciBET00gZWxlbWVudHMgb24gdG9wIG9mIHRoZSByZW5kZXJlcnMgQ2FudmFzIGVsZW1lbnQuIFdpdGggdGhpcyB5b3UnbGwgYmUgYmFsZSB0byBkZWxldGVnYXRlXG4gKiBhbm90aGVyIERPTSBlbGVtZW50IHRvIHJlY2VpdmUgdGhvc2UgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50IHtIVE1MRWxlbWVudH0gdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLlxuICogQHBhcmFtIFtyZXNvbHV0aW9uPTFdIHtudW1iZXJ9IFRIZSByZXNvbHV0aW9uIG9mIHRoZSBuZXcgZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIGNhbnZhcykuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVzb2x1dGlvbilcbntcbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCAxO1xuXG4gICAgdGhpcy5hZGRFdmVudHMoKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFsbCB0aGUgRE9NIGV2ZW50c1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkRXZlbnRzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvcmUudGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZClcbiAgICB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsICAgIHRoaXMub25Nb3VzZU1vdmUsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsICAgIHRoaXMub25Nb3VzZURvd24sIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgICAgIHRoaXMub25Nb3VzZU91dCwgdHJ1ZSk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgICB0aGlzLm9uVG91Y2hTdGFydCwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAgICAgdGhpcy5vblRvdWNoRW5kLCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAgICB0aGlzLm9uVG91Y2hNb3ZlLCB0cnVlKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgIHRoaXMub25Nb3VzZVVwLCB0cnVlKTtcblxuICAgIHRoaXMuZXZlbnRzQWRkZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCB0aGUgRE9NIGV2ZW50cyB0aGF0IHdlcmUgcHJldmlvdXNseSByZWdpc3RlcmVkXG4gKlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29yZS50aWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSk7XG5cbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJy1tcy1jb250ZW50LXpvb21pbmcnXSA9ICcnO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJyc7XG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24sIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgIHRoaXMub25Nb3VzZU91dCwgdHJ1ZSk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgIHRoaXMub25Ub3VjaEVuZCwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICB0aGlzLm9uTW91c2VVcCwgdHJ1ZSk7XG5cbiAgICB0aGlzLmV2ZW50c0FkZGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIGludGVyYWN0aXZlIG9iamVjdHMuXG4gKiBJbnZva2VkIGJ5IGEgdGhyb3R0bGVkIHRpY2tlciB1cGRhdGUgZnJvbVxuICoge0BsaW5rIFBJWEkudGlja2VyLnNoYXJlZH0uXG4gKlxuICogQHBhcmFtIGRlbHRhVGltZSB7bnVtYmVyfVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YVRpbWUpXG57XG4gICAgdGhpcy5fZGVsdGFUaW1lICs9IGRlbHRhVGltZTtcblxuICAgIGlmICh0aGlzLl9kZWx0YVRpbWUgPCB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RlbHRhVGltZSA9IDA7XG5cbiAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSB1c2VyIG1vdmUgdGhlIG1vdXNlIHRoaXMgY2hlY2sgaGFzIGFscmVhZHkgYmVlbiBkZm9uZSB1c2luZyB0aGUgbW91c2UgbW92ZSFcbiAgICBpZih0aGlzLmRpZE1vdmUpXG4gICAge1xuICAgICAgICB0aGlzLmRpZE1vdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3Vyc29yID0gJ2luaGVyaXQnO1xuXG4gICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUodGhpcy5tb3VzZS5nbG9iYWwsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzTW91c2VPdmVyT3V0LCB0cnVlICk7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgIT09IHRoaXMuY3Vyc29yKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gdGhpcy5jdXJzb3I7XG4gICAgfVxuXG4gICAgLy9UT0RPXG59O1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgb24gdGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2FzIGludGVyYWN0ZWQgd2l0aFxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IHRoZSBkaXNwbGF5IG9iamVjdCBpbiBxdWVzdGlvblxuICogQHBhcmFtIGV2ZW50U3RyaW5nIHtzdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZS5nLCBtb3VzZWRvd24pXG4gKiBAcGFyYW0gZXZlbnREYXRhIHtvYmplY3R9IHRoZSBldmVudCBkYXRhIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBldmVudFN0cmluZywgZXZlbnREYXRhIClcbntcbiAgICBpZighZXZlbnREYXRhLnN0b3BwZWQpXG4gICAge1xuICAgICAgICBldmVudERhdGEudGFyZ2V0ID0gZGlzcGxheU9iamVjdDtcbiAgICAgICAgZXZlbnREYXRhLnR5cGUgPSBldmVudFN0cmluZztcblxuICAgICAgICBkaXNwbGF5T2JqZWN0LmVtaXQoIGV2ZW50U3RyaW5nLCBldmVudERhdGEgKTtcblxuICAgICAgICBpZiggZGlzcGxheU9iamVjdFtldmVudFN0cmluZ10gKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0W2V2ZW50U3RyaW5nXSggZXZlbnREYXRhICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIE1hcHMgeCBhbmQgeSBjb29yZHMgZnJvbSBhIERPTSBvYmplY3QgYW5kIG1hcHMgdGhlbSBjb3JyZWN0bHkgdG8gdGhlIHBpeGkgdmlldy4gVGhlIHJlc3VsdGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gdGhlIHBvaW50LlxuICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGZhY3QgdGhhdCB0aGUgRE9NIGVsZW1lbnQgY291bGQgYmUgc2NhbGVkIGFuZCBwb3NpdGlvbmVkIGFueXdoZXJlIG9uIHRoZSBzY3JlZW4uXG4gKlxuICogQHBhcmFtICB7UElYSS5Qb2ludH0gcG9pbnQgdGhlIHBvaW50IHRoYXQgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCBpblxuICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICB0aGUgeCBjb29yZCBvZiB0aGUgcG9zaXRpb24gdG8gbWFwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgIHRoZSB5IGNvb3JkIG9mIHRoZSBwb3NpdGlvbiB0byBtYXBcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5tYXBQb3NpdGlvblRvUG9pbnQgPSBmdW5jdGlvbiAoIHBvaW50LCB4LCB5IClcbntcbiAgICB2YXIgcmVjdCA9IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHBvaW50LnggPSAoICggeCAtIHJlY3QubGVmdCApICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LndpZHRoICAvIHJlY3Qud2lkdGggICkgKSAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICBwb2ludC55ID0gKCAoIHkgLSByZWN0LnRvcCAgKSAqICh0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5oZWlnaHQgLyByZWN0LmhlaWdodCApICkgLyB0aGlzLnJlc29sdXRpb247XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcHJvdmlkZXMgYSBuZWF0IHdheSBvZiBjcmF3bGluZyB0aHJvdWdoIHRoZSBzY2VuZSBncmFwaCBhbmQgcnVubmluZyBhIHNwZWNpZmllZCBmdW5jdGlvbiBvbiBhbGwgaW50ZXJhY3RpdmUgb2JqZWN0cyBpdCBmaW5kcy5cbiAqIEl0IHdpbGwgYWxzbyB0YWtlIGNhcmUgb2YgaGl0IHRlc3RpbmcgdGhlIGludGVyYWN0aXZlIG9iamVjdHMgYW5kIHBhc3NlcyB0aGUgaGl0IGFjcm9zcyBpbiB0aGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7UElYSS5Qb2ludH0gcG9pbnQgdGhlIHBvaW50IHRoYXQgaXMgdGVzdGVkIGZvciBjb2xsaXNpb25cbiAqIEBwYXJhbSAge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gZGlzcGxheU9iamVjdCB0aGUgZGlzcGxheU9iamVjdCB0aGF0IHdpbGwgYmUgaGl0IHRlc3QgKHJlY3VyY3Npdmx5IGNyYXdscyBpdHMgY2hpbGRyZW4pXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZnVuYyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGludGVyYWN0aXZlIG9iamVjdC4gVGhlIGRpc3BsYXlPYmplY3QgYW5kIGhpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSAge2Jvb2xlYW59IGhpdFRlc3QgdGhpcyBpbmRpY2F0ZXMgaWYgdGhlIG9iamVjdHMgaW5zaWRlIHNob3VsZCBiZSBoaXQgdGVzdCBhZ2FpbnN0IHRoZSBwb2ludFxuICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBkaXNwbGF5T2JqZWN0IGhpdCB0aGUgcG9pbnRcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzSW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAocG9pbnQsIGRpc3BsYXlPYmplY3QsIGZ1bmMsIGhpdFRlc3QsIGludGVyYWN0aXZlKVxue1xuICAgIGlmKCFkaXNwbGF5T2JqZWN0IHx8ICFkaXNwbGF5T2JqZWN0LnZpc2libGUpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVG9vayBhIGxpdHRsZSB3aGlsZSB0byByZXdvcmsgdGhpcyBmdW5jdGlvbiBjb3JyZWN0bHkhIEJ1dCBub3cgaXQgaXMgZG9uZSBhbmQgbmljZSBhbmQgb3B0aW1pc2VkLiBeX15cbiAgICAvLyBcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbm93IGxvb3AgdGhyb3VnaCBhbGwgb2JqZWN0cyBhbmQgdGhlbiBvbmx5IGhpdCB0ZXN0IHRoZSBvYmplY3RzIGl0IEhBUyB0bywgbm90IGFsbCBvZiB0aGVtLiBNVUNIIGZhc3Rlci4uXG4gICAgLy8gQW4gb2JqZWN0IHdpbGwgYmUgaGl0IHRlc3QgaWYgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vIFxuICAgIC8vIDE6IEl0IGlzIGludGVyYWN0aXZlLlxuICAgIC8vIDI6IEl0IGJlbG9uZ3MgdG8gYSBwYXJlbnQgdGhhdCBpcyBpbnRlcmFjdGl2ZSBBTkQgb25lIG9mIHRoZSBwYXJlbnRzIGNoaWxkcmVuIGhhdmUgbm90IGFscmVhZHkgYmVlbiBoaXQuXG4gICAgLy8gXG4gICAgLy8gQXMgYW5vdGhlciBsaXR0bGUgb3B0aW1pc2F0aW9uIG9uY2UgYW4gaW50ZXJhY3RpdmUgb2JqZWN0IGhhcyBiZWVuIGhpdCB3ZSBjYW4gY2Fycnkgb24gdGhyb3VnaCB0aGUgc2NlbmVncmFwaCwgYnV0IHdlIGtub3cgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIG1vcmUgaGl0cyEgU28gd2UgY2FuIGF2b2lkIGV4dHJhIGhpdCB0ZXN0c1xuICAgIC8vIEEgZmluYWwgb3B0aW1pc2F0aW9uIGlzIHRoYXQgYW4gb2JqZWN0IGlzIG5vdCBoaXQgdGVzdCBkaXJlY3RseSBpZiBhIGNoaWxkIGhhcyBhbHJlYWR5IGJlZW4gaGl0LlxuICAgIFxuICAgIHZhciBoaXQgPSBmYWxzZSxcbiAgICAgICAgaW50ZXJhY3RpdmVQYXJlbnQgPSBpbnRlcmFjdGl2ZSA9IGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUgfHwgaW50ZXJhY3RpdmU7XG5cbiAgICAvLyBpZiB0aGUgZGlzcGxheW9iamVjdCBoYXMgYSBoaXRBcmVhLCB0aGVuIGl0IGRvZXMgbm90IG5lZWQgdG8gaGl0VGVzdCBjaGlsZHJlbi5cbiAgICBpZihkaXNwbGF5T2JqZWN0LmhpdEFyZWEpXG4gICAge1xuICAgICAgICBpbnRlcmFjdGl2ZVBhcmVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vICoqIEZSRUUgVElQICoqISBJZiBhbiBvYmplY3QgaXMgbm90IGludGVyYWN0dGl2ZSBvciBoYXMgbm8gYnV0dG9ucyBpbiBpdCAoc3VjaCBhcyBhIGdhbWUgc2NlbmUhKSBzZXQgaW50ZXJhY3RpdmVDaGlsZHJlbiB0byBmYWxzZSBmb3IgdGhhdCBkaXNwbGF5T2JqZWN0LlxuICAgIC8vIFRoaXMgd2lsbCBhbGxvdyBwaXhpIHRvIGNvbXBsZXRseSBpZ25vcmUgYW5kIGJ5cGFzcyBjaGVja2luZyB0aGUgZGlzcGxheU9iamVjdHMgY2hpbGRyZW4uXG4gICAgaWYoZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZUNoaWxkcmVuKVxuICAgIHsgICAgICAgXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgLy8gdGltZSB0byBnZXQgcmVjdXJzaXZlLi4gaWYgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBpZiBzb210aGluZyBpcyBoaXQuLlxuICAgICAgICAgICAgaWYodGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUocG9pbnQsIGNoaWxkLCBmdW5jLCBoaXRUZXN0LCBpbnRlcmFjdGl2ZVBhcmVudCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gaXRzIGEgZ29vZCBpZGVhIHRvIGNoZWNrIGlmIGEgY2hpbGQgaGFzIGxvc3QgaXRzIHBhcmVudC5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIG1lYW5zIGl0IGhhcyBiZWVuIHJlbW92ZWQgd2hpbHN0IGxvb3Bpbmcgc28gaXRzIGJlc3RcbiAgICAgICAgICAgICAgICBpZighY2hpbGQucGFyZW50KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGl0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIG5vIGxvbmdlciBuZWVkIHRvIGhpdCB0ZXN0IGFueSBtb3JlIG9iamVjdHMgaW4gdGhpcyBjb250YWluZXIgYXMgd2Ugd2Ugbm93IGtub3cgdGhlIHBhcmVudCBoYXMgYmVlbiBoaXRcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZVBhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGlsZCBpcyBpbnRlcmFjdGl2ZSAsIHRoYXQgbWVhbnMgdGhhdCB0aGUgb2JqZWN0IGhpdCB3YXMgYWN0dWFsbHkgaW50ZXJhY3RpdmUgYW5kIG5vdCBqdXN0IHRoZSBjaGlsZCBvZiBhbiBpbnRlcmFjdGl2ZSBvYmplY3QuIFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gaGl0IHRlc3QgYW55dGhpbmcgZWxzZS4gV2Ugc3RpbGwgbmVlZCB0byBydW4gdGhyb3VnaCBhbGwgb2JqZWN0cywgYnV0IHdlIGRvbid0IG5lZWQgdG8gcGVyZm9ybSBhbnkgaGl0IHRlc3RzLlxuICAgICAgICAgICAgICAgIC8vaWYoY2hpbGQuaW50ZXJhY3RpdmUpXG4gICAgICAgICAgICAgICAgLy97XG4gICAgICAgICAgICAgICAgaGl0VGVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vfVxuXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGJyZWFrIG5vdyBhcyB3ZSBoYXZlIGhpdCBhbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy9icmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIHBvaW50IHJ1bm5pbmcgdGhpcyBpZiB0aGUgaXRlbSBpcyBub3QgaW50ZXJhY3RpdmUgb3IgZG9lcyBub3QgaGF2ZSBhbiBpbnRlcmFjdGl2ZSBwYXJlbnQuXG4gICAgaWYoaW50ZXJhY3RpdmUpXG4gICAge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgaGl0IHRlc3RpbmcgKGFzIGluIHdlIGhhdmUgbm8gaGl0IGFueSBvYmplY3RzIHlldClcbiAgICAgICAgLy8gV2UgYWxzbyBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGhpdCB0ZXN0aW5nIGlmIG9uY2Ugb2YgdGhlIGRpc3BsYXlPYmplY3RzIGNoaWxkcmVuIGhhcyBhbHJlYWR5IGJlZW4gaGl0IVxuICAgICAgICBpZihoaXRUZXN0ICYmICFoaXQpXG4gICAgICAgIHsgIFxuICAgICAgICAgICAgaWYoZGlzcGxheU9iamVjdC5oaXRBcmVhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCAgdGhpcy5fdGVtcFBvaW50KTtcbiAgICAgICAgICAgICAgICBoaXQgPSBkaXNwbGF5T2JqZWN0LmhpdEFyZWEuY29udGFpbnMoIHRoaXMuX3RlbXBQb2ludC54LCB0aGlzLl90ZW1wUG9pbnQueSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaGl0ID0gZGlzcGxheU9iamVjdC5jb250YWluc1BvaW50KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZ1bmMoZGlzcGxheU9iamVjdCwgaGl0KTsgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGl0O1xuICBcbn07XG5cblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgZG93biBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBidXR0b24gYmVpbmcgcHJlc3NlZCBkb3duXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0aGlzLm1vdXNlO1xuICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCBtb3VzZSByZWZlcmVuY2VcbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludCggdGhpcy5tb3VzZS5nbG9iYWwsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuXG4gICAgaWYgKHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0KVxuICAgIHtcbiAgICAgICAgdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUodGhpcy5tb3VzZS5nbG9iYWwsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzTW91c2VEb3duLCB0cnVlICk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIHRoZSBtb3VzZSBkb3duIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gKlxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gVGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2FzIHRlc3RlZFxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BheSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc01vdXNlRG93biA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICB2YXIgZSA9IHRoaXMubW91c2Uub3JpZ2luYWxFdmVudDtcbiAgICBcbiAgICB2YXIgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyIHx8IGUud2hpY2ggPT09IDM7XG5cbiAgICBpZihoaXQpXG4gICAge1xuICAgICAgICBkaXNwbGF5T2JqZWN0WyBpc1JpZ2h0QnV0dG9uID8gJ19pc1JpZ2h0RG93bicgOiAnX2lzTGVmdERvd24nIF0gPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsIGlzUmlnaHRCdXR0b24gPyAncmlnaHRkb3duJyA6ICdtb3VzZWRvd24nLCB0aGlzLmV2ZW50RGF0YSApO1xuICAgIH1cbn07XG5cblxuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQgb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgbW91c2UgYnV0dG9uIGJlaW5nIHJlbGVhc2VkXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudClcbntcbiAgICB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmV2ZW50RGF0YS5kYXRhID0gdGhpcy5tb3VzZTtcbiAgICB0aGlzLmV2ZW50RGF0YS5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgbW91c2UgcmVmZXJlbmNlXG4gICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoIHRoaXMubW91c2UuZ2xvYmFsLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcblxuICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKHRoaXMubW91c2UuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc01vdXNlVXAsIHRydWUgKTtcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIG1vdXNlIHVwIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gKlxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gVGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2FzIHRlc3RlZFxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BsYXkgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NNb3VzZVVwID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxue1xuICAgIHZhciBlID0gdGhpcy5tb3VzZS5vcmlnaW5hbEV2ZW50O1xuXG4gICAgdmFyIGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMiB8fCBlLndoaWNoID09PSAzO1xuICAgIHZhciBpc0Rvd24gPSAgaXNSaWdodEJ1dHRvbiA/ICdfaXNSaWdodERvd24nIDogJ19pc0xlZnREb3duJztcblxuICAgIGlmKGhpdClcbiAgICB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZGlzcGxheU9iamVjdCwgaXNSaWdodEJ1dHRvbiA/ICdyaWdodHVwJyA6ICdtb3VzZXVwJywgdGhpcy5ldmVudERhdGEgKTtcblxuICAgICAgICBpZiggZGlzcGxheU9iamVjdFsgaXNEb3duIF0gKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0WyBpc0Rvd24gXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCBpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0Y2xpY2snIDogJ2NsaWNrJywgdGhpcy5ldmVudERhdGEgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiggZGlzcGxheU9iamVjdFsgaXNEb3duIF0gKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0WyBpc0Rvd24gXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCBpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0dXBvdXRzaWRlJyA6ICdtb3VzZXVwb3V0c2lkZScsIHRoaXMuZXZlbnREYXRhICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIGFjcm9zcyB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgdGhlIG1vdXNlIG1vdmluZ1xuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudClcbntcbiAgICB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmV2ZW50RGF0YS5kYXRhID0gdGhpcy5tb3VzZTtcbiAgICB0aGlzLmV2ZW50RGF0YS5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludCggdGhpcy5tb3VzZS5nbG9iYWwsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuXG4gICAgdGhpcy5kaWRNb3ZlID0gdHJ1ZTtcblxuICAgIHRoaXMuY3Vyc29yID0gJ2luaGVyaXQnO1xuXG4gICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUodGhpcy5tb3VzZS5nbG9iYWwsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzTW91c2VNb3ZlLCB0cnVlICk7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgIT09IHRoaXMuY3Vyc29yKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Q3Vyc29yU3R5bGUgPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gdGhpcy5jdXJzb3I7XG4gICAgfVxuXG4gICAgLy9UT0RPIEJVRyBmb3IgcGFyZW50cyBpbmVyYWN0aXZlIG9iamVjdCAoYm9yZGVyIG9yZGVyIGlzc3VlKVxufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiB0aGUgbW91c2UgbW92ZSBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzTW91c2VNb3ZlID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxue1xuICAgIHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dChkaXNwbGF5T2JqZWN0LCBoaXQpO1xuICAgIFxuICAgIC8vIG9ubHkgZGlzcGxheSBvbiBtb3VzZSBvdmVyXG4gICAgaWYoIXRoaXMubW92ZVdoZW5JbnNpZGUgfHwgaGl0KVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCAnbW91c2Vtb3ZlJywgdGhpcy5ldmVudERhdGEpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaXMgbW92ZWQgb3V0IG9mIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIG1vdXNlIGJlaW5nIG1vdmVkIG91dFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vdXNlT3V0ID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8vIFVwZGF0ZSBpbnRlcm5hbCBtb3VzZSByZWZlcmVuY2VcbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludCggdGhpcy5tb3VzZS5nbG9iYWwsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2luaGVyaXQnO1xuXG4gICAgLy8gVE9ETyBvcHRpbWl6ZSBieSBub3QgY2hlY2sgRVZFUlkgVElNRSEgbWF5YmUgaGFsZiBhcyBvZnRlbj8gLy9cbiAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludCggdGhpcy5tb3VzZS5nbG9iYWwsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKCB0aGlzLm1vdXNlLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NNb3VzZU92ZXJPdXQsIGZhbHNlICk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIHRoZSBtb3VzZSBvdmVyL291dCBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzTW91c2VPdmVyT3V0ID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxue1xuICAgIGlmKGhpdClcbiAgICB7XG4gICAgICAgIGlmKCFkaXNwbGF5T2JqZWN0Ll9vdmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0Ll9vdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZGlzcGxheU9iamVjdCwgJ21vdXNlb3ZlcicsIHRoaXMuZXZlbnREYXRhICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5idXR0b25Nb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IGRpc3BsYXlPYmplY3QuZGVmYXVsdEN1cnNvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZihkaXNwbGF5T2JqZWN0Ll9vdmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0Ll9vdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICdtb3VzZW91dCcsIHRoaXMuZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiBhIHRvdWNoIGlzIHN0YXJ0ZWQgb24gdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0gZXZlbnQge0V2ZW50fSBUaGUgRE9NIGV2ZW50IG9mIGEgdG91Y2ggc3RhcnRpbmcgb24gdGhlIHJlbmRlcmVyIHZpZXdcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdClcbiAgICB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgdmFyIGNMZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjTGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICAvL1RPRE8gUE9PTFxuICAgICAgICB2YXIgdG91Y2hEYXRhID0gdGhpcy5nZXRUb3VjaERhdGEoIHRvdWNoRXZlbnQgKTtcblxuICAgICAgICB0b3VjaERhdGEub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuXG4gICAgICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0b3VjaERhdGE7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSggdG91Y2hEYXRhLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NUb3VjaFN0YXJ0LCB0cnVlICk7XG5cbiAgICAgICAgdGhpcy5yZXR1cm5Ub3VjaERhdGEoIHRvdWNoRGF0YSApO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgYSB0b3VjaCBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzVG91Y2hTdGFydCA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICBpZihoaXQpXG4gICAge1xuICAgICAgICBkaXNwbGF5T2JqZWN0Ll90b3VjaERvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaHN0YXJ0JywgdGhpcy5ldmVudERhdGEgKTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBlbmRzIG9uIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIHRvdWNoIGVuZGluZyBvbiB0aGUgcmVuZGVyZXIgdmlld1xuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpXG57XG4gICAgaWYgKHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0KVxuICAgIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICB2YXIgY0xlbmd0aCA9IGNoYW5nZWRUb3VjaGVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGk9MDsgaSA8IGNMZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gY2hhbmdlZFRvdWNoZXNbaV07XG5cbiAgICAgICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuZ2V0VG91Y2hEYXRhKCB0b3VjaEV2ZW50ICk7XG5cbiAgICAgICAgdG91Y2hEYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcblxuICAgICAgICAvL1RPRE8gdGhpcyBzaG91bGQgYmUgcGFzc2VkIGFsb25nLi4gbm8gc2V0XG4gICAgICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0b3VjaERhdGE7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcblxuXG4gICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKCB0b3VjaERhdGEuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1RvdWNoRW5kLCB0cnVlICk7XG5cbiAgICAgICAgdGhpcy5yZXR1cm5Ub3VjaERhdGEoIHRvdWNoRGF0YSApO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIGVuZCBvZiBhIHRvdWNoIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gKlxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gVGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2FzIHRlc3RlZFxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BsYXkgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NUb3VjaEVuZCA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICBpZihoaXQpXG4gICAge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaGVuZCcsIHRoaXMuZXZlbnREYXRhICk7XG5cbiAgICAgICAgaWYoIGRpc3BsYXlPYmplY3QuX3RvdWNoRG93biApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuX3RvdWNoRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCAndGFwJywgdGhpcy5ldmVudERhdGEgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5fdG91Y2hEb3duIClcbiAgICAgICAge1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5fdG91Y2hEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaGVuZG91dHNpZGUnLCB0aGlzLmV2ZW50RGF0YSApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiBhIHRvdWNoIGlzIG1vdmVkIGFjcm9zcyB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSB0b3VjaCBtb3ZpbmcgYWNyb3NzIHRoZSByZW5kZXJlciB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdClcbiAgICB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgdmFyIGNMZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjTGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuXG4gICAgICAgIHZhciB0b3VjaERhdGEgPSB0aGlzLmdldFRvdWNoRGF0YSggdG91Y2hFdmVudCApO1xuXG4gICAgICAgIHRvdWNoRGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEuZGF0YSA9IHRvdWNoRGF0YTtcbiAgICAgICAgdGhpcy5ldmVudERhdGEuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKCB0b3VjaERhdGEuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1RvdWNoTW92ZSwgdGhpcy5tb3ZlV2hlbkluc2lkZSApO1xuXG4gICAgICAgIHRoaXMucmV0dXJuVG91Y2hEYXRhKCB0b3VjaERhdGEgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIGEgdG91Y2ggbW92ZSBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtQSVhJLkNvbnRhaW5lcnxQSVhJLlNwcml0ZXxQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzVG91Y2hNb3ZlID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxue1xuICAgIGlmKCF0aGlzLm1vdmVXaGVuSW5zaWRlIHx8IGhpdClcbiAgICB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZGlzcGxheU9iamVjdCwgJ3RvdWNobW92ZScsIHRoaXMuZXZlbnREYXRhKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdyYWJzIGFuIGludGVyYWN0aW9uIGRhdGEgb2JqZWN0IGZyb20gdGhlIGludGVybmFsIHBvb2xcbiAqXG4gKiBAcGFyYW0gdG91Y2hFdmVudCB7RXZlbnREYXRhfSBUaGUgdG91Y2ggZXZlbnQgd2UgbmVlZCB0byBwYWlyIHdpdGggYW4gaW50ZXJhY3Rpb25EYXRhIG9iamVjdFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VG91Y2hEYXRhID0gZnVuY3Rpb24gKHRvdWNoRXZlbnQpXG57XG4gICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbC5wb3AoKTtcblxuICAgIGlmKCF0b3VjaERhdGEpXG4gICAge1xuICAgICAgICB0b3VjaERhdGEgPSBuZXcgSW50ZXJhY3Rpb25EYXRhKCk7XG4gICAgfVxuXG4gICAgdG91Y2hEYXRhLmlkZW50aWZpZXIgPSB0b3VjaEV2ZW50LmlkZW50aWZpZXI7XG4gICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoIHRvdWNoRGF0YS5nbG9iYWwsIHRvdWNoRXZlbnQuY2xpZW50WCwgdG91Y2hFdmVudC5jbGllbnRZICk7XG5cbiAgICBpZihuYXZpZ2F0b3IuaXNDb2Nvb25KUylcbiAgICB7XG4gICAgICAgIHRvdWNoRGF0YS5nbG9iYWwueCA9IHRvdWNoRGF0YS5nbG9iYWwueCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICAgICAgdG91Y2hEYXRhLmdsb2JhbC55ID0gdG91Y2hEYXRhLmdsb2JhbC55IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIH1cblxuICAgIHRvdWNoRXZlbnQuZ2xvYmFsWCA9IHRvdWNoRGF0YS5nbG9iYWwueDtcbiAgICB0b3VjaEV2ZW50Lmdsb2JhbFkgPSB0b3VjaERhdGEuZ2xvYmFsLnk7XG5cbiAgICByZXR1cm4gdG91Y2hEYXRhO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGludGVyYWN0aW9uIGRhdGEgb2JqZWN0IHRvIHRoZSBpbnRlcm5hbCBwb29sXG4gKlxuICogQHBhcmFtIHRvdWNoRGF0YSB7UElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbkRhdGF9IFRoZSB0b3VjaCBkYXRhIG9iamVjdCB3ZSB3YW50IHRvIHJldHVybiB0byB0aGUgcG9vbFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmV0dXJuVG91Y2hEYXRhID0gZnVuY3Rpb24gKCB0b3VjaERhdGEgKVxue1xuICAgIHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbC5wdXNoKCB0b3VjaERhdGEgKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAqXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG5cbiAgICB0aGlzLm1vdXNlID0gbnVsbDtcblxuICAgIHRoaXMuZXZlbnREYXRhID0gbnVsbDtcblxuICAgIHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbCA9IG51bGw7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLm9uTW91c2VVcCA9IG51bGw7XG4gICAgdGhpcy5wcm9jZXNzTW91c2VVcCA9IG51bGw7XG5cblxuICAgIHRoaXMub25Nb3VzZURvd24gPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc01vdXNlRG93biA9IG51bGw7XG5cbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gbnVsbDtcbiAgICB0aGlzLnByb2Nlc3NNb3VzZU1vdmUgPSBudWxsO1xuXG4gICAgdGhpcy5vbk1vdXNlT3V0ID0gbnVsbDtcbiAgICB0aGlzLnByb2Nlc3NNb3VzZU92ZXJPdXQgPSBudWxsO1xuXG5cbiAgICB0aGlzLm9uVG91Y2hTdGFydCA9IG51bGw7XG4gICAgdGhpcy5wcm9jZXNzVG91Y2hTdGFydCA9IG51bGw7XG5cbiAgICB0aGlzLm9uVG91Y2hFbmQgPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc1RvdWNoRW5kID0gbnVsbDtcblxuICAgIHRoaXMub25Ub3VjaE1vdmUgPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc1RvdWNoTW92ZSA9IG51bGw7XG5cbiAgICB0aGlzLl90ZW1wUG9pbnQgPSBudWxsO1xufTtcblxuY29yZS5XZWJHTFJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdpbnRlcmFjdGlvbicsIEludGVyYWN0aW9uTWFuYWdlcik7XG5jb3JlLkNhbnZhc1JlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdpbnRlcmFjdGlvbicsIEludGVyYWN0aW9uTWFuYWdlcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogRGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZXMgb2YgaW50ZXJhY3RpdmUgb2JqZWN0c1xuICogdXNlZCBieSB7QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXJ9LlxuICpcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIFBJWEkuaW50ZXJhY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAgICAgIGZ1bmN0aW9uIE15T2JqZWN0KCkge31cbiAqXG4gKiAgICAgIE9iamVjdC5hc3NpZ24oXG4gKiAgICAgICAgICBNeU9iamVjdC5wcm90b3R5cGUsXG4gKiAgICAgICAgICBQSVhJLmludGVyYWN0aW9uLmludGVyYWN0aXZlVGFyZ2V0XG4gKiAgICAgICk7XG4gKi9cbnZhciBpbnRlcmFjdGl2ZVRhcmdldCA9IHtcbiAgICAvKipcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAqL1xuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAqL1xuICAgIGJ1dHRvbk1vZGU6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAgICovXG4gICAgaW50ZXJhY3RpdmVDaGlsZHJlbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAqL1xuICAgIGRlZmF1bHRDdXJzb3I6ICdwb2ludGVyJyxcblxuICAgIC8vIHNvbWUgaW50ZXJuYWwgY2hlY2tzLi5cblxuICAgIC8qKlxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb3ZlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b3VjaERvd246IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVyYWN0aXZlVGFyZ2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9pbnRlcmFjdGlvbi9pbnRlcmFjdGl2ZVRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIGxvYWRlcnMgbGlicmFyeVxuICogQGF1dGhvciAgICAgIE1hdCBHcm92ZXMgPG1hdEBnb29kYm95ZGlnaXRhbC5jb20+XG4gKiBAY29weXJpZ2h0ICAgMjAxMy0yMDE1IEdvb2RCb3lEaWdpdGFsXG4gKiBAbGljZW5zZSAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLmxvYWRlcnNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTG9hZGVyOiAgICAgICAgICAgICByZXF1aXJlKCcuL2xvYWRlcicpLFxuXG4gICAgLy8gcGFyc2Vyc1xuICAgIGJpdG1hcEZvbnRQYXJzZXI6ICAgcmVxdWlyZSgnLi9iaXRtYXBGb250UGFyc2VyJyksXG4gICAgc3ByaXRlc2hlZXRQYXJzZXI6ICByZXF1aXJlKCcuL3Nwcml0ZXNoZWV0UGFyc2VyJyksXG4gICAgdGV4dHVyZVBhcnNlcjogICAgICByZXF1aXJlKCcuL3RleHR1cmVQYXJzZXInKSxcbiAgICBSZXNvdXJjZTogICAgICAgICAgIHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpLlJlc291cmNlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9sb2FkZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlc291cmNlTG9hZGVyID0gcmVxdWlyZSgncmVzb3VyY2UtbG9hZGVyJyksXG4gICAgdGV4dHVyZVBhcnNlciA9IHJlcXVpcmUoJy4vdGV4dHVyZVBhcnNlcicpLFxuICAgIHNwcml0ZXNoZWV0UGFyc2VyID0gcmVxdWlyZSgnLi9zcHJpdGVzaGVldFBhcnNlcicpLFxuICAgIGJpdG1hcEZvbnRQYXJzZXIgPSByZXF1aXJlKCcuL2JpdG1hcEZvbnRQYXJzZXInKTtcblxuLyoqXG4gKlxuICogVGhlIG5ldyBsb2FkZXIsIGV4dGVuZHMgUmVzb3VyY2UgTG9hZGVyIGJ5IENoYWQgRW5nbGVyIDogaHR0cHM6Ly9naXRodWIuY29tL2VuZ2xlcmNqL3Jlc291cmNlLWxvYWRlclxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbG9hZGVyID0gUElYSS5sb2FkZXI7IC8vIHBpeGkgZXhwb3NlcyBhIHByZW1hZGUgaW5zdGFuY2UgZm9yIHlvdSB0byB1c2UuXG4gKiAvL29yXG4gKiB2YXIgbG9hZGVyID0gbmV3IFBJWEkubG9hZGVycy5Mb2FkZXIoKTsgLy8geW91IGNhbiBhbHNvIGNyZWF0ZSB5b3VyIG93biBpZiB5b3Ugd2FudFxuICpcbiAqIGxvYWRlci5hZGQoJ2J1bm55JyxcImRhdGEvYnVubnkucG5nXCIpO1xuICpcbiAqIGxvYWRlci5vbmNlKCdjb21wbGV0ZScsb25Bc3NldHNMb2FkZWQpO1xuICpcbiAqIGxvYWRlci5sb2FkKCk7XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuUmVzb3VyY2VMb2FkZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmxvYWRlcnNcbiAqIEBwYXJhbSBbYmFzZVVybD0nJ10ge3N0cmluZ30gVGhlIGJhc2UgdXJsIGZvciBhbGwgcmVzb3VyY2VzIGxvYWRlZCBieSB0aGlzIGxvYWRlci5cbiAqIEBwYXJhbSBbY29uY3VycmVuY3k9MTBdIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHRvIGxvYWQgY29uY3VycmVudGx5LlxuICovXG5mdW5jdGlvbiBMb2FkZXIoYmFzZVVybCwgY29uY3VycmVuY3kpXG57XG4gICAgUmVzb3VyY2VMb2FkZXIuY2FsbCh0aGlzLCBiYXNlVXJsLCBjb25jdXJyZW5jeSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IExvYWRlci5fcGl4aU1pZGRsZXdhcmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy51c2UoTG9hZGVyLl9waXhpTWlkZGxld2FyZVtpXSgpKTtcbiAgICB9XG59XG5cbkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlc291cmNlTG9hZGVyLnByb3RvdHlwZSk7XG5Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcjtcblxuTG9hZGVyLl9waXhpTWlkZGxld2FyZSA9IFtcbiAgICAvLyBwYXJzZSBhbnkgYmxvYiBpbnRvIG1vcmUgdXNhYmxlIG9iamVjdHMgKGUuZy4gSW1hZ2UpXG4gICAgUmVzb3VyY2VMb2FkZXIubWlkZGxld2FyZS5wYXJzaW5nLmJsb2IsXG4gICAgLy8gcGFyc2UgYW55IEltYWdlIG9iamVjdHMgaW50byB0ZXh0dXJlc1xuICAgIHRleHR1cmVQYXJzZXIsXG4gICAgLy8gcGFyc2UgYW55IHNwcml0ZXNoZWV0IGRhdGEgaW50byBtdWx0aXBsZSB0ZXh0dXJlc1xuICAgIHNwcml0ZXNoZWV0UGFyc2VyLFxuICAgIC8vIHBhcnNlIGFueSBzcHJpdGVzaGVldCBkYXRhIGludG8gbXVsdGlwbGUgdGV4dHVyZXNcbiAgICBiaXRtYXBGb250UGFyc2VyXG5dO1xuXG5Mb2FkZXIuYWRkUGl4aU1pZGRsZXdhcmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBMb2FkZXIuX3BpeGlNaWRkbGV3YXJlLnB1c2goZm4pO1xufTtcblxuLy8gQWRkIGN1c3RvbSBleHRlbnRpb25zXG52YXIgUmVzb3VyY2UgPSBSZXNvdXJjZUxvYWRlci5SZXNvdXJjZTtcblxuUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uWGhyVHlwZSgnZm50JywgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9sb2FkZXJzL2xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGVzbGludCBnbG9iYWwtcmVxdWlyZTogMCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vTG9hZGVyJyk7XG5tb2R1bGUuZXhwb3J0cy5SZXNvdXJjZSA9IHJlcXVpcmUoJy4vUmVzb3VyY2UnKTtcbm1vZHVsZS5leHBvcnRzLm1pZGRsZXdhcmUgPSB7XG4gICAgY2FjaGluZzoge1xuICAgICAgICBtZW1vcnk6IHJlcXVpcmUoJy4vbWlkZGxld2FyZXMvY2FjaGluZy9tZW1vcnknKVxuICAgIH0sXG4gICAgcGFyc2luZzoge1xuICAgICAgICBibG9iOiByZXF1aXJlKCcuL21pZGRsZXdhcmVzL3BhcnNpbmcvYmxvYicpXG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Jlc291cmNlLWxvYWRlci9zcmMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZVVyaSAgICAgICAgPSByZXF1aXJlKCdwYXJzZS11cmknKTtcbnZhciBhc3luYyAgICAgICAgICAgPSByZXF1aXJlKCcuL2FzeW5jJyk7XG52YXIgUmVzb3VyY2UgICAgICAgID0gcmVxdWlyZSgnLi9SZXNvdXJjZScpO1xudmFyIEV2ZW50RW1pdHRlciAgICA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxuLy8gc29tZSBjb25zdGFudHNcbnZhciBERUZBVUxUX0NPTkNVUlJFTkNZID0gMTA7XG52YXIgTUFYX1BST0dSRVNTID0gMTAwO1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBsb2FkaW5nIG9mIG11bHRpcGxlIHJlc291cmNlcyB0byBsb2FkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlVXJsPScnXSAtIFRoZSBiYXNlIHVybCBmb3IgYWxsIHJlc291cmNlcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PTEwXSAtIFRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHRvIGxvYWQgY29uY3VycmVudGx5LlxuICovXG5mdW5jdGlvbiBMb2FkZXIoYmFzZVVybCwgY29uY3VycmVuY3kpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIGNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgREVGQVVMVF9DT05DVVJSRU5DWTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIHVybCBmb3IgYWxsIHJlc291cmNlcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybCB8fCAnJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcm9ncmVzcyBwZXJjZW50IG9mIHRoZSBsb2FkZXIgZ29pbmcgdGhyb3VnaCB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBMb2FkaW5nIHN0YXRlIG9mIHRoZSBsb2FkZXIsIHRydWUgaWYgaXQgaXMgY3VycmVudGx5IGxvYWRpbmcgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwZXJjZW50YWdlIG9mIHRvdGFsIHByb2dyZXNzIHRoYXQgYSBzaW5nbGUgcmVzb3VyY2UgcmVwcmVzZW50cy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9wcm9ncmVzc0NodW5rID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaWRkbGV3YXJlIHRvIHJ1biBiZWZvcmUgbG9hZGluZyBlYWNoIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl9iZWZvcmVNaWRkbGV3YXJlID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWlkZGxld2FyZSB0byBydW4gYWZ0ZXIgbG9hZGluZyBlYWNoIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgKi9cbiAgICB0aGlzLl9hZnRlck1pZGRsZXdhcmUgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgX2xvYWRSZXNvdXJjZWAgZnVuY3Rpb24gYm91bmQgd2l0aCB0aGlzIG9iamVjdCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9ib3VuZExvYWRSZXNvdXJjZSA9IHRoaXMuX2xvYWRSZXNvdXJjZS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc291cmNlIGJ1ZmZlciB0aGF0IGZpbGxzIHVudGlsIGBsb2FkYCBpcyBjYWxsZWQgdG8gc3RhcnQgbG9hZGluZyByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge1Jlc291cmNlW119XG4gICAgICovXG4gICAgdGhpcy5fYnVmZmVyID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHRyYWNrIGxvYWQgY29tcGxldGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX251bVRvTG9hZCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb3VyY2VzIHdhaXRpbmcgdG8gYmUgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIHtSZXNvdXJjZVtdfVxuICAgICAqL1xuICAgIHRoaXMuX3F1ZXVlID0gYXN5bmMucXVldWUodGhpcy5fYm91bmRMb2FkUmVzb3VyY2UsIGNvbmN1cnJlbmN5KTtcblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgcmVzb3VyY2VzIGZvciB0aGlzIGxvYWRlciBrZXllZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0PHN0cmluZywgUmVzb3VyY2U+fVxuICAgICAqL1xuICAgIHRoaXMucmVzb3VyY2VzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIG9uY2UgcGVyIGxvYWRlZCBvciBlcnJvcmVkIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV2ZW50IHByb2dyZXNzXG4gICAgICogQG1lbWJlcm9mIExvYWRlciNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgb25jZSBwZXIgZXJyb3JlZCByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBlcnJvclxuICAgICAqIEBtZW1iZXJvZiBMb2FkZXIjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIG9uY2UgcGVyIGxvYWRlZCByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBsb2FkXG4gICAgICogQG1lbWJlcm9mIExvYWRlciNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgbG9hZGVyIGJlZ2lucyB0byBwcm9jZXNzIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBzdGFydFxuICAgICAqIEBtZW1iZXJvZiBMb2FkZXIjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIHF1ZXVlZCByZXNvdXJjZXMgYWxsIGxvYWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY29tcGxldGVcbiAgICAgKiBAbWVtYmVyb2YgTG9hZGVyI1xuICAgICAqL1xufVxuXG5Mb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbkxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2FkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcjtcblxuLyoqXG4gKiBBZGRzIGEgcmVzb3VyY2UgKG9yIG11bHRpcGxlIHJlc291cmNlcykgdG8gdGhlIGxvYWRlciBxdWV1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiB0YWtlIGEgd2lkZSB2YXJpZXR5IG9mIGRpZmZlcmVudCBwYXJhbWV0ZXJzLiBUaGUgb25seSB0aGluZyB0aGF0IGlzIGFsd2F5c1xuICogcmVxdWlyZWQgdGhlIHVybCB0byBsb2FkLiBBbGwgdGhlIGZvbGxvd2luZyB3aWxsIHdvcms6XG4gKlxuICogYGBganNcbiAqIGxvYWRlclxuICogICAgIC8vIG5vcm1hbCBwYXJhbSBzeW50YXhcbiAqICAgICAuYWRkKCdrZXknLCAnaHR0cDovLy4uLicsIGZ1bmN0aW9uICgpIHt9KVxuICogICAgIC5hZGQoJ2h0dHA6Ly8uLi4nLCBmdW5jdGlvbiAoKSB7fSlcbiAqICAgICAuYWRkKCdodHRwOi8vLi4uJylcbiAqXG4gKiAgICAgLy8gb2JqZWN0IHN5bnRheFxuICogICAgIC5hZGQoe1xuICogICAgICAgICBuYW1lOiAna2V5MicsXG4gKiAgICAgICAgIHVybDogJ2h0dHA6Ly8uLi4nXG4gKiAgICAgfSwgZnVuY3Rpb24gKCkge30pXG4gKiAgICAgLmFkZCh7XG4gKiAgICAgICAgIHVybDogJ2h0dHA6Ly8uLi4nXG4gKiAgICAgfSwgZnVuY3Rpb24gKCkge30pXG4gKiAgICAgLmFkZCh7XG4gKiAgICAgICAgIG5hbWU6ICdrZXkzJyxcbiAqICAgICAgICAgdXJsOiAnaHR0cDovLy4uLidcbiAqICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge31cbiAqICAgICB9KVxuICogICAgIC5hZGQoe1xuICogICAgICAgICB1cmw6ICdodHRwczovLy4uLicsXG4gKiAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHt9LFxuICogICAgICAgICBjcm9zc09yaWdpbjogdHJ1ZVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIHlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgdXJscyBvciBib3RoXG4gKiAgICAgLmFkZChbXG4gKiAgICAgICAgIHsgbmFtZTogJ2tleTQnLCB1cmw6ICdodHRwOi8vLi4uJywgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge30gfSxcbiAqICAgICAgICAgeyB1cmw6ICdodHRwOi8vLi4uJywgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge30gfSxcbiAqICAgICAgICAgJ2h0dHA6Ly8uLi4nXG4gKiAgICAgXSlcbiAqXG4gKiAgICAgLy8gYW5kIHlvdSBjYW4gdXNlIGJvdGggcGFyYW1zIGFuZCBvcHRpb25zXG4gKiAgICAgLmFkZCgna2V5JywgJ2h0dHA6Ly8uLi4nLCB7IGNyb3NzT3JpZ2luOiB0cnVlIH0sIGZ1bmN0aW9uICgpIHt9KVxuICogICAgIC5hZGQoJ2h0dHA6Ly8uLi4nLCB7IGNyb3NzT3JpZ2luOiB0cnVlIH0sIGZ1bmN0aW9uICgpIHt9KTtcbiAqIGBgYFxuICpcbiAqIEBhbGlhcyBlbnF1ZXVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIHRvIGxvYWQsIGlmIG5vdCBwYXNzZWQgdGhlIHVybCBpcyB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdIC0gVGhlIHVybCBmb3IgdGhpcyByZXNvdXJjZSwgcmVsYXRpdmUgdG8gdGhlIGJhc2VVcmwgb2YgdGhpcyBsb2FkZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2FkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gLSBJcyB0aGlzIHJlcXVlc3QgY3Jvc3Mtb3JpZ2luPyBEZWZhdWx0IGlzIHRvIGRldGVybWluZSBhdXRvbWF0aWNhbGx5LlxuICogQHBhcmFtIHtSZXNvdXJjZS5YSFJfTE9BRF9UWVBFfSBbb3B0aW9ucy5sb2FkVHlwZT1SZXNvdXJjZS5MT0FEX1RZUEUuWEhSXSAtIEhvdyBzaG91bGQgdGhpcyByZXNvdXJjZSBiZSBsb2FkZWQ/XG4gKiBAcGFyYW0ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBbb3B0aW9ucy54aHJUeXBlPVJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRFRkFVTFRdIC0gSG93IHNob3VsZCB0aGUgZGF0YSBiZWluZ1xuICogICAgICBsb2FkZWQgYmUgaW50ZXJwcmV0ZWQgd2hlbiB1c2luZyBYSFI/XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2JdIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgc3BlY2lmaWMgcmVzb3VyY2UgY29tcGxldGVzIGxvYWRpbmcuXG4gKiBAcmV0dXJuIHtMb2FkZXJ9IFJldHVybnMgaXRzZWxmLlxuICovXG5Mb2FkZXIucHJvdG90eXBlLmFkZCA9IExvYWRlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChuYW1lLCB1cmwsIG9wdGlvbnMsIGNiKSB7XG4gICAgLy8gc3BlY2lhbCBjYXNlIG9mIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgdXJsc1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hZGQobmFtZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiBhbiBvYmplY3QgaXMgcGFzc2VkIGluc3RlYWQgb2YgcGFyYW1zXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjYiA9IHVybCB8fCBuYW1lLmNhbGxiYWNrIHx8IG5hbWUub25Db21wbGV0ZTtcbiAgICAgICAgb3B0aW9ucyA9IG5hbWU7XG4gICAgICAgIHVybCA9IG5hbWUudXJsO1xuICAgICAgICBuYW1lID0gbmFtZS5uYW1lIHx8IG5hbWUua2V5IHx8IG5hbWUudXJsO1xuICAgIH1cblxuICAgIC8vIGNhc2Ugd2hlcmUgbm8gbmFtZSBpcyBwYXNzZWQgc2hpZnQgYWxsIGFyZ3Mgb3ZlciBieSBvbmUuXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgdXJsID0gbmFtZTtcbiAgICB9XG5cbiAgICAvLyBub3cgdGhhdCB3ZSBzaGlmdGVkIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcHJvcGVyIHVybC5cbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1cmwgcGFzc2VkIHRvIGFkZCByZXNvdXJjZSB0byBsb2FkZXIuJyk7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9ucyBhcmUgb3B0aW9uYWwgc28gcGVvcGxlIG1pZ2h0IHBhc3MgYSBmdW5jdGlvbiBhbmQgbm8gb3B0aW9uc1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHJlc291cmNlIGFscmVhZHkgZXhpc3RzLlxuICAgIGlmICh0aGlzLnJlc291cmNlc1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc291cmNlIHdpdGggbmFtZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLicpO1xuICAgIH1cblxuICAgIC8vIGFkZCBiYXNlIHVybCBpZiB0aGlzIGlzbid0IGFuIGFic29sdXRlIHVybFxuICAgIHVybCA9IHRoaXMuX3ByZXBhcmVVcmwodXJsKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgc3RvcmUgdGhlIHJlc291cmNlXG4gICAgdGhpcy5yZXNvdXJjZXNbbmFtZV0gPSBuZXcgUmVzb3VyY2UobmFtZSwgdXJsLCBvcHRpb25zKTtcblxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNbbmFtZV0ub25jZSgnYWZ0ZXJNaWRkbGV3YXJlJywgY2IpO1xuICAgIH1cblxuICAgIHRoaXMuX251bVRvTG9hZCsrO1xuXG4gICAgLy8gaWYgYWxyZWFkeSBsb2FkaW5nIGFkZCBpdCB0byB0aGUgd29ya2VyIHF1ZXVlXG4gICAgaWYgKHRoaXMuX3F1ZXVlLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh0aGlzLnJlc291cmNlc1tuYW1lXSk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ2h1bmsgPSAoTUFYX1BST0dSRVNTIC0gdGhpcy5wcm9ncmVzcykgLyAodGhpcy5fcXVldWUubGVuZ3RoKCkgKyB0aGlzLl9xdWV1ZS5ydW5uaW5nKCkpO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgYnVmZmVyIGl0IHRvIGJlIGFkZGVkIHRvIHRoZSBxdWV1ZSBsYXRlclxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9idWZmZXIucHVzaCh0aGlzLnJlc291cmNlc1tuYW1lXSk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ2h1bmsgPSBNQVhfUFJPR1JFU1MgLyB0aGlzLl9idWZmZXIubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuICpiZWZvcmUqIHRoZVxuICogcmVzb3VyY2UgaXMgbG9hZGVkLlxuICpcbiAqIEBhbGlhcyBwcmVcbiAqIEBtZXRob2QgYmVmb3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyLlxuICogQHJldHVybiB7TG9hZGVyfSBSZXR1cm5zIGl0c2VsZi5cbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5iZWZvcmUgPSBMb2FkZXIucHJvdG90eXBlLnByZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMuX2JlZm9yZU1pZGRsZXdhcmUucHVzaChmbik7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB1cCBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biAqYWZ0ZXIqIHRoZVxuICogcmVzb3VyY2UgaXMgbG9hZGVkLlxuICpcbiAqIEBhbGlhcyB1c2VcbiAqIEBtZXRob2QgYWZ0ZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIuXG4gKiBAcmV0dXJuIHtMb2FkZXJ9IFJldHVybnMgaXRzZWxmLlxuICovXG5Mb2FkZXIucHJvdG90eXBlLmFmdGVyID0gTG9hZGVyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB0aGlzLl9hZnRlck1pZGRsZXdhcmUucHVzaChmbik7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSBxdWV1ZSBvZiB0aGUgbG9hZGVyIHRvIHByZXBhcmUgZm9yIGEgbmV3IGxvYWQuXG4gKlxuICogQHJldHVybiB7TG9hZGVyfSBSZXR1cm5zIGl0c2VsZi5cbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsIHx8ICcnO1xuXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX3Byb2dyZXNzQ2h1bmsgPSAwO1xuXG4gICAgLy8gdGhpcy5fYmVmb3JlTWlkZGxld2FyZS5sZW5ndGggPSAwO1xuICAgIC8vIHRoaXMuX2FmdGVyTWlkZGxld2FyZS5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5fYnVmZmVyLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLl9udW1Ub0xvYWQgPSAwO1xuXG4gICAgdGhpcy5fcXVldWUua2lsbCgpO1xuICAgIHRoaXMuX3F1ZXVlLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIC8vIGFib3J0IGFsbCByZXNvdXJjZSBsb2Fkc1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5yZXNvdXJjZXMpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMucmVzb3VyY2VzW2tdO1xuXG4gICAgICAgIHJlcy5vZmYoJ2NvbXBsZXRlJywgdGhpcy5fb25Mb2FkLCB0aGlzKTtcblxuICAgICAgICBpZiAocmVzLmlzTG9hZGluZykge1xuICAgICAgICAgICAgcmVzLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlc291cmNlcyA9IHt9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBsb2FkaW5nIHRoZSBxdWV1ZWQgcmVzb3VyY2VzLlxuICpcbiAqIEBmaXJlcyBzdGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NiXSAtIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBib3VuZCB0byB0aGUgYGNvbXBsZXRlYCBldmVudC5cbiAqIEByZXR1cm4ge0xvYWRlcn0gUmV0dXJucyBpdHNlbGYuXG4gKi9cbkxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIC8vIHJlZ2lzdGVyIGNvbXBsZXRlIGNhbGxiYWNrIGlmIHRoZXkgcGFzcyBvbmVcbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub25jZSgnY29tcGxldGUnLCBjYik7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHF1ZXVlIGhhcyBhbHJlYWR5IHN0YXJ0ZWQgd2UgYXJlIGRvbmUgaGVyZVxuICAgIGlmICh0aGlzLl9xdWV1ZS5zdGFydGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIG5vdGlmeSBvZiBzdGFydFxuICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB0aGlzKTtcblxuICAgIC8vIHVwZGF0ZSBsb2FkaW5nIHN0YXRlXG4gICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgIC8vIHN0YXJ0IHRoZSBpbnRlcm5hbCBxdWV1ZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGhpcy5fYnVmZmVyW2ldKTtcbiAgICB9XG5cbiAgICAvLyBlbXB0eSB0aGUgYnVmZmVyXG4gICAgdGhpcy5fYnVmZmVyLmxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHJlcGFyZXMgYSB1cmwgZm9yIHVzYWdlIGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoaXMgb2JqZWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHByZXBhcmUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcmVwYXJlZCB1cmwuXG4gKi9cbkxvYWRlci5wcm90b3R5cGUuX3ByZXBhcmVVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIHBhcnNlZFVybCA9IHBhcnNlVXJpKHVybCwgeyBzdHJpY3RNb2RlOiB0cnVlIH0pO1xuXG4gICAgLy8gYWJzb2x1dGUgdXJsLCBqdXN0IHVzZSBpdCBhcyBpcy5cbiAgICBpZiAocGFyc2VkVXJsLnByb3RvY29sIHx8ICFwYXJzZWRVcmwucGF0aCB8fCBwYXJzZWRVcmwucGF0aC5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgLy8gaWYgYmFzZVVybCBkb2Vzbid0IGVuZCBpbiBzbGFzaCBhbmQgdXJsIGRvZXNuJ3Qgc3RhcnQgd2l0aCBzbGFzaCwgdGhlbiBhZGQgYSBzbGFzaCBpbmJldHdlZW5cbiAgICBpZiAodGhpcy5iYXNlVXJsLmxlbmd0aFxuICAgICAgICAmJiB0aGlzLmJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSAhPT0gdGhpcy5iYXNlVXJsLmxlbmd0aCAtIDFcbiAgICAgICAgJiYgdXJsLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VVcmwgKyAnLycgKyB1cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmFzZVVybCArIHVybDtcbn07XG5cbi8qKlxuICogTG9hZHMgYSBzaW5nbGUgcmVzb3VyY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVzb3VyY2V9IHJlc291cmNlIC0gVGhlIHJlc291cmNlIHRvIGxvYWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZXF1ZXVlIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB3ZSBuZWVkIHRvIGRlcXVldWUgdGhpcyBpdGVtLlxuICovXG5Mb2FkZXIucHJvdG90eXBlLl9sb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGRlcXVldWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXNvdXJjZS5fZGVxdWV1ZSA9IGRlcXVldWU7XG5cbiAgICAvLyBydW4gYmVmb3JlIG1pZGRsZXdhcmVcbiAgICBhc3luYy5lYWNoU2VyaWVzKFxuICAgICAgICB0aGlzLl9iZWZvcmVNaWRkbGV3YXJlLFxuICAgICAgICBmdW5jdGlvbiAoZm4sIG5leHQpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoc2VsZiwgcmVzb3VyY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYmVmb3JlIG1pZGRsZXdhcmUgbWFya3MgdGhlIHJlc291cmNlIGFzIGNvbXBsZXRlLFxuICAgICAgICAgICAgICAgIC8vIGJyZWFrIGFuZCBkb24ndCBwcm9jZXNzIGFueSBtb3JlIGJlZm9yZSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgICAgbmV4dChyZXNvdXJjZS5pc0NvbXBsZXRlID8ge30gOiBudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZXNvdXJjZS5vbigncHJvZ3Jlc3MnLCBzZWxmLmVtaXQuYmluZChzZWxmLCAncHJvZ3Jlc3MnKSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb25Mb2FkKHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc291cmNlLm9uY2UoJ2NvbXBsZXRlJywgc2VsZi5fb25Mb2FkLCBzZWxmKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5sb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb25jZSBlYWNoIHJlc291cmNlIGhhcyBsb2FkZWQuXG4gKlxuICogQGZpcmVzIGNvbXBsZXRlXG4gKiBAcHJpdmF0ZVxuICovXG5Mb2FkZXIucHJvdG90eXBlLl9vbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIHRoaXMsIHRoaXMucmVzb3VyY2VzKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGVhY2ggdGltZSBhIHJlc291cmNlcyBpcyBsb2FkZWQuXG4gKlxuICogQGZpcmVzIHByb2dyZXNzXG4gKiBAZmlyZXMgZXJyb3JcbiAqIEBmaXJlcyBsb2FkXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSZXNvdXJjZX0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdGhhdCB3YXMgbG9hZGVkXG4gKi9cbkxvYWRlci5wcm90b3R5cGUuX29uTG9hZCA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIHJ1biBtaWRkbGV3YXJlLCB0aGlzICptdXN0KiBoYXBwZW4gYmVmb3JlIGRlcXVldWUgc28gc3ViLWFzc2V0cyBnZXQgYWRkZWQgcHJvcGVybHlcbiAgICBhc3luYy5lYWNoU2VyaWVzKFxuICAgICAgICB0aGlzLl9hZnRlck1pZGRsZXdhcmUsXG4gICAgICAgIGZ1bmN0aW9uIChmbiwgbmV4dCkge1xuICAgICAgICAgICAgZm4uY2FsbChzZWxmLCByZXNvdXJjZSwgbmV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc291cmNlLmVtaXQoJ2FmdGVyTWlkZGxld2FyZScsIHJlc291cmNlKTtcblxuICAgICAgICAgICAgc2VsZi5fbnVtVG9Mb2FkLS07XG5cbiAgICAgICAgICAgIHNlbGYucHJvZ3Jlc3MgKz0gc2VsZi5fcHJvZ3Jlc3NDaHVuaztcbiAgICAgICAgICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBzZWxmLCByZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCByZXNvdXJjZS5lcnJvciwgc2VsZiwgcmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdsb2FkJywgc2VsZiwgcmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyBjb21wbGV0aW9uIGNoZWNrXG4gICAgICAgICAgICBpZiAoc2VsZi5fbnVtVG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcm9ncmVzcyA9IDEwMDtcbiAgICAgICAgICAgICAgICBzZWxmLl9vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gcmVtb3ZlIHRoaXMgcmVzb3VyY2UgZnJvbSB0aGUgYXN5bmMgcXVldWVcbiAgICByZXNvdXJjZS5fZGVxdWV1ZSgpO1xufTtcblxuTG9hZGVyLkxPQURfVFlQRSA9IFJlc291cmNlLkxPQURfVFlQRTtcbkxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRSA9IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZXNvdXJjZS1sb2FkZXIvc3JjL0xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlVVJJIChzdHIsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICB2YXIgbyA9IHtcbiAgICBrZXk6IFsnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvciddLFxuICAgIHE6IHtcbiAgICAgIG5hbWU6ICdxdWVyeUtleScsXG4gICAgICBwYXJzZXI6IC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZ1xuICAgIH0sXG4gICAgcGFyc2VyOiB7XG4gICAgICBzdHJpY3Q6IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oKCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS8sXG4gICAgICBsb29zZTogL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoW146XFwvPyMuXSspOik/KD86XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvXG4gICAgfVxuICB9XG5cbiAgdmFyIG0gPSBvLnBhcnNlcltvcHRzLnN0cmljdE1vZGUgPyAnc3RyaWN0JyA6ICdsb29zZSddLmV4ZWMoc3RyKVxuICB2YXIgdXJpID0ge31cbiAgdmFyIGkgPSAxNFxuXG4gIHdoaWxlIChpLS0pIHVyaVtvLmtleVtpXV0gPSBtW2ldIHx8ICcnXG5cbiAgdXJpW28ucS5uYW1lXSA9IHt9XG4gIHVyaVtvLmtleVsxMl1dLnJlcGxhY2Uoby5xLnBhcnNlciwgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICBpZiAoJDEpIHVyaVtvLnEubmFtZV1bJDFdID0gJDJcbiAgfSlcblxuICByZXR1cm4gdXJpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BhcnNlLXVyaS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTbWFsbGVyIHZlcnNpb24gb2YgdGhlIGFzeW5jIGxpYnJhcnkgY29uc3RydWN0cy5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZWFjaFNlcmllczogYXN5bmNFYWNoU2VyaWVzLFxuICAgIHF1ZXVlOiBhc3luY1F1ZXVlXG59O1xuXG5mdW5jdGlvbiBfbm9vcCgpIHsgLyogZW1wdHkgKi8gfVxuXG4vKipcbiAqIEl0ZXJhdGVzIGFuIGFycmF5IGluIHNlcmllcy5cbiAqXG4gKiBAcGFyYW0geypbXX0gYXJyYXkgLSBBcnJheSB0byBpdGVyYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBkb25lLCBvciBvbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gYXN5bmNFYWNoU2VyaWVzKGFycmF5LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcblxuICAgIChmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICBpZiAoZXJyIHx8IGkgPT09IGxlbikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0b3IoYXJyYXlbaSsrXSwgbmV4dCk7XG4gICAgfSkoKTtcbn1cblxuLyoqXG4gKiBFbnN1cmVzIGEgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSB3cmFwcGluZyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb25seU9uY2UoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG5cbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEFzeW5jIHF1ZXVlIGltcGxlbWVudGF0aW9uLFxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHdvcmtlciAtIFRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB0YXNrLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gSG93IG1hbnkgd29ya2VycyB0byBydW4gaW4gcGFycmFsbGVsLlxuICogQHJldHVybiB7Kn0gVGhlIGFzeW5jIHF1ZXVlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXN5bmNRdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgaWYgKGNvbmN1cnJlbmN5ID09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbmN1cnJlbmN5ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpO1xuICAgIH1cblxuICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICB2YXIgcSA9IHtcbiAgICAgICAgX3Rhc2tzOiBbXSxcbiAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICBzYXR1cmF0ZWQ6IF9ub29wLFxuICAgICAgICB1bnNhdHVyYXRlZDogX25vb3AsXG4gICAgICAgIGJ1ZmZlcjogY29uY3VycmVuY3kgLyA0LFxuICAgICAgICBlbXB0eTogX25vb3AsXG4gICAgICAgIGRyYWluOiBfbm9vcCxcbiAgICAgICAgZXJyb3I6IF9ub29wLFxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHEuZHJhaW4gPSBfbm9vcDtcbiAgICAgICAgICAgIHEuX3Rhc2tzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgX2luc2VydChkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdoaWxlICghcS5wYXVzZWQgJiYgd29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLl90YXNrcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEuX3Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcnMgPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBvbmx5T25jZShfbmV4dCh0YXNrKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICB9LFxuICAgICAgICBpZGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcS5fdGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBxLnByb2Nlc3Mgb25jZSBwZXIgY29uY3VycmVudFxuICAgICAgICAgICAgLy8gd29ya2VyIHRvIHByZXNlcnZlIGZ1bGwgY29uY3VycmVuY3kgYWZ0ZXIgcGF1c2VcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAxOyB3IDw9IHEuY29uY3VycmVuY3k7IHcrKykge1xuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9pbnNlcnQoZGF0YSwgaW5zZXJ0QXRGcm9udCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCAmJiBxLmlkbGUoKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IF9ub29wXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGluc2VydEF0RnJvbnQpIHtcbiAgICAgICAgICAgIHEuX3Rhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25leHQodGFzaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuXG4gICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gIT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgICAgICAgICAgICAgcS5lcnJvcihhcmd1bWVudHNbMF0sIHRhc2suZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3b3JrZXJzIDw9IChxLmNvbmN1cnJlbmN5IC0gcS5idWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgcS51bnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocS5pZGxlKCkpIHtcbiAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBxO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZXNvdXJjZS1sb2FkZXIvc3JjL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyICAgID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xudmFyIHBhcnNlVXJpICAgICAgICA9IHJlcXVpcmUoJ3BhcnNlLXVyaScpO1xuXG4vLyB0ZXN0cyBpcyBDT1JTIGlzIHN1cHBvcnRlZCBpbiBYSFIsIGlmIG5vdCB3ZSBuZWVkIHRvIHVzZSBYRFJcbnZhciB1c2VYZHIgPSAhISh3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiAobmV3IFhNTEh0dHBSZXF1ZXN0KCkpKSk7XG52YXIgdGVtcEFuY2hvciA9IG51bGw7XG5cbi8vIHNvbWUgc3RhdHVzIGNvbnN0YW50c1xudmFyIFNUQVRVU19OT05FID0gMDtcbnZhciBTVEFUVVNfT0sgPSAyMDA7XG52YXIgU1RBVFVTX0VNUFRZID0gMjA0O1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBsb2FkaW5nIG9mIGEgc2luZ2xlIHJlc291cmNlIHJlcHJlc2VudGVkIGJ5XG4gKiBhIHNpbmdsZSBVUkwuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHVybCAtIFRoZSB1cmwgZm9yIHRoaXMgcmVzb3VyY2UsIGZvciBhdWRpby92aWRlbyBsb2FkcyB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgb2Ygc291cmNlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGxvYWQuXG4gKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gLSBJcyB0aGlzIHJlcXVlc3QgY3Jvc3Mtb3JpZ2luPyBEZWZhdWx0IGlzIHRvIGRldGVybWluZSBhdXRvbWF0aWNhbGx5LlxuICogQHBhcmFtIHtSZXNvdXJjZS5MT0FEX1RZUEV9IFtvcHRpb25zLmxvYWRUeXBlPVJlc291cmNlLkxPQURfVFlQRS5YSFJdIC0gSG93IHNob3VsZCB0aGlzIHJlc291cmNlIGJlIGxvYWRlZD9cbiAqIEBwYXJhbSB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IFtvcHRpb25zLnhoclR5cGU9UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuREVGQVVMVF0gLSBIb3cgc2hvdWxkIHRoZSBkYXRhIGJlaW5nXG4gKiAgICAgIGxvYWRlZCBiZSBpbnRlcnByZXRlZCB3aGVuIHVzaW5nIFhIUj9cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tZXRhZGF0YV0gLSBFeHRyYSBpbmZvIGZvciBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBSZXNvdXJjZShuYW1lLCB1cmwsIG9wdGlvbnMpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggbmFtZSBhbmQgdXJsIGFyZSByZXF1aXJlZCBmb3IgY29uc3RydWN0aW5nIGEgcmVzb3VyY2UuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVybCB1c2VkIHRvIGxvYWQgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnVybCA9IHVybDtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIHVybCBpcyBhIGRhdGEgdXJsLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmlzRGF0YVVybCA9IHRoaXMudXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IHdhcyBsb2FkZWQgYnkgdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7YW55fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIHJlcXVlc3QgY3Jvc3Mtb3JpZ2luPyBJZiB1bnNldCwgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJ2Fub255bW91cycgOiBvcHRpb25zLmNyb3NzT3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCBvZiBsb2FkaW5nIHRvIHVzZSBmb3IgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1Jlc291cmNlLkxPQURfVFlQRX1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRUeXBlID0gb3B0aW9ucy5sb2FkVHlwZSB8fCB0aGlzLl9kZXRlcm1pbmVMb2FkVHlwZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgdXNlZCB0byBsb2FkIHRoZSByZXNvdXJjZSB2aWEgWEhSLiBJZiB1bnNldCwgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMueGhyVHlwZSA9IG9wdGlvbnMueGhyVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhIGluZm8gZm9yIG1pZGRsZXdhcmUsIGFuZCBjb250cm9sbGluZyBzcGVjaWZpY3MgYWJvdXQgaG93IHRoZSByZXNvdXJjZSBsb2Fkcy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpZiB5b3UgcGFzcyBpbiBhIGBsb2FkRWxlbWVudGAsIHRoZSBSZXNvdXJjZSBjbGFzcyB0YWtlcyBvd25lcnNoaXAgb2YgaXQuXG4gICAgICogTWVhbmluZyBpdCB3aWxsIG1vZGlmeSBpdCBhcyBpdCBzZWVzIGZpdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxJbWFnZUVsZW1lbnR8SFRNTEF1ZGlvRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBbbG9hZEVsZW1lbnQ9bnVsbF0gLSBUaGVcbiAgICAgKiAgZWxlbWVudCB0byB1c2UgZm9yIGxvYWRpbmcsIGluc3RlYWQgb2YgY3JlYXRpbmcgb25lLlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NraXBTb3VyY2U9ZmFsc2VdIC0gU2tpcHMgYWRkaW5nIHNvdXJjZShzKSB0byB0aGUgbG9hZCBlbGVtZW50LiBUaGlzXG4gICAgICogIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBwYXNzIGluIGEgYGxvYWRFbGVtZW50YCB0aGF0IHlvdSBhbHJlYWR5IGFkZGVkIGxvYWQgc291cmNlc1xuICAgICAqICB0by5cbiAgICAgKi9cbiAgICB0aGlzLm1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtFcnJvcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmVycm9yID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gbG9hZCB0aGlzIHJlc291cmNlLiBUaGlzIGlzIG9ubHkgc2V0XG4gICAgICogd2hlbiBgbG9hZFR5cGVgIGlzIGBSZXNvdXJjZS5MT0FEX1RZUEUuWEhSYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1hNTEh0dHBSZXF1ZXN0fVxuICAgICAqL1xuICAgIHRoaXMueGhyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyBpZiB0aGlzIHJlc291cmNlIHdhcyBsb2FkZWQgYXMganNvbi4gT25seSB2YWxpZCBhZnRlciB0aGUgcmVzb3VyY2VcbiAgICAgKiBoYXMgY29tcGxldGVseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNKc29uID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgaWYgdGhpcyByZXNvdXJjZSB3YXMgbG9hZGVkIGFzIHhtbC4gT25seSB2YWxpZCBhZnRlciB0aGUgcmVzb3VyY2VcbiAgICAgKiBoYXMgY29tcGxldGVseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNYbWwgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyBpZiB0aGlzIHJlc291cmNlIHdhcyBsb2FkZWQgYXMgYW4gaW1hZ2UgdGFnLiBPbmx5IHZhbGlkIGFmdGVyIHRoZSByZXNvdXJjZVxuICAgICAqIGhhcyBjb21wbGV0ZWx5IGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0ltYWdlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgaWYgdGhpcyByZXNvdXJjZSB3YXMgbG9hZGVkIGFzIGFuIGF1ZGlvIHRhZy4gT25seSB2YWxpZCBhZnRlciB0aGUgcmVzb3VyY2VcbiAgICAgKiBoYXMgY29tcGxldGVseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNBdWRpbyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIGlmIHRoaXMgcmVzb3VyY2Ugd2FzIGxvYWRlZCBhcyBhIHZpZGVvIHRhZy4gT25seSB2YWxpZCBhZnRlciB0aGUgcmVzb3VyY2VcbiAgICAgKiBoYXMgY29tcGxldGVseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNWaWRlbyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIGlmIHRoaXMgcmVzb3VyY2UgaGFzIGZpbmlzaGVkIGxvYWRpbmcuIElzIHRydWUgd2hlbiB0aGUgcmVzb3VyY2UgaGFzIGNvbXBsZXRlbHlcbiAgICAgKiBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIGlmIHRoaXMgcmVzb3VyY2UgaXMgY3VycmVudGx5IGxvYWRpbmcuIElzIHRydWUgd2hlbiB0aGUgcmVzb3VyY2Ugc3RhcnRzIGxvYWRpbmcsXG4gICAgICogYW5kIGlzIGZhbHNlIGFnYWluIHdoZW4gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYGRlcXVldWVgIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZCBhIHN0b3JhZ2UgcGxhY2UgZm9yIHRoZSBhc3luYyBxdWV1ZSBkZXF1ZXVlIG1ldGhvZFxuICAgICAqIHVzZWQgcHJpdmF0ZWx5IGJ5IHRoZSBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2RlcXVldWUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBjb21wbGV0ZWAgZnVuY3Rpb24gYm91bmQgdG8gdGhpcyByZXNvdXJjZSdzIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2JvdW5kQ29tcGxldGUgPSB0aGlzLmNvbXBsZXRlLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYF9vbkVycm9yYCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIHJlc291cmNlJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fYm91bmRPbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBfb25Qcm9ncmVzc2AgZnVuY3Rpb24gYm91bmQgdG8gdGhpcyByZXNvdXJjZSdzIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2JvdW5kT25Qcm9ncmVzcyA9IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKTtcblxuICAgIC8vIHhociBjYWxsYmFja3NcbiAgICB0aGlzLl9ib3VuZFhock9uRXJyb3IgPSB0aGlzLl94aHJPbkVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRYaHJPbkFib3J0ID0gdGhpcy5feGhyT25BYm9ydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kWGhyT25Mb2FkID0gdGhpcy5feGhyT25Mb2FkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRYZHJPblRpbWVvdXQgPSB0aGlzLl94ZHJPblRpbWVvdXQuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgcmVzb3VyY2UgYmVpbmdzIHRvIGxvYWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgc3RhcnRcbiAgICAgKiBAbWVtYmVyb2YgUmVzb3VyY2UjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIGVhY2ggdGltZSBwcm9ncmVzcyBvZiB0aGlzIHJlc291cmNlIGxvYWQgdXBkYXRlcy5cbiAgICAgKiBOb3QgYWxsIHJlc291cmNlcyB0eXBlcyBhbmQgbG9hZGVyIHN5c3RlbXMgY2FuIHN1cHBvcnQgdGhpcyBldmVudFxuICAgICAqIHNvIHNvbWV0aW1lcyBpdCBtYXkgbm90IGJlIGF2YWlsYWJsZS4gSWYgdGhlIHJlc291cmNlXG4gICAgICogaXMgYmVpbmcgbG9hZGVkIG9uIGEgbW9kZXJuIGJyb3dzZXIsIHVzaW5nIFhIUiwgYW5kIHRoZSByZW1vdGUgc2VydmVyXG4gICAgICogcHJvcGVybHkgc2V0cyBDb250ZW50LUxlbmd0aCBoZWFkZXJzLCB0aGVuIHRoaXMgd2lsbCBiZSBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgcHJvZ3Jlc3NcbiAgICAgKiBAbWVtYmVyb2YgUmVzb3VyY2UjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIG9uY2UgdGhpcyByZXNvdXJjZSBoYXMgbG9hZGVkLCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgaXQgd2lsbFxuICAgICAqIGJlIGluIHRoZSBgZXJyb3JgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQGV2ZW50IGNvbXBsZXRlXG4gICAgICogQG1lbWJlcm9mIFJlc291cmNlI1xuICAgICAqL1xufVxuXG5SZXNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuUmVzb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVzb3VyY2U7XG5tb2R1bGUuZXhwb3J0cyA9IFJlc291cmNlO1xuXG4vKipcbiAqIE1hcmtzIHRoZSByZXNvdXJjZSBhcyBjb21wbGV0ZS5cbiAqXG4gKiBAZmlyZXMgY29tcGxldGVcbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgaW4gYSB3cmFwcGVyIG9yIHNvbWV0aGluZy4uLmdyb3NzLi4uLlxuICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRPbkVycm9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZGF0YS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kYXRhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnhocikge1xuICAgICAgICBpZiAodGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZFhock9uRXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX2JvdW5kT25Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kWGhyT25Mb2FkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnhoci5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMueGhyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcGxldGUgY2FsbGVkIGFnYWluIGZvciBhbiBhbHJlYWR5IGNvbXBsZXRlZCByZXNvdXJjZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcyk7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgbG9hZGluZyBvZiB0aGlzIHJlc291cmNlLCB3aXRoIGFuIG9wdGlvbmFsIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byB1c2UgZm9yIHRoZSBlcnJvclxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIC8vIGFib3J0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIGlnbm9yZSBzdWJzZXF1ZW50IGNhbGxzLlxuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdG9yZSBlcnJvclxuICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cbiAgICAvLyBhYm9ydCB0aGUgYWN0dWFsIGxvYWRpbmdcbiAgICBpZiAodGhpcy54aHIpIHtcbiAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy54ZHIpIHtcbiAgICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgIC8vIHNpbmdsZSBzb3VyY2VcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNyYyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11bHRpLXNvdXJjZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmRhdGEuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5yZW1vdmVDaGlsZCh0aGlzLmRhdGEuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkb25lIG5vdy5cbiAgICB0aGlzLmNvbXBsZXRlKCk7XG59O1xuXG4vKipcbiAqIEtpY2tzIG9mZiBsb2FkaW5nIG9mIHRoaXMgcmVzb3VyY2UuIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cy5cbiAqXG4gKiBAZmlyZXMgc3RhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYl0gLSBPcHRpb25hbCBjYWxsYmFjayB0byBjYWxsIG9uY2UgdGhlIHJlc291cmNlIGlzIGxvYWRlZC5cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAodGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiKHNlbGYpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY29tcGxldGUnLCBjYik7XG4gICAgfVxuXG4gICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5lbWl0KCdzdGFydCcsIHRoaXMpO1xuXG4gICAgLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbiA9PT0gZmFsc2UgfHwgdHlwZW9mIHRoaXMuY3Jvc3NPcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB0aGlzLl9kZXRlcm1pbmVDcm9zc09yaWdpbih0aGlzLnVybCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLmxvYWRUeXBlKSB7XG4gICAgICAgIGNhc2UgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFOlxuICAgICAgICAgICAgdGhpcy5fbG9hZEVsZW1lbnQoJ2ltYWdlJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJlc291cmNlLkxPQURfVFlQRS5BVURJTzpcbiAgICAgICAgICAgIHRoaXMuX2xvYWRTb3VyY2VFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuVklERU86XG4gICAgICAgICAgICB0aGlzLl9sb2FkU291cmNlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUmVzb3VyY2UuTE9BRF9UWVBFLlhIUjpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICh1c2VYZHIgJiYgdGhpcy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRYZHIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRYaHIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHNpbmdsZSBzb3VyY2UsXG4gKiBsaWtlIGFuIEhUTUxJbWFnZUVsZW1lbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZWxlbWVudCB0byB1c2UuXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fbG9hZEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLm1ldGFkYXRhLmxvYWRFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMubWV0YWRhdGEubG9hZEVsZW1lbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdpbWFnZScgJiYgdHlwZW9mIHdpbmRvdy5JbWFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuZGF0YS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1ldGFkYXRhLnNraXBTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNyYyA9IHRoaXMudXJsO1xuICAgIH1cblxuICAgIHZhciB0eXBlTmFtZSA9ICdpcycgKyB0eXBlWzBdLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cmluZygxKTtcblxuICAgIGlmICh0aGlzW3R5cGVOYW1lXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpc1t0eXBlTmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kT25FcnJvciwgZmFsc2UpO1xuICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX2JvdW5kT25Qcm9ncmVzcywgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBlbGVtZW50IHRoYXQgaGFzIG11bHRpcGxlIHNvdXJjZXMsXG4gKiBsaWtlIGFuIEhUTUxBdWRpb0VsZW1lbnQgb3IgSFRNTFZpZGVvRWxlbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBlbGVtZW50IHRvIHVzZS5cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9sb2FkU291cmNlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEubG9hZEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5tZXRhZGF0YS5sb2FkRWxlbWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiB0eXBlb2Ygd2luZG93LkF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXVkaW8oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFib3J0KCdVbnN1cHBvcnRlZCBlbGVtZW50ICcgKyB0eXBlKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1ldGFkYXRhLnNraXBTb3VyY2UpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBmb3IgQ29jb29uSlMgQ2FudmFzKyBydW50aW1lLCBsYWNrcyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKVxuICAgICAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zcmMgPSBBcnJheS5pc0FycmF5KHRoaXMudXJsKSA/IHRoaXMudXJsWzBdIDogdGhpcy51cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnVybCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51cmwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU291cmNlKHR5cGUsIHRoaXMudXJsW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU291cmNlKHR5cGUsIHRoaXMudXJsKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzWydpcycgKyB0eXBlWzBdLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnN1YnN0cmluZygxKV0gPSB0cnVlO1xuXG4gICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRPbkVycm9yLCBmYWxzZSk7XG4gICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZENvbXBsZXRlLCBmYWxzZSk7XG4gICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XG4gICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuXG4gICAgdGhpcy5kYXRhLmxvYWQoKTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gWE1MSHR0cFJlcXVlc3QuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9sb2FkWGhyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIHVuc2V0LCBkZXRlcm1pbmUgdGhlIHZhbHVlXG4gICAgaWYgKHR5cGVvZiB0aGlzLnhoclR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMueGhyVHlwZSA9IHRoaXMuX2RldGVybWluZVhoclR5cGUoKTtcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIHNldCB0aGUgcmVxdWVzdCB0eXBlIGFuZCB1cmxcbiAgICB4aHIub3BlbignR0VUJywgdGhpcy51cmwsIHRydWUpO1xuXG4gICAgLy8gbG9hZCBqc29uIGFzIHRleHQgYW5kIHBhcnNlIGl0IG91cnNlbHZlcy4gV2UgZG8gdGhpcyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAvLyAqY291Z2gqIHNhZmFyaSAqY291Z2gqIGNhbid0IGRlYWwgd2l0aCBpdC5cbiAgICBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5KU09OIHx8IHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy54aHJUeXBlO1xuICAgIH1cblxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kWGhyT25FcnJvciwgZmFsc2UpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXMuX2JvdW5kWGhyT25BYm9ydCwgZmFsc2UpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX2JvdW5kT25Qcm9ncmVzcywgZmFsc2UpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRYaHJPbkxvYWQsIGZhbHNlKTtcblxuICAgIHhoci5zZW5kKCk7XG59O1xuXG4vKipcbiAqIExvYWRzIHRoaXMgcmVzb3VyY2VzIHVzaW5nIGFuIFhEb21haW5SZXF1ZXN0LiBUaGlzIGlzIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIHN1cHBvcnQgSUU5IChncm9zcykuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9sb2FkWGRyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIHVuc2V0LCBkZXRlcm1pbmUgdGhlIHZhbHVlXG4gICAgaWYgKHR5cGVvZiB0aGlzLnhoclR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMueGhyVHlwZSA9IHRoaXMuX2RldGVybWluZVhoclR5cGUoKTtcbiAgICB9XG5cbiAgICB2YXIgeGRyID0gdGhpcy54aHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcblxuICAgIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZldyBxdWlya3MuIE9jY2FzaW9uYWxseSBpdCB3aWxsIGFib3J0IHJlcXVlc3RzXG4gICAgLy8gQSB3YXkgdG8gYXZvaWQgdGhpcyBpcyB0byBtYWtlIHN1cmUgQUxMIGNhbGxiYWNrcyBhcmUgc2V0IGV2ZW4gaWYgbm90IHVzZWRcbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTc4Njk2Ni94ZG9tYWlucmVxdWVzdC1hYm9ydHMtcG9zdC1vbi1pZS05XG4gICAgeGRyLnRpbWVvdXQgPSA1MDAwO1xuXG4gICAgeGRyLm9uZXJyb3IgPSB0aGlzLl9ib3VuZFhock9uRXJyb3I7XG4gICAgeGRyLm9udGltZW91dCA9IHRoaXMuX2JvdW5kWGRyT25UaW1lb3V0O1xuICAgIHhkci5vbnByb2dyZXNzID0gdGhpcy5fYm91bmRPblByb2dyZXNzO1xuICAgIHhkci5vbmxvYWQgPSB0aGlzLl9ib3VuZFhock9uTG9hZDtcblxuICAgIHhkci5vcGVuKCdHRVQnLCB0aGlzLnVybCwgdHJ1ZSk7XG5cbiAgICAvLyBOb3RlOiBUaGUgeGRyLnNlbmQoKSBjYWxsIGlzIHdyYXBwZWQgaW4gYSB0aW1lb3V0IHRvIHByZXZlbnQgYW5cbiAgICAvLyBpc3N1ZSB3aXRoIHRoZSBpbnRlcmZhY2Ugd2hlcmUgc29tZSByZXF1ZXN0cyBhcmUgbG9zdCBpZiBtdWx0aXBsZVxuICAgIC8vIFhEb21haW5SZXF1ZXN0cyBhcmUgYmVpbmcgc2VudCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIFNvbWUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2lzc3Vlcy8xMjQ4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHhkci5zZW5kKCk7XG4gICAgfSwgMCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzb3VyY2UgdXNlZCBpbiBsb2FkaW5nIHZpYSBhbiBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBlbGVtZW50IHR5cGUgKHZpZGVvIG9yIGF1ZGlvKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgc291cmNlIFVSTCB0byBsb2FkIGZyb20uXG4gKiBAcGFyYW0ge3N0cmluZ30gW21pbWVdIC0gVGhlIG1pbWUgdHlwZSBvZiB0aGUgdmlkZW9cbiAqIEByZXR1cm4ge0hUTUxTb3VyY2VFbGVtZW50fSBUaGUgc291cmNlIGVsZW1lbnQuXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fY3JlYXRlU291cmNlID0gZnVuY3Rpb24gKHR5cGUsIHVybCwgbWltZSkge1xuICAgIGlmICghbWltZSkge1xuICAgICAgICBtaW1lID0gdHlwZSArICcvJyArIHVybC5zdWJzdHIodXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG5cbiAgICBzb3VyY2Uuc3JjID0gdXJsO1xuICAgIHNvdXJjZS50eXBlID0gbWltZTtcblxuICAgIHJldHVybiBzb3VyY2U7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiBhIGxvYWQgZXJyb3JzIG91dC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBlcnJvciBldmVudCBmcm9tIHRoZSBlbGVtZW50IHRoYXQgZW1pdHMgaXQuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmFib3J0KCdGYWlsZWQgdG8gbG9hZCBlbGVtZW50IHVzaW5nICcgKyBldmVudC50YXJnZXQubm9kZU5hbWUpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgYSBsb2FkIHByb2dyZXNzIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxuICpcbiAqIEBmaXJlcyBwcm9ncmVzc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3RQcm9ncmVzc0V2ZW50fEV2ZW50fSBldmVudCAtIFByb2dyZXNzIGV2ZW50LlxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX29uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdGhpcywgZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIGFuIGVycm9yIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0RXJyb3JFdmVudHxFdmVudH0gZXZlbnQgLSBFcnJvciBldmVudC5cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl94aHJPbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB4aHIgPSB0aGlzLnhocjtcblxuICAgIHRoaXMuYWJvcnQocmVxVHlwZSh4aHIpICsgJyBSZXF1ZXN0IGZhaWxlZC4gU3RhdHVzOiAnICsgeGhyLnN0YXR1cyArICcsIHRleHQ6IFwiJyArIHhoci5zdGF0dXNUZXh0ICsgJ1wiJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiBhbiBhYm9ydCBldmVudCBmaXJlcyBmb3IgeGhyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0QWJvcnRFdmVudH0gZXZlbnQgLSBBYm9ydCBFdmVudFxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX3hock9uQWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hYm9ydChyZXFUeXBlKHRoaXMueGhyKSArICcgUmVxdWVzdCB3YXMgYWJvcnRlZCBieSB0aGUgdXNlci4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIGEgdGltZW91dCBldmVudCBmaXJlcyBmb3IgeGRyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRpbWVvdXQgZXZlbnQuXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5feGRyT25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWJvcnQocmVxVHlwZSh0aGlzLnhocikgKyAnIFJlcXVlc3QgdGltZWQgb3V0LicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBkYXRhIHN1Y2Nlc3NmdWxseSBsb2FkcyBmcm9tIGFuIHhoci94ZHIgcmVxdWVzdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdExvYWRFdmVudHxFdmVudH0gZXZlbnQgLSBMb2FkIGV2ZW50XG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5feGhyT25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB4aHIgPSB0aGlzLnhocjtcbiAgICB2YXIgc3RhdHVzID0gdHlwZW9mIHhoci5zdGF0dXMgPT09ICd1bmRlZmluZWQnID8geGhyLnN0YXR1cyA6IFNUQVRVU19PSzsgLy8gWERSIGhhcyBubyBgLnN0YXR1c2AsIGFzc3VtZSAyMDAuXG5cbiAgICAvLyBzdGF0dXMgY2FuIGJlIDAgd2hlbiB1c2luZyB0aGUgZmlsZTovLyBwcm90b2NvbCwgYWxzbyBjaGVjayBpZiBhIHJlc3BvbnNlIHdhcyBmb3VuZFxuICAgIGlmIChzdGF0dXMgPT09IFNUQVRVU19PSyB8fCBzdGF0dXMgPT09IFNUQVRVU19FTVBUWSB8fCAoc3RhdHVzID09PSBTVEFUVVNfTk9ORSAmJiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IDApKSB7XG4gICAgICAgIC8vIGlmIHRleHQsIGp1c3QgcmV0dXJuIGl0XG4gICAgICAgIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYganNvbiwgcGFyc2UgaW50byBqc29uIG9iamVjdFxuICAgICAgICBlbHNlIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSnNvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBsb2FkZWQganNvbjonLCBlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB4bWwsIHBhcnNlIGludG8gYW4geG1sIGRvY3VtZW50IG9yIGRpdiBlbGVtZW50XG4gICAgICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkb21wYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhoci5yZXNwb25zZVRleHQsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkaXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaXNYbWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgbG9hZGVkIHhtbDonLCBlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlciB0eXBlcyBqdXN0IHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hYm9ydCgnWycgKyB4aHIuc3RhdHVzICsgJ10nICsgeGhyLnN0YXR1c1RleHQgKyAnOicgKyB4aHIucmVzcG9uc2VVUkwpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgZm9yIHRoaXMgcmVzb3VyY2UgYmFzZWQgb24gaWYgdGhlIHVybFxuICogZm9yIHRoaXMgcmVzb3VyY2UgaXMgY3Jvc3Mtb3JpZ2luLiBJZiBjcm9zc09yaWdpbiB3YXMgbWFudWFsbHkgc2V0LCB0aGlzXG4gKiBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHRlc3QuXG4gKiBAcGFyYW0ge29iamVjdH0gW2xvYz13aW5kb3cubG9jYXRpb25dIC0gVGhlIGxvY2F0aW9uIG9iamVjdCB0byB0ZXN0IGFnYWluc3QuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjcm9zc09yaWdpbiB2YWx1ZSB0byB1c2UgKG9yIGVtcHR5IHN0cmluZyBmb3Igbm9uZSkuXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4gPSBmdW5jdGlvbiAodXJsLCBsb2MpIHtcbiAgICAvLyBkYXRhOiBhbmQgamF2YXNjcmlwdDogdXJscyBhcmUgY29uc2lkZXJlZCBzYW1lLW9yaWdpblxuICAgIGlmICh1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBpcyB3aW5kb3cubG9jYXRpb25cbiAgICBsb2MgPSBsb2MgfHwgd2luZG93LmxvY2F0aW9uO1xuXG4gICAgaWYgKCF0ZW1wQW5jaG9yKSB7XG4gICAgICAgIHRlbXBBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuXG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRldGVybWluZSB0aGUgZnVsbCBocmVmIGZvciB0aGUgdXJsIG9mIHRoaXMgcmVzb3VyY2UgYW5kIHRoZW5cbiAgICAvLyBwYXJzZSB3aXRoIHRoZSBub2RlIHVybCBsaWIsIHdlIGNhbid0IHVzZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgYW5jaG9yIGVsZW1lbnRcbiAgICAvLyBiZWNhdXNlIHRoZXkgZG9uJ3Qgd29yayBpbiBJRTkgOihcbiAgICB0ZW1wQW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgdXJsID0gcGFyc2VVcmkodGVtcEFuY2hvci5ocmVmLCB7IHN0cmljdE1vZGU6IHRydWUgfSk7XG5cbiAgICB2YXIgc2FtZVBvcnQgPSAoIXVybC5wb3J0ICYmIGxvYy5wb3J0ID09PSAnJykgfHwgKHVybC5wb3J0ID09PSBsb2MucG9ydCk7XG4gICAgdmFyIHByb3RvY29sID0gdXJsLnByb3RvY29sID8gdXJsLnByb3RvY29sICsgJzonIDogJyc7XG5cbiAgICAvLyBpZiBjcm9zcyBvcmlnaW5cbiAgICBpZiAodXJsLmhvc3QgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgcHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgICAgICByZXR1cm4gJ2Fub255bW91cyc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSByZXNwb25zZVR5cGUgb2YgYW4gWEhSIHJlcXVlc3QgYmFzZWQgb24gdGhlIGV4dGVuc2lvbiBvZiB0aGVcbiAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IFRoZSByZXNwb25zZVR5cGUgdG8gdXNlLlxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2RldGVybWluZVhoclR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlc291cmNlLl94aHJUeXBlTWFwW3RoaXMuX2dldEV4dGVuc2lvbigpXSB8fCBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5URVhUO1xufTtcblxuUmVzb3VyY2UucHJvdG90eXBlLl9kZXRlcm1pbmVMb2FkVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVzb3VyY2UuX2xvYWRUeXBlTWFwW3RoaXMuX2dldEV4dGVuc2lvbigpXSB8fCBSZXNvdXJjZS5MT0FEX1RZUEUuWEhSO1xufTtcblxuUmVzb3VyY2UucHJvdG90eXBlLl9nZXRFeHRlbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVybCA9IHRoaXMudXJsO1xuICAgIHZhciBleHQgPSAnJztcblxuICAgIGlmICh0aGlzLmlzRGF0YVVybCkge1xuICAgICAgICB2YXIgc2xhc2hJbmRleCA9IHVybC5pbmRleE9mKCcvJyk7XG5cbiAgICAgICAgZXh0ID0gdXJsLnN1YnN0cmluZyhzbGFzaEluZGV4ICsgMSwgdXJsLmluZGV4T2YoJzsnLCBzbGFzaEluZGV4KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XG5cbiAgICAgICAgaWYgKHF1ZXJ5U3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwuc3Vic3RyaW5nKDAsIHF1ZXJ5U3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXh0ID0gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBleHQudG9Mb3dlckNhc2UoKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbWltZSB0eXBlIG9mIGFuIFhIUiByZXF1ZXN0IGJhc2VkIG9uIHRoZSByZXNwb25zZVR5cGUgb2ZcbiAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRX0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCBhIG1pbWUgdHlwZSBmb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtaW1lIHR5cGUgdG8gdXNlLlxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2dldE1pbWVGcm9tWGhyVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSOlxuICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1iaW5hcnknO1xuXG4gICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQjpcbiAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vYmxvYic7XG5cbiAgICAgICAgY2FzZSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24veG1sJztcblxuICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT046XG4gICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2pzb24nO1xuXG4gICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuREVGQVVMVDpcbiAgICAgICAgY2FzZSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5URVhUOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICd0ZXh0L3BsYWluJztcblxuICAgIH1cbn07XG5cbi8qKlxuICogUXVpY2sgaGVscGVyIHRvIGdldCBzdHJpbmcgeGhyIHR5cGUuXG4gKlxuICogQGlnbm9yZVxuICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdHxYRG9tYWluUmVxdWVzdH0geGhyIC0gVGhlIHJlcXVlc3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0eXBlLlxuICovXG5mdW5jdGlvbiByZXFUeXBlKHhocikge1xuICAgIHJldHVybiB4aHIudG9TdHJpbmcoKS5yZXBsYWNlKCdvYmplY3QgJywgJycpO1xufVxuXG4vKipcbiAqIFRoZSB0eXBlcyBvZiBsb2FkaW5nIGEgcmVzb3VyY2UgY2FuIHVzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cblJlc291cmNlLkxPQURfVFlQRSA9IHtcbiAgICAvKiogVXNlcyBYTUxIdHRwUmVxdWVzdCB0byBsb2FkIHRoZSByZXNvdXJjZS4gKi9cbiAgICBYSFI6ICAgIDEsXG4gICAgLyoqIFVzZXMgYW4gYEltYWdlYCBvYmplY3QgdG8gbG9hZCB0aGUgcmVzb3VyY2UuICovXG4gICAgSU1BR0U6ICAyLFxuICAgIC8qKiBVc2VzIGFuIGBBdWRpb2Agb2JqZWN0IHRvIGxvYWQgdGhlIHJlc291cmNlLiAqL1xuICAgIEFVRElPOiAgMyxcbiAgICAvKiogVXNlcyBhIGBWaWRlb2Agb2JqZWN0IHRvIGxvYWQgdGhlIHJlc291cmNlLiAqL1xuICAgIFZJREVPOiAgNFxufTtcblxuLyoqXG4gKiBUaGUgWEhSIHJlYWR5IHN0YXRlcywgdXNlZCBpbnRlcm5hbGx5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUgPSB7XG4gICAgLyoqIGRlZmF1bHRzIHRvIHRleHQgKi9cbiAgICBERUZBVUxUOiAgICAndGV4dCcsXG4gICAgLyoqIEFycmF5QnVmZmVyICovXG4gICAgQlVGRkVSOiAgICAgJ2FycmF5YnVmZmVyJyxcbiAgICAvKiogQmxvYiAqL1xuICAgIEJMT0I6ICAgICAgICdibG9iJyxcbiAgICAvKiogRG9jdW1lbnQgKi9cbiAgICBET0NVTUVOVDogICAnZG9jdW1lbnQnLFxuICAgIC8qKiBPYmplY3QgKi9cbiAgICBKU09OOiAgICAgICAnanNvbicsXG4gICAgLyoqIFN0cmluZyAqL1xuICAgIFRFWFQ6ICAgICAgICd0ZXh0J1xufTtcblxuUmVzb3VyY2UuX2xvYWRUeXBlTWFwID0ge1xuICAgIGdpZjogICAgICBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAgcG5nOiAgICAgIFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICBibXA6ICAgICAgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIGpwZzogICAgICBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAganBlZzogICAgIFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICB0aWY6ICAgICAgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgIHRpZmY6ICAgICBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAgd2VicDogICAgIFJlc291cmNlLkxPQURfVFlQRS5JTUFHRSxcbiAgICB0Z2E6ICAgICAgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgICdzdmcreG1sJzogIFJlc291cmNlLkxPQURfVFlQRS5JTUFHRVxufTtcblxuUmVzb3VyY2UuX3hoclR5cGVNYXAgPSB7XG4gICAgLy8geG1sXG4gICAgeGh0bWw6ICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIGh0bWw6ICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICBodG06ICAgICAgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG4gICAgeG1sOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIHRteDogICAgICBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICB0c3g6ICAgICAgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG4gICAgc3ZnOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuXG4gICAgLy8gaW1hZ2VzXG4gICAgZ2lmOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgcG5nOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgYm1wOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAganBnOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAganBlZzogICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgdGlmOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgdGlmZjogICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgd2VicDogICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgdGdhOiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG5cbiAgICAvLyBqc29uXG4gICAganNvbjogICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04sXG5cbiAgICAvLyB0ZXh0XG4gICAgdGV4dDogICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQsXG4gICAgdHh0OiAgICAgIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFRcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbG9hZCB0eXBlIHRvIGJlIHVzZWQgZm9yIGEgc3BlY2lmaWMgZXh0ZW5zaW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHRuYW1lIC0gVGhlIGV4dGVuc2lvbiB0byBzZXQgdGhlIHR5cGUgZm9yLCBlLmcuIFwicG5nXCIgb3IgXCJmbnRcIlxuICogQHBhcmFtIHtSZXNvdXJjZS5MT0FEX1RZUEV9IGxvYWRUeXBlIC0gVGhlIGxvYWQgdHlwZSB0byBzZXQgaXQgdG8uXG4gKi9cblJlc291cmNlLnNldEV4dGVuc2lvbkxvYWRUeXBlID0gZnVuY3Rpb24gKGV4dG5hbWUsIGxvYWRUeXBlKSB7XG4gICAgc2V0RXh0TWFwKFJlc291cmNlLl9sb2FkVHlwZU1hcCwgZXh0bmFtZSwgbG9hZFR5cGUpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsb2FkIHR5cGUgdG8gYmUgdXNlZCBmb3IgYSBzcGVjaWZpYyBleHRlbnNpb24uXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtzdHJpbmd9IGV4dG5hbWUgLSBUaGUgZXh0ZW5zaW9uIHRvIHNldCB0aGUgdHlwZSBmb3IsIGUuZy4gXCJwbmdcIiBvciBcImZudFwiXG4gKiBAcGFyYW0ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSB4aHJUeXBlIC0gVGhlIHhociB0eXBlIHRvIHNldCBpdCB0by5cbiAqL1xuUmVzb3VyY2Uuc2V0RXh0ZW5zaW9uWGhyVHlwZSA9IGZ1bmN0aW9uIChleHRuYW1lLCB4aHJUeXBlKSB7XG4gICAgc2V0RXh0TWFwKFJlc291cmNlLl94aHJUeXBlTWFwLCBleHRuYW1lLCB4aHJUeXBlKTtcbn07XG5cbmZ1bmN0aW9uIHNldEV4dE1hcChtYXAsIGV4dG5hbWUsIHZhbCkge1xuICAgIGlmIChleHRuYW1lICYmIGV4dG5hbWUuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgIGV4dG5hbWUgPSBleHRuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4dG5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1hcFtleHRuYW1lXSA9IHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVzb3VyY2UtbG9hZGVyL3NyYy9SZXNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtCb29sZWFufSBleGlzdHMgT25seSBjaGVjayBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0FycmF5fEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCwgZXhpc3RzKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBhdmFpbGFibGUgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoZXhpc3RzKSByZXR1cm4gISFhdmFpbGFibGU7XG4gIGlmICghYXZhaWxhYmxlKSByZXR1cm4gW107XG4gIGlmIChhdmFpbGFibGUuZm4pIHJldHVybiBbYXZhaWxhYmxlLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGF2YWlsYWJsZS5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBhdmFpbGFibGVbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIHRoaXMuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzLCB0cnVlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCB0aGlzLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW3RoaXMuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm5cbiAgICAgICYmICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSlcbiAgICAgICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmblxuICAgICAgICB8fCAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpXG4gICAgICAgIHx8IChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgICAgZWxzZSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFwcGx5IGFueW1vcmUuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVzb3VyY2UtbG9hZGVyL34vZXZlbnRlbWl0dGVyMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gYSBzaW1wbGUgaW4tbWVtb3J5IGNhY2hlIGZvciByZXNvdXJjZXNcbnZhciBjYWNoZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KSB7XG4gICAgICAgIC8vIGlmIGNhY2hlZCwgdGhlbiBzZXQgZGF0YSBhbmQgY29tcGxldGUgdGhlIHJlc291cmNlXG4gICAgICAgIGlmIChjYWNoZVtyZXNvdXJjZS51cmxdKSB7XG4gICAgICAgICAgICByZXNvdXJjZS5kYXRhID0gY2FjaGVbcmVzb3VyY2UudXJsXTtcbiAgICAgICAgICAgIHJlc291cmNlLmNvbXBsZXRlKCk7IC8vIG1hcmtzIHJlc291cmNlIGxvYWQgY29tcGxldGUgYW5kIHN0b3BzIHByb2Nlc3NpbmcgYmVmb3JlIG1pZGRsZXdhcmVzXG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm90IGNhY2hlZCwgd2FpdCBmb3IgY29tcGxldGUgYW5kIHN0b3JlIGl0IGluIHRoZSBjYWNoZS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZS5vbmNlKCdjb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVt0aGlzLnVybF0gPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVzb3VyY2UtbG9hZGVyL3NyYy9taWRkbGV3YXJlcy9jYWNoaW5nL21lbW9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlc291cmNlID0gcmVxdWlyZSgnLi4vLi4vUmVzb3VyY2UnKTtcbnZhciBiNjQgPSByZXF1aXJlKCcuLi8uLi9iNjQnKTtcblxudmFyIFVybCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblxuLy8gYSBtaWRkbGV3YXJlIGZvciB0cmFuc2Zvcm1pbmcgWEhSIGxvYWRlZCBCbG9icyBpbnRvIG1vcmUgdXNlZnVsIG9iamVjdHNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvdXJjZSwgbmV4dCkge1xuICAgICAgICBpZiAoIXJlc291cmNlLmRhdGEpIHtcbiAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyB3YXMgYW4gWEhSIGxvYWQgb2YgYSBibG9iXG4gICAgICAgIGlmIChyZXNvdXJjZS54aHIgJiYgcmVzb3VyY2UueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQikge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYmxvYiBzdXBwb3J0IHdlIHByb2JhYmx5IGdvdCBhIGJpbmFyeSBzdHJpbmcgYmFja1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuQmxvYiB8fCB0eXBlb2YgcmVzb3VyY2UuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHJlc291cmNlLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGltYWdlLCBjb252ZXJ0IHRoZSBiaW5hcnkgc3RyaW5nIGludG8gYSBkYXRhIHVybFxuICAgICAgICAgICAgICAgIGlmICh0eXBlICYmIHR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEuc3JjID0gJ2RhdGE6JyArIHR5cGUgKyAnO2Jhc2U2NCwnICsgYjY0LmVuY29kZUJpbmFyeShyZXNvdXJjZS54aHIucmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5pc0ltYWdlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBpbWFnZSBsb2FkcyBhbmQgdGhlbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEub25sb2FkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQgd2lsbCBiZSBjYWxsZWQgb24gbG9hZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY29udGVudCB0eXBlIHNheXMgdGhpcyBpcyBhbiBpbWFnZSwgdGhlbiB3ZSBzaG91bGQgdHJhbnNmb3JtIHRoZSBibG9iIGludG8gYW4gSW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNvdXJjZS5kYXRhLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBVcmwuY3JlYXRlT2JqZWN0VVJMKHJlc291cmNlLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuYmxvYiA9IHJlc291cmNlLmRhdGE7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEuc3JjID0gc3JjO1xuXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuaXNJbWFnZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIHRoZSBubyBsb25nZXIgdXNlZCBibG9iIGFmdGVyIHRoZSBpbWFnZSBsb2Fkc1xuICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBVcmwucmV2b2tlT2JqZWN0VVJMKHNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEub25sb2FkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIG5leHQgd2lsbCBiZSBjYWxsZWQgb24gbG9hZC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Jlc291cmNlLWxvYWRlci9zcmMvbWlkZGxld2FyZXMvcGFyc2luZy9ibG9iLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IDAgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gcHJpdmF0ZSBwcm9wZXJ0eVxuICAgIF9rZXlTdHI6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPScsXG5cbiAgICBlbmNvZGVCaW5hcnk6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgIHZhciBieXRlYnVmZmVyO1xuICAgICAgICB2YXIgZW5jb2RlZENoYXJJbmRleGVzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICB2YXIgaW54ID0gMDtcbiAgICAgICAgdmFyIGpueCA9IDA7XG4gICAgICAgIHZhciBwYWRkaW5nQnl0ZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChpbnggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgYnl0ZSBidWZmZXIgYXJyYXlcbiAgICAgICAgICAgIGJ5dGVidWZmZXIgPSBuZXcgQXJyYXkoMyk7XG5cbiAgICAgICAgICAgIGZvciAoam54ID0gMDsgam54IDwgYnl0ZWJ1ZmZlci5sZW5ndGg7IGpueCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlueCA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBhd2F5IGhpZ2gtb3JkZXIgYnl0ZSwgYXMgZG9jdW1lbnRlZCBhdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvRW4vVXNpbmdfWE1MSHR0cFJlcXVlc3QjSGFuZGxpbmdfYmluYXJ5X2RhdGFcbiAgICAgICAgICAgICAgICAgICAgYnl0ZWJ1ZmZlcltqbnhdID0gaW5wdXQuY2hhckNvZGVBdChpbngrKykgJiAweGZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZWJ1ZmZlcltqbnhdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBlYWNoIGVuY29kZWQgY2hhcmFjdGVyLCA2IGJpdHMgYXQgYSB0aW1lXG4gICAgICAgICAgICAvLyBpbmRleCAxOiBmaXJzdCA2IGJpdHNcbiAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1swXSA9IGJ5dGVidWZmZXJbMF0gPj4gMjtcbiAgICAgICAgICAgIC8vIGluZGV4IDI6IHNlY29uZCA2IGJpdHMgKDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIGlucHV0IGJ5dGUgMSArIDQgbW9zdCBzaWduaWZpY2FudCBiaXRzIGZyb20gYnl0ZSAyKVxuICAgICAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzFdID0gKChieXRlYnVmZmVyWzBdICYgMHgzKSA8PCA0KSB8IChieXRlYnVmZmVyWzFdID4+IDQpO1xuICAgICAgICAgICAgLy8gaW5kZXggMzogdGhpcmQgNiBiaXRzICg0IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBpbnB1dCBieXRlIDIgKyAyIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIGJ5dGUgMylcbiAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1syXSA9ICgoYnl0ZWJ1ZmZlclsxXSAmIDB4MGYpIDw8IDIpIHwgKGJ5dGVidWZmZXJbMl0gPj4gNik7XG4gICAgICAgICAgICAvLyBpbmRleCAzOiBmb3J0aCA2IGJpdHMgKDYgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIGlucHV0IGJ5dGUgMylcbiAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1szXSA9IGJ5dGVidWZmZXJbMl0gJiAweDNmO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBwYWRkaW5nIGhhcHBlbmVkLCBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgICAgICAgICBwYWRkaW5nQnl0ZXMgPSBpbnggLSAoaW5wdXQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhZGRpbmdCeXRlcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxhc3QgMiBjaGFyYWN0ZXJzIHRvIHBhZGRpbmcgY2hhclxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbM10gPSA2NDtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzJdID0gNjQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgbGFzdCBjaGFyYWN0ZXIgdG8gcGFkZGluZyBjaGFyXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1szXSA9IDY0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBObyBwYWRkaW5nIC0gcHJvY2VlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3cgd2Ugd2lsbCBncmFiIGVhY2ggYXBwcm9wcmlhdGUgY2hhcmFjdGVyIG91dCBvZiBvdXIga2V5c3RyaW5nXG4gICAgICAgICAgICAvLyBiYXNlZCBvbiBvdXIgaW5kZXggYXJyYXkgYW5kIGFwcGVuZCBpdCB0byB0aGUgb3V0cHV0IHN0cmluZ1xuICAgICAgICAgICAgZm9yIChqbnggPSAwOyBqbnggPCBlbmNvZGVkQ2hhckluZGV4ZXMubGVuZ3RoOyBqbngrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSB0aGlzLl9rZXlTdHIuY2hhckF0KGVuY29kZWRDaGFySW5kZXhlc1tqbnhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVzb3VyY2UtbG9hZGVyL3NyYy9iNjQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVzb3VyY2UsIG5leHQpXG4gICAge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgdGV4dHVyZSBpZiB0aGUgZGF0YSBpcyBhbiBJbWFnZSBvYmplY3RcbiAgICAgICAgaWYgKHJlc291cmNlLmRhdGEgJiYgcmVzb3VyY2UuaXNJbWFnZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gbmV3IGNvcmUuQmFzZVRleHR1cmUocmVzb3VyY2UuZGF0YSwgbnVsbCwgY29yZS51dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwocmVzb3VyY2UudXJsKSk7XG4gICAgICAgICAgICBiYXNlVGV4dHVyZS5pbWFnZVVybCA9IHJlc291cmNlLnVybDtcbiAgICAgICAgICAgIHJlc291cmNlLnRleHR1cmUgPSBuZXcgY29yZS5UZXh0dXJlKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgICAgIC8vIGxldHMgYWxzbyBhZGQgdGhlIGZyYW1lIHRvIHBpeGkncyBnbG9iYWwgY2FjaGUgZm9yIGZyb21GcmFtZSBhbmQgZnJvbUltYWdlIGZ1Y250aW9uc1xuICAgICAgICAgICAgY29yZS51dGlscy5CYXNlVGV4dHVyZUNhY2hlW3Jlc291cmNlLnVybF0gPSBiYXNlVGV4dHVyZTtcbiAgICAgICAgICAgIGNvcmUudXRpbHMuVGV4dHVyZUNhY2hlW3Jlc291cmNlLnVybF0gPSByZXNvdXJjZS50ZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9sb2FkZXJzL3RleHR1cmVQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUmVzb3VyY2UgPSByZXF1aXJlKCdyZXNvdXJjZS1sb2FkZXInKS5SZXNvdXJjZSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xuXG52YXIgQkFUQ0hfU0laRSA9IDEwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KVxuICAgIHtcbiAgICAgICAgdmFyIGltYWdlUmVzb3VyY2VOYW1lID0gcmVzb3VyY2UubmFtZSArICdfaW1hZ2UnO1xuXG4gICAgICAgIC8vIHNraXAgaWYgbm8gZGF0YSwgaXRzIG5vdCBqc29uLCBpdCBpc24ndCBzcHJpdGVzaGVldCBkYXRhLCBvciB0aGUgaW1hZ2UgcmVzb3VyY2UgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKCFyZXNvdXJjZS5kYXRhIHx8ICFyZXNvdXJjZS5pc0pzb24gfHwgIXJlc291cmNlLmRhdGEuZnJhbWVzIHx8IHRoaXMucmVzb3VyY2VzW2ltYWdlUmVzb3VyY2VOYW1lXSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luOiByZXNvdXJjZS5jcm9zc09yaWdpbixcbiAgICAgICAgICAgIGxvYWRUeXBlOiBSZXNvdXJjZS5MT0FEX1RZUEUuSU1BR0UsXG4gICAgICAgICAgICBtZXRhZGF0YTogcmVzb3VyY2UubWV0YWRhdGEuaW1hZ2VNZXRhZGF0YVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByb3V0ZSA9IHBhdGguZGlybmFtZShyZXNvdXJjZS51cmwucmVwbGFjZSh0aGlzLmJhc2VVcmwsICcnKSk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgaW1hZ2UgZm9yIHRoaXMgc2hlZXRcbiAgICAgICAgdGhpcy5hZGQoaW1hZ2VSZXNvdXJjZU5hbWUsIHJvdXRlICsgJy8nICsgcmVzb3VyY2UuZGF0YS5tZXRhLmltYWdlLCBsb2FkT3B0aW9ucywgZnVuY3Rpb24gKHJlcylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzb3VyY2UudGV4dHVyZXMgPSB7fTtcblxuICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHJlc291cmNlLmRhdGEuZnJhbWVzO1xuICAgICAgICAgICAgdmFyIGZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKGZyYW1lcyk7XG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHJlc291cmNlLnVybCk7XG4gICAgICAgICAgICB2YXIgYmF0Y2hJbmRleCA9IDA7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NGcmFtZXMoaW5pdGlhbEZyYW1lSW5kZXgsIG1heEZyYW1lcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVJbmRleCA9IGluaXRpYWxGcmFtZUluZGV4O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZyYW1lSW5kZXggLSBpbml0aWFsRnJhbWVJbmRleCA8IG1heEZyYW1lcyAmJiBmcmFtZUluZGV4IDwgZnJhbWVLZXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tmcmFtZUtleXNbZnJhbWVJbmRleF1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGZyYW1lLmZyYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJpbSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZS5yb3RhdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBuZXcgY29yZS5SZWN0YW5nbGUocmVjdC54LCByZWN0LnksIHJlY3QuaCwgcmVjdC53KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gbmV3IGNvcmUuUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUudHJpbW1lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmltID0gbmV3IGNvcmUuUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5zcHJpdGVTb3VyY2VTaXplLnggLyByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5zcHJpdGVTb3VyY2VTaXplLnkgLyByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5zb3VyY2VTaXplLncgLyByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5zb3VyY2VTaXplLmggLyByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmxpcCB0aGUgd2lkdGggYW5kIGhlaWdodCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZS5yb3RhdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplLnggLz0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUueSAvPSByZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZS53aWR0aCAvPSByZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgLz0gcmVzb2x1dGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UudGV4dHVyZXNbZnJhbWVLZXlzW2ZyYW1lSW5kZXhdXSA9IG5ldyBjb3JlLlRleHR1cmUocmVzLnRleHR1cmUuYmFzZVRleHR1cmUsIHNpemUsIHNpemUuY2xvbmUoKSwgdHJpbSwgZnJhbWUucm90YXRlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldHMgYWxzbyBhZGQgdGhlIGZyYW1lIHRvIHBpeGkncyBnbG9iYWwgY2FjaGUgZm9yIGZyb21GcmFtZSBhbmQgZnJvbUltYWdlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS51dGlscy5UZXh0dXJlQ2FjaGVbZnJhbWVLZXlzW2ZyYW1lSW5kZXhdXSA9IHJlc291cmNlLnRleHR1cmVzW2ZyYW1lS2V5c1tmcmFtZUluZGV4XV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc05leHRCYXRjaCgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoSW5kZXggKiBCQVRDSF9TSVpFIDwgZnJhbWVLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc05leHRCYXRjaChkb25lKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGcmFtZXMoYmF0Y2hJbmRleCAqIEJBVENIX1NJWkUsIEJBVENIX1NJWkUpO1xuICAgICAgICAgICAgICAgIGJhdGNoSW5kZXgrKztcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJhbWVLZXlzLmxlbmd0aCA8PSBCQVRDSF9TSVpFKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGcmFtZXMoMCwgQkFUQ0hfU0laRSk7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdChzaG91bGRQcm9jZXNzTmV4dEJhdGNoLCBwcm9jZXNzTmV4dEJhdGNoLCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2xvYWRlcnMvc3ByaXRlc2hlZXRQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlc291cmNlID0gcmVxdWlyZSgncmVzb3VyY2UtbG9hZGVyJykuUmVzb3VyY2UsXG4gICAgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBleHRyYXMgPSByZXF1aXJlKCcuLi9leHRyYXMnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5cbmZ1bmN0aW9uIHBhcnNlKHJlc291cmNlLCB0ZXh0dXJlKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgaW5mbyA9IHJlc291cmNlLmRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2luZm8nKVswXTtcbiAgICB2YXIgY29tbW9uID0gcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29tbW9uJylbMF07XG5cbiAgICBkYXRhLmZvbnQgPSBpbmZvLmdldEF0dHJpYnV0ZSgnZmFjZScpO1xuICAgIGRhdGEuc2l6ZSA9IHBhcnNlSW50KGluZm8uZ2V0QXR0cmlidXRlKCdzaXplJyksIDEwKTtcbiAgICBkYXRhLmxpbmVIZWlnaHQgPSBwYXJzZUludChjb21tb24uZ2V0QXR0cmlidXRlKCdsaW5lSGVpZ2h0JyksIDEwKTtcbiAgICBkYXRhLmNoYXJzID0ge307XG5cbiAgICAvL3BhcnNlIGxldHRlcnNcbiAgICB2YXIgbGV0dGVycyA9IHJlc291cmNlLmRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NoYXInKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCAxMCk7XG5cbiAgICAgICAgdmFyIHRleHR1cmVSZWN0ID0gbmV3IGNvcmUuUmVjdGFuZ2xlKFxuICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3gnKSwgMTApICsgdGV4dHVyZS5mcmFtZS54LFxuICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3knKSwgMTApICsgdGV4dHVyZS5mcmFtZS55LFxuICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSwgMTApXG4gICAgICAgICk7XG5cbiAgICAgICAgZGF0YS5jaGFyc1tjaGFyQ29kZV0gPSB7XG4gICAgICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneG9mZnNldCcpLCAxMCksXG4gICAgICAgICAgICB5T2Zmc2V0OiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneW9mZnNldCcpLCAxMCksXG4gICAgICAgICAgICB4QWR2YW5jZTogcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3hhZHZhbmNlJyksIDEwKSxcbiAgICAgICAgICAgIGtlcm5pbmc6IHt9LFxuICAgICAgICAgICAgdGV4dHVyZTogbmV3IGNvcmUuVGV4dHVyZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlUmVjdClcblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vcGFyc2Uga2VybmluZ3NcbiAgICB2YXIga2VybmluZ3MgPSByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdrZXJuaW5nJyk7XG4gICAgZm9yIChpID0gMDsgaSA8IGtlcm5pbmdzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZ3NbaV0uZ2V0QXR0cmlidXRlKCdmaXJzdCcpLCAxMCk7XG4gICAgICAgIHZhciBzZWNvbmQgPSBwYXJzZUludChrZXJuaW5nc1tpXS5nZXRBdHRyaWJ1dGUoJ3NlY29uZCcpLCAxMCk7XG4gICAgICAgIHZhciBhbW91bnQgPSBwYXJzZUludChrZXJuaW5nc1tpXS5nZXRBdHRyaWJ1dGUoJ2Ftb3VudCcpLCAxMCk7XG5cbiAgICAgICAgaWYoZGF0YS5jaGFyc1tzZWNvbmRdKVxuICAgICAgICB7XG4gICAgICAgICAgICBkYXRhLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNvdXJjZS5iaXRtYXBGb250ID0gZGF0YTtcblxuICAgIC8vIEknbSBsZWF2aW5nIHRoaXMgYXMgYSB0ZW1wb3JhcnkgZml4IHNvIHdlIGNhbiB0ZXN0IHRoZSBiaXRtYXAgZm9udHMgaW4gdjNcbiAgICAvLyBidXQgaXQncyB2ZXJ5IGxpa2VseSB0byBjaGFuZ2VcbiAgICBleHRyYXMuQml0bWFwVGV4dC5mb250c1tkYXRhLmZvbnRdID0gZGF0YTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvdXJjZSwgbmV4dClcbiAgICB7XG4gICAgICAgIC8vIHNraXAgaWYgbm8gZGF0YSBvciBub3QgeG1sIGRhdGFcbiAgICAgICAgaWYgKCFyZXNvdXJjZS5kYXRhIHx8ICFyZXNvdXJjZS5pc1htbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraXAgaWYgbm90IGJpdG1hcCBmb250IGRhdGEsIHVzaW5nIHNvbWUgc2lsbHkgZHVjay10eXBpbmdcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFnZScpLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdLmdldEF0dHJpYnV0ZSgnZmFjZScpID09PSBudWxsXG4gICAgICAgICAgICApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeG1sVXJsID0gcGF0aC5kaXJuYW1lKHJlc291cmNlLnVybCk7XG5cbiAgICAgICAgaWYgKHhtbFVybCA9PT0gJy4nKSB7XG4gICAgICAgICAgICB4bWxVcmwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJhc2VVcmwgJiYgeG1sVXJsKSB7XG4gICAgICAgICAgICAvLyBpZiBiYXNldXJsIGhhcyBhIHRyYWlsaW5nIHNsYXNoIHRoZW4gYWRkIG9uZSB0byB4bWxVcmwgc28gdGhlIHJlcGxhY2Ugd29ya3MgYmVsb3dcbiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VVcmwuY2hhckF0KHRoaXMuYmFzZVVybC5sZW5ndGggLSAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgeG1sVXJsICs9ICcvJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGJhc2VVcmwgZnJvbSB4bWxVcmxcbiAgICAgICAgICAgIHhtbFVybCA9IHhtbFVybC5yZXBsYWNlKHRoaXMuYmFzZVVybCwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4geG1sVXJsIG5vdywgaXQgbmVlZHMgYSB0cmFpbGluZyBzbGFzaC4gRW5zdXJlIHRoYXQgaXQgZG9lcyBpZiB0aGUgc3RyaW5nIGlzbid0IGVtcHR5LlxuICAgICAgICBpZiAoeG1sVXJsICYmIHhtbFVybC5jaGFyQXQoeG1sVXJsLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgICAgICAgIHhtbFVybCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHR1cmVVcmwgPSB4bWxVcmwgKyByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJylbMF0uZ2V0QXR0cmlidXRlKCdmaWxlJyk7XG4gICAgICAgIGlmIChjb3JlLnV0aWxzLlRleHR1cmVDYWNoZVt0ZXh0dXJlVXJsXSkge1xuICAgICAgICAgICAgLy9yZXVzZSBleGlzdGluZyB0ZXh0dXJlXG4gICAgICAgICAgICBwYXJzZShyZXNvdXJjZSwgY29yZS51dGlscy5UZXh0dXJlQ2FjaGVbdGV4dHVyZVVybF0pO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiByZXNvdXJjZS5jcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgICBsb2FkVHlwZTogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByZXNvdXJjZS5tZXRhZGF0YS5pbWFnZU1ldGFkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbG9hZCB0aGUgdGV4dHVyZSBmb3IgdGhlIGZvbnRcbiAgICAgICAgICAgIHRoaXMuYWRkKHJlc291cmNlLm5hbWUgKyAnX2ltYWdlJywgdGV4dHVyZVVybCwgbG9hZE9wdGlvbnMsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICBwYXJzZShyZXNvdXJjZSwgcmVzLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2xvYWRlcnMvYml0bWFwRm9udFBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIGV4dHJhcyBsaWJyYXJ5XG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkubWVzaFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBNZXNoOiAgICAgICAgICAgcmVxdWlyZSgnLi9NZXNoJyksXG4gICAgUGxhbmU6ICAgICAgICAgICByZXF1aXJlKCcuL1BsYW5lJyksXG4gICAgUm9wZTogICAgICAgICAgIHJlcXVpcmUoJy4vUm9wZScpLFxuICAgIE1lc2hSZW5kZXJlcjogICByZXF1aXJlKCcuL3dlYmdsL01lc2hSZW5kZXJlcicpLFxuICAgIE1lc2hTaGFkZXI6ICAgICByZXF1aXJlKCcuL3dlYmdsL01lc2hTaGFkZXInKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvbWVzaC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpLFxuICAgIHRlbXBQb2ludCA9IG5ldyBjb3JlLlBvaW50KCksXG4gICAgdGVtcFBvbHlnb24gPSBuZXcgY29yZS5Qb2x5Z29uKCk7XG5cbi8qKlxuICogQmFzZSBtZXNoIGNsYXNzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuQ29udGFpbmVyXG4gKiBAbWVtYmVyb2YgUElYSS5tZXNoXG4gKiBAcGFyYW0gdGV4dHVyZSB7UElYSS5UZXh0dXJlfSBUaGUgdGV4dHVyZSB0byB1c2VcbiAqIEBwYXJhbSBbdmVydGljZXNdIHtGbG9hdDMyQXJyYXl9IGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIHZlcnRpY2VzXG4gKiBAcGFyYW0gW3V2c10ge0Zsb2F0MzJBcnJheX0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgdXZzXG4gKiBAcGFyYW0gW2luZGljZXNdIHtVaW50MTZBcnJheX0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgaW5kaWNlc1xuICogQHBhcmFtIFtkcmF3TW9kZV0ge251bWJlcn0gdGhlIGRyYXdNb2RlLCBjYW4gYmUgYW55IG9mIHRoZSBNZXNoLkRSQVdfTU9ERVMgY29uc3RzXG4gKi9cbmZ1bmN0aW9uIE1lc2godGV4dHVyZSwgdmVydGljZXMsIHV2cywgaW5kaWNlcywgZHJhd01vZGUpXG57XG4gICAgY29yZS5Db250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIG9mIHRoZSBNZXNoXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBVdnMgb2YgdGhlIE1lc2hcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnV2cyA9IHV2cyB8fCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLFxuICAgICAgICAxLCAwLFxuICAgICAgICAxLCAxLFxuICAgICAgICAwLCAxXSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB2ZXJ0aWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcyB8fCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLFxuICAgICAgICAxMDAsIDAsXG4gICAgICAgIDEwMCwgMTAwLFxuICAgICAgICAwLCAxMDBdKTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gICAgICovXG4gICAgLy8gIFRPRE8gYXV0byBnZW5lcmF0ZSB0aGlzIGJhc2VkIG9uIGRyYXcgbW9kZSFcbiAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzIHx8IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMywgMl0pO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgTWVzaCBpcyBkaXJ0eSBvciBub3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFNldCB0byBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlbW92ZSBhbnkgYmxlbmQgbW9kZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlID0gY29yZS5CTEVORF9NT0RFUy5OT1JNQUw7XG5cbiAgICAvKipcbiAgICAgKiBUcmlhbmdsZXMgaW4gY2FudmFzIG1vZGUgYXJlIGF1dG9tYXRpY2FsbHkgYW50aWFsaWFzZWQsIHVzZSB0aGlzIHZhbHVlIHRvIGZvcmNlIHRyaWFuZ2xlcyB0byBvdmVybGFwIGEgYml0IHdpdGggZWFjaCBvdGhlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc1BhZGRpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdheSB0aGUgTWVzaCBzaG91bGQgYmUgZHJhd24sIGNhbiBiZSBhbnkgb2YgdGhlIHtAbGluayBQSVhJLm1lc2guTWVzaC5EUkFXX01PREVTfSBjb25zdHNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAc2VlIFBJWEkubWVzaC5NZXNoLkRSQVdfTU9ERVNcbiAgICAgKi9cbiAgICB0aGlzLmRyYXdNb2RlID0gZHJhd01vZGUgfHwgTWVzaC5EUkFXX01PREVTLlRSSUFOR0xFX01FU0g7XG5cbiAgICAvLyBydW4gdGV4dHVyZSBzZXR0ZXI7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzaGFkZXIgdGhhdCBpcyB1c2VkIGlmIGEgbWVzaCBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbn1cblxuLy8gY29uc3RydWN0b3Jcbk1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkNvbnRhaW5lci5wcm90b3R5cGUpO1xuTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNZXNoLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICAgICAqIEBtZW1iZXJvZiBQSVhJLm1lc2guTWVzaCNcbiAgICAgKi9cbiAgICB0ZXh0dXJlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUgPT09IHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIHRleHR1cmUgdG8gbG9hZFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUub25jZSgndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtQSVhJLldlYkdMUmVuZGVyZXJ9IGEgcmVmZXJlbmNlIHRvIHRoZSBXZWJHTCByZW5kZXJlclxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIHJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnMubWVzaCk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5tZXNoLnJlbmRlcih0aGlzKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuQ2FudmFzUmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIHZhciByZXMgPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuXG4gICAgaWYgKHJlbmRlcmVyLnJvdW5kUGl4ZWxzKVxuICAgIHtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEgKiByZXMsIHRyYW5zZm9ybS5iICogcmVzLCB0cmFuc2Zvcm0uYyAqIHJlcywgdHJhbnNmb3JtLmQgKiByZXMsICh0cmFuc2Zvcm0udHggKiByZXMpIHwgMCwgKHRyYW5zZm9ybS50eSAqIHJlcykgfCAwKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEgKiByZXMsIHRyYW5zZm9ybS5iICogcmVzLCB0cmFuc2Zvcm0uYyAqIHJlcywgdHJhbnNmb3JtLmQgKiByZXMsIHRyYW5zZm9ybS50eCAqIHJlcywgdHJhbnNmb3JtLnR5ICogcmVzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kcmF3TW9kZSA9PT0gTWVzaC5EUkFXX01PREVTLlRSSUFOR0xFX01FU0gpXG4gICAge1xuICAgICAgICB0aGlzLl9yZW5kZXJDYW52YXNUcmlhbmdsZU1lc2goY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNhbnZhc1RyaWFuZ2xlcyhjb250ZXh0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERyYXdzIHRoZSBvYmplY3QgaW4gVHJpYW5nbGUgTWVzaCBtb2RlIHVzaW5nIGNhbnZhc1xuICpcbiAqIEBwYXJhbSBjb250ZXh0IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IHRoZSBjdXJyZW50IGRyYXdpbmcgY29udGV4dFxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuX3JlbmRlckNhbnZhc1RyaWFuZ2xlTWVzaCA9IGZ1bmN0aW9uIChjb250ZXh0KVxue1xuICAgIC8vIGRyYXcgdHJpYW5nbGVzISFcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciB1dnMgPSB0aGlzLnV2cztcblxuICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGggLyAyO1xuICAgIC8vIHRoaXMuY291bnQrKztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMjsgaSsrKVxuICAgIHtcbiAgICAgICAgLy8gZHJhdyBzb21lIHRyaWFuZ2xlcyFcbiAgICAgICAgdmFyIGluZGV4ID0gaSAqIDI7XG4gICAgICAgIHRoaXMuX3JlbmRlckNhbnZhc0RyYXdUcmlhbmdsZShjb250ZXh0LCB2ZXJ0aWNlcywgdXZzLCBpbmRleCwgKGluZGV4ICsgMiksIChpbmRleCArIDQpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERyYXdzIHRoZSBvYmplY3QgaW4gdHJpYW5nbGUgbW9kZSB1c2luZyBjYW52YXNcbiAqXG4gKiBAcGFyYW0gY29udGV4dCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSB0aGUgY3VycmVudCBkcmF3aW5nIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKi9cbk1lc2gucHJvdG90eXBlLl9yZW5kZXJDYW52YXNUcmlhbmdsZXMgPSBmdW5jdGlvbiAoY29udGV4dClcbntcbiAgICAvLyBkcmF3IHRyaWFuZ2xlcyEhXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICB2YXIgdXZzID0gdGhpcy51dnM7XG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgLy8gdGhpcy5jb3VudCsrO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMylcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgc29tZSB0cmlhbmdsZXMhXG4gICAgICAgIHZhciBpbmRleDAgPSBpbmRpY2VzW2ldICogMiwgaW5kZXgxID0gaW5kaWNlc1tpICsgMV0gKiAyLCBpbmRleDIgPSBpbmRpY2VzW2kgKyAyXSAqIDI7XG4gICAgICAgIHRoaXMuX3JlbmRlckNhbnZhc0RyYXdUcmlhbmdsZShjb250ZXh0LCB2ZXJ0aWNlcywgdXZzLCBpbmRleDAsIGluZGV4MSwgaW5kZXgyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERyYXdzIG9uZSBvZiB0aGUgdHJpYW5nbGVzIHRoYXQgZm9ybSB0aGlzIE1lc2hcbiAqXG4gKiBAcGFyYW0gY29udGV4dCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSB0aGUgY3VycmVudCBkcmF3aW5nIGNvbnRleHRcbiAqIEBwYXJhbSB2ZXJ0aWNlcyB7RmxvYXQzMkFycmF5fSBhIHJlZmVyZW5jZSB0byB0aGUgdmVydGljZXMgb2YgdGhlIE1lc2hcbiAqIEBwYXJhbSB1dnMge0Zsb2F0MzJBcnJheX0gYSByZWZlcmVuY2UgdG8gdGhlIHV2cyBvZiB0aGUgTWVzaFxuICogQHBhcmFtIGluZGV4MCB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHZlcnRleFxuICogQHBhcmFtIGluZGV4MSB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHNlY29uZCB2ZXJ0ZXhcbiAqIEBwYXJhbSBpbmRleDIge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSB0aGlyZCB2ZXJ0ZXhcbiAqIEBwcml2YXRlXG4gKi9cbk1lc2gucHJvdG90eXBlLl9yZW5kZXJDYW52YXNEcmF3VHJpYW5nbGUgPSBmdW5jdGlvbiAoY29udGV4dCwgdmVydGljZXMsIHV2cywgaW5kZXgwLCBpbmRleDEsIGluZGV4MilcbntcbiAgICB2YXIgYmFzZSA9IHRoaXMuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdmFyIHRleHR1cmVTb3VyY2UgPSBiYXNlLnNvdXJjZTtcbiAgICB2YXIgdGV4dHVyZVdpZHRoID0gYmFzZS53aWR0aDtcbiAgICB2YXIgdGV4dHVyZUhlaWdodCA9IGJhc2UuaGVpZ2h0O1xuXG4gICAgdmFyIHgwID0gdmVydGljZXNbaW5kZXgwXSwgeDEgPSB2ZXJ0aWNlc1tpbmRleDFdLCB4MiA9IHZlcnRpY2VzW2luZGV4Ml07XG4gICAgdmFyIHkwID0gdmVydGljZXNbaW5kZXgwICsgMV0sIHkxID0gdmVydGljZXNbaW5kZXgxICsgMV0sIHkyID0gdmVydGljZXNbaW5kZXgyICsgMV07XG5cbiAgICB2YXIgdTAgPSB1dnNbaW5kZXgwXSAqIGJhc2Uud2lkdGgsIHUxID0gdXZzW2luZGV4MV0gKiBiYXNlLndpZHRoLCB1MiA9IHV2c1tpbmRleDJdICogYmFzZS53aWR0aDtcbiAgICB2YXIgdjAgPSB1dnNbaW5kZXgwICsgMV0gKiBiYXNlLmhlaWdodCwgdjEgPSB1dnNbaW5kZXgxICsgMV0gKiBiYXNlLmhlaWdodCwgdjIgPSB1dnNbaW5kZXgyICsgMV0gKiBiYXNlLmhlaWdodDtcblxuICAgIGlmICh0aGlzLmNhbnZhc1BhZGRpbmcgPiAwKVxuICAgIHtcbiAgICAgICAgdmFyIHBhZGRpbmdYID0gdGhpcy5jYW52YXNQYWRkaW5nIC8gdGhpcy53b3JsZFRyYW5zZm9ybS5hO1xuICAgICAgICB2YXIgcGFkZGluZ1kgPSB0aGlzLmNhbnZhc1BhZGRpbmcgLyB0aGlzLndvcmxkVHJhbnNmb3JtLmQ7XG4gICAgICAgIHZhciBjZW50ZXJYID0gKHgwICsgeDEgKyB4MikgLyAzO1xuICAgICAgICB2YXIgY2VudGVyWSA9ICh5MCArIHkxICsgeTIpIC8gMztcblxuICAgICAgICB2YXIgbm9ybVggPSB4MCAtIGNlbnRlclg7XG4gICAgICAgIHZhciBub3JtWSA9IHkwIC0gY2VudGVyWTtcblxuICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydChub3JtWCAqIG5vcm1YICsgbm9ybVkgKiBub3JtWSk7XG4gICAgICAgIHgwID0gY2VudGVyWCArIChub3JtWCAvIGRpc3QpICogKGRpc3QgKyBwYWRkaW5nWCk7XG4gICAgICAgIHkwID0gY2VudGVyWSArIChub3JtWSAvIGRpc3QpICogKGRpc3QgKyBwYWRkaW5nWSk7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBub3JtWCA9IHgxIC0gY2VudGVyWDtcbiAgICAgICAgbm9ybVkgPSB5MSAtIGNlbnRlclk7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChub3JtWCAqIG5vcm1YICsgbm9ybVkgKiBub3JtWSk7XG4gICAgICAgIHgxID0gY2VudGVyWCArIChub3JtWCAvIGRpc3QpICogKGRpc3QgKyBwYWRkaW5nWCk7XG4gICAgICAgIHkxID0gY2VudGVyWSArIChub3JtWSAvIGRpc3QpICogKGRpc3QgKyBwYWRkaW5nWSk7XG5cbiAgICAgICAgbm9ybVggPSB4MiAtIGNlbnRlclg7XG4gICAgICAgIG5vcm1ZID0geTIgLSBjZW50ZXJZO1xuXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQobm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkpO1xuICAgICAgICB4MiA9IGNlbnRlclggKyAobm9ybVggLyBkaXN0KSAqIChkaXN0ICsgcGFkZGluZ1gpO1xuICAgICAgICB5MiA9IGNlbnRlclkgKyAobm9ybVkgLyBkaXN0KSAqIChkaXN0ICsgcGFkZGluZ1kpO1xuICAgIH1cblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblxuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGNvbnRleHQuY2xpcCgpO1xuXG4gICAgLy8gQ29tcHV0ZSBtYXRyaXggdHJhbnNmb3JtXG4gICAgdmFyIGRlbHRhID0gICh1MCAqIHYxKSAgICAgICsgKHYwICogdTIpICAgICAgKyAodTEgKiB2MikgICAgICAtICh2MSAqIHUyKSAgICAgIC0gKHYwICogdTEpICAgICAgLSAodTAgKiB2Mik7XG4gICAgdmFyIGRlbHRhQSA9ICh4MCAqIHYxKSAgICAgICsgKHYwICogeDIpICAgICAgKyAoeDEgKiB2MikgICAgICAtICh2MSAqIHgyKSAgICAgIC0gKHYwICogeDEpICAgICAgLSAoeDAgKiB2Mik7XG4gICAgdmFyIGRlbHRhQiA9ICh1MCAqIHgxKSAgICAgICsgKHgwICogdTIpICAgICAgKyAodTEgKiB4MikgICAgICAtICh4MSAqIHUyKSAgICAgIC0gKHgwICogdTEpICAgICAgLSAodTAgKiB4Mik7XG4gICAgdmFyIGRlbHRhQyA9ICh1MCAqIHYxICogeDIpICsgKHYwICogeDEgKiB1MikgKyAoeDAgKiB1MSAqIHYyKSAtICh4MCAqIHYxICogdTIpIC0gKHYwICogdTEgKiB4MikgLSAodTAgKiB4MSAqIHYyKTtcbiAgICB2YXIgZGVsdGFEID0gKHkwICogdjEpICAgICAgKyAodjAgKiB5MikgICAgICArICh5MSAqIHYyKSAgICAgIC0gKHYxICogeTIpICAgICAgLSAodjAgKiB5MSkgICAgICAtICh5MCAqIHYyKTtcbiAgICB2YXIgZGVsdGFFID0gKHUwICogeTEpICAgICAgKyAoeTAgKiB1MikgICAgICArICh1MSAqIHkyKSAgICAgIC0gKHkxICogdTIpICAgICAgLSAoeTAgKiB1MSkgICAgICAtICh1MCAqIHkyKTtcbiAgICB2YXIgZGVsdGFGID0gKHUwICogdjEgKiB5MikgKyAodjAgKiB5MSAqIHUyKSArICh5MCAqIHUxICogdjIpIC0gKHkwICogdjEgKiB1MikgLSAodjAgKiB1MSAqIHkyKSAtICh1MCAqIHkxICogdjIpO1xuXG4gICAgY29udGV4dC50cmFuc2Zvcm0oZGVsdGFBIC8gZGVsdGEsIGRlbHRhRCAvIGRlbHRhLFxuICAgICAgICBkZWx0YUIgLyBkZWx0YSwgZGVsdGFFIC8gZGVsdGEsXG4gICAgICAgIGRlbHRhQyAvIGRlbHRhLCBkZWx0YUYgLyBkZWx0YSk7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlU291cmNlLCAwLCAwLCB0ZXh0dXJlV2lkdGggKiBiYXNlLnJlc29sdXRpb24sIHRleHR1cmVIZWlnaHQgKiBiYXNlLnJlc29sdXRpb24sIDAsIDAsIHRleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodCk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG59O1xuXG5cblxuLyoqXG4gKiBSZW5kZXJzIGEgZmxhdCBNZXNoXG4gKlxuICogQHBhcmFtIE1lc2gge1BJWEkubWVzaC5NZXNofSBUaGUgTWVzaCB0byByZW5kZXJcbiAqIEBwcml2YXRlXG4gKi9cbk1lc2gucHJvdG90eXBlLnJlbmRlck1lc2hGbGF0ID0gZnVuY3Rpb24gKE1lc2gpXG57XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgdmFyIHZlcnRpY2VzID0gTWVzaC52ZXJ0aWNlcztcblxuICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGgvMjtcbiAgICAvLyB0aGlzLmNvdW50Kys7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGZvciAodmFyIGk9MTsgaSA8IGxlbmd0aC0yOyBpKyspXG4gICAge1xuICAgICAgICAvLyBkcmF3IHNvbWUgdHJpYW5nbGVzIVxuICAgICAgICB2YXIgaW5kZXggPSBpKjI7XG5cbiAgICAgICAgdmFyIHgwID0gdmVydGljZXNbaW5kZXhdLCAgIHgxID0gdmVydGljZXNbaW5kZXgrMl0sIHgyID0gdmVydGljZXNbaW5kZXgrNF07XG4gICAgICAgIHZhciB5MCA9IHZlcnRpY2VzW2luZGV4KzFdLCB5MSA9IHZlcnRpY2VzW2luZGV4KzNdLCB5MiA9IHZlcnRpY2VzW2luZGV4KzVdO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgfVxuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnI0ZGMDAwMCc7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICpcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgbWVzaCBhcyBhIHJlY3RhbmdsZS4gVGhlIGJvdW5kcyBjYWxjdWxhdGlvbiB0YWtlcyB0aGUgd29ybGRUcmFuc2Zvcm0gaW50byBhY2NvdW50LlxuICpcbiAqIEBwYXJhbSBtYXRyaXgge1BJWEkuTWF0cml4fSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBzcHJpdGVcbiAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKG1hdHJpeClcbntcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRCb3VuZHMpIHtcbiAgICAgICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gbWF0cml4IHx8IHRoaXMud29ybGRUcmFuc2Zvcm07XG5cbiAgICAgICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xuICAgICAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmI7XG4gICAgICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYztcbiAgICAgICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xuICAgICAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcbiAgICAgICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7XG5cbiAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciByYXdYID0gdmVydGljZXNbaV0sIHJhd1kgPSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICAgICAgICB2YXIgeCA9IChhICogcmF3WCkgKyAoYyAqIHJhd1kpICsgdHg7XG4gICAgICAgICAgICB2YXIgeSA9IChkICogcmF3WSkgKyAoYiAqIHJhd1gpICsgdHk7XG5cbiAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG5cbiAgICAgICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWCA9PT0gLUluZmluaXR5IHx8IG1heFkgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5SZWN0YW5nbGUuRU1QVFk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICAgICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG5cbiAgICAgICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgICAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAgICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJvdW5kcztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBtZXNoLiBXb3JrcyBvbmx5IGZvciBUUklBTkdMRV9NRVNIXG4gKlxuICogQHBhcmFtIHBvaW50IHtQSVhJLlBvaW50fSB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxuICovXG5NZXNoLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24oIHBvaW50ICkge1xuICAgIGlmICghdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCAgdGVtcFBvaW50KTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIHBvaW50cyA9IHRlbXBQb2x5Z29uLnBvaW50cztcbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgaWYgKHRoaXMuZHJhd01vZGUgPT09IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRVMpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIGxlbiA9IHRoaXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIC8vVE9ETzogaW5saW5lIHRoaXMuXG4gICAgICAgIGZvciAoaT0wO2k8bGVuO2krPTMpIHtcbiAgICAgICAgICAgIHZhciBpbmQwID0gaW5kaWNlc1tpXSoyLCBpbmQxID0gaW5kaWNlc1tpKzFdKjIsIGluZDIgPSBpbmRpY2VzW2krMl0qMjtcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHZlcnRpY2VzW2luZDBdO1xuICAgICAgICAgICAgcG9pbnRzWzFdID0gdmVydGljZXNbaW5kMCsxXTtcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHZlcnRpY2VzW2luZDFdO1xuICAgICAgICAgICAgcG9pbnRzWzNdID0gdmVydGljZXNbaW5kMSsxXTtcbiAgICAgICAgICAgIHBvaW50c1s0XSA9IHZlcnRpY2VzW2luZDJdO1xuICAgICAgICAgICAgcG9pbnRzWzVdID0gdmVydGljZXNbaW5kMisxXTtcbiAgICAgICAgICAgIGlmICh0ZW1wUG9seWdvbi5jb250YWlucyh0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaT0wO2k8bGVuO2krPTYpIHtcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgcG9pbnRzWzFdID0gdmVydGljZXNbaSsxXTtcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHZlcnRpY2VzW2krMl07XG4gICAgICAgICAgICBwb2ludHNbM10gPSB2ZXJ0aWNlc1tpKzNdO1xuICAgICAgICAgICAgcG9pbnRzWzRdID0gdmVydGljZXNbaSs0XTtcbiAgICAgICAgICAgIHBvaW50c1s1XSA9IHZlcnRpY2VzW2krNV07XG4gICAgICAgICAgICBpZiAodGVtcFBvbHlnb24uY29udGFpbnModGVtcFBvaW50LngsIHRlbXBQb2ludC55KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRGlmZmVyZW50IGRyYXdpbmcgYnVmZmVyIG1vZGVzIHN1cHBvcnRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IHtvYmplY3R9IERSQVdfTU9ERVNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFX01FU0hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFU1xuICovXG5NZXNoLkRSQVdfTU9ERVMgPSB7XG4gICAgVFJJQU5HTEVfTUVTSDogMCxcbiAgICBUUklBTkdMRVM6IDFcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL21lc2gvTWVzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNZXNoID0gcmVxdWlyZSgnLi9NZXNoJyk7XG5cbi8qKlxuICogVGhlIFBsYW5lIGFsbG93cyB5b3UgdG8gZHJhdyBhIHRleHR1cmUgYWNyb3NzIHNldmVyYWwgcG9pbnRzIGFuZCB0aGVtIG1hbmlwdWxhdGUgdGhlc2UgcG9pbnRzXG4gKlxuICpgYGBqc1xuICogZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gKiAgICAgcG9pbnRzLnB1c2gobmV3IFBJWEkuUG9pbnQoaSAqIDUwLCAwKSk7XG4gKiB9O1xuICogdmFyIFBsYW5lID0gbmV3IFBJWEkuUGxhbmUoUElYSS5UZXh0dXJlLmZyb21JbWFnZShcInNuYWtlLnBuZ1wiKSwgcG9pbnRzKTtcbiAqICBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkubWVzaC5NZXNoXG4gKiBAbWVtYmVyb2YgUElYSS5tZXNoXG4gKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIHVzZSBvbiB0aGUgUGxhbmUuXG4gKiBAcGFyYW0ge2ludH0gc2VnbWVudHNYIC0gVGhlIG51bWJlciBveCB4IHNlZ21lbnRzXG4gKiBAcGFyYW0ge2ludH0gc2VnbWVudHNZIC0gVGhlIG51bWJlciBvZiB5IHNlZ21lbnRzXG4gKlxuICovXG5mdW5jdGlvbiBQbGFuZSh0ZXh0dXJlLCBzZWdtZW50c1gsIHNlZ21lbnRzWSlcbntcbiAgICBNZXNoLmNhbGwodGhpcywgdGV4dHVyZSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFja2VyIGZvciBpZiB0aGUgUGxhbmUgaXMgcmVhZHkgdG8gYmUgZHJhd24uIE5lZWRlZCBiZWNhdXNlIE1lc2ggY3RvciBjYW5cbiAgICAgKiBjYWxsIF9vblRleHR1cmVVcGRhdGVkIHdoaWNoIGNvdWxkIGNhbGwgcmVmcmVzaCB0b28gZWFybHkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVhZHkgPSB0cnVlO1xuXG4gICAgdGhpcy5zZWdtZW50c1ggPSAgc2VnbWVudHNYIHx8IDEwO1xuICAgIHRoaXMuc2VnbWVudHNZID0gc2VnbWVudHNZIHx8IDEwO1xuXG4gICAgdGhpcy5kcmF3TW9kZSA9IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG5cbn1cblxuXG4vLyBjb25zdHJ1Y3RvclxuUGxhbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcblxuLyoqXG4gKiBSZWZyZXNoZXNcbiAqXG4gKi9cblBsYW5lLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciB0b3RhbCA9IHRoaXMuc2VnbWVudHNYICogdGhpcy5zZWdtZW50c1k7XG4gICAgdmFyIHZlcnRzID0gW107XG4gICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgIHZhciB1dnMgPSBbXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuXG4gIC8vICB0ZXh0dXJlLndpZHRoID0gODAwIHRleHR1cmUud2lkdGggfHwgODAwO1xuIC8vICAgdGV4dHVyZS5oZWlnaHQgPSA4MDAvL3RleHR1cmUuaGVpZ2h0IHx8IDgwMDtcblxuICAgIHZhciBzZWdtZW50c1hTdWIgPSB0aGlzLnNlZ21lbnRzWCAtIDE7XG4gICAgdmFyIHNlZ21lbnRzWVN1YiA9IHRoaXMuc2VnbWVudHNZIC0gMTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB2YXIgc2l6ZVggPSB0ZXh0dXJlLndpZHRoIC8gc2VnbWVudHNYU3ViO1xuICAgIHZhciBzaXplWSA9IHRleHR1cmUuaGVpZ2h0IC8gc2VnbWVudHNZU3ViO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcblxuICAgICAgICB2YXIgeCA9IChpICUgdGhpcy5zZWdtZW50c1gpO1xuICAgICAgICB2YXIgeSA9ICggKGkgLyB0aGlzLnNlZ21lbnRzWCApIHwgMCApO1xuXG5cbiAgICAgICAgdmVydHMucHVzaCgoeCAqIHNpemVYKSxcbiAgICAgICAgICAgICAgICAgICAoeSAqIHNpemVZKSk7XG5cbiAgICAgICAgLy8gdGhpcyB3b3JrcyBmb3IgcmVjdGFuZ3VsYXIgdGV4dHVyZXMuIFxuICAgICAgICB1dnMucHVzaCh0ZXh0dXJlLl91dnMueDAgKyAodGV4dHVyZS5fdXZzLngxIC0gdGV4dHVyZS5fdXZzLngwKSAqICh4IC8gKHRoaXMuc2VnbWVudHNYLTEpKSwgdGV4dHVyZS5fdXZzLnkwICsgKHRleHR1cmUuX3V2cy55My10ZXh0dXJlLl91dnMueTApICogKHkvICh0aGlzLnNlZ21lbnRzWS0xKSkpO1xuICAgICAgfVxuXG4gICAgLy8gIGNvbnNcblxuICAgIHZhciB0b3RhbFN1YiA9IHNlZ21lbnRzWFN1YiAqIHNlZ21lbnRzWVN1YjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbFN1YjsgaSsrKSB7XG5cbiAgICAgICAgdmFyIHhwb3MgPSBpICUgc2VnbWVudHNYU3ViO1xuICAgICAgICB2YXIgeXBvcyA9IChpIC8gc2VnbWVudHNYU3ViICkgfCAwO1xuXG5cbiAgICAgICAgdmFyICB2YWx1ZSA9ICh5cG9zICogdGhpcy5zZWdtZW50c1gpICsgeHBvcztcbiAgICAgICAgdmFyICB2YWx1ZTIgPSAoeXBvcyAqIHRoaXMuc2VnbWVudHNYKSArIHhwb3MgKyAxO1xuICAgICAgICB2YXIgIHZhbHVlMyA9ICgoeXBvcysxKSAqIHRoaXMuc2VnbWVudHNYKSArIHhwb3M7XG4gICAgICAgIHZhciAgdmFsdWU0ID0gKCh5cG9zKzEpICogdGhpcy5zZWdtZW50c1gpICsgeHBvcyArIDE7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZhbHVlLCB2YWx1ZTIsIHZhbHVlMyk7XG4gICAgICAgIGluZGljZXMucHVzaCh2YWx1ZTIsIHZhbHVlNCwgdmFsdWUzKTtcbiAgICB9XG5cblxuICAgIC8vY29uc29sZS5sb2coaW5kaWNlcylcbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0cyk7XG4gICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KHV2cyk7XG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KGNvbG9ycyk7XG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KGluZGljZXMpO1xufTtcblxuLyoqXG4gKiBDbGVhciB0ZXh0dXJlIFVWcyB3aGVuIG5ldyB0ZXh0dXJlIGlzIHNldFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblBsYW5lLnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24gKClcbntcbiAgICBNZXNoLnByb3RvdHlwZS5fb25UZXh0dXJlVXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAvLyB3YWl0IGZvciB0aGUgUGxhbmUgY3RvciB0byBmaW5pc2ggYmVmb3JlIGNhbGxpbmcgcmVmcmVzaFxuICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9tZXNoL1BsYW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1lc2ggPSByZXF1aXJlKCcuL01lc2gnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIFRoZSByb3BlIGFsbG93cyB5b3UgdG8gZHJhdyBhIHRleHR1cmUgYWNyb3NzIHNldmVyYWwgcG9pbnRzIGFuZCB0aGVtIG1hbmlwdWxhdGUgdGhlc2UgcG9pbnRzXG4gKlxuICpgYGBqc1xuICogZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gKiAgICAgcG9pbnRzLnB1c2gobmV3IFBJWEkuUG9pbnQoaSAqIDUwLCAwKSk7XG4gKiB9O1xuICogdmFyIHJvcGUgPSBuZXcgUElYSS5Sb3BlKFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoXCJzbmFrZS5wbmdcIiksIHBvaW50cyk7XG4gKiAgYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQSVhJLm1lc2guTWVzaFxuICogQG1lbWJlcm9mIFBJWEkubWVzaFxuICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byB1c2Ugb24gdGhlIHJvcGUuXG4gKiBAcGFyYW0ge1BJWEkuUG9pbnRbXX0gcG9pbnRzIC0gQW4gYXJyYXkgb2Yge0BsaW5rIFBJWEkuUG9pbnR9IG9iamVjdHMgdG8gY29uc3RydWN0IHRoaXMgcm9wZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIFJvcGUodGV4dHVyZSwgcG9pbnRzKVxue1xuICAgIE1lc2guY2FsbCh0aGlzLCB0ZXh0dXJlKTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfSBBbiBhcnJheSBvZiBwb2ludHMgdGhhdCBkZXRlcm1pbmUgdGhlIHJvcGVcbiAgICAgKi9cbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fSBBbiBhcnJheSBvZiB2ZXJ0aWNlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGlzIHJvcGUuXG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9IFRoZSBXZWJHTCBVdnMgb2YgdGhlIHJvcGUuXG4gICAgICovXG4gICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBjb2xvciBjb21wb25lbnRzXG4gICAgICovXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrZXIgZm9yIGlmIHRoZSByb3BlIGlzIHJlYWR5IHRvIGJlIGRyYXduLiBOZWVkZWQgYmVjYXVzZSBNZXNoIGN0b3IgY2FuXG4gICAgICogY2FsbCBfb25UZXh0dXJlVXBkYXRlZCB3aGljaCBjb3VsZCBjYWxsIHJlZnJlc2ggdG9vIGVhcmx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICB0aGlzLl9yZWFkeSA9IHRydWU7XG5cbiAgICAgdGhpcy5yZWZyZXNoKCk7XG59XG5cblxuLy8gY29uc3RydWN0b3JcblJvcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNZXNoLnByb3RvdHlwZSk7XG5Sb3BlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvcGU7XG5tb2R1bGUuZXhwb3J0cyA9IFJvcGU7XG5cbi8qKlxuICogUmVmcmVzaGVzXG4gKlxuICovXG5Sb3BlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICAvLyBpZiB0b28gbGl0dGxlIHBvaW50cywgb3IgdGV4dHVyZSBoYXNuJ3QgZ290IFVWcyBzZXQgeWV0IGp1c3QgbW92ZSBvbi5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEgfHwgIXRoaXMuX3RleHR1cmUuX3V2cylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXZzID0gdGhpcy51dnM7XG5cbiAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgICB2YXIgY29sb3JzID0gdGhpcy5jb2xvcnM7XG5cbiAgICB2YXIgdGV4dHVyZVV2cyA9IHRoaXMuX3RleHR1cmUuX3V2cztcbiAgICB2YXIgb2Zmc2V0ID0gbmV3IGNvcmUuUG9pbnQodGV4dHVyZVV2cy54MCwgdGV4dHVyZVV2cy55MCk7XG4gICAgdmFyIGZhY3RvciA9IG5ldyBjb3JlLlBvaW50KHRleHR1cmVVdnMueDIgLSB0ZXh0dXJlVXZzLngwLCB0ZXh0dXJlVXZzLnkyIC0gdGV4dHVyZVV2cy55MCk7XG5cbiAgICB1dnNbMF0gPSAwICsgb2Zmc2V0Lng7XG4gICAgdXZzWzFdID0gMCArIG9mZnNldC55O1xuICAgIHV2c1syXSA9IDAgKyBvZmZzZXQueDtcbiAgICB1dnNbM10gPSAxICogZmFjdG9yLnkgKyBvZmZzZXQueTtcblxuICAgIGNvbG9yc1swXSA9IDE7XG4gICAgY29sb3JzWzFdID0gMTtcblxuICAgIGluZGljZXNbMF0gPSAwO1xuICAgIGluZGljZXNbMV0gPSAxO1xuXG4gICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgcG9pbnQsIGluZGV4LCBhbW91bnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRvdGFsOyBpKyspXG4gICAge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgaW5kZXggPSBpICogNDtcbiAgICAgICAgLy8gdGltZSB0byBkbyBzb21lIHNtYXJ0IGRyYXdpbmchXG4gICAgICAgIGFtb3VudCA9IGkgLyAodG90YWwtMSk7XG5cbiAgICAgICAgdXZzW2luZGV4XSA9IGFtb3VudCAqIGZhY3Rvci54ICsgb2Zmc2V0Lng7XG4gICAgICAgIHV2c1tpbmRleCsxXSA9IDAgKyBvZmZzZXQueTtcblxuICAgICAgICB1dnNbaW5kZXgrMl0gPSBhbW91bnQgKiBmYWN0b3IueCArIG9mZnNldC54O1xuICAgICAgICB1dnNbaW5kZXgrM10gPSAxICogZmFjdG9yLnkgKyBvZmZzZXQueTtcblxuICAgICAgICBpbmRleCA9IGkgKiAyO1xuICAgICAgICBjb2xvcnNbaW5kZXhdID0gMTtcbiAgICAgICAgY29sb3JzW2luZGV4KzFdID0gMTtcblxuICAgICAgICBpbmRleCA9IGkgKiAyO1xuICAgICAgICBpbmRpY2VzW2luZGV4XSA9IGluZGV4O1xuICAgICAgICBpbmRpY2VzW2luZGV4ICsgMV0gPSBpbmRleCArIDE7XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vKipcbiAqIENsZWFyIHRleHR1cmUgVVZzIHdoZW4gbmV3IHRleHR1cmUgaXMgc2V0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuUm9wZS5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgTWVzaC5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gd2FpdCBmb3IgdGhlIFJvcGUgY3RvciB0byBmaW5pc2ggYmVmb3JlIGNhbGxpbmcgcmVmcmVzaFxuICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBwcml2YXRlXG4gKi9cblJvcGUucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgdmFyIG5leHRQb2ludDtcbiAgICB2YXIgcGVycFggPSAwO1xuICAgIHZhciBwZXJwWSA9IDA7XG5cbiAgICAvLyB0aGlzLmNvdW50IC09IDAuMjtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgcG9pbnQsIGluZGV4LCByYXRpbywgcGVycExlbmd0aCwgbnVtO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKVxuICAgIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGluZGV4ID0gaSAqIDQ7XG5cbiAgICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpKzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBwZXJwWSA9IC0obmV4dFBvaW50LnggLSBsYXN0UG9pbnQueCk7XG4gICAgICAgIHBlcnBYID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcblxuICAgICAgICByYXRpbyA9ICgxIC0gKGkgLyAodG90YWwtMSkpKSAqIDEwO1xuXG4gICAgICAgIGlmIChyYXRpbyA+IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJhdGlvID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBlcnBMZW5ndGggPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICAgICAgICBudW0gPSB0aGlzLl90ZXh0dXJlLmhlaWdodCAvIDI7IC8vKDIwICsgTWF0aC5hYnMoTWF0aC5zaW4oKGkgKyB0aGlzLmNvdW50KSAqIDAuMykgKiA1MCkgKSogcmF0aW87XG4gICAgICAgIHBlcnBYIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBZIC89IHBlcnBMZW5ndGg7XG5cbiAgICAgICAgcGVycFggKj0gbnVtO1xuICAgICAgICBwZXJwWSAqPSBudW07XG5cbiAgICAgICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYO1xuICAgICAgICB2ZXJ0aWNlc1tpbmRleCsxXSA9IHBvaW50LnkgKyBwZXJwWTtcbiAgICAgICAgdmVydGljZXNbaW5kZXgrMl0gPSBwb2ludC54IC0gcGVycFg7XG4gICAgICAgIHZlcnRpY2VzW2luZGV4KzNdID0gcG9pbnQueSAtIHBlcnBZO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgIH1cblxuICAgIHRoaXMuY29udGFpbmVyVXBkYXRlVHJhbnNmb3JtKCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9waXhpLmpzL3NyYy9tZXNoL1JvcGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKSxcbiAgICBNZXNoID0gcmVxdWlyZSgnLi4vTWVzaCcpO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXkgbm93IHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIE1lc2hSZW5kZXJlcjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvTWVzaFJlbmRlcmVyLmphdmFcbiAqL1xuXG4vKipcbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSS5tZXNoXG4gKiBAZXh0ZW5kcyBQSVhJLk9iamVjdFJlbmRlcmVyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1BJWEkuV2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gTWVzaFJlbmRlcmVyKHJlbmRlcmVyKVxue1xuICAgIGNvcmUuT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBpbmRpY2VzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgKi9cbiAgICBcbiAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoMTUwMDApO1xuXG4gICAgLy9UT0RPIHRoaXMgY291bGQgYmUgYSBzaW5nbGUgYnVmZmVyIHNoYXJlZCBhbW9uZ3N0IGFsbCByZW5kZXJlcnMgYXMgd2UgcmV1c2UgdGhpcyBzZXQgdXAgaW4gbW9zdCByZW5kZXJlcnNcbiAgICBmb3IgKHZhciBpPTAsIGo9MDsgaSA8IDE1MDAwOyBpICs9IDYsIGogKz0gNClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgM10gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gbnVsbDtcbn1cblxuTWVzaFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUpO1xuTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hSZW5kZXJlcjtcbm1vZHVsZS5leHBvcnRzID0gTWVzaFJlbmRlcmVyO1xuXG5jb3JlLldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ21lc2gnLCBNZXNoUmVuZGVyZXIpO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKi9cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcbntcblxufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzcHJpdGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtZXNoIHtQSVhJLm1lc2guTWVzaH0gdGhlIG1lc2ggdG8gcmVuZGVyXG4gKi9cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKG1lc2gpXG57XG4gICAgaWYoIW1lc2guX3ZlcnRleEJ1ZmZlcilcbiAgICB7XG4gICAgICAgIHRoaXMuX2luaXRXZWJHTChtZXNoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICBnbCA9IHJlbmRlcmVyLmdsLFxuICAgICAgICB0ZXh0dXJlID0gbWVzaC5fdGV4dHVyZS5iYXNlVGV4dHVyZSxcbiAgICAgICAgc2hhZGVyID0gbWVzaC5zaGFkZXI7Ly8gfHwgcmVuZGVyZXIuc2hhZGVyTWFuYWdlci5wbHVnaW5zLm1lc2hTaGFkZXI7XG5cbiAgICB2YXIgZHJhd01vZGUgPSBtZXNoLmRyYXdNb2RlID09PSBNZXNoLkRSQVdfTU9ERVMuVFJJQU5HTEVfTUVTSCA/IGdsLlRSSUFOR0xFX1NUUklQIDogZ2wuVFJJQU5HTEVTO1xuXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUobWVzaC5ibGVuZE1vZGUpO1xuXG4gICAgLy9UT0RPIGNhY2hlIGN1c3RvbSBzdGF0ZS4uXG4gICAgaWYgKCFzaGFkZXIpXG4gICAge1xuICAgICAgICBzaGFkZXIgPSByZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnBsdWdpbnMubWVzaFNoYWRlcjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgc2hhZGVyID0gc2hhZGVyLnNoYWRlcnNbZ2wuaWRdIHx8IHNoYWRlci5nZXRTaGFkZXIocmVuZGVyZXIpOy8vIDogc2hhZGVyO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcblxuICAgIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeC52YWx1ZSA9IG1lc2gud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKTtcbiAgICBzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZSA9IHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgIHNoYWRlci51bmlmb3Jtcy5hbHBoYS52YWx1ZSA9IG1lc2gud29ybGRBbHBoYTtcblxuICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoKTtcblxuICAgIGlmICghbWVzaC5kaXJ0eSlcbiAgICB7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX3ZlcnRleEJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBtZXNoLnZlcnRpY2VzKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB1dnNcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX3V2QnVmZmVyKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG5cbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAgICBpZiAoIXRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG1lc2guX2luZGV4QnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgMCwgbWVzaC5pbmRpY2VzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcblxuICAgICAgICBtZXNoLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLl92ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC52ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHV2c1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC5fdXZCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC51dnMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgICAgICBpZiAoIXRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbnQgbmVlZCB0byB1cGxvYWQhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG1lc2guX2luZGV4QnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbWVzaC5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICB9XG5cbiAgICBnbC5kcmF3RWxlbWVudHMoZHJhd01vZGUsIG1lc2guaW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcblxufTtcblxuLyoqXG4gKiBQcmVwYXJlcyBhbGwgdGhlIGJ1ZmZlcnMgdG8gcmVuZGVyIHRoaXMgbWVzaFxuICogQHBhcmFtIG1lc2gge1BJWEkubWVzaC5NZXNofSB0aGUgbWVzaCB0byByZW5kZXJcbiAqL1xuTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5faW5pdFdlYkdMID0gZnVuY3Rpb24gKG1lc2gpXG57XG4gICAgLy8gYnVpbGQgdGhlIHN0cmlwIVxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICBtZXNoLl92ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBtZXNoLl9pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIG1lc2guX3V2QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblxuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX3ZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG1lc2gudmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC5fdXZCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAgbWVzaC51dnMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIGlmKG1lc2guY29sb3JzKXtcbiAgICAgICAgbWVzaC5fY29sb3JCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX2NvbG9yQnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG1lc2guY29sb3JzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgfVxuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbWVzaC5faW5kZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG1lc2guaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xufTtcblxuXG4vKipcbiAqIEVtcHRpZXMgdGhlIGN1cnJlbnQgYmF0Y2guXG4gKlxuICovXG5NZXNoUmVuZGVyZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKClcbntcblxufTtcblxuLyoqXG4gKiBTdGFydHMgYSBuZXcgbWVzaCByZW5kZXJlci5cbiAqXG4gKi9cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIFxuXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIE1lc2ggcmVuZGVyZXJcbiAqXG4gKi9cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29yZS5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvbWVzaC93ZWJnbC9NZXNoUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBJWEkuU2hhZGVyXG4gKiBAbWVtYmVyb2YgUElYSS5tZXNoXG4gKiBAcGFyYW0gc2hhZGVyTWFuYWdlciB7UElYSS5TaGFkZXJNYW5hZ2VyfSBUaGUgV2ViR0wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBNZXNoU2hhZGVyKHNoYWRlck1hbmFnZXIpXG57XG4gICAgY29yZS5TaGFkZXIuY2FsbCh0aGlzLFxuICAgICAgICBzaGFkZXJNYW5hZ2VyLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFtcbiAgICAgICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OycsXG5cbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsnLFxuICAgICAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXG5cbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG5cbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcbiAgICAgICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogYWxwaGEgOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFscGhhOiAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogMCB9LFxuICAgICAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg5KSB9LFxuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDkpIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gY3VzdG9tIGF0dHJpYnV0ZXNcbiAgICAgICAge1xuICAgICAgICAgICAgYVZlcnRleFBvc2l0aW9uOjAsXG4gICAgICAgICAgICBhVGV4dHVyZUNvb3JkOjBcbiAgICAgICAgfVxuICAgICk7XG59XG5cbk1lc2hTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLlNoYWRlci5wcm90b3R5cGUpO1xuTWVzaFNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoU2hhZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNoU2hhZGVyO1xuXG5jb3JlLlNoYWRlck1hbmFnZXIucmVnaXN0ZXJQbHVnaW4oJ21lc2hTaGFkZXInLCBNZXNoU2hhZGVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvbWVzaC93ZWJnbC9NZXNoU2hhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgYWNjZXNzaWJpbGl0eSBsaWJyYXJ5XG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkuaW50ZXJhY3Rpb25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWNjZXNzaWJsZVRhcmdldDogICAgIHJlcXVpcmUoJy4vYWNjZXNzaWJsZVRhcmdldCcpLFxuICAgIEFjY2Vzc2liaWxpdHlNYW5hZ2VyOiByZXF1aXJlKCcuL0FjY2Vzc2liaWxpdHlNYW5hZ2VyJylcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2FjY2Vzc2liaWxpdHkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIERlZmF1bHQgcHJvcGVydHkgdmFsdWVzIG9mIGFjY2Vzc2libGUgb2JqZWN0c1xuICogdXNlZCBieSB7QGxpbmsgUElYSS5hY2Nlc3NpYmlsaXR5LkFjY2Vzc2liaWxpdHlNYW5hZ2VyfS5cbiAqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXhhbXBsZVxuICogICAgICBmdW5jdGlvbiBNeU9iamVjdCgpIHt9XG4gKlxuICogICAgICBPYmplY3QuYXNzaWduKFxuICogICAgICAgICAgTXlPYmplY3QucHJvdG90eXBlLFxuICogICAgICAgICAgUElYSS5hY2Nlc3NpYmlsaXR5LmFjY2Vzc2libGVUYXJnZXRcbiAqICAgICAgKTtcbiAqL1xudmFyIGFjY2Vzc2libGVUYXJnZXQgPSB7XG4gICAgXG4gICAgLyoqXG4gICAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICAgKi9cbiAgICBhY2Nlc3NpYmxlOmZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICAgKi9cbiAgICBhY2Nlc3NpYmxlVGl0bGU6bnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAgICovXG4gICAgdGFiSW5kZXg6MCxcblxuICAgIC8qKlxuICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXG4gICAgICovXG4gICAgX2FjY2Vzc2libGVBY3RpdmU6ZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAqL1xuICAgIF9hY2Nlc3NpYmxlRGl2OmZhbHNlXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjZXNzaWJsZVRhcmdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvYWNjZXNzaWJpbGl0eS9hY2Nlc3NpYmxlVGFyZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8vIGFkZCBzb21lIGV4dHJhIHZhcmlhYmxlcyB0byB0aGUgY29udGFpbmVyLi5cbk9iamVjdC5hc3NpZ24oXG4gICAgY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSxcbiAgICByZXF1aXJlKCcuL2FjY2Vzc2libGVUYXJnZXQnKVxuKTtcblxuXG4vKipcbiAqIFRoZSBBY2Nlc3NpYmlsaXR5IG1hbmFnZXIgcmVhY3JlYXRlcyB0aGUgYWJpbGl0eSB0byB0YWIgYW5kIGFuZCBoYXZlIGNvbnRlbnQgcmVhZCBieSBzY3JlZW4gcmVhZGVycy4gVGhpcyBpcyB2ZXJ5IGltcG9ydGFudCBhcyBpdCBjYW4gcG9zc2libHkgaGVscCBwZW9wbGUgd2l0aCBkaXNhYmlsaXRpZXMgYWNjZXNzIHBpeGkgY29udGVudC5cbiAqIE11Y2ggbGlrZSBpbnRlcmFjdGlvbiBhbnkgRGlzcGxheU9iamVjdCBjYW4gYmUgbWFkZSBhY2Nlc3NpYmxlLiBUaGlzIG1hbmFnZXIgd2lsbCBtYXAgdGhlIGV2ZW50cyBhcyBpZiB0aGUgbW91c2Ugd2FzIGJlaW5nIHVzZWQsIG1pbmltaXppbmcgdGhlIGVmZmVyb3QgcmVxdWlyZWQgdG8gaW1wbGVtZW50LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSByZW5kZXJlciB7UElYSS5DYW52YXNSZW5kZXJlcnxQSVhJLldlYkdMUmVuZGVyZXJ9IEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gKi9cbmZ1bmN0aW9uIEFjY2Vzc2liaWxpdHlNYW5hZ2VyKHJlbmRlcmVyKVxue1xuXHQvLyBmaXJzdCB3ZSBjcmVhdGUgYSBkaXYgdGhhdCB3aWxsIHNpdCBvdmVyIHRoZSBwaXhpIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLlxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBcbiAgICBkaXYuc3R5bGUud2lkdGggPSAxMDAgKyAncHgnO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAxMDAgKyAncHgnO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZGl2LnN0eWxlLnRvcCA9IDA7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSAwO1xuICAgLy9cbiAgICBkaXYuc3R5bGUuekluZGV4ID0gMjtcbiAgIFx0XG4gICBcdC8qKlxuICAgXHQgKiBUaGlzIGlzIHRoZSBkb20gZWxlbWVudCB0aGF0IHdpbGwgc2l0IG92ZXIgdGhlIHBpeGkgZWxlbWVudC4gVGhpcyBpcyB3aGVyZSB0aGUgZGl2IG92ZXJsYXlzIHdpbGwgZ28uXG4gICBcdCAqIFxuICAgXHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICBcdCAqIEBwcml2YXRlXG4gICBcdCAqL1xuICAgXHR0aGlzLmRpdiA9IGRpdjtcblxuICAgXHQvKipcbiAgIFx0ICogQSBzaW1wbGUgcG9vbCBmb3Igc3RvcmluZyBkaXZzLlxuICAgXHQgKiBcbiAgIFx0ICogQHR5cGUge0FycmF5fVxuICAgXHQgKiBAcHJpdmF0ZVxuICAgXHQgKi9cbiBcdHRoaXMucG9vbCA9IFtdO1xuXG4gXHQvKipcbiBcdCAqIFRoaXMgaXMgYSB0aWNrIHVzZWQgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIG5vIGxvbmdlciBiZWluZyByZW5kZXJlZC5cbiBcdCAqIFxuIFx0ICogQHR5cGUge051bWJlcn1cbiBcdCAqIEBwcml2YXRlXG4gXHQgKi9cbiAgIFx0dGhpcy5yZW5kZXJJZCA9IDA7XG5cbiAgIFx0LyoqXG4gICBcdCAqIFNldHRpbmcgdGhpcyB0byB0cnVlIHdpbGwgdmlzdWFsbHkgc2hvdyB0aGUgZGl2c1xuICAgXHQgKiBcbiAgIFx0ICogQHR5cGUge0Jvb2xlYW59XG4gICBcdCAqL1xuICAgXHR0aGlzLmRlYnVnID0gZmFsc2U7XG5cbiAgXHQvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgdGhpcyBhY2Nlc3NpYmlsaXR5IG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5TeXN0ZW1SZW5kZXJlcn1cbiAgICAgKi9cbiAgIFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gICBcdC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgYWN0aXZlIGFjY2Vzc2libGUgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgXHR0aGlzLmNoaWxkcmVuID0gW107XG4gICBcdFxuICAgXHQvKipcbiAgICAgKiBwcmUgYmluZCB0aGUgZnVuY3Rpb25zLi5cbiAgICAgKi9cbiAgIFx0dGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyk7XG4gICBcdHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgIFx0XG4gICBcdC8qKlxuICAgICAqIHN0b3JlcyB0aGUgc3RhdGUgb2YgdGhlIG1hbmFnZXIuIElmIHRoZXJlIGFyZSBubyBhY2Nlc3NpYmxlIG9iamVjdHMgb3IgdGhlIG1vdXNlIGlzIG1vdmluZyB0aGUgd2lsbCBiZSBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICBcdHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcblxuXG4gICBcdC8vIGxldCBsaXN0ZW4gZm9yIHRhYi4uIG9uY2UgcHJlc3NlZCB3ZSBjYW4gZmlyZSB1cCBhbmQgc2hvdyB0aGUgYWNjZXNzaWJpbGl0eSBsYXllclxuICAgXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xufVxuXG5cbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlcjtcblxuLyoqXG4gKiBBY3RpdmF0aW5nIHdpbGwgY2F1c2UgdGhlIEFjY2Vzc2liaWxpdHkgbGF5ZXIgdG8gYmUgc2hvd24uIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIHByZXNlcyB0aGUgdGFiIGtleVxuICogQHByaXZhdGVcbiAqL1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKVxue1xuXHRpZih0aGlzLmlzQWN0aXZlKVxuXHR7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy5pc0FjdGl2ZSA9IHRydWU7XG5cblx0d2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcblxuXHR0aGlzLnJlbmRlcmVyLm9uKCdwb3N0cmVuZGVyJywgdGhpcy51cGRhdGUsIHRoaXMpO1xuXG5cdHRoaXMucmVuZGVyZXIudmlldy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcdFxufTtcblxuLyoqXG4gKiBEZWFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBoaWRkZW4uIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIG1vdmVzIHRoZSBtb3VzZVxuICogQHByaXZhdGVcbiAqL1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpXG57XG5cdGlmKCF0aGlzLmlzQWN0aXZlKVxuXHR7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG5cdHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG5cblx0dGhpcy5yZW5kZXJlci5vZmYoJ3Bvc3RyZW5kZXInLCB0aGlzLnVwZGF0ZSk7XG5cblx0dGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG5cbn07XG5cbi8qKlxuICogVGhpcyByZWN1cnNpdmUgZnVuY3Rpb24gd2lsbCBydW4gdGhyb3VnaHQgaGUgc2NlbmUgZ3JhcGggYW5kIGFkZCBhbnkgbmV3IGFjY2Vzc2libGUgb2JqZWN0cyB0byB0aGUgRE9NIGxheWVyLlxuICogQHBhcmFtIGVsZW1lbnQge1BJWEkuQ29udGFpbmVyfFBJWEkuU3ByaXRlfFBJWEkuZXh0cmFzLlRpbGluZ1Nwcml0ZX0gdGhlIERpc3BsYXlPYmplY3QgdG8gY2hlY2suXG4gKiBAcHJpdmF0ZVxuICovXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWNjZXNzaWJsZU9iamVjdHMgPSBmdW5jdGlvbihkaXNwbGF5T2JqZWN0KVxue1xuXHRpZighZGlzcGxheU9iamVjdC52aXNpYmxlKVxuXHR7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlICYmIGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUpXG5cdHtcblx0XHRpZighZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZUFjdGl2ZSlcblx0XHR7XG5cdFx0XHR0aGlzLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xuXHRcdH1cblx0ICAgXHRcblx0ICAgXHRkaXNwbGF5T2JqZWN0LnJlbmRlcklkID0gdGhpcy5yZW5kZXJJZDtcblx0fVxuXG5cblx0aWYoZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZUNoaWxkcmVuKVxuXHR7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XG5cdFx0XHR0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGNoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqXG4gKiBCZWZvcmUgZWFjaCByZW5kZXIgdGhpcyBmdW5jdGlvbiB3aWxsIGVuc3VyZSB0aGF0IGFsbCBkaXZzIGFyZSBtYXBwZWQgY29ycmVjdGx5IHRvIHRoZWlyIERpc3BsYXlPYmplY3RzXG4gKiBAcHJpdmF0ZVxuICovXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKVxue1xuXG5cdC8vIHVwZGF0ZSBjaGlsZHJlbi4uLlxuXHR0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCk7XG5cblx0dmFyIHJlY3QgPSB0aGlzLnJlbmRlcmVyLnZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdHZhciBzeCA9IHJlY3Qud2lkdGggIC8gdGhpcy5yZW5kZXJlci53aWR0aDtcblx0dmFyIHN5ID0gcmVjdC5oZWlnaHQgLyB0aGlzLnJlbmRlcmVyLmhlaWdodDtcblxuXHR2YXIgZGl2ID0gdGhpcy5kaXY7XG5cblx0ZGl2LnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyAncHgnO1xuXHRkaXYuc3R5bGUudG9wID0gcmVjdC50b3AgKyAncHgnO1xuXHRkaXYuc3R5bGUud2lkdGggPSB0aGlzLnJlbmRlcmVyLndpZHRoICsgJ3B4Jztcblx0ZGl2LnN0eWxlLmhlaWdodCA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0ICsgJ3B4JztcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG5cdHtcblxuXHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cblx0XHRpZihjaGlsZC5yZW5kZXJJZCAhPT0gdGhpcy5yZW5kZXJJZClcblx0XHR7XG5cdFx0XHRjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb3JlLnV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGksIDEpO1xuXHRcdFx0dGhpcy5kaXYucmVtb3ZlQ2hpbGQoIGNoaWxkLl9hY2Nlc3NpYmxlRGl2ICk7XG5cdFx0XHR0aGlzLnBvb2wucHVzaChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG5cdFx0XHRjaGlsZC5fYWNjZXNzaWJsZURpdiA9IG51bGw7XG5cblx0XHRcdGktLTtcblxuXHRcdFx0aWYodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZGVhY3RpdmF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Ly8gbWFwIGRpdiB0byBkaXNwbGF5Li5cblx0XHRcdGRpdiA9IGNoaWxkLl9hY2Nlc3NpYmxlRGl2O1xuXHRcdFx0dmFyIGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xuXHRcdFx0dmFyIHd0ID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XG5cblx0XHRcdGlmKGNoaWxkLmhpdEFyZWEpXG5cdFx0XHR7XG5cdFx0XHRcdGRpdi5zdHlsZS5sZWZ0ID0gKCh3dC50eCArIChoaXRBcmVhLnggKiB3dC5hKSkgKiBzeCkgKyAncHgnO1xuXHRcdFx0XHRkaXYuc3R5bGUudG9wID0gICgod3QudHkgKyAoaGl0QXJlYS55ICogd3QuZCkpICogc3kpICsgICdweCc7XG5cblx0XHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gKGhpdEFyZWEud2lkdGggKiB3dC5hICogc3gpICsgJ3B4Jztcblx0XHRcdFx0ZGl2LnN0eWxlLmhlaWdodCA9IChoaXRBcmVhLmhlaWdodCAqIHd0LmQgKiBzeSkgKyAncHgnO1xuXHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGhpdEFyZWEgPSBjaGlsZC5nZXRCb3VuZHMoKTtcblxuXHRcdFx0XHR0aGlzLmNhcEhpdEFyZWEoaGl0QXJlYSk7XG5cblx0XHRcdFx0ZGl2LnN0eWxlLmxlZnQgPSAoaGl0QXJlYS54ICogc3gpICsgJ3B4Jztcblx0XHRcdFx0ZGl2LnN0eWxlLnRvcCA9ICAoaGl0QXJlYS55ICogc3kpICsgICdweCc7XG5cblx0XHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gKGhpdEFyZWEud2lkdGggKiBzeCkgKyAncHgnO1xuXHRcdFx0XHRkaXYuc3R5bGUuaGVpZ2h0ID0gKGhpdEFyZWEuaGVpZ2h0ICogc3kpICsgJ3B4Jztcblx0XHRcdH1cdFx0XG5cdFx0fVxuXHR9XG5cblx0Ly8gaW5jcmVtZW50IHRoZSByZW5kZXIgaWQuLlxuXHR0aGlzLnJlbmRlcklkKys7XG59O1xuXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuY2FwSGl0QXJlYSA9IGZ1bmN0aW9uIChoaXRBcmVhKVxue1xuICAgIGlmIChoaXRBcmVhLnggPCAwKVxuICAgIHtcbiAgICAgICAgaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLng7XG4gICAgICAgIGhpdEFyZWEueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGhpdEFyZWEueSA8IDApXG4gICAge1xuICAgICAgICBoaXRBcmVhLmhlaWdodCArPSBoaXRBcmVhLnk7XG4gICAgICAgIGhpdEFyZWEueSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCBoaXRBcmVhLnggKyBoaXRBcmVhLndpZHRoID4gdGhpcy5yZW5kZXJlci53aWR0aCApXG4gICAge1xuICAgICAgICBoaXRBcmVhLndpZHRoID0gdGhpcy5yZW5kZXJlci53aWR0aCAtIGhpdEFyZWEueDtcbiAgICB9XG5cbiAgICBpZiAoIGhpdEFyZWEueSArIGhpdEFyZWEuaGVpZ2h0ID4gdGhpcy5yZW5kZXJlci5oZWlnaHQgKVxuICAgIHtcbiAgICAgICAgaGl0QXJlYS5oZWlnaHQgPSB0aGlzLnJlbmRlcmVyLmhlaWdodCAtIGhpdEFyZWEueTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIERpc3BsYXlPYmplY3QgdG8gdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxuICogQHByaXZhdGVcbiAqL1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oZGlzcGxheU9iamVjdClcbntcbi8vXHR0aGlzLmFjdGl2YXRlKCk7XG5cdFxuXHR2YXIgZGl2ID0gdGhpcy5wb29sLnBvcCgpO1xuXG5cdGlmKCFkaXYpXG5cdHtcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTsgXG5cblx0ICAgIGRpdi5zdHlsZS53aWR0aCA9IDEwMCArICdweCc7XG5cdCAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gMTAwICsgJ3B4Jztcblx0ICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRlYnVnID8gJ3JnYmEoMjU1LDAsMCwwLjUpJyA6ICd0cmFuc3BhcmVudCc7XG5cdCAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgZGl2LnN0eWxlLnpJbmRleCA9IDI7XG5cdCAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnbm9uZSc7XG5cblx0ICAgIFxuXHQgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljay5iaW5kKHRoaXMpKTtcblx0ICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSk7XG5cdCAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl9vbkZvY3VzT3V0LmJpbmQodGhpcykpO1xuXHR9XG5cdCAgIFx0XG5cblxuXG5cdGRpdi50aXRsZSA9IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlIHx8ICdkaXNwbGF5T2JqZWN0ICcgKyB0aGlzLnRhYkluZGV4O1xuXG5cdC8vXG5cdFxuXHRkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlQWN0aXZlID0gdHJ1ZTtcblx0ZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdiA9IGRpdjtcblx0ZGl2LmRpc3BsYXlPYmplY3QgPSBkaXNwbGF5T2JqZWN0O1xuXG5cblx0dGhpcy5jaGlsZHJlbi5wdXNoKGRpc3BsYXlPYmplY3QpO1xuXHR0aGlzLmRpdi5hcHBlbmRDaGlsZCggZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdiApO1xuXHRkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2LnRhYkluZGV4ID0gZGlzcGxheU9iamVjdC50YWJJbmRleDtcbn07XG5cblxuLyoqXG4gKiBNYXBzIHRoZSBkaXYgYnV0dG9uIHByZXNzIHRvIHBpeGkncyBJbnRlcmFjdGlvbk1hbmFnZXIgKGNsaWNrKVxuICogQHByaXZhdGVcbiAqL1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24oZSlcbntcblx0dmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcblx0aW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ2NsaWNrJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aXMgSW50ZXJhY3Rpb25NYW5hZ2VyIChtb3VzZW92ZXIpXG4gKiBAcHJpdmF0ZVxuICovXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbihlKVxue1xuXHR2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xuXHRpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnbW91c2VvdmVyJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aXMgSW50ZXJhY3Rpb25NYW5hZ2VyIChtb3VzZW91dClcbiAqIEBwcml2YXRlXG4gKi9cbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLnByb3RvdHlwZS5fb25Gb2N1c091dCA9IGZ1bmN0aW9uKGUpXG57XG5cdHZhciBpbnRlcmFjdGlvbk1hbmFnZXIgPSB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb247XG5cdGludGVyYWN0aW9uTWFuYWdlci5kaXNwYXRjaEV2ZW50KGUudGFyZ2V0LmRpc3BsYXlPYmplY3QsICdtb3VzZW91dCcsIGludGVyYWN0aW9uTWFuYWdlci5ldmVudERhdGEpO1xufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiBhIGtleSBpcyBwcmVzc2VkXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIucHJvdG90eXBlLl9vbktleURvd24gPSBmdW5jdGlvbihlKVxue1xuXHRpZihlLmtleUNvZGUgIT09IDkpXG5cdHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR0aGlzLmFjdGl2YXRlKCk7XG59O1xuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24oKVxue1xuXHR0aGlzLmRlYWN0aXZhdGUoKTtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgYWNjZXNzaWJpbGl0eSBtYW5hZ2VyXG4gKlxuICovXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIFxue1xuXHR0aGlzLmRpdiA9IG51bGw7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuXHR7XG5cdFx0dGhpcy5jaGlsZHJlbltpXS5kaXYgPSBudWxsO1xuXHR9XG5cblx0XG5cdHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcblx0XHRcblx0dGhpcy5wb29sID0gbnVsbDtcblx0dGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cdHRoaXMucmVuZGVyZXIgPSBudWxsO1xuXG59O1xuXG5jb3JlLldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2FjY2Vzc2liaWxpdHknLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcik7XG5jb3JlLkNhbnZhc1JlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdhY2Nlc3NpYmlsaXR5JywgQWNjZXNzaWJpbGl0eU1hbmFnZXIpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BpeGkuanMvc3JjL2FjY2Vzc2liaWxpdHkvQWNjZXNzaWJpbGl0eU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKmdsb2JhbCBjb25zb2xlICovXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpLFxuICAgIG1lc2ggPSByZXF1aXJlKCcuL21lc2gnKSxcbiAgICBleHRyYXMgPSByZXF1aXJlKCcuL2V4dHJhcycpLFxuICAgIGZpbHRlcnMgPSByZXF1aXJlKCcuL2ZpbHRlcnMnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBTcHJpdGVCYXRjaFxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBzZWUgUElYSS5QYXJ0aWNsZUNvbnRhaW5lclxuICogQHRocm93cyB7UmVmZXJlbmNlRXJyb3J9IFNwcml0ZUJhdGNoIGRvZXMgbm90IGV4aXN0IGFueSBtb3JlLCBwbGVhc2UgdXNlIHRoZSBuZXcgUGFydGljbGVDb250YWluZXIgaW5zdGVhZC5cbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAqL1xuY29yZS5TcHJpdGVCYXRjaCA9IGZ1bmN0aW9uKClcbntcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1Nwcml0ZUJhdGNoIGRvZXMgbm90IGV4aXN0IGFueSBtb3JlLCBwbGVhc2UgdXNlIHRoZSBuZXcgUGFydGljbGVDb250YWluZXIgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgQXNzZXRMb2FkZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAc2VlIFBJWEkubG9hZGVycy5Mb2FkZXJcbiAqIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBUaGUgbG9hZGVyIHN5c3RlbSB3YXMgb3ZlcmhhdWxlZCBpbiBwaXhpIHYzLCBwbGVhc2Ugc2VlIHRoZSBuZXcgUElYSS5sb2FkZXJzLkxvYWRlciBjbGFzcy5cbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAqL1xuY29yZS5Bc3NldExvYWRlciA9IGZ1bmN0aW9uKClcbntcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1RoZSBsb2FkZXIgc3lzdGVtIHdhcyBvdmVyaGF1bGVkIGluIHBpeGkgdjMsIHBsZWFzZSBzZWUgdGhlIG5ldyBQSVhJLmxvYWRlcnMuTG9hZGVyIGNsYXNzLicpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29yZSwge1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBTdGFnZVxuICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICogQHNlZSBQSVhJLkNvbnRhaW5lclxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgKi9cbiAgICBTdGFnZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdZb3UgZG8gbm90IG5lZWQgdG8gdXNlIGEgUElYSSBTdGFnZSBhbnkgbW9yZSwgeW91IGNhbiBzaW1wbHkgcmVuZGVyIGFueSBjb250YWluZXIuJyk7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5Db250YWluZXI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgKiBAc2VlIFBJWEkuQ29udGFpbmVyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICAgICAqL1xuICAgIERpc3BsYXlPYmplY3RDb250YWluZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcGxheU9iamVjdENvbnRhaW5lciBoYXMgYmVlbiBzaG9ydGVuZWQgdG8gQ29udGFpbmVyLCBwbGVhc2UgdXNlIENvbnRhaW5lciBmcm9tIG5vdyBvbi4nKTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLkNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIFN0cmlwXG4gICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgKiBAc2VlIFBJWEkubWVzaC5NZXNoXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICAgICAqL1xuICAgIFN0cmlwOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBTdHJpcCBjbGFzcyBoYXMgYmVlbiByZW5hbWVkIHRvIE1lc2ggYW5kIG1vdmVkIHRvIG1lc2guTWVzaCwgcGxlYXNlIHVzZSBtZXNoLk1lc2ggZnJvbSBub3cgb24uJyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzaC5NZXNoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgUm9wZVxuICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICogQHNlZSBQSVhJLm1lc2guUm9wZVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgKi9cbiAgICBSb3BlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBSb3BlIGNsYXNzIGhhcyBiZWVuIG1vdmVkIHRvIG1lc2guUm9wZSwgcGxlYXNlIHVzZSBtZXNoLlJvcGUgZnJvbSBub3cgb24uJyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzaC5Sb3BlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgTW92aWVDbGlwXG4gICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgKiBAc2VlIFBJWEkuZXh0cmFzLk1vdmllQ2xpcFxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgKi9cbiAgICBNb3ZpZUNsaXA6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIE1vdmllQ2xpcCBjbGFzcyBoYXMgYmVlbiBtb3ZlZCB0byBleHRyYXMuTW92aWVDbGlwLCBwbGVhc2UgdXNlIGV4dHJhcy5Nb3ZpZUNsaXAgZnJvbSBub3cgb24uJyk7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmFzLk1vdmllQ2xpcDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIFRpbGluZ1Nwcml0ZVxuICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICogQHNlZSBQSVhJLmV4dHJhcy5UaWxpbmdTcHJpdGVcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICovXG4gICAgVGlsaW5nU3ByaXRlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBUaWxpbmdTcHJpdGUgY2xhc3MgaGFzIGJlZW4gbW92ZWQgdG8gZXh0cmFzLlRpbGluZ1Nwcml0ZSwgcGxlYXNlIHVzZSBleHRyYXMuVGlsaW5nU3ByaXRlIGZyb20gbm93IG9uLicpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhcy5UaWxpbmdTcHJpdGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBCaXRtYXBUZXh0XG4gICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgKiBAc2VlIFBJWEkuZXh0cmFzLkJpdG1hcFRleHRcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICovXG4gICAgQml0bWFwVGV4dDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgQml0bWFwVGV4dCBjbGFzcyBoYXMgYmVlbiBtb3ZlZCB0byBleHRyYXMuQml0bWFwVGV4dCwgcGxlYXNlIHVzZSBleHRyYXMuQml0bWFwVGV4dCBmcm9tIG5vdyBvbi4nKTtcbiAgICAgICAgICAgIHJldHVybiBleHRyYXMuQml0bWFwVGV4dDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGJsZW5kTW9kZXNcbiAgICAgKiBAbWVtYmVyb2YgUElYSVxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgKi9cbiAgICBibGVuZE1vZGVzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBibGVuZE1vZGVzIGhhcyBiZWVuIG1vdmVkIHRvIEJMRU5EX01PREVTLCBwbGVhc2UgdXNlIEJMRU5EX01PREVTIGZyb20gbm93IG9uLicpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuQkxFTkRfTU9ERVM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzY2FsZU1vZGVzXG4gICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgKiBAc2VlIFBJWEkuU0NBTEVfTU9ERVNcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICovXG4gICAgc2NhbGVNb2Rlczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgc2NhbGVNb2RlcyBoYXMgYmVlbiBtb3ZlZCB0byBTQ0FMRV9NT0RFUywgcGxlYXNlIHVzZSBTQ0FMRV9NT0RFUyBmcm9tIG5vdyBvbi4nKTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLlNDQUxFX01PREVTO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgQmFzZVRleHR1cmVDYWNoZVxuICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICogQHNlZSBQSVhJLnV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gICAgICovXG4gICAgQmFzZVRleHR1cmVDYWNoZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIEJhc2VUZXh0dXJlQ2FjaGUgY2xhc3MgaGFzIGJlZW4gbW92ZWQgdG8gdXRpbHMuQmFzZVRleHR1cmVDYWNoZSwgcGxlYXNlIHVzZSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlIGZyb20gbm93IG9uLicpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUudXRpbHMuQmFzZVRleHR1cmVDYWNoZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIFRleHR1cmVDYWNoZVxuICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICogQHNlZSBQSVhJLnV0aWxzLlRleHR1cmVDYWNoZVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAgICAgKi9cbiAgICBUZXh0dXJlQ2FjaGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBUZXh0dXJlQ2FjaGUgY2xhc3MgaGFzIGJlZW4gbW92ZWQgdG8gdXRpbHMuVGV4dHVyZUNhY2hlLCBwbGVhc2UgdXNlIHV0aWxzLlRleHR1cmVDYWNoZSBmcm9tIG5vdyBvbi4nKTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLnV0aWxzLlRleHR1cmVDYWNoZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBtYXRoXG4gICAgICogQG1lbWJlcm9mIFBJWElcbiAgICAgKiBAc2VlIFBJWElcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC42XG4gICAgICovXG4gICAgbWF0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIG1hdGggbmFtZXNwYWNlIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSBhY2Nlc3MgbWVtYmVycyBhbHJlYWR5IGFjY2Vzc2libGUgb24gUElYSS4nKTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqIEBuYW1lIFBJWEkuU3ByaXRlI3NldFRleHR1cmVcbiAqIEBzZWUgUElYSS5TcHJpdGUjdGV4dHVyZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICovXG5jb3JlLlNwcml0ZS5wcm90b3R5cGUuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpXG57XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICBjb25zb2xlLndhcm4oJ3NldFRleHR1cmUgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIHRleHR1cmUgcHJvcGVydHksIGUuZyA6IHNwcml0ZS50ZXh0dXJlID0gdGV4dHVyZTsnKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZFxuICogQG5hbWUgUElYSS5leHRyYXMuQml0bWFwVGV4dCNzZXRUZXh0XG4gKiBAc2VlIFBJWEkuZXh0cmFzLkJpdG1hcFRleHQjdGV4dFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjAuMFxuICovXG5leHRyYXMuQml0bWFwVGV4dC5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpXG57XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICBjb25zb2xlLndhcm4oJ3NldFRleHQgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgdGhlIHRleHQgcHJvcGVydHksIGUuZyA6IG15Qml0bWFwVGV4dC50ZXh0ID0gXFwnbXkgdGV4dFxcJzsnKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZFxuICogQG5hbWUgUElYSS5UZXh0I3NldFRleHRcbiAqIEBzZWUgUElYSS5UZXh0I3RleHRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjBcbiAqL1xuY29yZS5UZXh0LnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24odGV4dClcbntcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGNvbnNvbGUud2Fybignc2V0VGV4dCBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgdGV4dCBwcm9wZXJ0eSwgZS5nIDogbXlUZXh0LnRleHQgPSBcXCdteSB0ZXh0XFwnOycpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBQSVhJLlRleHQjc2V0U3R5bGVcbiAqIEBzZWUgUElYSS5UZXh0I3N0eWxlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gKi9cbmNvcmUuVGV4dC5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbihzdHlsZSlcbntcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgY29uc29sZS53YXJuKCdzZXRTdHlsZSBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgc3R5bGUgcHJvcGVydHksIGUuZyA6IG15VGV4dC5zdHlsZSA9IHN0eWxlOycpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBQSVhJLlRleHR1cmUjc2V0RnJhbWVcbiAqIEBzZWUgUElYSS5UZXh0dXJlI3NldEZyYW1lXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC4wXG4gKi9cbmNvcmUuVGV4dHVyZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZSlcbntcbiAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgY29uc29sZS53YXJuKCdzZXRGcmFtZSBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgZnJhbWUgcHJvcGVydHksIGUuZyA6IG15VGV4dHVyZS5mcmFtZSA9IGZyYW1lOycpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZmlsdGVycywge1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBQSVhJLmZpbHRlcnMuQWJzdHJhY3RGaWx0ZXJcbiAgICAgKiBAc2VlIFBJWEkuQWJzdHJhY3RGaWx0ZXJcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC42XG4gICAgICovXG4gICAgQWJzdHJhY3RGaWx0ZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignZmlsdGVycy5BYnN0cmFjdEZpbHRlciBpcyBhbiB1bmRvY3VtZW50ZWQgYWxpYXMsIHBsZWFzZSB1c2UgQWJzdHJhY3RGaWx0ZXIgZnJvbSBub3cgb24uJyk7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5BYnN0cmFjdEZpbHRlcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIFBJWEkuZmlsdGVycy5GWEFBRmlsdGVyXG4gICAgICogQHNlZSBQSVhJLkZYQUFGaWx0ZXJcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMC42XG4gICAgICovXG4gICAgRlhBQUZpbHRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdmaWx0ZXJzLkZYQUFGaWx0ZXIgaXMgYW4gdW5kb2N1bWVudGVkIGFsaWFzLCBwbGVhc2UgdXNlIEZYQUFGaWx0ZXIgZnJvbSBub3cgb24uJyk7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5GWEFBRmlsdGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgUElYSS5maWx0ZXJzLlNwcml0ZU1hc2tGaWx0ZXJcbiAgICAgKiBAc2VlIFBJWEkuU3ByaXRlTWFza0ZpbHRlclxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjZcbiAgICAgKi9cbiAgICBTcHJpdGVNYXNrRmlsdGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ZpbHRlcnMuU3ByaXRlTWFza0ZpbHRlciBpcyBhbiB1bmRvY3VtZW50ZWQgYWxpYXMsIHBsZWFzZSB1c2UgU3ByaXRlTWFza0ZpbHRlciBmcm9tIG5vdyBvbi4nKTtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLlNwcml0ZU1hc2tGaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBQSVhJLnV0aWxzLnV1aWRcbiAqIEBzZWUgUElYSS51dGlscy51aWRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4wLjZcbiAqL1xuY29yZS51dGlscy51dWlkID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zb2xlLndhcm4oJ3V0aWxzLnV1aWQoKSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHV0aWxzLnVpZCgpIGZyb20gbm93IG9uLicpO1xuICAgIHJldHVybiBjb3JlLnV0aWxzLnVpZCgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGl4aS5qcy9zcmMvZGVwcmVjYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBSRVNJWkUgfSBmcm9tICcuLi9jb25zdGFudHMvR2FtZUNvbnN0YW50cyc7XG5cbmNsYXNzIFJlbmRlcmVyU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgc3RhZ2VXaWR0aDogMCxcbiAgICAgIHN0YWdlSGVpZ2h0OiAwLFxuICAgICAgc3RhZ2VDZW50ZXI6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIHJlc29sdXRpb246IDFcbiAgICB9O1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcbiAgfVxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cblxuICBlbWl0Q2hhbmdlKCkge1xuICAgIHRoaXMuZW1pdChSRVNJWkUsIHRoaXMuZGF0YSk7XG4gIH1cblxuICBhZGRDaGFuZ2VMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIHRoaXMub24oUkVTSVpFLCBjYWxsYmFjaywgdGhpcy5kYXRhKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgUmVuZGVyZXJTdG9yZSgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3RvcmVzL1JlbmRlcmVyU3RvcmUuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgY29uc3RhbnRzID0ge1xuICBSRVNJWkU6ICAgJ0FQUF9SRVNJWkUnLFxuICBBTklNQVRFOiAgJ0FQUF9BTklNQVRFJyxcbiAgQkVUX01BREU6ICdCRVRfTUFERSdcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbnN0YW50cy9HYW1lQ29uc3RhbnRzLmpzIiwiaW1wb3J0IFNjYWxlZENvbnRhaW5lciBmcm9tICcuLi9TY2FsZWRDb250YWluZXIvU2NhbGVkQ29udGFpbmVyJztcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gJy4uL0JhY2tncm91bmQvQmFja2dyb3VuZCc7XG5pbXBvcnQgR2FtZSBmcm9tICcuLi9HYW1lL0dhbWUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHAgZXh0ZW5kcyBTY2FsZWRDb250YWluZXIge1xuXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBiZyA9IG5ldyBCYWNrZ3JvdW5kKCk7XG4gICAgY29uc3QgZ2FtZSA9IG5ldyBHYW1lKCk7XG5cbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuYWRkQ2hpbGQoYmcpO1xuICAgIHRoaXMuYWRkQ2hpbGQoZ2FtZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Rpc3BsYXlvYmplY3RzL0FwcC9BcHAuanMiLCJpbXBvcnQgUElYSSBmcm9tICdwaXhpLmpzJztcbmltcG9ydCBSZW5kZXJlclN0b3JlIGZyb20gJy4uLy4uL3N0b3Jlcy9SZW5kZXJlclN0b3JlLmpzJztcbmltcG9ydCB7IFJFU0laRSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9HYW1lQ29uc3RhbnRzLmpzJztcblxubGV0IHR3ID0gMTkyMDtcbmxldCB0aCA9IDEwODA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYWxlZENvbnRhaW5lciBleHRlbmRzIFBJWEkuQ29udGFpbmVyIHtcblxuICBjb25zdHJ1Y3Rvcih0YXJnZXRfdyx0YXJnZXRfaCkge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIHR3ID0gdGFyZ2V0X3cgfHwgUmVuZGVyZXJTdG9yZS5nZXQoJ3RhcmdldF93aWR0aCcpO1xuICAgIHRoID0gdGFyZ2V0X2ggfHwgUmVuZGVyZXJTdG9yZS5nZXQoJ3RhcmdldF9oZWlnaHQnKTtcblxuICAgIFJlbmRlcmVyU3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5yZXNpemVIYW5kbGVyLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5yZXNpemVIYW5kbGVyKCk7XG4gIH1cblxuICByZXNpemVIYW5kbGVyKCkge1xuICAgIGNvbnN0IHJ3ID0gUmVuZGVyZXJTdG9yZS5nZXQoJ3dpZHRoJyk7XG4gICAgY29uc3QgcmggPSBSZW5kZXJlclN0b3JlLmdldCgnaGVpZ2h0Jyk7XG4gICAgY29uc3QgWHJhdGlvID0gcncgLyB0dztcbiAgICBjb25zdCBZcmF0aW8gPSByaCAvIHRoO1xuICAgIGxldCBzY2FsZVJhdGlvID0gcncgPiByaCA/IFhyYXRpbyA6IFlyYXRpbztcbiAgICBsZXQgc2NhbGUgPSBuZXcgUElYSS5Qb2ludChzY2FsZVJhdGlvLCBzY2FsZVJhdGlvKTtcbiAgICBsZXQgb2Zmc2V0WCA9IChydyAvIDIpIC0gKHR3ICogc2NhbGVSYXRpbyAvIDIpO1xuICAgIGxldCBvZmZzZXRZID0gKHJoIC8gMikgLSAodGggKiBzY2FsZVJhdGlvIC8gMik7XG5cbiAgICBpZih0aCpzY2FsZVJhdGlvIDwgcmgpIHtcbiAgICAgIHNjYWxlUmF0aW8gPSBZcmF0aW87XG4gICAgICBzY2FsZSA9IG5ldyBQSVhJLlBvaW50KHNjYWxlUmF0aW8sIHNjYWxlUmF0aW8pO1xuICAgICAgb2Zmc2V0WCA9IChydyAvIDIpIC0gKHR3ICogc2NhbGVSYXRpbyAvIDIpO1xuICAgICAgb2Zmc2V0WSA9IChyaCAvIDIpIC0gKHRoICogc2NhbGVSYXRpbyAvIDIpO1xuICAgIH1cblxuICAgIHRoaXMucG9zaXRpb24ueCA9IG9mZnNldFg7XG4gICAgdGhpcy5wb3NpdGlvbi55ID0gb2Zmc2V0WTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZGlzcGxheW9iamVjdHMvU2NhbGVkQ29udGFpbmVyL1NjYWxlZENvbnRhaW5lci5qcyIsImltcG9ydCBQSVhJIGZyb20gJ3BpeGkuanMnO1xuXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IEJBQ0tHUk9VTkRfVEVYVFVSRSBmcm9tICcuLi9pbWFnZXMva2l0Y2hlbi5wbmcnO1xuaW1wb3J0IFRBQkxFX1RFWFRVUkUgZnJvbSAnLi4vaW1hZ2VzL3RhYmxlLnBuZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tncm91bmQgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IHBvc2l0aW9uWCA9IGNvbmZpZy5zdGFnZVdpZHRoIC8gMy41O1xuICAgIGNvbnN0IHBvc2l0aW9uWSA9IGNvbmZpZy5zdGFnZUhlaWdodCAvIDU7XG5cbiAgICBjb25zdCBiZyA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShCQUNLR1JPVU5EX1RFWFRVUkUpO1xuICAgIGNvbnN0IHRhYmxlID0gUElYSS5TcHJpdGUuZnJvbUltYWdlKFRBQkxFX1RFWFRVUkUpO1xuXG4gICAgYmcuYW5jaG9yLnggPSAwO1xuICAgIGJnLmFuY2hvci55ID0gMDtcbiAgICBiZy5hbHBoYSA9IC43O1xuICAgIGJnLnBvc2l0aW9uLnggPSAtMTIwO1xuICAgIGJnLnBvc2l0aW9uLnkgPSA1MDtcblxuICAgIHRhYmxlLnggPSBwb3NpdGlvblggKyAyMzA7XG4gICAgdGFibGUueSA9IHBvc2l0aW9uWSArIDQyMDtcbiAgICB0YWJsZS5zY2FsZS54ID0gMS41O1xuICAgIHRhYmxlLnNjYWxlLnkgPSAxLjU7XG5cbiAgICBjb25zdCBibHVyRmlsdGVyID0gbmV3IFBJWEkuZmlsdGVycy5CbHVyRmlsdGVyKCk7XG4gICAgYmx1ckZpbHRlci5ibHVyID0gMztcbiAgICBiZy5maWx0ZXJzID0gW2JsdXJGaWx0ZXJdO1xuXG4gICAgdGhpcy5hZGRDaGlsZChiZywgdGFibGUpO1xuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Rpc3BsYXlvYmplY3RzL0JhY2tncm91bmQvQmFja2dyb3VuZC5qcyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9raXRjaGVuLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL2tpdGNoZW4ucG5nXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiZGlzcGxheW9iamVjdHMvaW1hZ2VzL3RhYmxlLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL3RhYmxlLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQSVhJIGZyb20gJ3BpeGkuanMnO1xuXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IEJhbm5lciBmcm9tICcuL0Jhbm5lcic7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL3V0aWxzL2J1dHRvbi9CdXR0b24nO1xuaW1wb3J0IEdhbWVTdG9yZSBmcm9tICcuLi8uLi9zdG9yZXMvR2FtZVN0b3JlJztcbmltcG9ydCBHYW1lV2luIGZyb20gJy4uL091dGNvbWUvV2luJztcbmltcG9ydCBHYW1lTG9zcyBmcm9tICcuLi9PdXRjb21lL0xvc2UnO1xuaW1wb3J0IENBS0VfVEVYVFVSRSBmcm9tICcuLi9pbWFnZXMvY2FrZS5wbmcnO1xuaW1wb3J0IENBS0VfVEVYVFVSRV8xIGZyb20gJy4uL2ltYWdlcy9jYWtlMS5wbmcnO1xuaW1wb3J0IENBS0VfVEVYVFVSRV8zIGZyb20gJy4uL2ltYWdlcy9jYWtlMy5wbmcnO1xuaW1wb3J0IENBS0VfVEVYVFVSRV80IGZyb20gJy4uL2ltYWdlcy9jYWtlNC5wbmcnO1xuaW1wb3J0IENBS0VfVEVYVFVSRV81IGZyb20gJy4uL2ltYWdlcy9jYWtlNi5wbmcnO1xuaW1wb3J0IExFRlRfQlVUVE9OIGZyb20gJy4uL2ltYWdlcy9sZWZ0TGFkeS5wbmcnO1xuaW1wb3J0IFJJR0hUX0JVVFRPTiBmcm9tICcuLi9pbWFnZXMvcmlnaHRMYWR5LnBuZyc7XG5pbXBvcnQgTEVGVF9CVVRUT05fT1ZFUiBmcm9tICcuLi9pbWFnZXMvbGVmdExhZHlPdmVyLnBuZyc7XG5pbXBvcnQgUklHSFRfQlVUVE9OX09WRVIgZnJvbSAnLi4vaW1hZ2VzL3JpZ2h0TGFkeU92ZXIucG5nJztcbmltcG9ydCBMRUZUX0xBRFlfRkFUXzEgZnJvbSAnLi4vaW1hZ2VzL2xlZnRMYWR5MS5wbmcnO1xuaW1wb3J0IExFRlRfTEFEWV9GQVRfMiBmcm9tICcuLi9pbWFnZXMvbGVmdExhZHkyLnBuZyc7XG5pbXBvcnQgTEVGVF9MQURZX0ZBVF8zIGZyb20gJy4uL2ltYWdlcy9sZWZ0TGFkeTMucG5nJztcbmltcG9ydCBMRUZUX0xBRFlfRkFUXzQgZnJvbSAnLi4vaW1hZ2VzL2xlZnRMYWR5NC5wbmcnO1xuaW1wb3J0IFJJR0hUX0xBRFlfRkFUXzEgZnJvbSAnLi4vaW1hZ2VzL3JpZ2h0TGFkeTEucG5nJztcbmltcG9ydCBSSUdIVF9MQURZX0ZBVF8yIGZyb20gJy4uL2ltYWdlcy9yaWdodExhZHkyLnBuZyc7XG5pbXBvcnQgUklHSFRfTEFEWV9GQVRfMyBmcm9tICcuLi9pbWFnZXMvcmlnaHRMYWR5My5wbmcnO1xuaW1wb3J0IFJJR0hUX0xBRFlfRkFUXzQgZnJvbSAnLi4vaW1hZ2VzL3JpZ2h0TGFkeTQucG5nJztcblxuY29uc3QgbGVmdEJ1dHRvblRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKExFRlRfQlVUVE9OKTtcbmNvbnN0IHJpZ2h0QnV0dG9uVGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoUklHSFRfQlVUVE9OKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmV0IGV4dGVuZHMgUElYSS5TcHJpdGUge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCBwb3NpdGlvblggPSBjb25maWcuc3RhZ2VXaWR0aCAvIDMuNTtcbiAgICBjb25zdCBwb3NpdGlvblkgPSBjb25maWcuc3RhZ2VIZWlnaHQgLyA1O1xuXG4gICAgY29uc3QgY2FrZVRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKENBS0VfVEVYVFVSRSk7XG4gICAgY29uc3QgbGVmdEJ1dHRvblRleHR1cmVPdmVyID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShMRUZUX0JVVFRPTl9PVkVSKTtcbiAgICBjb25zdCByaWdodEJ1dHRvblRleHR1cmVPdmVyID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShSSUdIVF9CVVRUT05fT1ZFUik7XG5cbiAgICBjb25zdCBiYW5uZXIgPSBuZXcgQmFubmVyKCk7XG4gICAgY29uc3QgY2FrZSA9IG5ldyBQSVhJLlNwcml0ZShjYWtlVGV4dHVyZSk7XG4gICAgY29uc3QgbGVmdEJ1dHRvbiA9IG5ldyBCdXR0b24obGVmdEJ1dHRvblRleHR1cmUpO1xuICAgIGNvbnN0IHJpZ2h0QnV0dG9uID0gbmV3IEJ1dHRvbihyaWdodEJ1dHRvblRleHR1cmUpO1xuICAgIGNvbnN0IGdhbWVXaW4gPSBuZXcgR2FtZVdpbigpO1xuICAgIGNvbnN0IGdhbWVMb3NzID0gbmV3IEdhbWVMb3NzKCk7XG4gICAgY29uc3QgZ2V0UmVhZHlUZXh0ID0gbmV3IFBJWEkuVGV4dCgnJywge1xuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgZm9udFNpemU6IDYwLFxuICAgICAgZm9udEZhbWlseTogJ0hlbHZldGljYScsXG4gICAgICBmaWxsOiAnI2NjMDBmZicsXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgIHN0cm9rZVRoaWNrbmVzczogM1xuICAgIH0pXG5cbiAgICBjYWtlLnBvc2l0aW9uLnggPSBwb3NpdGlvblggLSAtMzIwO1xuICAgIGNha2UucG9zaXRpb24ueSA9IHBvc2l0aW9uWSArIDE4NTtcbiAgICBjYWtlLnNjYWxlLnggPSAuNDtcbiAgICBjYWtlLnNjYWxlLnkgPSAuNDtcblxuICAgIGdldFJlYWR5VGV4dC5wb3NpdGlvbi54ID0gcG9zaXRpb25YIC0gLTM1MDtcbiAgICBnZXRSZWFkeVRleHQucG9zaXRpb24ueSA9IHBvc2l0aW9uWSAtIC0yMDtcbiAgICBnZXRSZWFkeVRleHQuc2NhbGUueCA9IDI7XG4gICAgZ2V0UmVhZHlUZXh0LnNjYWxlLnkgPSAyO1xuXG4gICAgZ2FtZVdpbi52aXNpYmxlID0gZmFsc2U7XG4gICAgZ2FtZUxvc3MudmlzaWJsZSA9IGZhbHNlO1xuICAgIGdldFJlYWR5VGV4dC52aXNpYmxlID0gZmFsc2U7XG5cbiAgICBsZWZ0QnV0dG9uLnNldCgndGV4dHVyZScsIGxlZnRCdXR0b25UZXh0dXJlT3Zlcik7XG4gICAgbGVmdEJ1dHRvbi5hbmNob3Iuc2V0KC41KTtcbiAgICBsZWZ0QnV0dG9uLnggPSBwb3NpdGlvblggKyAyMzA7XG4gICAgbGVmdEJ1dHRvbi55ID0gcG9zaXRpb25ZICsgMzI1O1xuICAgIGxlZnRCdXR0b24uYW5jaG9yLnggPSAuNTtcbiAgICBsZWZ0QnV0dG9uLmFuY2hvci55ID0gLjMzO1xuICAgIGxlZnRCdXR0b24uc2NhbGUueCA9IDEuNTtcbiAgICBsZWZ0QnV0dG9uLnNjYWxlLnkgPSAxLjU7XG4gICAgbGVmdEJ1dHRvbi5hZGRJbnRlcmFjdGl2aXR5VG9CdXR0b25zKCk7XG4gICAgbGVmdEJ1dHRvbi5hZGRCdXR0b25FdmVudHMoKTtcbiAgICBsZWZ0QnV0dG9uLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuYnV0dG9uVXBkYXRlcyhsZWZ0QnV0dG9uLCByaWdodEJ1dHRvbik7XG4gICAgICBHYW1lU3RvcmUuc2V0KCdnYW1lUHJlZGljdGlvbicsIHRydWUpO1xuICAgICAgYmFubmVyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIGdldFJlYWR5VGV4dC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuY291bnRkb3duKGdldFJlYWR5VGV4dCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5lYXRDYWtlKGNha2UsIGxlZnRCdXR0b24sIHJpZ2h0QnV0dG9uKTtcbiAgICAgIH0sIDYwMDApO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZ2FtZU91dGNvbWUoZ2FtZVdpbiwgZ2FtZUxvc3MpXG4gICAgICB9LCAxMjAwMCk7XG4gICAgfSk7XG5cbiAgICByaWdodEJ1dHRvbi5zZXQoJ3RleHR1cmUnLCByaWdodEJ1dHRvblRleHR1cmVPdmVyKTtcbiAgICByaWdodEJ1dHRvbi5hbmNob3Iuc2V0KC41KTtcbiAgICByaWdodEJ1dHRvbi54ID0gcG9zaXRpb25YICsgNjUwO1xuICAgIHJpZ2h0QnV0dG9uLnkgPSBwb3NpdGlvblkgKyAzMjU7XG4gICAgcmlnaHRCdXR0b24uYW5jaG9yLnggPSAuNTtcbiAgICByaWdodEJ1dHRvbi5hbmNob3IueSA9IC4zMztcbiAgICByaWdodEJ1dHRvbi5zY2FsZS54ID0gMS41O1xuICAgIHJpZ2h0QnV0dG9uLnNjYWxlLnkgPSAxLjU7XG4gICAgcmlnaHRCdXR0b24uYWRkSW50ZXJhY3Rpdml0eVRvQnV0dG9ucygpO1xuICAgIHJpZ2h0QnV0dG9uLmFkZEJ1dHRvbkV2ZW50cygpO1xuICAgIHJpZ2h0QnV0dG9uLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuYnV0dG9uVXBkYXRlcyhsZWZ0QnV0dG9uLCByaWdodEJ1dHRvbik7XG4gICAgICBHYW1lU3RvcmUuc2V0KCdnYW1lUHJlZGljdGlvbicsIGZhbHNlKTtcbiAgICAgIGJhbm5lci52aXNpYmxlID0gZmFsc2U7XG4gICAgICBnZXRSZWFkeVRleHQudmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmNvdW50ZG93bihnZXRSZWFkeVRleHQpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZWF0Q2FrZShjYWtlLCBsZWZ0QnV0dG9uLCByaWdodEJ1dHRvbik7XG4gICAgICB9LCA2MDAwKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmdhbWVPdXRjb21lKGdhbWVXaW4sIGdhbWVMb3NzKVxuICAgICAgfSwgMTIwMDApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRDaGlsZChiYW5uZXIsIGNha2UsIGxlZnRCdXR0b24sIHJpZ2h0QnV0dG9uLCBnZXRSZWFkeVRleHQsIGdhbWVXaW4sIGdhbWVMb3NzKTtcbiAgfVxuXG4gIGJ1dHRvblVwZGF0ZXMoYnV0dG9uWCwgYnV0dG9uWSkge1xuICAgIGJ1dHRvblgudGV4dHVyZSA9IGxlZnRCdXR0b25UZXh0dXJlO1xuICAgIGJ1dHRvblkudGV4dHVyZSA9IHJpZ2h0QnV0dG9uVGV4dHVyZTtcbiAgICBidXR0b25YLnJlbW92ZUludGVyYWN0aXZpdHlUb0J1dHRvbnMoKTtcbiAgICBidXR0b25ZLnJlbW92ZUludGVyYWN0aXZpdHlUb0J1dHRvbnMoKTtcbiAgfVxuXG4gIGNvdW50ZG93bihjb3VudGRvd25UZXh0KSB7XG4gICAgICBsZXQgY291bnRlciA9IDM7XG4gICAgICBjb25zdCB0aWNrZXIgPSBQSVhJLnRpY2tlci5zaGFyZWQ7XG4gICAgICB0aWNrZXIuYWRkKCAoKSA9PiB7XG4gICAgICAgIGNvdW50ZXIgLT0gMC4wMTtcblxuICAgICAgICBpZiAoY291bnRlciA+IDIpIHtcbiAgICAgICAgICBjb3VudGRvd25UZXh0LnRleHQgPSAnUmVhZHlcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvdW50ZXIgPiAxKSB7XG4gICAgICAgICAgY291bnRkb3duVGV4dC50ZXh0ID0gJ1JlYWR5XFxuU2V0XFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgIGNvdW50ZG93blRleHQudGV4dCA9ICdSZWFkeVxcblNldFxcbkdPISc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY291bnRkb3duVGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gIGVhdENha2UoY2FrZVRleHR1cmUsIGxlZnRCdXR0b25UZXh0dXJlLCByaWdodEJ1dHRvblRleHR1cmUpIHtcbiAgICBjb25zdCBjYWtlVGV4dHVyZTEgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKENBS0VfVEVYVFVSRV8xKTtcbiAgICBjb25zdCBjYWtlVGV4dHVyZTMgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKENBS0VfVEVYVFVSRV8zKTtcbiAgICBjb25zdCBjYWtlVGV4dHVyZTQgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKENBS0VfVEVYVFVSRV80KTtcbiAgICBjb25zdCBjYWtlVGV4dHVyZTUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKENBS0VfVEVYVFVSRV81KTtcbiAgICBjb25zdCByaWdodExhZHlGYXQxID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShSSUdIVF9MQURZX0ZBVF8xKTtcbiAgICBjb25zdCByaWdodExhZHlGYXQyID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShSSUdIVF9MQURZX0ZBVF8yKTtcbiAgICBjb25zdCByaWdodExhZHlGYXQzID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShSSUdIVF9MQURZX0ZBVF8zKTtcbiAgICBjb25zdCByaWdodExhZHlGYXQ0ID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShSSUdIVF9MQURZX0ZBVF80KTtcbiAgICBjb25zdCBsZWZ0TGFkeUZhdDEgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKExFRlRfTEFEWV9GQVRfMSk7XG4gICAgY29uc3QgbGVmdExhZHlGYXQyID0gUElYSS5UZXh0dXJlLmZyb21JbWFnZShMRUZUX0xBRFlfRkFUXzIpO1xuICAgIGNvbnN0IGxlZnRMYWR5RmF0MyA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoTEVGVF9MQURZX0ZBVF8zKTtcbiAgICBjb25zdCBsZWZ0TGFkeUZhdDQgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKExFRlRfTEFEWV9GQVRfNCk7XG5cbiAgICAgIGxldCBjb3VudGVyID0gMztcbiAgICAgIGNvbnN0IHRpY2tlciA9IFBJWEkudGlja2VyLnNoYXJlZDtcbiAgICAgIHRpY2tlci5hZGQoICgpID0+IHtcbiAgICAgICAgY291bnRlciAtPSAwLjAxO1xuXG4gICAgICAgIGlmIChjb3VudGVyID4gMikge1xuICAgICAgICAgIGNha2VUZXh0dXJlLnRleHR1cmUgPSBjYWtlVGV4dHVyZTE7XG4gICAgICAgICAgaWYoR2FtZVN0b3JlLmdldCgnZ2FtZU91dGNvbWUnKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGVmdEJ1dHRvblRleHR1cmUudGV4dHVyZSA9IGxlZnRMYWR5RmF0MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByaWdodEJ1dHRvblRleHR1cmUudGV4dHVyZSA9IHJpZ2h0TGFkeUZhdDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvdW50ZXIgPiAxKSB7XG4gICAgICAgICAgY2FrZVRleHR1cmUudGV4dHVyZSA9IGNha2VUZXh0dXJlMztcbiAgICAgICAgICBpZihHYW1lU3RvcmUuZ2V0KCdnYW1lT3V0Y29tZScpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBsZWZ0QnV0dG9uVGV4dHVyZS50ZXh0dXJlID0gbGVmdExhZHlGYXQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJpZ2h0QnV0dG9uVGV4dHVyZS50ZXh0dXJlID0gcmlnaHRMYWR5RmF0MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgICBjYWtlVGV4dHVyZS50ZXh0dXJlID0gY2FrZVRleHR1cmU0O1xuICAgICAgICAgIGlmKEdhbWVTdG9yZS5nZXQoJ2dhbWVPdXRjb21lJykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxlZnRCdXR0b25UZXh0dXJlLnRleHR1cmUgPSBsZWZ0TGFkeUZhdDM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmlnaHRCdXR0b25UZXh0dXJlLnRleHR1cmUgPSByaWdodExhZHlGYXQzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYWtlVGV4dHVyZS50ZXh0dXJlID0gY2FrZVRleHR1cmU1O1xuICAgICAgICAgIGlmKEdhbWVTdG9yZS5nZXQoJ2dhbWVPdXRjb21lJykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxlZnRCdXR0b25UZXh0dXJlLnRleHR1cmUgPSBsZWZ0TGFkeUZhdDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmlnaHRCdXR0b25UZXh0dXJlLnRleHR1cmUgPSByaWdodExhZHlGYXQ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgZ2FtZU91dGNvbWUod2luLCBsb3NzKSB7XG4gICAgaWYgKEdhbWVTdG9yZS5pc1dpbm5lcigpID09PSB0cnVlKSB7XG4gICAgICB3aW4udmlzaWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbG9zcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Rpc3BsYXlvYmplY3RzL0dhbWUvR2FtZS5qcyIsImltcG9ydCB7IFRleHQgfSBmcm9tICdwaXhpLmpzJztcblxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZS5qc29uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFubmVyIGV4dGVuZHMgUElYSS5TcHJpdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgcG9zaXRpb25YID0gY29uZmlnLnN0YWdlV2lkdGggLyAzLjU7XG4gICAgY29uc3QgcG9zaXRpb25ZID0gY29uZmlnLnN0YWdlSGVpZ2h0IC8gNTtcblxuICAgIGNvbnN0IHRleHRDb250YWluZXIgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuXG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCdXaG9cXCdzIGdvaW5nIHRvIGVhdCBhbGwgdGhlIGNha2U/XFxuUGljayB5b3VyIHdpbm5lcicsIHtcbiAgICAgIGZvbnRGYW1pbHk6ICdIZXZldGljYScsXG4gICAgICBmb250U2l6ZTogOTYsXG4gICAgICBmaWxsOiAnI2NjMDBmZicsXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBzdHJva2U6ICcjRkZGRkZGJ1xuICAgIH0pO1xuXG4gICAgdGV4dENvbnRhaW5lci5iZWdpbkZpbGwoMHgwMDAwMDApO1xuICAgIHRleHRDb250YWluZXIubGluZVN0eWxlKDIsIDB4RkZGRkZGKTtcbiAgICB0ZXh0Q29udGFpbmVyLmRyYXdSZWN0KHBvc2l0aW9uWCArIDExMCwgcG9zaXRpb25ZLCA2MzUsIDExNSk7XG4gICAgdGV4dENvbnRhaW5lci5hbHBoYSA9IC41O1xuXG4gICAgdGV4dC5wb3NpdGlvbi54ID0gcG9zaXRpb25YIC0gLTEyNztcbiAgICB0ZXh0LnBvc2l0aW9uLnkgPSBwb3NpdGlvblkgLSAtMTA7XG4gICAgdGV4dC5zY2FsZS54ID0gMS41O1xuICAgIHRleHQuc2NhbGUueSA9IDEuNTtcblxuICAgIHRoaXMuYWRkQ2hpbGQodGV4dENvbnRhaW5lciwgdGV4dCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Rpc3BsYXlvYmplY3RzL0dhbWUvQmFubmVyLmpzIiwiaW1wb3J0IFBJWEkgZnJvbSAncGl4aS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIFBJWEkuU3ByaXRlIHtcblxuICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIHRleHR1cmU6IDAsXG4gICAgICB0ZXh0dXJlTm9ybWFsOiAwXG4gICAgfVxuXG4gICAgbmV3IFBJWEkuU3ByaXRlKHRoaXMuZGF0YS50ZXh0dXJlTm9ybWFsKTtcbiAgfVxuXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XG4gIH1cblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgc2V0VGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgdGhpcy5zZXQoJ3RleHR1cmVOb3JtYWwnLCB0ZXh0dXJlKTtcbiAgfVxuXG4gIGFkZEludGVyYWN0aXZpdHlUb0J1dHRvbnMoKSB7XG4gICAgdGhpcy5idXR0b25Nb2RlID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIHJlbW92ZUludGVyYWN0aXZpdHlUb0J1dHRvbnMoKSB7XG4gICAgdGhpcy5idXR0b25Nb2RlID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgYWRkQnV0dG9uRXZlbnRzKCkge1xuICAgICAgdGhpc1xuICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCB0aGlzLm9uQnV0dG9uRG93bilcbiAgICAgICAgLm9uKCd0b3VjaGVuZCcsIHRoaXMub25CdXR0b25VcClcbiAgICAgICAgLm9uKCd0b3VjaGVuZG91dHNpZGUnLCB0aGlzLm9uQnV0dG9uVXApXG4gICAgICAgIC5vbignbW91c2Vkb3duJywgdGhpcy5vbkJ1dHRvbkRvd24pXG4gICAgICAgIC5vbignbW91c2V1cCcsIHRoaXMub25CdXR0b25VcClcbiAgICAgICAgLm9uKCdtb3VzZXVwb3V0c2lkZScsIHRoaXMub25CdXR0b25VcClcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCB0aGlzLm9uQnV0dG9uT3ZlcilcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIHRoaXMub25CdXR0b25PdXQpO1xuICB9XG5cbiAgb25CdXR0b25Eb3duKCkge1xuICAgIHRoaXMuaXNkb3duID0gdHJ1ZTtcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLmRhdGEudGV4dHVyZTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgfVxuXG4gIG9uQnV0dG9uVXAoKSB7XG4gICAgdGhpcy5pc2Rvd24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc092ZXIpIHtcbiAgICAgIGlmICh0aGlzLmxlZnRCdXR0b24pIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5kYXRhLnRleHR1cmU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5kYXRhLnRleHR1cmU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5kYXRhLnRleHR1cmVOb3JtYWw7XG4gICAgfVxuICB9XG5cbiAgb25CdXR0b25PdmVyKCkge1xuICAgIHRoaXMuaXNPdmVyID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5pc2Rvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLmRhdGEudGV4dHVyZTtcbiAgfVxuXG4gIG9uQnV0dG9uT3V0KCkge1xuICAgIHRoaXMuaXNPdmVyID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNkb3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLmRhdGEudGV4dHVyZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdXRpbHMvYnV0dG9uL0J1dHRvbi5qcyIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IEJFVF9NQURFIH0gZnJvbSAnLi4vY29uc3RhbnRzL0dhbWVDb25zdGFudHMnO1xuXG5jbGFzcyBHYW1lU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBnYW1lT3V0Y29tZTogdHJ1ZSxcbiAgICAgIGdhbWVQcmVkaWN0aW9uOiB0cnVlLFxuICAgICAgd2luQW1vdW50OiAwXG4gICAgfTtcbiAgfVxuXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XG4gIH1cblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgc2V0R2FtZU91dGNvbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5nYW1lT3V0Y29tZSA9IE1hdGgucmFuZG9tKCkgPj0gMC41O1xuICB9XG5cbiAgZW1pdENoYW5nZSgpIHtcbiAgICB0aGlzLmVtaXQoQkVUX01BREUsIHRoaXMuZGF0YSk7XG4gIH1cblxuICBhZGRDaGFuZ2VMaXN0ZW5lcihjYWxsYmFjaykge1xuICAgIHRoaXMub24oQkVUX01BREUsIGNhbGxiYWNrLCB0aGlzLmRhdGEpO1xuICB9XG5cbiAgaXNXaW5uZXIoKSB7XG4gICAgbGV0IHdpbm5lciA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmRhdGEuZ2FtZU91dGNvbWUgPT09IHRoaXMuZGF0YS5nYW1lUHJlZGljdGlvbikge1xuICAgICAgd2lubmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbm5lcjtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBHYW1lU3RvcmUoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3N0b3Jlcy9HYW1lU3RvcmUuanMiLCJpbXBvcnQgUElYSSBmcm9tICdwaXhpLmpzJztcblxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZS5qc29uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lubmluZ091dGNvbWUgZXh0ZW5kcyBQSVhJLlNwcml0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCBwb3NpdGlvblggPSBjb25maWcuc3RhZ2VXaWR0aCAvIDMuNTtcbiAgICBjb25zdCBwb3NpdGlvblkgPSBjb25maWcuc3RhZ2VIZWlnaHQgLyA1O1xuXG4gICAgY29uc3QgdGV4dCA9IG5ldyBQSVhJLlRleHQoJ0NvbmdyYXR1bGF0aW9uc1xcbiBZT1VcXCdWRVxcbiBXT04nLCB7XG4gICAgICBmb250RmFtaWx5OiAnSGV2ZXRpY2EnLFxuICAgICAgZm9udFNpemU6IDk2LFxuICAgICAgZmlsbDogJyNjYzAwZmYnLFxuICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICBzdHJva2VUaGlja25lc3M6IDNcbiAgICB9KTtcblxuICAgIHRleHQucG9zaXRpb24ueCA9IHBvc2l0aW9uWCAtIC0yNzA7XG4gICAgdGV4dC5wb3NpdGlvbi55ID0gcG9zaXRpb25ZIC0gLTIwO1xuICAgIHRleHQuc2NhbGUueCA9IDEuNTtcbiAgICB0ZXh0LnNjYWxlLnkgPSAxLjU7XG5cbiAgICB0aGlzLmFkZENoaWxkKHRleHQpO1xuXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Rpc3BsYXlvYmplY3RzL091dGNvbWUvV2luLmpzIiwiaW1wb3J0IHsgVGV4dCB9IGZyb20gJ3BpeGkuanMnO1xuXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi8uLi8uLi9wYWNrYWdlLmpzb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb3NpbmdPdXRjb21lIGV4dGVuZHMgUElYSS5TcHJpdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgcG9zaXRpb25YID0gY29uZmlnLnN0YWdlV2lkdGggLyAzLjU7XG4gICAgY29uc3QgcG9zaXRpb25ZID0gY29uZmlnLnN0YWdlSGVpZ2h0IC8gNTtcblxuICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgnU29ycnlcXG4gRHVkZS4uLlxcbiBZb3VcXCd2ZSBsb3N0Jywge1xuICAgICAgZm9udEZhbWlseTogJ0hlbHZldGljYScsXG4gICAgICBmb250U2l6ZTogOTYsXG4gICAgICBmaWxsOiAnI2NjMDBmZicsXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgIHN0cm9rZVRoaWNrbmVzczogM1xuICAgIH0pO1xuXG4gICAgdGV4dC5wb3NpdGlvbi54ID0gcG9zaXRpb25YIC0gLTMwMDtcbiAgICB0ZXh0LnBvc2l0aW9uLnkgPSBwb3NpdGlvblkgLSAtMjA7XG4gICAgdGV4dC5zY2FsZS54ID0gMS41O1xuICAgIHRleHQuc2NhbGUueSA9IDEuNTtcblxuICAgIHRoaXMuYWRkQ2hpbGQodGV4dCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Rpc3BsYXlvYmplY3RzL091dGNvbWUvTG9zZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9jYWtlLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL2Nha2UucG5nXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiZGlzcGxheW9iamVjdHMvaW1hZ2VzL2Nha2UxLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL2Nha2UxLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9jYWtlMy5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9jYWtlMy5wbmdcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkaXNwbGF5b2JqZWN0cy9pbWFnZXMvY2FrZTQucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvY2FrZTQucG5nXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiZGlzcGxheW9iamVjdHMvaW1hZ2VzL2Nha2U2LnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL2Nha2U2LnBuZ1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeS5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeS5wbmdcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkaXNwbGF5b2JqZWN0cy9pbWFnZXMvcmlnaHRMYWR5LnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL3JpZ2h0TGFkeS5wbmdcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkaXNwbGF5b2JqZWN0cy9pbWFnZXMvbGVmdExhZHlPdmVyLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL2xlZnRMYWR5T3Zlci5wbmdcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkaXNwbGF5b2JqZWN0cy9pbWFnZXMvcmlnaHRMYWR5T3Zlci5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9yaWdodExhZHlPdmVyLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTEucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvbGVmdExhZHkxLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTIucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvbGVmdExhZHkyLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTMucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvbGVmdExhZHkzLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9sZWZ0TGFkeTQucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvbGVmdExhZHk0LnBuZ1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9yaWdodExhZHkxLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL3JpZ2h0TGFkeTEucG5nXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiZGlzcGxheW9iamVjdHMvaW1hZ2VzL3JpZ2h0TGFkeTIucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXNwbGF5b2JqZWN0cy9pbWFnZXMvcmlnaHRMYWR5Mi5wbmdcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJkaXNwbGF5b2JqZWN0cy9pbWFnZXMvcmlnaHRMYWR5My5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3BsYXlvYmplY3RzL2ltYWdlcy9yaWdodExhZHkzLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImRpc3BsYXlvYmplY3RzL2ltYWdlcy9yaWdodExhZHk0LnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzcGxheW9iamVjdHMvaW1hZ2VzL3JpZ2h0TGFkeTQucG5nXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==